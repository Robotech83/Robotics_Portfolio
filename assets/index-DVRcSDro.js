function z7(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const a=Object.getOwnPropertyDescriptor(s,i);a&&Object.defineProperty(n,i,a.get?a:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const r of a.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function t(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(i){if(i.ep)return;i.ep=!0;const a=t(i);fetch(i.href,a)}})();function KE(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function VD(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var i=!1;try{i=this instanceof s}catch{}return i?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),t}var IR={exports:{}},Qb={};var FF;function $7(){if(FF)return Qb;FF=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,i,a){var r=null;if(a!==void 0&&(r=""+a),i.key!==void 0&&(r=""+i.key),"key"in i){a={};for(var o in i)o!=="key"&&(a[o]=i[o])}else a=i;return i=a.ref,{$$typeof:n,type:s,key:r,ref:i!==void 0?i:null,props:a}}return Qb.Fragment=e,Qb.jsx=t,Qb.jsxs=t,Qb}var UF;function G7(){return UF||(UF=1,IR.exports=$7()),IR.exports}var V=G7(),DR={exports:{}},Pn={};var PF;function V7(){if(PF)return Pn;PF=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),a=Symbol.for("react.consumer"),r=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),d=Symbol.for("react.activity"),p=Symbol.iterator;function g(Y){return Y===null||typeof Y!="object"?null:(Y=p&&Y[p]||Y["@@iterator"],typeof Y=="function"?Y:null)}var v={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},_=Object.assign,S={};function b(Y,re,he){this.props=Y,this.context=re,this.refs=S,this.updater=he||v}b.prototype.isReactComponent={},b.prototype.setState=function(Y,re){if(typeof Y!="object"&&typeof Y!="function"&&Y!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,Y,re,"setState")},b.prototype.forceUpdate=function(Y){this.updater.enqueueForceUpdate(this,Y,"forceUpdate")};function w(){}w.prototype=b.prototype;function T(Y,re,he){this.props=Y,this.context=re,this.refs=S,this.updater=he||v}var E=T.prototype=new w;E.constructor=T,_(E,b.prototype),E.isPureReactComponent=!0;var R=Array.isArray;function D(){}var F={H:null,A:null,T:null,S:null},U=Object.prototype.hasOwnProperty;function O(Y,re,he){var me=he.ref;return{$$typeof:n,type:Y,key:re,ref:me!==void 0?me:null,props:he}}function B(Y,re){return O(Y.type,re,Y.props)}function L(Y){return typeof Y=="object"&&Y!==null&&Y.$$typeof===n}function H(Y){var re={"=":"=0",":":"=2"};return"$"+Y.replace(/[=:]/g,function(he){return re[he]})}var K=/\/+/g;function Z(Y,re){return typeof Y=="object"&&Y!==null&&Y.key!=null?H(""+Y.key):re.toString(36)}function Q(Y){switch(Y.status){case"fulfilled":return Y.value;case"rejected":throw Y.reason;default:switch(typeof Y.status=="string"?Y.then(D,D):(Y.status="pending",Y.then(function(re){Y.status==="pending"&&(Y.status="fulfilled",Y.value=re)},function(re){Y.status==="pending"&&(Y.status="rejected",Y.reason=re)})),Y.status){case"fulfilled":return Y.value;case"rejected":throw Y.reason}}throw Y}function P(Y,re,he,me,Ne){var fe=typeof Y;(fe==="undefined"||fe==="boolean")&&(Y=null);var Te=!1;if(Y===null)Te=!0;else switch(fe){case"bigint":case"string":case"number":Te=!0;break;case"object":switch(Y.$$typeof){case n:case e:Te=!0;break;case h:return Te=Y._init,P(Te(Y._payload),re,he,me,Ne)}}if(Te)return Ne=Ne(Y),Te=me===""?"."+Z(Y,0):me,R(Ne)?(he="",Te!=null&&(he=Te.replace(K,"$&/")+"/"),P(Ne,re,he,"",function(yt){return yt})):Ne!=null&&(L(Ne)&&(Ne=B(Ne,he+(Ne.key==null||Y&&Y.key===Ne.key?"":(""+Ne.key).replace(K,"$&/")+"/")+Te)),re.push(Ne)),1;Te=0;var Ge=me===""?".":me+":";if(R(Y))for(var nt=0;nt<Y.length;nt++)me=Y[nt],fe=Ge+Z(me,nt),Te+=P(me,re,he,fe,Ne);else if(nt=g(Y),typeof nt=="function")for(Y=nt.call(Y),nt=0;!(me=Y.next()).done;)me=me.value,fe=Ge+Z(me,nt++),Te+=P(me,re,he,fe,Ne);else if(fe==="object"){if(typeof Y.then=="function")return P(Q(Y),re,he,me,Ne);throw re=String(Y),Error("Objects are not valid as a React child (found: "+(re==="[object Object]"?"object with keys {"+Object.keys(Y).join(", ")+"}":re)+"). If you meant to render a collection of children, use an array instead.")}return Te}function W(Y,re,he){if(Y==null)return Y;var me=[],Ne=0;return P(Y,me,"","",function(fe){return re.call(he,fe,Ne++)}),me}function q(Y){if(Y._status===-1){var re=Y._result;re=re(),re.then(function(he){(Y._status===0||Y._status===-1)&&(Y._status=1,Y._result=he)},function(he){(Y._status===0||Y._status===-1)&&(Y._status=2,Y._result=he)}),Y._status===-1&&(Y._status=0,Y._result=re)}if(Y._status===1)return Y._result.default;throw Y._result}var se=typeof reportError=="function"?reportError:function(Y){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var re=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof Y=="object"&&Y!==null&&typeof Y.message=="string"?String(Y.message):String(Y),error:Y});if(!window.dispatchEvent(re))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",Y);return}console.error(Y)},le={map:W,forEach:function(Y,re,he){W(Y,function(){re.apply(this,arguments)},he)},count:function(Y){var re=0;return W(Y,function(){re++}),re},toArray:function(Y){return W(Y,function(re){return re})||[]},only:function(Y){if(!L(Y))throw Error("React.Children.only expected to receive a single React element child.");return Y}};return Pn.Activity=d,Pn.Children=le,Pn.Component=b,Pn.Fragment=t,Pn.Profiler=i,Pn.PureComponent=T,Pn.StrictMode=s,Pn.Suspense=l,Pn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=F,Pn.__COMPILER_RUNTIME={__proto__:null,c:function(Y){return F.H.useMemoCache(Y)}},Pn.cache=function(Y){return function(){return Y.apply(null,arguments)}},Pn.cacheSignal=function(){return null},Pn.cloneElement=function(Y,re,he){if(Y==null)throw Error("The argument must be a React element, but you passed "+Y+".");var me=_({},Y.props),Ne=Y.key;if(re!=null)for(fe in re.key!==void 0&&(Ne=""+re.key),re)!U.call(re,fe)||fe==="key"||fe==="__self"||fe==="__source"||fe==="ref"&&re.ref===void 0||(me[fe]=re[fe]);var fe=arguments.length-2;if(fe===1)me.children=he;else if(1<fe){for(var Te=Array(fe),Ge=0;Ge<fe;Ge++)Te[Ge]=arguments[Ge+2];me.children=Te}return O(Y.type,Ne,me)},Pn.createContext=function(Y){return Y={$$typeof:r,_currentValue:Y,_currentValue2:Y,_threadCount:0,Provider:null,Consumer:null},Y.Provider=Y,Y.Consumer={$$typeof:a,_context:Y},Y},Pn.createElement=function(Y,re,he){var me,Ne={},fe=null;if(re!=null)for(me in re.key!==void 0&&(fe=""+re.key),re)U.call(re,me)&&me!=="key"&&me!=="__self"&&me!=="__source"&&(Ne[me]=re[me]);var Te=arguments.length-2;if(Te===1)Ne.children=he;else if(1<Te){for(var Ge=Array(Te),nt=0;nt<Te;nt++)Ge[nt]=arguments[nt+2];Ne.children=Ge}if(Y&&Y.defaultProps)for(me in Te=Y.defaultProps,Te)Ne[me]===void 0&&(Ne[me]=Te[me]);return O(Y,fe,Ne)},Pn.createRef=function(){return{current:null}},Pn.forwardRef=function(Y){return{$$typeof:o,render:Y}},Pn.isValidElement=L,Pn.lazy=function(Y){return{$$typeof:h,_payload:{_status:-1,_result:Y},_init:q}},Pn.memo=function(Y,re){return{$$typeof:c,type:Y,compare:re===void 0?null:re}},Pn.startTransition=function(Y){var re=F.T,he={};F.T=he;try{var me=Y(),Ne=F.S;Ne!==null&&Ne(he,me),typeof me=="object"&&me!==null&&typeof me.then=="function"&&me.then(D,se)}catch(fe){se(fe)}finally{re!==null&&he.types!==null&&(re.types=he.types),F.T=re}},Pn.unstable_useCacheRefresh=function(){return F.H.useCacheRefresh()},Pn.use=function(Y){return F.H.use(Y)},Pn.useActionState=function(Y,re,he){return F.H.useActionState(Y,re,he)},Pn.useCallback=function(Y,re){return F.H.useCallback(Y,re)},Pn.useContext=function(Y){return F.H.useContext(Y)},Pn.useDebugValue=function(){},Pn.useDeferredValue=function(Y,re){return F.H.useDeferredValue(Y,re)},Pn.useEffect=function(Y,re){return F.H.useEffect(Y,re)},Pn.useEffectEvent=function(Y){return F.H.useEffectEvent(Y)},Pn.useId=function(){return F.H.useId()},Pn.useImperativeHandle=function(Y,re,he){return F.H.useImperativeHandle(Y,re,he)},Pn.useInsertionEffect=function(Y,re){return F.H.useInsertionEffect(Y,re)},Pn.useLayoutEffect=function(Y,re){return F.H.useLayoutEffect(Y,re)},Pn.useMemo=function(Y,re){return F.H.useMemo(Y,re)},Pn.useOptimistic=function(Y,re){return F.H.useOptimistic(Y,re)},Pn.useReducer=function(Y,re,he){return F.H.useReducer(Y,re,he)},Pn.useRef=function(Y){return F.H.useRef(Y)},Pn.useState=function(Y){return F.H.useState(Y)},Pn.useSyncExternalStore=function(Y,re,he){return F.H.useSyncExternalStore(Y,re,he)},Pn.useTransition=function(){return F.H.useTransition()},Pn.version="19.2.0",Pn}var zF;function ay(){return zF||(zF=1,DR.exports=V7()),DR.exports}var pe=ay();const H7=KE(pe);var OR={exports:{}},e1={},BR={exports:{}},kR={};var $F;function W7(){return $F||($F=1,(function(n){function e(P,W){var q=P.length;P.push(W);e:for(;0<q;){var se=q-1>>>1,le=P[se];if(0<i(le,W))P[se]=W,P[q]=le,q=se;else break e}}function t(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var W=P[0],q=P.pop();if(q!==W){P[0]=q;e:for(var se=0,le=P.length,Y=le>>>1;se<Y;){var re=2*(se+1)-1,he=P[re],me=re+1,Ne=P[me];if(0>i(he,q))me<le&&0>i(Ne,he)?(P[se]=Ne,P[me]=q,se=me):(P[se]=he,P[re]=q,se=re);else if(me<le&&0>i(Ne,q))P[se]=Ne,P[me]=q,se=me;else break e}}return W}function i(P,W){var q=P.sortIndex-W.sortIndex;return q!==0?q:P.id-W.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var a=performance;n.unstable_now=function(){return a.now()}}else{var r=Date,o=r.now();n.unstable_now=function(){return r.now()-o}}var l=[],c=[],h=1,d=null,p=3,g=!1,v=!1,_=!1,S=!1,b=typeof setTimeout=="function"?setTimeout:null,w=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function E(P){for(var W=t(c);W!==null;){if(W.callback===null)s(c);else if(W.startTime<=P)s(c),W.sortIndex=W.expirationTime,e(l,W);else break;W=t(c)}}function R(P){if(_=!1,E(P),!v)if(t(l)!==null)v=!0,D||(D=!0,H());else{var W=t(c);W!==null&&Q(R,W.startTime-P)}}var D=!1,F=-1,U=5,O=-1;function B(){return S?!0:!(n.unstable_now()-O<U)}function L(){if(S=!1,D){var P=n.unstable_now();O=P;var W=!0;try{e:{v=!1,_&&(_=!1,w(F),F=-1),g=!0;var q=p;try{t:{for(E(P),d=t(l);d!==null&&!(d.expirationTime>P&&B());){var se=d.callback;if(typeof se=="function"){d.callback=null,p=d.priorityLevel;var le=se(d.expirationTime<=P);if(P=n.unstable_now(),typeof le=="function"){d.callback=le,E(P),W=!0;break t}d===t(l)&&s(l),E(P)}else s(l);d=t(l)}if(d!==null)W=!0;else{var Y=t(c);Y!==null&&Q(R,Y.startTime-P),W=!1}}break e}finally{d=null,p=q,g=!1}W=void 0}}finally{W?H():D=!1}}}var H;if(typeof T=="function")H=function(){T(L)};else if(typeof MessageChannel<"u"){var K=new MessageChannel,Z=K.port2;K.port1.onmessage=L,H=function(){Z.postMessage(null)}}else H=function(){b(L,0)};function Q(P,W){F=b(function(){P(n.unstable_now())},W)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):U=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_next=function(P){switch(p){case 1:case 2:case 3:var W=3;break;default:W=p}var q=p;p=W;try{return P()}finally{p=q}},n.unstable_requestPaint=function(){S=!0},n.unstable_runWithPriority=function(P,W){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var q=p;p=P;try{return W()}finally{p=q}},n.unstable_scheduleCallback=function(P,W,q){var se=n.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?se+q:se):q=se,P){case 1:var le=-1;break;case 2:le=250;break;case 5:le=1073741823;break;case 4:le=1e4;break;default:le=5e3}return le=q+le,P={id:h++,callback:W,priorityLevel:P,startTime:q,expirationTime:le,sortIndex:-1},q>se?(P.sortIndex=q,e(c,P),t(l)===null&&P===t(c)&&(_?(w(F),F=-1):_=!0,Q(R,q-se))):(P.sortIndex=le,e(l,P),v||g||(v=!0,D||(D=!0,H()))),P},n.unstable_shouldYield=B,n.unstable_wrapCallback=function(P){var W=p;return function(){var q=p;p=W;try{return P.apply(this,arguments)}finally{p=q}}}})(kR)),kR}var GF;function j7(){return GF||(GF=1,BR.exports=W7()),BR.exports}var LR={exports:{}},kr={};var VF;function X7(){if(VF)return kr;VF=1;var n=ay();function e(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var h=2;h<arguments.length;h++)c+="&args[]="+encodeURIComponent(arguments[h])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},i=Symbol.for("react.portal");function a(l,c,h){var d=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:d==null?null:""+d,children:l,containerInfo:c,implementation:h}}var r=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,c){if(l==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return kr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,kr.createPortal=function(l,c){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(e(299));return a(l,c,null,h)},kr.flushSync=function(l){var c=r.T,h=s.p;try{if(r.T=null,s.p=2,l)return l()}finally{r.T=c,s.p=h,s.d.f()}},kr.preconnect=function(l,c){typeof l=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,s.d.C(l,c))},kr.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},kr.preinit=function(l,c){if(typeof l=="string"&&c&&typeof c.as=="string"){var h=c.as,d=o(h,c.crossOrigin),p=typeof c.integrity=="string"?c.integrity:void 0,g=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;h==="style"?s.d.S(l,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:d,integrity:p,fetchPriority:g}):h==="script"&&s.d.X(l,{crossOrigin:d,integrity:p,fetchPriority:g,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},kr.preinitModule=function(l,c){if(typeof l=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var h=o(c.as,c.crossOrigin);s.d.M(l,{crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&s.d.M(l)},kr.preload=function(l,c){if(typeof l=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var h=c.as,d=o(h,c.crossOrigin);s.d.L(l,h,{crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},kr.preloadModule=function(l,c){if(typeof l=="string")if(c){var h=o(c.as,c.crossOrigin);s.d.m(l,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else s.d.m(l)},kr.requestFormReset=function(l){s.d.r(l)},kr.unstable_batchedUpdates=function(l,c){return l(c)},kr.useFormState=function(l,c,h){return r.H.useFormState(l,c,h)},kr.useFormStatus=function(){return r.H.useHostTransitionStatus()},kr.version="19.2.0",kr}var HF;function q7(){if(HF)return LR.exports;HF=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),LR.exports=X7(),LR.exports}var WF;function K7(){if(WF)return e1;WF=1;var n=j7(),e=ay(),t=q7();function s(u){var f="https://react.dev/errors/"+u;if(1<arguments.length){f+="?args[]="+encodeURIComponent(arguments[1]);for(var y=2;y<arguments.length;y++)f+="&args[]="+encodeURIComponent(arguments[y])}return"Minified React error #"+u+"; visit "+f+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function a(u){var f=u,y=u;if(u.alternate)for(;f.return;)f=f.return;else{u=f;do f=u,(f.flags&4098)!==0&&(y=f.return),u=f.return;while(u)}return f.tag===3?y:null}function r(u){if(u.tag===13){var f=u.memoizedState;if(f===null&&(u=u.alternate,u!==null&&(f=u.memoizedState)),f!==null)return f.dehydrated}return null}function o(u){if(u.tag===31){var f=u.memoizedState;if(f===null&&(u=u.alternate,u!==null&&(f=u.memoizedState)),f!==null)return f.dehydrated}return null}function l(u){if(a(u)!==u)throw Error(s(188))}function c(u){var f=u.alternate;if(!f){if(f=a(u),f===null)throw Error(s(188));return f!==u?null:u}for(var y=u,A=f;;){var M=y.return;if(M===null)break;var I=M.alternate;if(I===null){if(A=M.return,A!==null){y=A;continue}break}if(M.child===I.child){for(I=M.child;I;){if(I===y)return l(M),u;if(I===A)return l(M),f;I=I.sibling}throw Error(s(188))}if(y.return!==A.return)y=M,A=I;else{for(var G=!1,ne=M.child;ne;){if(ne===y){G=!0,y=M,A=I;break}if(ne===A){G=!0,A=M,y=I;break}ne=ne.sibling}if(!G){for(ne=I.child;ne;){if(ne===y){G=!0,y=I,A=M;break}if(ne===A){G=!0,A=I,y=M;break}ne=ne.sibling}if(!G)throw Error(s(189))}}if(y.alternate!==A)throw Error(s(190))}if(y.tag!==3)throw Error(s(188));return y.stateNode.current===y?u:f}function h(u){var f=u.tag;if(f===5||f===26||f===27||f===6)return u;for(u=u.child;u!==null;){if(f=h(u),f!==null)return f;u=u.sibling}return null}var d=Object.assign,p=Symbol.for("react.element"),g=Symbol.for("react.transitional.element"),v=Symbol.for("react.portal"),_=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),b=Symbol.for("react.profiler"),w=Symbol.for("react.consumer"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),D=Symbol.for("react.suspense_list"),F=Symbol.for("react.memo"),U=Symbol.for("react.lazy"),O=Symbol.for("react.activity"),B=Symbol.for("react.memo_cache_sentinel"),L=Symbol.iterator;function H(u){return u===null||typeof u!="object"?null:(u=L&&u[L]||u["@@iterator"],typeof u=="function"?u:null)}var K=Symbol.for("react.client.reference");function Z(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===K?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case _:return"Fragment";case b:return"Profiler";case S:return"StrictMode";case R:return"Suspense";case D:return"SuspenseList";case O:return"Activity"}if(typeof u=="object")switch(u.$$typeof){case v:return"Portal";case T:return u.displayName||"Context";case w:return(u._context.displayName||"Context")+".Consumer";case E:var f=u.render;return u=u.displayName,u||(u=f.displayName||f.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case F:return f=u.displayName||null,f!==null?f:Z(u.type)||"Memo";case U:f=u._payload,u=u._init;try{return Z(u(f))}catch{}}return null}var Q=Array.isArray,P=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,W=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,q={pending:!1,data:null,method:null,action:null},se=[],le=-1;function Y(u){return{current:u}}function re(u){0>le||(u.current=se[le],se[le]=null,le--)}function he(u,f){le++,se[le]=u.current,u.current=f}var me=Y(null),Ne=Y(null),fe=Y(null),Te=Y(null);function Ge(u,f){switch(he(fe,f),he(Ne,u),he(me,null),f.nodeType){case 9:case 11:u=(u=f.documentElement)&&(u=u.namespaceURI)?rF(u):0;break;default:if(u=f.tagName,f=f.namespaceURI)f=rF(f),u=oF(f,u);else switch(u){case"svg":u=1;break;case"math":u=2;break;default:u=0}}re(me),he(me,u)}function nt(){re(me),re(Ne),re(fe)}function yt(u){u.memoizedState!==null&&he(Te,u);var f=me.current,y=oF(f,u.type);f!==y&&(he(Ne,u),he(me,y))}function Dt(u){Ne.current===u&&(re(me),re(Ne)),Te.current===u&&(re(Te),Kb._currentValue=q)}var qt,Bt;function Je(u){if(qt===void 0)try{throw Error()}catch(y){var f=y.stack.trim().match(/\n( *(at )?)/);qt=f&&f[1]||"",Bt=-1<y.stack.indexOf(`
    at`)?" (<anonymous>)":-1<y.stack.indexOf("@")?"@unknown:0:0":""}return`
`+qt+u+Bt}var oe=!1;function Ze(u,f){if(!u||oe)return"";oe=!0;var y=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var A={DetermineComponentFrameRoot:function(){try{if(f){var xt=function(){throw Error()};if(Object.defineProperty(xt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(xt,[])}catch(Qe){var je=Qe}Reflect.construct(u,[],xt)}else{try{xt.call()}catch(Qe){je=Qe}u.call(xt.prototype)}}else{try{throw Error()}catch(Qe){je=Qe}(xt=u())&&typeof xt.catch=="function"&&xt.catch(function(){})}}catch(Qe){if(Qe&&je&&typeof Qe.stack=="string")return[Qe.stack,je.stack]}return[null,null]}};A.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var M=Object.getOwnPropertyDescriptor(A.DetermineComponentFrameRoot,"name");M&&M.configurable&&Object.defineProperty(A.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var I=A.DetermineComponentFrameRoot(),G=I[0],ne=I[1];if(G&&ne){var Ae=G.split(`
`),$e=ne.split(`
`);for(M=A=0;A<Ae.length&&!Ae[A].includes("DetermineComponentFrameRoot");)A++;for(;M<$e.length&&!$e[M].includes("DetermineComponentFrameRoot");)M++;if(A===Ae.length||M===$e.length)for(A=Ae.length-1,M=$e.length-1;1<=A&&0<=M&&Ae[A]!==$e[M];)M--;for(;1<=A&&0<=M;A--,M--)if(Ae[A]!==$e[M]){if(A!==1||M!==1)do if(A--,M--,0>M||Ae[A]!==$e[M]){var ot=`
`+Ae[A].replace(" at new "," at ");return u.displayName&&ot.includes("<anonymous>")&&(ot=ot.replace("<anonymous>",u.displayName)),ot}while(1<=A&&0<=M);break}}}finally{oe=!1,Error.prepareStackTrace=y}return(y=u?u.displayName||u.name:"")?Je(y):""}function it(u,f){switch(u.tag){case 26:case 27:case 5:return Je(u.type);case 16:return Je("Lazy");case 13:return u.child!==f&&f!==null?Je("Suspense Fallback"):Je("Suspense");case 19:return Je("SuspenseList");case 0:case 15:return Ze(u.type,!1);case 11:return Ze(u.type.render,!1);case 1:return Ze(u.type,!0);case 31:return Je("Activity");default:return""}}function ft(u){try{var f="",y=null;do f+=it(u,y),y=u,u=u.return;while(u);return f}catch(A){return`
Error generating stack: `+A.message+`
`+A.stack}}var gt=Object.prototype.hasOwnProperty,Tt=n.unstable_scheduleCallback,Et=n.unstable_cancelCallback,kt=n.unstable_shouldYield,ce=n.unstable_requestPaint,J=n.unstable_now,Ie=n.unstable_getCurrentPriorityLevel,Ye=n.unstable_ImmediatePriority,lt=n.unstable_UserBlockingPriority,Ve=n.unstable_NormalPriority,Gt=n.unstable_LowPriority,Lt=n.unstable_IdlePriority,tn=n.log,Jt=n.unstable_setDisableYieldValue,at=null,ut=null;function Zt(u){if(typeof tn=="function"&&Jt(u),ut&&typeof ut.setStrictMode=="function")try{ut.setStrictMode(at,u)}catch{}}var xe=Math.clz32?Math.clz32:ge,Fe=Math.log,mt=Math.LN2;function ge(u){return u>>>=0,u===0?32:31-(Fe(u)/mt|0)|0}var Ue=256,At=262144,Rt=4194304;function St(u){var f=u&42;if(f!==0)return f;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return u&261888;case 262144:case 524288:case 1048576:case 2097152:return u&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function dt(u,f,y){var A=u.pendingLanes;if(A===0)return 0;var M=0,I=u.suspendedLanes,G=u.pingedLanes;u=u.warmLanes;var ne=A&134217727;return ne!==0?(A=ne&~I,A!==0?M=St(A):(G&=ne,G!==0?M=St(G):y||(y=ne&~u,y!==0&&(M=St(y))))):(ne=A&~I,ne!==0?M=St(ne):G!==0?M=St(G):y||(y=A&~u,y!==0&&(M=St(y)))),M===0?0:f!==0&&f!==M&&(f&I)===0&&(I=M&-M,y=f&-f,I>=y||I===32&&(y&4194048)!==0)?f:M}function Ut(u,f){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&f)===0}function cn(u,f){switch(u){case 1:case 2:case 4:case 8:case 64:return f+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Wn(){var u=Rt;return Rt<<=1,(Rt&62914560)===0&&(Rt=4194304),u}function Fn(u){for(var f=[],y=0;31>y;y++)f.push(u);return f}function ei(u,f){u.pendingLanes|=f,f!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function Ni(u,f,y,A,M,I){var G=u.pendingLanes;u.pendingLanes=y,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=y,u.entangledLanes&=y,u.errorRecoveryDisabledLanes&=y,u.shellSuspendCounter=0;var ne=u.entanglements,Ae=u.expirationTimes,$e=u.hiddenUpdates;for(y=G&~y;0<y;){var ot=31-xe(y),xt=1<<ot;ne[ot]=0,Ae[ot]=-1;var je=$e[ot];if(je!==null)for($e[ot]=null,ot=0;ot<je.length;ot++){var Qe=je[ot];Qe!==null&&(Qe.lane&=-536870913)}y&=~xt}A!==0&&xh(u,A,0),I!==0&&M===0&&u.tag!==0&&(u.suspendedLanes|=I&~(G&~f))}function xh(u,f,y){u.pendingLanes|=f,u.suspendedLanes&=~f;var A=31-xe(f);u.entangledLanes|=f,u.entanglements[A]=u.entanglements[A]|1073741824|y&261930}function fc(u,f){var y=u.entangledLanes|=f;for(u=u.entanglements;y;){var A=31-xe(y),M=1<<A;M&f|u[A]&f&&(u[A]|=f),y&=~M}}function Oo(u,f){var y=f&-f;return y=(y&42)!==0?1:zi(y),(y&(u.suspendedLanes|f))!==0?0:y}function zi(u){switch(u){case 2:u=1;break;case 8:u=4;break;case 32:u=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:u=128;break;case 268435456:u=134217728;break;default:u=0}return u}function Ar(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function ca(){var u=W.p;return u!==0?u:(u=window.event,u===void 0?32:RF(u.type))}function Cn(u,f){var y=W.p;try{return W.p=u,f()}finally{W.p=y}}var Ji=Math.random().toString(36).slice(2),Un="__reactFiber$"+Ji,j="__reactProps$"+Ji,ae="__reactContainer$"+Ji,Ce="__reactEvents$"+Ji,We="__reactListeners$"+Ji,st="__reactHandles$"+Ji,tt="__reactResources$"+Ji,Mt="__reactMarker$"+Ji;function wt(u){delete u[Un],delete u[j],delete u[Ce],delete u[We],delete u[st]}function Ct(u){var f=u[Un];if(f)return f;for(var y=u.parentNode;y;){if(f=y[ae]||y[Un]){if(y=f.alternate,f.child!==null||y!==null&&y.child!==null)for(u=pF(u);u!==null;){if(y=u[Un])return y;u=pF(u)}return f}u=y,y=u.parentNode}return null}function X(u){if(u=u[Un]||u[ae]){var f=u.tag;if(f===5||f===6||f===13||f===31||f===26||f===27||f===3)return u}return null}function de(u){var f=u.tag;if(f===5||f===26||f===27||f===6)return u.stateNode;throw Error(s(33))}function Se(u){var f=u[tt];return f||(f=u[tt]={hoistableStyles:new Map,hoistableScripts:new Map}),f}function De(u){u[Mt]=!0}var ye=new Set,Ke={};function ct(u,f){vt(u,f),vt(u+"Capture",f)}function vt(u,f){for(Ke[u]=f,u=0;u<f.length;u++)ye.add(f[u])}var It=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Pt={},Kt={};function jt(u){return gt.call(Kt,u)?!0:gt.call(Pt,u)?!1:It.test(u)?Kt[u]=!0:(Pt[u]=!0,!1)}function Qt(u,f,y){if(jt(f))if(y===null)u.removeAttribute(f);else{switch(typeof y){case"undefined":case"function":case"symbol":u.removeAttribute(f);return;case"boolean":var A=f.toLowerCase().slice(0,5);if(A!=="data-"&&A!=="aria-"){u.removeAttribute(f);return}}u.setAttribute(f,""+y)}}function In(u,f,y){if(y===null)u.removeAttribute(f);else{switch(typeof y){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(f);return}u.setAttribute(f,""+y)}}function hn(u,f,y,A){if(A===null)u.removeAttribute(y);else{switch(typeof A){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(y);return}u.setAttributeNS(f,y,""+A)}}function bn(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function jn(u){var f=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(f==="checkbox"||f==="radio")}function dn(u,f,y){var A=Object.getOwnPropertyDescriptor(u.constructor.prototype,f);if(!u.hasOwnProperty(f)&&typeof A<"u"&&typeof A.get=="function"&&typeof A.set=="function"){var M=A.get,I=A.set;return Object.defineProperty(u,f,{configurable:!0,get:function(){return M.call(this)},set:function(G){y=""+G,I.call(this,G)}}),Object.defineProperty(u,f,{enumerable:A.enumerable}),{getValue:function(){return y},setValue:function(G){y=""+G},stopTracking:function(){u._valueTracker=null,delete u[f]}}}}function zn(u){if(!u._valueTracker){var f=jn(u)?"checked":"value";u._valueTracker=dn(u,f,""+u[f])}}function nn(u){if(!u)return!1;var f=u._valueTracker;if(!f)return!0;var y=f.getValue(),A="";return u&&(A=jn(u)?u.checked?"true":"false":u.value),u=A,u!==y?(f.setValue(u),!0):!1}function ss(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var ms=/[\n"\\]/g;function mn(u){return u.replace(ms,function(f){return"\\"+f.charCodeAt(0).toString(16)+" "})}function li(u,f,y,A,M,I,G,ne){u.name="",G!=null&&typeof G!="function"&&typeof G!="symbol"&&typeof G!="boolean"?u.type=G:u.removeAttribute("type"),f!=null?G==="number"?(f===0&&u.value===""||u.value!=f)&&(u.value=""+bn(f)):u.value!==""+bn(f)&&(u.value=""+bn(f)):G!=="submit"&&G!=="reset"||u.removeAttribute("value"),f!=null?vs(u,G,bn(f)):y!=null?vs(u,G,bn(y)):A!=null&&u.removeAttribute("value"),M==null&&I!=null&&(u.defaultChecked=!!I),M!=null&&(u.checked=M&&typeof M!="function"&&typeof M!="symbol"),ne!=null&&typeof ne!="function"&&typeof ne!="symbol"&&typeof ne!="boolean"?u.name=""+bn(ne):u.removeAttribute("name")}function cs(u,f,y,A,M,I,G,ne){if(I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(u.type=I),f!=null||y!=null){if(!(I!=="submit"&&I!=="reset"||f!=null)){zn(u);return}y=y!=null?""+bn(y):"",f=f!=null?""+bn(f):y,ne||f===u.value||(u.value=f),u.defaultValue=f}A=A??M,A=typeof A!="function"&&typeof A!="symbol"&&!!A,u.checked=ne?u.checked:!!A,u.defaultChecked=!!A,G!=null&&typeof G!="function"&&typeof G!="symbol"&&typeof G!="boolean"&&(u.name=G),zn(u)}function vs(u,f,y){f==="number"&&ss(u.ownerDocument)===u||u.defaultValue===""+y||(u.defaultValue=""+y)}function Ps(u,f,y,A){if(u=u.options,f){f={};for(var M=0;M<y.length;M++)f["$"+y[M]]=!0;for(y=0;y<u.length;y++)M=f.hasOwnProperty("$"+u[y].value),u[y].selected!==M&&(u[y].selected=M),M&&A&&(u[y].defaultSelected=!0)}else{for(y=""+bn(y),f=null,M=0;M<u.length;M++){if(u[M].value===y){u[M].selected=!0,A&&(u[M].defaultSelected=!0);return}f!==null||u[M].disabled||(f=u[M])}f!==null&&(f.selected=!0)}}function Zi(u,f,y){if(f!=null&&(f=""+bn(f),f!==u.value&&(u.value=f),y==null)){u.defaultValue!==f&&(u.defaultValue=f);return}u.defaultValue=y!=null?""+bn(y):""}function pi(u,f,y,A){if(f==null){if(A!=null){if(y!=null)throw Error(s(92));if(Q(A)){if(1<A.length)throw Error(s(93));A=A[0]}y=A}y==null&&(y=""),f=y}y=bn(f),u.defaultValue=y,A=u.textContent,A===y&&A!==""&&A!==null&&(u.value=A),zn(u)}function nl(u,f){if(f){var y=u.firstChild;if(y&&y===u.lastChild&&y.nodeType===3){y.nodeValue=f;return}}u.textContent=f}var Bo=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function gp(u,f,y){var A=f.indexOf("--")===0;y==null||typeof y=="boolean"||y===""?A?u.setProperty(f,""):f==="float"?u.cssFloat="":u[f]="":A?u.setProperty(f,y):typeof y!="number"||y===0||Bo.has(f)?f==="float"?u.cssFloat=y:u[f]=(""+y).trim():u[f]=y+"px"}function Nv(u,f,y){if(f!=null&&typeof f!="object")throw Error(s(62));if(u=u.style,y!=null){for(var A in y)!y.hasOwnProperty(A)||f!=null&&f.hasOwnProperty(A)||(A.indexOf("--")===0?u.setProperty(A,""):A==="float"?u.cssFloat="":u[A]="");for(var M in f)A=f[M],f.hasOwnProperty(M)&&y[M]!==A&&gp(u,M,A)}else for(var I in f)f.hasOwnProperty(I)&&gp(u,I,f[I])}function xp(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var MA=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),NA=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function yp(u){return NA.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}function Ml(){}var vp=null;function $g(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var yh=null,cu=null;function Rv(u){var f=X(u);if(f&&(u=f.stateNode)){var y=u[j]||null;e:switch(u=f.stateNode,f.type){case"input":if(li(u,y.value,y.defaultValue,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name),f=y.name,y.type==="radio"&&f!=null){for(y=u;y.parentNode;)y=y.parentNode;for(y=y.querySelectorAll('input[name="'+mn(""+f)+'"][type="radio"]'),f=0;f<y.length;f++){var A=y[f];if(A!==u&&A.form===u.form){var M=A[j]||null;if(!M)throw Error(s(90));li(A,M.value,M.defaultValue,M.defaultValue,M.checked,M.defaultChecked,M.type,M.name)}}for(f=0;f<y.length;f++)A=y[f],A.form===u.form&&nn(A)}break e;case"textarea":Zi(u,y.value,y.defaultValue);break e;case"select":f=y.value,f!=null&&Ps(u,!!y.multiple,f,!1)}}}var Gg=!1;function Iv(u,f,y){if(Gg)return u(f,y);Gg=!0;try{var A=u(f);return A}finally{if(Gg=!1,(yh!==null||cu!==null)&&(ie(),yh&&(f=yh,u=cu,cu=yh=null,Rv(f),u)))for(f=0;f<u.length;f++)Rv(u[f])}}function vh(u,f){var y=u.stateNode;if(y===null)return null;var A=y[j]||null;if(A===null)return null;y=A[f];e:switch(f){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(A=!A.disabled)||(u=u.type,A=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!A;break e;default:u=!1}if(u)return null;if(y&&typeof y!="function")throw Error(s(231,f,typeof y));return y}var Nl=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Vg=!1;if(Nl)try{var bp={};Object.defineProperty(bp,"passive",{get:function(){Vg=!0}}),window.addEventListener("test",bp,bp),window.removeEventListener("test",bp,bp)}catch{Vg=!1}var uu=null,Hg=null,hu=null;function Wg(){if(hu)return hu;var u,f=Hg,y=f.length,A,M="value"in uu?uu.value:uu.textContent,I=M.length;for(u=0;u<y&&f[u]===M[u];u++);var G=y-u;for(A=1;A<=G&&f[y-A]===M[I-A];A++);return hu=M.slice(u,1<A?1-A:void 0)}function bh(u){var f=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&f===13&&(u=13)):u=f,u===10&&(u=13),32<=u||u===13?u:0}function Sp(){return!0}function Dv(){return!1}function Pa(u){function f(y,A,M,I,G){this._reactName=y,this._targetInst=M,this.type=A,this.nativeEvent=I,this.target=G,this.currentTarget=null;for(var ne in u)u.hasOwnProperty(ne)&&(y=u[ne],this[ne]=y?y(I):I[ne]);return this.isDefaultPrevented=(I.defaultPrevented!=null?I.defaultPrevented:I.returnValue===!1)?Sp:Dv,this.isPropagationStopped=Dv,this}return d(f.prototype,{preventDefault:function(){this.defaultPrevented=!0;var y=this.nativeEvent;y&&(y.preventDefault?y.preventDefault():typeof y.returnValue!="unknown"&&(y.returnValue=!1),this.isDefaultPrevented=Sp)},stopPropagation:function(){var y=this.nativeEvent;y&&(y.stopPropagation?y.stopPropagation():typeof y.cancelBubble!="unknown"&&(y.cancelBubble=!0),this.isPropagationStopped=Sp)},persist:function(){},isPersistent:Sp}),f}var du={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},_p=Pa(du),sl=d({},du,{view:0,detail:0}),jg=Pa(sl),Xg,Ap,Id,wp=d({},sl,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Tp,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==Id&&(Id&&u.type==="mousemove"?(Xg=u.screenX-Id.screenX,Ap=u.screenY-Id.screenY):Ap=Xg=0,Id=u),Xg)},movementY:function(u){return"movementY"in u?u.movementY:Ap}}),RA=Pa(wp),_a=d({},wp,{dataTransfer:0}),IA=Pa(_a),DA=d({},sl,{relatedTarget:0}),qg=Pa(DA),OA=d({},du,{animationName:0,elapsedTime:0,pseudoElement:0}),BA=Pa(OA),Cp=d({},du,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),Ov=Pa(Cp),kA=d({},du,{data:0}),Bv=Pa(kA),LA={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kv={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Lv={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function FA(u){var f=this.nativeEvent;return f.getModifierState?f.getModifierState(u):(u=Lv[u])?!!f[u]:!1}function Tp(){return FA}var Fv=d({},sl,{key:function(u){if(u.key){var f=LA[u.key]||u.key;if(f!=="Unidentified")return f}return u.type==="keypress"?(u=bh(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?kv[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Tp,charCode:function(u){return u.type==="keypress"?bh(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?bh(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),Uv=Pa(Fv),UA=d({},wp,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Kg=Pa(UA),PA=d({},sl,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Tp}),pc=Pa(PA),Pv=d({},du,{propertyName:0,elapsedTime:0,pseudoElement:0}),YN=Pa(Pv),zA=d({},wp,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),fu=Pa(zA),mc=d({},du,{newState:0,oldState:0}),zv=Pa(mc),$v=[9,13,27,32],Sh=Nl&&"CompositionEvent"in window,pu=null;Nl&&"documentMode"in document&&(pu=document.documentMode);var _h=Nl&&"TextEvent"in window&&!pu,Aa=Nl&&(!Sh||pu&&8<pu&&11>=pu),Ep=" ",Gv=!1;function Yg(u,f){switch(u){case"keyup":return $v.indexOf(f.keyCode)!==-1;case"keydown":return f.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Dd(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var mu=!1;function Jg(u,f){switch(u){case"compositionend":return Dd(f);case"keypress":return f.which!==32?null:(Gv=!0,Ep);case"textInput":return u=f.data,u===Ep&&Gv?null:u;default:return null}}function $A(u,f){if(mu)return u==="compositionend"||!Sh&&Yg(u,f)?(u=Wg(),hu=Hg=uu=null,mu=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(f.ctrlKey||f.altKey||f.metaKey)||f.ctrlKey&&f.altKey){if(f.char&&1<f.char.length)return f.char;if(f.which)return String.fromCharCode(f.which)}return null;case"compositionend":return Aa&&f.locale!=="ko"?null:f.data;default:return null}}var Jr={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vv(u){var f=u&&u.nodeName&&u.nodeName.toLowerCase();return f==="input"?!!Jr[u.type]:f==="textarea"}function Zg(u,f,y,A){yh?cu?cu.push(A):cu=[A]:yh=A,f=Dw(f,"onChange"),0<f.length&&(y=new _p("onChange","change",null,y,A),u.push({event:y,listeners:f}))}var Od=null,Bd=null;function Hv(u){eF(u,0)}function kd(u){var f=de(u);if(nn(f))return u}function Wv(u,f){if(u==="change")return f}var Mp=!1;if(Nl){var Ah;if(Nl){var ti="oninput"in document;if(!ti){var GA=document.createElement("div");GA.setAttribute("oninput","return;"),ti=typeof GA.oninput=="function"}Ah=ti}else Ah=!1;Mp=Ah&&(!document.documentMode||9<document.documentMode)}function VA(){Od&&(Od.detachEvent("onpropertychange",jv),Bd=Od=null)}function jv(u){if(u.propertyName==="value"&&kd(Bd)){var f=[];Zg(f,Bd,u,$g(u)),Iv(Hv,f)}}function Np(u,f,y){u==="focusin"?(VA(),Od=f,Bd=y,Od.attachEvent("onpropertychange",jv)):u==="focusout"&&VA()}function gu(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return kd(Bd)}function HA(u,f){if(u==="click")return kd(f)}function WA(u,f){if(u==="input"||u==="change")return kd(f)}function wh(u,f){return u===f&&(u!==0||1/u===1/f)||u!==u&&f!==f}var ni=typeof Object.is=="function"?Object.is:wh;function Ld(u,f){if(ni(u,f))return!0;if(typeof u!="object"||u===null||typeof f!="object"||f===null)return!1;var y=Object.keys(u),A=Object.keys(f);if(y.length!==A.length)return!1;for(A=0;A<y.length;A++){var M=y[A];if(!gt.call(f,M)||!ni(u[M],f[M]))return!1}return!0}function Xv(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function qv(u,f){var y=Xv(u);u=0;for(var A;y;){if(y.nodeType===3){if(A=u+y.textContent.length,u<=f&&A>=f)return{node:y,offset:f-u};u=A}e:{for(;y;){if(y.nextSibling){y=y.nextSibling;break e}y=y.parentNode}y=void 0}y=Xv(y)}}function Qg(u,f){return u&&f?u===f?!0:u&&u.nodeType===3?!1:f&&f.nodeType===3?Qg(u,f.parentNode):"contains"in u?u.contains(f):u.compareDocumentPosition?!!(u.compareDocumentPosition(f)&16):!1:!1}function e0(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var f=ss(u.document);f instanceof u.HTMLIFrameElement;){try{var y=typeof f.contentWindow.location.href=="string"}catch{y=!1}if(y)u=f.contentWindow;else break;f=ss(u.document)}return f}function Fd(u){var f=u&&u.nodeName&&u.nodeName.toLowerCase();return f&&(f==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||f==="textarea"||u.contentEditable==="true")}var jA=Nl&&"documentMode"in document&&11>=document.documentMode,Ud=null,t0=null,Pd=null,Zr=!1;function n0(u,f,y){var A=y.window===y?y.document:y.nodeType===9?y:y.ownerDocument;Zr||Ud==null||Ud!==ss(A)||(A=Ud,"selectionStart"in A&&Fd(A)?A={start:A.selectionStart,end:A.selectionEnd}:(A=(A.ownerDocument&&A.ownerDocument.defaultView||window).getSelection(),A={anchorNode:A.anchorNode,anchorOffset:A.anchorOffset,focusNode:A.focusNode,focusOffset:A.focusOffset}),Pd&&Ld(Pd,A)||(Pd=A,A=Dw(t0,"onSelect"),0<A.length&&(f=new _p("onSelect","select",null,f,y),u.push({event:f,listeners:A}),f.target=Ud)))}function xu(u,f){var y={};return y[u.toLowerCase()]=f.toLowerCase(),y["Webkit"+u]="webkit"+f,y["Moz"+u]="moz"+f,y}var zd={animationend:xu("Animation","AnimationEnd"),animationiteration:xu("Animation","AnimationIteration"),animationstart:xu("Animation","AnimationStart"),transitionrun:xu("Transition","TransitionRun"),transitionstart:xu("Transition","TransitionStart"),transitioncancel:xu("Transition","TransitionCancel"),transitionend:xu("Transition","TransitionEnd")},Rp={},or={};Nl&&(or=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);function yu(u){if(Rp[u])return Rp[u];if(!zd[u])return u;var f=zd[u],y;for(y in f)if(f.hasOwnProperty(y)&&y in or)return Rp[u]=f[y];return u}var wr=yu("animationend"),Kv=yu("animationiteration"),Rl=yu("animationstart"),$d=yu("transitionrun"),vu=yu("transitionstart"),Yv=yu("transitioncancel"),s0=yu("transitionend"),gc=new Map,i0="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");i0.push("scrollEnd");function za(u,f){gc.set(u,f),ct(f,[u])}var bu=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var f=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(f))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",u);return}console.error(u)},ua=[],Ch=0,a0=0;function Su(){for(var u=Ch,f=a0=Ch=0;f<u;){var y=ua[f];ua[f++]=null;var A=ua[f];ua[f++]=null;var M=ua[f];ua[f++]=null;var I=ua[f];if(ua[f++]=null,A!==null&&M!==null){var G=A.pending;G===null?M.next=M:(M.next=G.next,G.next=M),A.pending=M}I!==0&&r0(y,M,I)}}function Ip(u,f,y,A){ua[Ch++]=u,ua[Ch++]=f,ua[Ch++]=y,ua[Ch++]=A,a0|=A,u.lanes|=A,u=u.alternate,u!==null&&(u.lanes|=A)}function Gd(u,f,y,A){return Ip(u,f,y,A),Vd(u)}function _u(u,f){return Ip(u,null,null,f),Vd(u)}function r0(u,f,y){u.lanes|=y;var A=u.alternate;A!==null&&(A.lanes|=y);for(var M=!1,I=u.return;I!==null;)I.childLanes|=y,A=I.alternate,A!==null&&(A.childLanes|=y),I.tag===22&&(u=I.stateNode,u===null||u._visibility&1||(M=!0)),u=I,I=I.return;return u.tag===3?(I=u.stateNode,M&&f!==null&&(M=31-xe(y),u=I.hiddenUpdates,A=u[M],A===null?u[M]=[f]:A.push(f),f.lane=y|536870912),I):null}function Vd(u){if(50<Gh)throw Gh=0,Vh=null,Error(s(185));for(var f=u.return;f!==null;)u=f,f=u.return;return u.tag===3?u.stateNode:null}var Au={};function XA(u,f,y,A){this.tag=u,this.key=y,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=f,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=A,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function lr(u,f,y,A){return new XA(u,f,y,A)}function cr(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Il(u,f){var y=u.alternate;return y===null?(y=lr(u.tag,f,u.key,u.mode),y.elementType=u.elementType,y.type=u.type,y.stateNode=u.stateNode,y.alternate=u,u.alternate=y):(y.pendingProps=f,y.type=u.type,y.flags=0,y.subtreeFlags=0,y.deletions=null),y.flags=u.flags&65011712,y.childLanes=u.childLanes,y.lanes=u.lanes,y.child=u.child,y.memoizedProps=u.memoizedProps,y.memoizedState=u.memoizedState,y.updateQueue=u.updateQueue,f=u.dependencies,y.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext},y.sibling=u.sibling,y.index=u.index,y.ref=u.ref,y.refCleanup=u.refCleanup,y}function $a(u,f){u.flags&=65011714;var y=u.alternate;return y===null?(u.childLanes=0,u.lanes=f,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=y.childLanes,u.lanes=y.lanes,u.child=y.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=y.memoizedProps,u.memoizedState=y.memoizedState,u.updateQueue=y.updateQueue,u.type=y.type,f=y.dependencies,u.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext}),u}function Dp(u,f,y,A,M,I){var G=0;if(A=u,typeof u=="function")cr(u)&&(G=1);else if(typeof u=="string")G=M7(u,y,me.current)?26:u==="html"||u==="head"||u==="body"?27:5;else e:switch(u){case O:return u=lr(31,y,f,M),u.elementType=O,u.lanes=I,u;case _:return xc(y.children,M,I,f);case S:G=8,M|=24;break;case b:return u=lr(12,y,f,M|2),u.elementType=b,u.lanes=I,u;case R:return u=lr(13,y,f,M),u.elementType=R,u.lanes=I,u;case D:return u=lr(19,y,f,M),u.elementType=D,u.lanes=I,u;default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case T:G=10;break e;case w:G=9;break e;case E:G=11;break e;case F:G=14;break e;case U:G=16,A=null;break e}G=29,y=Error(s(130,u===null?"null":typeof u,"")),A=null}return f=lr(G,y,f,M),f.elementType=u,f.type=A,f.lanes=I,f}function xc(u,f,y,A){return u=lr(7,u,A,f),u.lanes=y,u}function o0(u,f,y){return u=lr(6,u,null,f),u.lanes=y,u}function qA(u){var f=lr(18,null,null,0);return f.stateNode=u,f}function il(u,f,y){return f=lr(4,u.children!==null?u.children:[],u.key,f),f.lanes=y,f.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},f}var Jv=new WeakMap;function Cr(u,f){if(typeof u=="object"&&u!==null){var y=Jv.get(u);return y!==void 0?y:(f={value:u,source:f,stack:ft(f)},Jv.set(u,f),f)}return{value:u,source:f,stack:ft(f)}}var al=[],Th=0,Op=null,Hd=0,Qr=[],Tr=0,Dl=null,Ol=1,Bl="";function yc(u,f){al[Th++]=Hd,al[Th++]=Op,Op=u,Hd=f}function Zv(u,f,y){Qr[Tr++]=Ol,Qr[Tr++]=Bl,Qr[Tr++]=Dl,Dl=u;var A=Ol;u=Bl;var M=32-xe(A)-1;A&=~(1<<M),y+=1;var I=32-xe(f)+M;if(30<I){var G=M-M%5;I=(A&(1<<G)-1).toString(32),A>>=G,M-=G,Ol=1<<32-xe(f)+M|y<<M|A,Bl=I+u}else Ol=1<<I|y<<M|A,Bl=u}function l0(u){u.return!==null&&(yc(u,1),Zv(u,1,0))}function wu(u){for(;u===Op;)Op=al[--Th],al[Th]=null,Hd=al[--Th],al[Th]=null;for(;u===Dl;)Dl=Qr[--Tr],Qr[Tr]=null,Bl=Qr[--Tr],Qr[Tr]=null,Ol=Qr[--Tr],Qr[Tr]=null}function Bp(u,f){Qr[Tr++]=Ol,Qr[Tr++]=Bl,Qr[Tr++]=Dl,Ol=f.id,Bl=f.overflow,Dl=u}var ha=null,Ks=null,us=!1,vc=null,da=!1,c0=Error(s(519));function rs(u){var f=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw kp(Cr(f,u)),c0}function u0(u){var f=u.stateNode,y=u.type,A=u.memoizedProps;switch(f[Un]=u,f[j]=A,y){case"dialog":hs("cancel",f),hs("close",f);break;case"iframe":case"object":case"embed":hs("load",f);break;case"video":case"audio":for(y=0;y<Hb.length;y++)hs(Hb[y],f);break;case"source":hs("error",f);break;case"img":case"image":case"link":hs("error",f),hs("load",f);break;case"details":hs("toggle",f);break;case"input":hs("invalid",f),cs(f,A.value,A.defaultValue,A.checked,A.defaultChecked,A.type,A.name,!0);break;case"select":hs("invalid",f);break;case"textarea":hs("invalid",f),pi(f,A.value,A.defaultValue,A.children)}y=A.children,typeof y!="string"&&typeof y!="number"&&typeof y!="bigint"||f.textContent===""+y||A.suppressHydrationWarning===!0||iF(f.textContent,y)?(A.popover!=null&&(hs("beforetoggle",f),hs("toggle",f)),A.onScroll!=null&&hs("scroll",f),A.onScrollEnd!=null&&hs("scrollend",f),A.onClick!=null&&(f.onclick=Ml),f=!0):f=!1,f||rs(u,!0)}function KA(u){for(ha=u.return;ha;)switch(ha.tag){case 5:case 31:case 13:da=!1;return;case 27:case 3:da=!0;return;default:ha=ha.return}}function Eh(u){if(u!==ha)return!1;if(!us)return KA(u),us=!0,!1;var f=u.tag,y;if((y=f!==3&&f!==27)&&((y=f===5)&&(y=u.type,y=!(y!=="form"&&y!=="button")||gR(u.type,u.memoizedProps)),y=!y),y&&Ks&&rs(u),KA(u),f===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Ks=fF(u)}else if(f===31){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Ks=fF(u)}else f===27?(f=Ks,uf(u.type)?(u=SR,SR=null,Ks=u):Ks=f):Ks=ha?Wl(u.stateNode.nextSibling):null;return!0}function Mh(){Ks=ha=null,us=!1}function Qv(){var u=vc;return u!==null&&(Xa===null?Xa=u:Xa.push.apply(Xa,u),vc=null),u}function kp(u){vc===null?vc=[u]:vc.push(u)}var eb=Y(null),bc=null,Ga=null;function Sc(u,f,y){he(eb,f._currentValue),f._currentValue=y}function ko(u){u._currentValue=eb.current,re(eb)}function _c(u,f,y){for(;u!==null;){var A=u.alternate;if((u.childLanes&f)!==f?(u.childLanes|=f,A!==null&&(A.childLanes|=f)):A!==null&&(A.childLanes&f)!==f&&(A.childLanes|=f),u===y)break;u=u.return}}function h0(u,f,y,A){var M=u.child;for(M!==null&&(M.return=u);M!==null;){var I=M.dependencies;if(I!==null){var G=M.child;I=I.firstContext;e:for(;I!==null;){var ne=I;I=M;for(var Ae=0;Ae<f.length;Ae++)if(ne.context===f[Ae]){I.lanes|=y,ne=I.alternate,ne!==null&&(ne.lanes|=y),_c(I.return,y,u),A||(G=null);break e}I=ne.next}}else if(M.tag===18){if(G=M.return,G===null)throw Error(s(341));G.lanes|=y,I=G.alternate,I!==null&&(I.lanes|=y),_c(G,y,u),G=null}else G=M.child;if(G!==null)G.return=M;else for(G=M;G!==null;){if(G===u){G=null;break}if(M=G.sibling,M!==null){M.return=G.return,G=M;break}G=G.return}M=G}}function Cu(u,f,y,A){u=null;for(var M=f,I=!1;M!==null;){if(!I){if((M.flags&524288)!==0)I=!0;else if((M.flags&262144)!==0)break}if(M.tag===10){var G=M.alternate;if(G===null)throw Error(s(387));if(G=G.memoizedProps,G!==null){var ne=M.type;ni(M.pendingProps.value,G.value)||(u!==null?u.push(ne):u=[ne])}}else if(M===Te.current){if(G=M.alternate,G===null)throw Error(s(387));G.memoizedState.memoizedState!==M.memoizedState.memoizedState&&(u!==null?u.push(Kb):u=[Kb])}M=M.return}u!==null&&h0(f,u,y,A),f.flags|=262144}function Wd(u){for(u=u.firstContext;u!==null;){if(!ni(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function Nh(u){bc=u,Ga=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function fa(u){return tb(bc,u)}function Lp(u,f){return bc===null&&Nh(u),tb(u,f)}function tb(u,f){var y=f._currentValue;if(f={context:f,memoizedValue:y,next:null},Ga===null){if(u===null)throw Error(s(308));Ga=f,u.dependencies={lanes:0,firstContext:f},u.flags|=524288}else Ga=Ga.next=f;return y}var YA=typeof AbortController<"u"?AbortController:function(){var u=[],f=this.signal={aborted:!1,addEventListener:function(y,A){u.push(A)}};this.abort=function(){f.aborted=!0,u.forEach(function(y){return y()})}},JA=n.unstable_scheduleCallback,nb=n.unstable_NormalPriority,xn={$$typeof:T,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function sb(){return{controller:new YA,data:new Map,refCount:0}}function wa(u){u.refCount--,u.refCount===0&&JA(nb,function(){u.controller.abort()})}var Rh=null,ib=0,Ac=0,rl=null;function jd(u,f){if(Rh===null){var y=Rh=[];ib=0,Ac=oR(),rl={status:"pending",value:void 0,then:function(A){y.push(A)}}}return ib++,f.then(ab,ab),f}function ab(){if(--ib===0&&Rh!==null){rl!==null&&(rl.status="fulfilled");var u=Rh;Rh=null,Ac=0,rl=null;for(var f=0;f<u.length;f++)(0,u[f])()}}function rb(u,f){var y=[],A={status:"pending",value:null,reason:null,then:function(M){y.push(M)}};return u.then(function(){A.status="fulfilled",A.value=f;for(var M=0;M<y.length;M++)(0,y[M])(f)},function(M){for(A.status="rejected",A.reason=M,M=0;M<y.length;M++)(0,y[M])(void 0)}),A}var ZA=P.S;P.S=function(u,f){of=J(),typeof f=="object"&&f!==null&&typeof f.then=="function"&&jd(u,f),ZA!==null&&ZA(u,f)};var Tu=Y(null);function kl(){var u=Tu.current;return u!==null?u:Os.pooledCache}function Xd(u,f){f===null?he(Tu,Tu.current):he(Tu,f.pool)}function d0(){var u=kl();return u===null?null:{parent:xn._currentValue,pool:u}}var Eu=Error(s(460)),Fp=Error(s(474)),ol=Error(s(542)),Up={then:function(){}};function QA(u){return u=u.status,u==="fulfilled"||u==="rejected"}function ob(u,f,y){switch(y=u[y],y===void 0?u.push(f):y!==f&&(f.then(Ml,Ml),f=y),f.status){case"fulfilled":return f.value;case"rejected":throw u=f.reason,lb(u),u;default:if(typeof f.status=="string")f.then(Ml,Ml);else{if(u=Os,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=f,u.status="pending",u.then(function(A){if(f.status==="pending"){var M=f;M.status="fulfilled",M.value=A}},function(A){if(f.status==="pending"){var M=f;M.status="rejected",M.reason=A}})}switch(f.status){case"fulfilled":return f.value;case"rejected":throw u=f.reason,lb(u),u}throw An=f,Eu}}function Ih(u){try{var f=u._init;return f(u._payload)}catch(y){throw y!==null&&typeof y=="object"&&typeof y.then=="function"?(An=y,Eu):y}}var An=null;function f0(){if(An===null)throw Error(s(459));var u=An;return An=null,u}function lb(u){if(u===Eu||u===ol)throw Error(s(483))}var Mu=null,Nu=0;function p0(u){var f=Nu;return Nu+=1,Mu===null&&(Mu=[]),ob(Mu,u,f)}function Pp(u,f){f=f.props.ref,u.ref=f!==void 0?f:null}function zp(u,f){throw f.$$typeof===p?Error(s(525)):(u=Object.prototype.toString.call(f),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(f).join(", ")+"}":u)))}function qd(u){function f(Be,Re){if(u){var ze=Be.deletions;ze===null?(Be.deletions=[Re],Be.flags|=16):ze.push(Re)}}function y(Be,Re){if(!u)return null;for(;Re!==null;)f(Be,Re),Re=Re.sibling;return null}function A(Be){for(var Re=new Map;Be!==null;)Be.key!==null?Re.set(Be.key,Be):Re.set(Be.index,Be),Be=Be.sibling;return Re}function M(Be,Re){return Be=Il(Be,Re),Be.index=0,Be.sibling=null,Be}function I(Be,Re,ze){return Be.index=ze,u?(ze=Be.alternate,ze!==null?(ze=ze.index,ze<Re?(Be.flags|=67108866,Re):ze):(Be.flags|=67108866,Re)):(Be.flags|=1048576,Re)}function G(Be){return u&&Be.alternate===null&&(Be.flags|=67108866),Be}function ne(Be,Re,ze,pt){return Re===null||Re.tag!==6?(Re=o0(ze,Be.mode,pt),Re.return=Be,Re):(Re=M(Re,ze),Re.return=Be,Re)}function Ae(Be,Re,ze,pt){var Sn=ze.type;return Sn===_?ot(Be,Re,ze.props.children,pt,ze.key):Re!==null&&(Re.elementType===Sn||typeof Sn=="object"&&Sn!==null&&Sn.$$typeof===U&&Ih(Sn)===Re.type)?(Re=M(Re,ze.props),Pp(Re,ze),Re.return=Be,Re):(Re=Dp(ze.type,ze.key,ze.props,null,Be.mode,pt),Pp(Re,ze),Re.return=Be,Re)}function $e(Be,Re,ze,pt){return Re===null||Re.tag!==4||Re.stateNode.containerInfo!==ze.containerInfo||Re.stateNode.implementation!==ze.implementation?(Re=il(ze,Be.mode,pt),Re.return=Be,Re):(Re=M(Re,ze.children||[]),Re.return=Be,Re)}function ot(Be,Re,ze,pt,Sn){return Re===null||Re.tag!==7?(Re=xc(ze,Be.mode,pt,Sn),Re.return=Be,Re):(Re=M(Re,ze),Re.return=Be,Re)}function xt(Be,Re,ze){if(typeof Re=="string"&&Re!==""||typeof Re=="number"||typeof Re=="bigint")return Re=o0(""+Re,Be.mode,ze),Re.return=Be,Re;if(typeof Re=="object"&&Re!==null){switch(Re.$$typeof){case g:return ze=Dp(Re.type,Re.key,Re.props,null,Be.mode,ze),Pp(ze,Re),ze.return=Be,ze;case v:return Re=il(Re,Be.mode,ze),Re.return=Be,Re;case U:return Re=Ih(Re),xt(Be,Re,ze)}if(Q(Re)||H(Re))return Re=xc(Re,Be.mode,ze,null),Re.return=Be,Re;if(typeof Re.then=="function")return xt(Be,p0(Re),ze);if(Re.$$typeof===T)return xt(Be,Lp(Be,Re),ze);zp(Be,Re)}return null}function je(Be,Re,ze,pt){var Sn=Re!==null?Re.key:null;if(typeof ze=="string"&&ze!==""||typeof ze=="number"||typeof ze=="bigint")return Sn!==null?null:ne(Be,Re,""+ze,pt);if(typeof ze=="object"&&ze!==null){switch(ze.$$typeof){case g:return ze.key===Sn?Ae(Be,Re,ze,pt):null;case v:return ze.key===Sn?$e(Be,Re,ze,pt):null;case U:return ze=Ih(ze),je(Be,Re,ze,pt)}if(Q(ze)||H(ze))return Sn!==null?null:ot(Be,Re,ze,pt,null);if(typeof ze.then=="function")return je(Be,Re,p0(ze),pt);if(ze.$$typeof===T)return je(Be,Re,Lp(Be,ze),pt);zp(Be,ze)}return null}function Qe(Be,Re,ze,pt,Sn){if(typeof pt=="string"&&pt!==""||typeof pt=="number"||typeof pt=="bigint")return Be=Be.get(ze)||null,ne(Re,Be,""+pt,Sn);if(typeof pt=="object"&&pt!==null){switch(pt.$$typeof){case g:return Be=Be.get(pt.key===null?ze:pt.key)||null,Ae(Re,Be,pt,Sn);case v:return Be=Be.get(pt.key===null?ze:pt.key)||null,$e(Re,Be,pt,Sn);case U:return pt=Ih(pt),Qe(Be,Re,ze,pt,Sn)}if(Q(pt)||H(pt))return Be=Be.get(ze)||null,ot(Re,Be,pt,Sn,null);if(typeof pt.then=="function")return Qe(Be,Re,ze,p0(pt),Sn);if(pt.$$typeof===T)return Qe(Be,Re,ze,Lp(Re,pt),Sn);zp(Re,pt)}return null}function an(Be,Re,ze,pt){for(var Sn=null,ks=null,fn=Re,Yn=Re=0,ys=null;fn!==null&&Yn<ze.length;Yn++){fn.index>Yn?(ys=fn,fn=null):ys=fn.sibling;var Ls=je(Be,fn,ze[Yn],pt);if(Ls===null){fn===null&&(fn=ys);break}u&&fn&&Ls.alternate===null&&f(Be,fn),Re=I(Ls,Re,Yn),ks===null?Sn=Ls:ks.sibling=Ls,ks=Ls,fn=ys}if(Yn===ze.length)return y(Be,fn),us&&yc(Be,Yn),Sn;if(fn===null){for(;Yn<ze.length;Yn++)fn=xt(Be,ze[Yn],pt),fn!==null&&(Re=I(fn,Re,Yn),ks===null?Sn=fn:ks.sibling=fn,ks=fn);return us&&yc(Be,Yn),Sn}for(fn=A(fn);Yn<ze.length;Yn++)ys=Qe(fn,Be,Yn,ze[Yn],pt),ys!==null&&(u&&ys.alternate!==null&&fn.delete(ys.key===null?Yn:ys.key),Re=I(ys,Re,Yn),ks===null?Sn=ys:ks.sibling=ys,ks=ys);return u&&fn.forEach(function(mf){return f(Be,mf)}),us&&yc(Be,Yn),Sn}function Tn(Be,Re,ze,pt){if(ze==null)throw Error(s(151));for(var Sn=null,ks=null,fn=Re,Yn=Re=0,ys=null,Ls=ze.next();fn!==null&&!Ls.done;Yn++,Ls=ze.next()){fn.index>Yn?(ys=fn,fn=null):ys=fn.sibling;var mf=je(Be,fn,Ls.value,pt);if(mf===null){fn===null&&(fn=ys);break}u&&fn&&mf.alternate===null&&f(Be,fn),Re=I(mf,Re,Yn),ks===null?Sn=mf:ks.sibling=mf,ks=mf,fn=ys}if(Ls.done)return y(Be,fn),us&&yc(Be,Yn),Sn;if(fn===null){for(;!Ls.done;Yn++,Ls=ze.next())Ls=xt(Be,Ls.value,pt),Ls!==null&&(Re=I(Ls,Re,Yn),ks===null?Sn=Ls:ks.sibling=Ls,ks=Ls);return us&&yc(Be,Yn),Sn}for(fn=A(fn);!Ls.done;Yn++,Ls=ze.next())Ls=Qe(fn,Be,Yn,Ls.value,pt),Ls!==null&&(u&&Ls.alternate!==null&&fn.delete(Ls.key===null?Yn:Ls.key),Re=I(Ls,Re,Yn),ks===null?Sn=Ls:ks.sibling=Ls,ks=Ls);return u&&fn.forEach(function(P7){return f(Be,P7)}),us&&yc(Be,Yn),Sn}function Zs(Be,Re,ze,pt){if(typeof ze=="object"&&ze!==null&&ze.type===_&&ze.key===null&&(ze=ze.props.children),typeof ze=="object"&&ze!==null){switch(ze.$$typeof){case g:e:{for(var Sn=ze.key;Re!==null;){if(Re.key===Sn){if(Sn=ze.type,Sn===_){if(Re.tag===7){y(Be,Re.sibling),pt=M(Re,ze.props.children),pt.return=Be,Be=pt;break e}}else if(Re.elementType===Sn||typeof Sn=="object"&&Sn!==null&&Sn.$$typeof===U&&Ih(Sn)===Re.type){y(Be,Re.sibling),pt=M(Re,ze.props),Pp(pt,ze),pt.return=Be,Be=pt;break e}y(Be,Re);break}else f(Be,Re);Re=Re.sibling}ze.type===_?(pt=xc(ze.props.children,Be.mode,pt,ze.key),pt.return=Be,Be=pt):(pt=Dp(ze.type,ze.key,ze.props,null,Be.mode,pt),Pp(pt,ze),pt.return=Be,Be=pt)}return G(Be);case v:e:{for(Sn=ze.key;Re!==null;){if(Re.key===Sn)if(Re.tag===4&&Re.stateNode.containerInfo===ze.containerInfo&&Re.stateNode.implementation===ze.implementation){y(Be,Re.sibling),pt=M(Re,ze.children||[]),pt.return=Be,Be=pt;break e}else{y(Be,Re);break}else f(Be,Re);Re=Re.sibling}pt=il(ze,Be.mode,pt),pt.return=Be,Be=pt}return G(Be);case U:return ze=Ih(ze),Zs(Be,Re,ze,pt)}if(Q(ze))return an(Be,Re,ze,pt);if(H(ze)){if(Sn=H(ze),typeof Sn!="function")throw Error(s(150));return ze=Sn.call(ze),Tn(Be,Re,ze,pt)}if(typeof ze.then=="function")return Zs(Be,Re,p0(ze),pt);if(ze.$$typeof===T)return Zs(Be,Re,Lp(Be,ze),pt);zp(Be,ze)}return typeof ze=="string"&&ze!==""||typeof ze=="number"||typeof ze=="bigint"?(ze=""+ze,Re!==null&&Re.tag===6?(y(Be,Re.sibling),pt=M(Re,ze),pt.return=Be,Be=pt):(y(Be,Re),pt=o0(ze,Be.mode,pt),pt.return=Be,Be=pt),G(Be)):y(Be,Re)}return function(Be,Re,ze,pt){try{Nu=0;var Sn=Zs(Be,Re,ze,pt);return Mu=null,Sn}catch(fn){if(fn===Eu||fn===ol)throw fn;var ks=lr(29,fn,null,Be.mode);return ks.lanes=pt,ks.return=Be,ks}finally{}}}var Dh=qd(!0),ew=qd(!1),Ru=!1;function cb(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ub(u,f){u=u.updateQueue,f.updateQueue===u&&(f.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function Ll(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function wc(u,f,y){var A=u.updateQueue;if(A===null)return null;if(A=A.shared,(gs&2)!==0){var M=A.pending;return M===null?f.next=f:(f.next=M.next,M.next=f),A.pending=f,f=Vd(u),r0(u,null,y),f}return Ip(u,A,f,y),Vd(u)}function Iu(u,f,y){if(f=f.updateQueue,f!==null&&(f=f.shared,(y&4194048)!==0)){var A=f.lanes;A&=u.pendingLanes,y|=A,f.lanes=y,fc(u,y)}}function m0(u,f){var y=u.updateQueue,A=u.alternate;if(A!==null&&(A=A.updateQueue,y===A)){var M=null,I=null;if(y=y.firstBaseUpdate,y!==null){do{var G={lane:y.lane,tag:y.tag,payload:y.payload,callback:null,next:null};I===null?M=I=G:I=I.next=G,y=y.next}while(y!==null);I===null?M=I=f:I=I.next=f}else M=I=f;y={baseState:A.baseState,firstBaseUpdate:M,lastBaseUpdate:I,shared:A.shared,callbacks:A.callbacks},u.updateQueue=y;return}u=y.lastBaseUpdate,u===null?y.firstBaseUpdate=f:u.next=f,y.lastBaseUpdate=f}var hb=!1;function $p(){if(hb){var u=rl;if(u!==null)throw u}}function Oh(u,f,y,A){hb=!1;var M=u.updateQueue;Ru=!1;var I=M.firstBaseUpdate,G=M.lastBaseUpdate,ne=M.shared.pending;if(ne!==null){M.shared.pending=null;var Ae=ne,$e=Ae.next;Ae.next=null,G===null?I=$e:G.next=$e,G=Ae;var ot=u.alternate;ot!==null&&(ot=ot.updateQueue,ne=ot.lastBaseUpdate,ne!==G&&(ne===null?ot.firstBaseUpdate=$e:ne.next=$e,ot.lastBaseUpdate=Ae))}if(I!==null){var xt=M.baseState;G=0,ot=$e=Ae=null,ne=I;do{var je=ne.lane&-536870913,Qe=je!==ne.lane;if(Qe?(os&je)===je:(A&je)===je){je!==0&&je===Ac&&(hb=!0),ot!==null&&(ot=ot.next={lane:0,tag:ne.tag,payload:ne.payload,callback:null,next:null});e:{var an=u,Tn=ne;je=f;var Zs=y;switch(Tn.tag){case 1:if(an=Tn.payload,typeof an=="function"){xt=an.call(Zs,xt,je);break e}xt=an;break e;case 3:an.flags=an.flags&-65537|128;case 0:if(an=Tn.payload,je=typeof an=="function"?an.call(Zs,xt,je):an,je==null)break e;xt=d({},xt,je);break e;case 2:Ru=!0}}je=ne.callback,je!==null&&(u.flags|=64,Qe&&(u.flags|=8192),Qe=M.callbacks,Qe===null?M.callbacks=[je]:Qe.push(je))}else Qe={lane:je,tag:ne.tag,payload:ne.payload,callback:ne.callback,next:null},ot===null?($e=ot=Qe,Ae=xt):ot=ot.next=Qe,G|=je;if(ne=ne.next,ne===null){if(ne=M.shared.pending,ne===null)break;Qe=ne,ne=Qe.next,Qe.next=null,M.lastBaseUpdate=Qe,M.shared.pending=null}}while(!0);ot===null&&(Ae=xt),M.baseState=Ae,M.firstBaseUpdate=$e,M.lastBaseUpdate=ot,I===null&&(M.shared.lanes=0),uo|=G,u.lanes=G,u.memoizedState=xt}}function Fl(u,f){if(typeof u!="function")throw Error(s(191,u));u.call(f)}function Ca(u,f){var y=u.callbacks;if(y!==null)for(u.callbacks=null,u=0;u<y.length;u++)Fl(y[u],f)}var eo=Y(null),ur=Y(0);function db(u,f){u=Bi,he(ur,u),he(eo,f),Bi=u|f.baseLanes}function fb(){he(ur,Bi),he(eo,eo.current)}function Va(){Bi=ur.current,re(eo),re(ur)}var Qi=Y(null),Lo=null;function Du(u){var f=u.alternate;he(mi,mi.current&1),he(Qi,u),Lo===null&&(f===null||eo.current!==null||f.memoizedState!==null)&&(Lo=u)}function pb(u){he(mi,mi.current),he(Qi,u),Lo===null&&(Lo=u)}function tw(u){u.tag===22?(he(mi,mi.current),he(Qi,u),Lo===null&&(Lo=u)):Cc()}function Cc(){he(mi,mi.current),he(Qi,Qi.current)}function to(u){re(Qi),Lo===u&&(Lo=null),re(mi)}var mi=Y(0);function g0(u){for(var f=u;f!==null;){if(f.tag===13){var y=f.memoizedState;if(y!==null&&(y=y.dehydrated,y===null||vR(y)||bR(y)))return f}else if(f.tag===19&&(f.memoizedProps.revealOrder==="forwards"||f.memoizedProps.revealOrder==="backwards"||f.memoizedProps.revealOrder==="unstable_legacy-backwards"||f.memoizedProps.revealOrder==="together")){if((f.flags&128)!==0)return f}else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===u)break;for(;f.sibling===null;){if(f.return===null||f.return===u)return null;f=f.return}f.sibling.return=f.return,f=f.sibling}return null}var Er=0,En=null,zs=null,$i=null,x0=!1,Ul=!1,Bh=!1,y0=0,Gp=0,Pl=null,JN=0;function gi(){throw Error(s(321))}function mb(u,f){if(f===null)return!1;for(var y=0;y<f.length&&y<u.length;y++)if(!ni(u[y],f[y]))return!1;return!0}function gb(u,f,y,A,M,I){return Er=I,En=f,f.memoizedState=null,f.updateQueue=null,f.lanes=0,P.H=u===null||u.memoizedState===null?Sw:Jd,Bh=!1,I=y(A,M),Bh=!1,Ul&&(I=sw(f,y,A,M)),nw(u),I}function nw(u){P.H=Xp;var f=zs!==null&&zs.next!==null;if(Er=0,$i=zs=En=null,x0=!1,Gp=0,Pl=null,f)throw Error(s(300));u===null||si||(u=u.dependencies,u!==null&&Wd(u)&&(si=!0))}function sw(u,f,y,A){En=u;var M=0;do{if(Ul&&(Pl=null),Gp=0,Ul=!1,25<=M)throw Error(s(301));if(M+=1,$i=zs=null,u.updateQueue!=null){var I=u.updateQueue;I.lastEffect=null,I.events=null,I.stores=null,I.memoCache!=null&&(I.memoCache.index=0)}P.H=qp,I=f(y,A)}while(Ul);return I}function ZN(){var u=P.H,f=u.useState()[0];return f=typeof f.then=="function"?Hp(f):f,u=u.useState()[0],(zs!==null?zs.memoizedState:null)!==u&&(En.flags|=1024),f}function xb(){var u=y0!==0;return y0=0,u}function yb(u,f,y){f.updateQueue=u.updateQueue,f.flags&=-2053,u.lanes&=~y}function vb(u){if(x0){for(u=u.memoizedState;u!==null;){var f=u.queue;f!==null&&(f.pending=null),u=u.next}x0=!1}Er=0,$i=zs=En=null,Ul=!1,Gp=y0=0,Pl=null}function hr(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return $i===null?En.memoizedState=$i=u:$i=$i.next=u,$i}function Ri(){if(zs===null){var u=En.alternate;u=u!==null?u.memoizedState:null}else u=zs.next;var f=$i===null?En.memoizedState:$i.next;if(f!==null)$i=f,zs=u;else{if(u===null)throw En.alternate===null?Error(s(467)):Error(s(310));zs=u,u={memoizedState:zs.memoizedState,baseState:zs.baseState,baseQueue:zs.baseQueue,queue:zs.queue,next:null},$i===null?En.memoizedState=$i=u:$i=$i.next=u}return $i}function Vp(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Hp(u){var f=Gp;return Gp+=1,Pl===null&&(Pl=[]),u=ob(Pl,u,f),f=En,($i===null?f.memoizedState:$i.next)===null&&(f=f.alternate,P.H=f===null||f.memoizedState===null?Sw:Jd),u}function v0(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Hp(u);if(u.$$typeof===T)return fa(u)}throw Error(s(438,String(u)))}function bb(u){var f=null,y=En.updateQueue;if(y!==null&&(f=y.memoCache),f==null){var A=En.alternate;A!==null&&(A=A.updateQueue,A!==null&&(A=A.memoCache,A!=null&&(f={data:A.data.map(function(M){return M.slice()}),index:0})))}if(f==null&&(f={data:[],index:0}),y===null&&(y=Vp(),En.updateQueue=y),y.memoCache=f,y=f.data[f.index],y===void 0)for(y=f.data[f.index]=Array(u),A=0;A<u;A++)y[A]=B;return f.index++,y}function Tc(u,f){return typeof f=="function"?f(u):f}function b0(u){var f=Ri();return Sb(f,zs,u)}function Sb(u,f,y){var A=u.queue;if(A===null)throw Error(s(311));A.lastRenderedReducer=y;var M=u.baseQueue,I=A.pending;if(I!==null){if(M!==null){var G=M.next;M.next=I.next,I.next=G}f.baseQueue=M=I,A.pending=null}if(I=u.baseState,M===null)u.memoizedState=I;else{f=M.next;var ne=G=null,Ae=null,$e=f,ot=!1;do{var xt=$e.lane&-536870913;if(xt!==$e.lane?(os&xt)===xt:(Er&xt)===xt){var je=$e.revertLane;if(je===0)Ae!==null&&(Ae=Ae.next={lane:0,revertLane:0,gesture:null,action:$e.action,hasEagerState:$e.hasEagerState,eagerState:$e.eagerState,next:null}),xt===Ac&&(ot=!0);else if((Er&je)===je){$e=$e.next,je===Ac&&(ot=!0);continue}else xt={lane:0,revertLane:$e.revertLane,gesture:null,action:$e.action,hasEagerState:$e.hasEagerState,eagerState:$e.eagerState,next:null},Ae===null?(ne=Ae=xt,G=I):Ae=Ae.next=xt,En.lanes|=je,uo|=je;xt=$e.action,Bh&&y(I,xt),I=$e.hasEagerState?$e.eagerState:y(I,xt)}else je={lane:xt,revertLane:$e.revertLane,gesture:$e.gesture,action:$e.action,hasEagerState:$e.hasEagerState,eagerState:$e.eagerState,next:null},Ae===null?(ne=Ae=je,G=I):Ae=Ae.next=je,En.lanes|=xt,uo|=xt;$e=$e.next}while($e!==null&&$e!==f);if(Ae===null?G=I:Ae.next=ne,!ni(I,u.memoizedState)&&(si=!0,ot&&(y=rl,y!==null)))throw y;u.memoizedState=I,u.baseState=G,u.baseQueue=Ae,A.lastRenderedState=I}return M===null&&(A.lanes=0),[u.memoizedState,A.dispatch]}function S0(u){var f=Ri(),y=f.queue;if(y===null)throw Error(s(311));y.lastRenderedReducer=u;var A=y.dispatch,M=y.pending,I=f.memoizedState;if(M!==null){y.pending=null;var G=M=M.next;do I=u(I,G.action),G=G.next;while(G!==M);ni(I,f.memoizedState)||(si=!0),f.memoizedState=I,f.baseQueue===null&&(f.baseState=I),y.lastRenderedState=I}return[I,A]}function _b(u,f,y){var A=En,M=Ri(),I=us;if(I){if(y===void 0)throw Error(s(407));y=y()}else y=f();var G=!ni((zs||M).memoizedState,y);if(G&&(M.memoizedState=y,si=!0),M=M.queue,Eb(wb.bind(null,A,M,u),[u]),M.getSnapshot!==f||G||$i!==null&&$i.memoizedState.tag&1){if(A.flags|=2048,Kd(9,{destroy:void 0},Ab.bind(null,A,M,y,f),null),Os===null)throw Error(s(349));I||(Er&127)!==0||iw(A,f,y)}return y}function iw(u,f,y){u.flags|=16384,u={getSnapshot:f,value:y},f=En.updateQueue,f===null?(f=Vp(),En.updateQueue=f,f.stores=[u]):(y=f.stores,y===null?f.stores=[u]:y.push(u))}function Ab(u,f,y,A){f.value=y,f.getSnapshot=A,Cb(f)&&_0(u)}function wb(u,f,y){return y(function(){Cb(f)&&_0(u)})}function Cb(u){var f=u.getSnapshot;u=u.value;try{var y=f();return!ni(u,y)}catch{return!0}}function _0(u){var f=_u(u,2);f!==null&&x(f,u,2)}function Wp(u){var f=hr();if(typeof u=="function"){var y=u;if(u=y(),Bh){Zt(!0);try{y()}finally{Zt(!1)}}}return f.memoizedState=f.baseState=u,f.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Tc,lastRenderedState:u},f}function aw(u,f,y,A){return u.baseState=y,Sb(u,zs,typeof A=="function"?A:Tc)}function QN(u,f,y,A,M){if(Ec(u))throw Error(s(485));if(u=f.action,u!==null){var I={payload:M,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(G){I.listeners.push(G)}};P.T!==null?y(!0):I.isTransition=!1,A(I),y=f.pending,y===null?(I.next=f.pending=I,rw(f,I)):(I.next=y.next,f.pending=y.next=I)}}function rw(u,f){var y=f.action,A=f.payload,M=u.state;if(f.isTransition){var I=P.T,G={};P.T=G;try{var ne=y(M,A),Ae=P.S;Ae!==null&&Ae(G,ne),ow(u,f,ne)}catch($e){A0(u,f,$e)}finally{I!==null&&G.types!==null&&(I.types=G.types),P.T=I}}else try{I=y(M,A),ow(u,f,I)}catch($e){A0(u,f,$e)}}function ow(u,f,y){y!==null&&typeof y=="object"&&typeof y.then=="function"?y.then(function(A){Tb(u,f,A)},function(A){return A0(u,f,A)}):Tb(u,f,y)}function Tb(u,f,y){f.status="fulfilled",f.value=y,lw(f),u.state=y,f=u.pending,f!==null&&(y=f.next,y===f?u.pending=null:(y=y.next,f.next=y,rw(u,y)))}function A0(u,f,y){var A=u.pending;if(u.pending=null,A!==null){A=A.next;do f.status="rejected",f.reason=y,lw(f),f=f.next;while(f!==A)}u.action=null}function lw(u){u=u.listeners;for(var f=0;f<u.length;f++)(0,u[f])()}function cw(u,f){return f}function uw(u,f){if(us){var y=Os.formState;if(y!==null){e:{var A=En;if(us){if(Ks){t:{for(var M=Ks,I=da;M.nodeType!==8;){if(!I){M=null;break t}if(M=Wl(M.nextSibling),M===null){M=null;break t}}I=M.data,M=I==="F!"||I==="F"?M:null}if(M){Ks=Wl(M.nextSibling),A=M.data==="F!";break e}}rs(A)}A=!1}A&&(f=y[0])}}return y=hr(),y.memoizedState=y.baseState=f,A={pending:null,lanes:0,dispatch:null,lastRenderedReducer:cw,lastRenderedState:f},y.queue=A,y=bw.bind(null,En,A),A.dispatch=y,A=Wp(!1),I=jp.bind(null,En,!1,A.queue),A=hr(),M={state:f,dispatch:null,action:u,pending:null},A.queue=M,y=QN.bind(null,En,M,I,y),M.dispatch=y,A.memoizedState=u,[f,y,!1]}function hw(u){var f=Ri();return dw(f,zs,u)}function dw(u,f,y){if(f=Sb(u,f,cw)[0],u=b0(Tc)[0],typeof f=="object"&&f!==null&&typeof f.then=="function")try{var A=Hp(f)}catch(G){throw G===Eu?ol:G}else A=f;f=Ri();var M=f.queue,I=M.dispatch;return y!==f.memoizedState&&(En.flags|=2048,Kd(9,{destroy:void 0},eR.bind(null,M,y),null)),[A,I,u]}function eR(u,f){u.action=f}function fw(u){var f=Ri(),y=zs;if(y!==null)return dw(f,y,u);Ri(),f=f.memoizedState,y=Ri();var A=y.queue.dispatch;return y.memoizedState=u,[f,A,!1]}function Kd(u,f,y,A){return u={tag:u,create:y,deps:A,inst:f,next:null},f=En.updateQueue,f===null&&(f=Vp(),En.updateQueue=f),y=f.lastEffect,y===null?f.lastEffect=u.next=u:(A=y.next,y.next=u,u.next=A,f.lastEffect=u),u}function pw(){return Ri().memoizedState}function w0(u,f,y,A){var M=hr();En.flags|=u,M.memoizedState=Kd(1|f,{destroy:void 0},y,A===void 0?null:A)}function C0(u,f,y,A){var M=Ri();A=A===void 0?null:A;var I=M.memoizedState.inst;zs!==null&&A!==null&&mb(A,zs.memoizedState.deps)?M.memoizedState=Kd(f,I,y,A):(En.flags|=u,M.memoizedState=Kd(1|f,I,y,A))}function mw(u,f){w0(8390656,8,u,f)}function Eb(u,f){C0(2048,8,u,f)}function gw(u){En.flags|=4;var f=En.updateQueue;if(f===null)f=Vp(),En.updateQueue=f,f.events=[u];else{var y=f.events;y===null?f.events=[u]:y.push(u)}}function xw(u){var f=Ri().memoizedState;return gw({ref:f,nextImpl:u}),function(){if((gs&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}function yw(u,f){return C0(4,2,u,f)}function no(u,f){return C0(4,4,u,f)}function Mb(u,f){if(typeof f=="function"){u=u();var y=f(u);return function(){typeof y=="function"?y():f(null)}}if(f!=null)return u=u(),f.current=u,function(){f.current=null}}function T0(u,f,y){y=y!=null?y.concat([u]):null,C0(4,4,Mb.bind(null,f,u),y)}function E0(){}function Nb(u,f){var y=Ri();f=f===void 0?null:f;var A=y.memoizedState;return f!==null&&mb(f,A[1])?A[0]:(y.memoizedState=[u,f],u)}function Rb(u,f){var y=Ri();f=f===void 0?null:f;var A=y.memoizedState;if(f!==null&&mb(f,A[1]))return A[0];if(A=u(),Bh){Zt(!0);try{u()}finally{Zt(!1)}}return y.memoizedState=[A,f],A}function Ib(u,f,y){return y===void 0||(Er&1073741824)!==0&&(os&261930)===0?u.memoizedState=f:(u.memoizedState=y,u=m(),En.lanes|=u,uo|=u,y)}function Db(u,f,y,A){return ni(y,f)?y:eo.current!==null?(u=Ib(u,y,A),ni(u,f)||(si=!0),u):(Er&42)===0||(Er&1073741824)!==0&&(os&261930)===0?(si=!0,u.memoizedState=y):(u=m(),En.lanes|=u,uo|=u,f)}function Ob(u,f,y,A,M){var I=W.p;W.p=I!==0&&8>I?I:8;var G=P.T,ne={};P.T=ne,jp(u,!1,f,y);try{var Ae=M(),$e=P.S;if($e!==null&&$e(ne,Ae),Ae!==null&&typeof Ae=="object"&&typeof Ae.then=="function"){var ot=rb(Ae,A);Yd(u,f,ot,fr(u))}else Yd(u,f,A,fr(u))}catch(xt){Yd(u,f,{then:function(){},status:"rejected",reason:xt},fr())}finally{W.p=I,G!==null&&ne.types!==null&&(G.types=ne.types),P.T=G}}function tR(){}function Bb(u,f,y,A){if(u.tag!==5)throw Error(s(476));var M=vw(u).queue;Ob(u,M,f,q,y===null?tR:function(){return kb(u),y(A)})}function vw(u){var f=u.memoizedState;if(f!==null)return f;f={memoizedState:q,baseState:q,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Tc,lastRenderedState:q},next:null};var y={};return f.next={memoizedState:y,baseState:y,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Tc,lastRenderedState:y},next:null},u.memoizedState=f,u=u.alternate,u!==null&&(u.memoizedState=f),f}function kb(u){var f=vw(u);f.next===null&&(f=u.alternate.memoizedState),Yd(u,f.next.queue,{},fr())}function Lb(){return fa(Kb)}function Ta(){return Ri().memoizedState}function Fb(){return Ri().memoizedState}function nR(u){for(var f=u.return;f!==null;){switch(f.tag){case 24:case 3:var y=fr();u=Ll(y);var A=wc(f,u,y);A!==null&&(x(A,f,y),Iu(A,f,y)),f={cache:sb()},u.payload=f;return}f=f.return}}function sR(u,f,y){var A=fr();y={lane:A,revertLane:0,gesture:null,action:y,hasEagerState:!1,eagerState:null,next:null},Ec(u)?kh(f,y):(y=Gd(u,f,y,A),y!==null&&(x(y,u,A),Mr(y,f,A)))}function bw(u,f,y){var A=fr();Yd(u,f,y,A)}function Yd(u,f,y,A){var M={lane:A,revertLane:0,gesture:null,action:y,hasEagerState:!1,eagerState:null,next:null};if(Ec(u))kh(f,M);else{var I=u.alternate;if(u.lanes===0&&(I===null||I.lanes===0)&&(I=f.lastRenderedReducer,I!==null))try{var G=f.lastRenderedState,ne=I(G,y);if(M.hasEagerState=!0,M.eagerState=ne,ni(ne,G))return Ip(u,f,M,0),Os===null&&Su(),!1}catch{}finally{}if(y=Gd(u,f,M,A),y!==null)return x(y,u,A),Mr(y,f,A),!0}return!1}function jp(u,f,y,A){if(A={lane:2,revertLane:oR(),gesture:null,action:A,hasEagerState:!1,eagerState:null,next:null},Ec(u)){if(f)throw Error(s(479))}else f=Gd(u,y,A,2),f!==null&&x(f,u,2)}function Ec(u){var f=u.alternate;return u===En||f!==null&&f===En}function kh(u,f){Ul=x0=!0;var y=u.pending;y===null?f.next=f:(f.next=y.next,y.next=f),u.pending=f}function Mr(u,f,y){if((y&4194048)!==0){var A=f.lanes;A&=u.pendingLanes,y|=A,f.lanes=y,fc(u,y)}}var Xp={readContext:fa,use:v0,useCallback:gi,useContext:gi,useEffect:gi,useImperativeHandle:gi,useLayoutEffect:gi,useInsertionEffect:gi,useMemo:gi,useReducer:gi,useRef:gi,useState:gi,useDebugValue:gi,useDeferredValue:gi,useTransition:gi,useSyncExternalStore:gi,useId:gi,useHostTransitionStatus:gi,useFormState:gi,useActionState:gi,useOptimistic:gi,useMemoCache:gi,useCacheRefresh:gi};Xp.useEffectEvent=gi;var Sw={readContext:fa,use:v0,useCallback:function(u,f){return hr().memoizedState=[u,f===void 0?null:f],u},useContext:fa,useEffect:mw,useImperativeHandle:function(u,f,y){y=y!=null?y.concat([u]):null,w0(4194308,4,Mb.bind(null,f,u),y)},useLayoutEffect:function(u,f){return w0(4194308,4,u,f)},useInsertionEffect:function(u,f){w0(4,2,u,f)},useMemo:function(u,f){var y=hr();f=f===void 0?null:f;var A=u();if(Bh){Zt(!0);try{u()}finally{Zt(!1)}}return y.memoizedState=[A,f],A},useReducer:function(u,f,y){var A=hr();if(y!==void 0){var M=y(f);if(Bh){Zt(!0);try{y(f)}finally{Zt(!1)}}}else M=f;return A.memoizedState=A.baseState=M,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:M},A.queue=u,u=u.dispatch=sR.bind(null,En,u),[A.memoizedState,u]},useRef:function(u){var f=hr();return u={current:u},f.memoizedState=u},useState:function(u){u=Wp(u);var f=u.queue,y=bw.bind(null,En,f);return f.dispatch=y,[u.memoizedState,y]},useDebugValue:E0,useDeferredValue:function(u,f){var y=hr();return Ib(y,u,f)},useTransition:function(){var u=Wp(!1);return u=Ob.bind(null,En,u.queue,!0,!1),hr().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,f,y){var A=En,M=hr();if(us){if(y===void 0)throw Error(s(407));y=y()}else{if(y=f(),Os===null)throw Error(s(349));(os&127)!==0||iw(A,f,y)}M.memoizedState=y;var I={value:y,getSnapshot:f};return M.queue=I,mw(wb.bind(null,A,I,u),[u]),A.flags|=2048,Kd(9,{destroy:void 0},Ab.bind(null,A,I,y,f),null),y},useId:function(){var u=hr(),f=Os.identifierPrefix;if(us){var y=Bl,A=Ol;y=(A&~(1<<32-xe(A)-1)).toString(32)+y,f="_"+f+"R_"+y,y=y0++,0<y&&(f+="H"+y.toString(32)),f+="_"}else y=JN++,f="_"+f+"r_"+y.toString(32)+"_";return u.memoizedState=f},useHostTransitionStatus:Lb,useFormState:uw,useActionState:uw,useOptimistic:function(u){var f=hr();f.memoizedState=f.baseState=u;var y={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return f.queue=y,f=jp.bind(null,En,!0,y),y.dispatch=f,[u,f]},useMemoCache:bb,useCacheRefresh:function(){return hr().memoizedState=nR.bind(null,En)},useEffectEvent:function(u){var f=hr(),y={impl:u};return f.memoizedState=y,function(){if((gs&2)!==0)throw Error(s(440));return y.impl.apply(void 0,arguments)}}},Jd={readContext:fa,use:v0,useCallback:Nb,useContext:fa,useEffect:Eb,useImperativeHandle:T0,useInsertionEffect:yw,useLayoutEffect:no,useMemo:Rb,useReducer:b0,useRef:pw,useState:function(){return b0(Tc)},useDebugValue:E0,useDeferredValue:function(u,f){var y=Ri();return Db(y,zs.memoizedState,u,f)},useTransition:function(){var u=b0(Tc)[0],f=Ri().memoizedState;return[typeof u=="boolean"?u:Hp(u),f]},useSyncExternalStore:_b,useId:Ta,useHostTransitionStatus:Lb,useFormState:hw,useActionState:hw,useOptimistic:function(u,f){var y=Ri();return aw(y,zs,u,f)},useMemoCache:bb,useCacheRefresh:Fb};Jd.useEffectEvent=xw;var qp={readContext:fa,use:v0,useCallback:Nb,useContext:fa,useEffect:Eb,useImperativeHandle:T0,useInsertionEffect:yw,useLayoutEffect:no,useMemo:Rb,useReducer:S0,useRef:pw,useState:function(){return S0(Tc)},useDebugValue:E0,useDeferredValue:function(u,f){var y=Ri();return zs===null?Ib(y,u,f):Db(y,zs.memoizedState,u,f)},useTransition:function(){var u=S0(Tc)[0],f=Ri().memoizedState;return[typeof u=="boolean"?u:Hp(u),f]},useSyncExternalStore:_b,useId:Ta,useHostTransitionStatus:Lb,useFormState:fw,useActionState:fw,useOptimistic:function(u,f){var y=Ri();return zs!==null?aw(y,zs,u,f):(y.baseState=u,[u,y.queue.dispatch])},useMemoCache:bb,useCacheRefresh:Fb};qp.useEffectEvent=xw;function Zd(u,f,y,A){f=u.memoizedState,y=y(A,f),y=y==null?f:d({},f,y),u.memoizedState=y,u.lanes===0&&(u.updateQueue.baseState=y)}var Kp={enqueueSetState:function(u,f,y){u=u._reactInternals;var A=fr(),M=Ll(A);M.payload=f,y!=null&&(M.callback=y),f=wc(u,M,A),f!==null&&(x(f,u,A),Iu(f,u,A))},enqueueReplaceState:function(u,f,y){u=u._reactInternals;var A=fr(),M=Ll(A);M.tag=1,M.payload=f,y!=null&&(M.callback=y),f=wc(u,M,A),f!==null&&(x(f,u,A),Iu(f,u,A))},enqueueForceUpdate:function(u,f){u=u._reactInternals;var y=fr(),A=Ll(y);A.tag=2,f!=null&&(A.callback=f),f=wc(u,A,y),f!==null&&(x(f,u,y),Iu(f,u,y))}};function _w(u,f,y,A,M,I,G){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(A,I,G):f.prototype&&f.prototype.isPureReactComponent?!Ld(y,A)||!Ld(M,I):!0}function Aw(u,f,y,A){u=f.state,typeof f.componentWillReceiveProps=="function"&&f.componentWillReceiveProps(y,A),typeof f.UNSAFE_componentWillReceiveProps=="function"&&f.UNSAFE_componentWillReceiveProps(y,A),f.state!==u&&Kp.enqueueReplaceState(f,f.state,null)}function Ea(u,f){var y=f;if("ref"in f){y={};for(var A in f)A!=="ref"&&(y[A]=f[A])}if(u=u.defaultProps){y===f&&(y=d({},y));for(var M in u)y[M]===void 0&&(y[M]=u[M])}return y}function Ub(u){bu(u)}function ww(u){console.error(u)}function M0(u){bu(u)}function N0(u,f){try{var y=u.onUncaughtError;y(f.value,{componentStack:f.stack})}catch(A){setTimeout(function(){throw A})}}function Cw(u,f,y){try{var A=u.onCaughtError;A(y.value,{componentStack:y.stack,errorBoundary:f.tag===1?f.stateNode:null})}catch(M){setTimeout(function(){throw M})}}function Pb(u,f,y){return y=Ll(y),y.tag=3,y.payload={element:null},y.callback=function(){N0(u,f)},y}function Qd(u){return u=Ll(u),u.tag=3,u}function Nr(u,f,y,A){var M=y.type.getDerivedStateFromError;if(typeof M=="function"){var I=A.value;u.payload=function(){return M(I)},u.callback=function(){Cw(f,y,A)}}var G=y.stateNode;G!==null&&typeof G.componentDidCatch=="function"&&(u.callback=function(){Cw(f,y,A),typeof M!="function"&&(Hl===null?Hl=new Set([this]):Hl.add(this));var ne=A.stack;this.componentDidCatch(A.value,{componentStack:ne!==null?ne:""})})}function so(u,f,y,A,M){if(y.flags|=32768,A!==null&&typeof A=="object"&&typeof A.then=="function"){if(f=y.alternate,f!==null&&Cu(f,y,M,!0),y=Qi.current,y!==null){switch(y.tag){case 31:case 13:return Lo===null?Dn():y.alternate===null&&Bs===0&&(Bs=3),y.flags&=-257,y.flags|=65536,y.lanes=M,A===Up?y.flags|=16384:(f=y.updateQueue,f===null?y.updateQueue=new Set([A]):f.add(A),iR(u,A,M)),!1;case 22:return y.flags|=65536,A===Up?y.flags|=16384:(f=y.updateQueue,f===null?(f={transitions:null,markerInstances:null,retryQueue:new Set([A])},y.updateQueue=f):(y=f.retryQueue,y===null?f.retryQueue=new Set([A]):y.add(A)),iR(u,A,M)),!1}throw Error(s(435,y.tag))}return iR(u,A,M),Dn(),!1}if(us)return f=Qi.current,f!==null?((f.flags&65536)===0&&(f.flags|=256),f.flags|=65536,f.lanes=M,A!==c0&&(u=Error(s(422),{cause:A}),kp(Cr(u,y)))):(A!==c0&&(f=Error(s(423),{cause:A}),kp(Cr(f,y))),u=u.current.alternate,u.flags|=65536,M&=-M,u.lanes|=M,A=Cr(A,y),M=Pb(u.stateNode,A,M),m0(u,M),Bs!==4&&(Bs=2)),!1;var I=Error(s(520),{cause:A});if(I=Cr(I,y),dl===null?dl=[I]:dl.push(I),Bs!==4&&(Bs=2),f===null)return!0;A=Cr(A,y),y=f;do{switch(y.tag){case 3:return y.flags|=65536,u=M&-M,y.lanes|=u,u=Pb(y.stateNode,A,u),m0(y,u),!1;case 1:if(f=y.type,I=y.stateNode,(y.flags&128)===0&&(typeof f.getDerivedStateFromError=="function"||I!==null&&typeof I.componentDidCatch=="function"&&(Hl===null||!Hl.has(I))))return y.flags|=65536,M&=-M,y.lanes|=M,M=Qd(M),Nr(M,u,y,A),m0(y,M),!1}y=y.return}while(y!==null);return!1}var R0=Error(s(461)),si=!1;function xi(u,f,y,A){f.child=u===null?ew(f,null,y,A):Dh(f,u.child,y,A)}function Yp(u,f,y,A,M){y=y.render;var I=f.ref;if("ref"in A){var G={};for(var ne in A)ne!=="ref"&&(G[ne]=A[ne])}else G=A;return Nh(f),A=gb(u,f,y,G,I,M),ne=xb(),u!==null&&!si?(yb(u,f,M),ul(u,f,M)):(us&&ne&&l0(f),f.flags|=1,xi(u,f,A,M),f.child)}function Jp(u,f,y,A,M){if(u===null){var I=y.type;return typeof I=="function"&&!cr(I)&&I.defaultProps===void 0&&y.compare===null?(f.tag=15,f.type=I,io(u,f,I,A,M)):(u=Dp(y.type,null,A,f,f.mode,M),u.ref=f.ref,u.return=f,f.child=u)}if(I=u.child,!Bu(u,M)){var G=I.memoizedProps;if(y=y.compare,y=y!==null?y:Ld,y(G,A)&&u.ref===f.ref)return ul(u,f,M)}return f.flags|=1,u=Il(I,A),u.ref=f.ref,u.return=f,f.child=u}function io(u,f,y,A,M){if(u!==null){var I=u.memoizedProps;if(Ld(I,A)&&u.ref===f.ref)if(si=!1,f.pendingProps=A=I,Bu(u,M))(u.flags&131072)!==0&&(si=!0);else return f.lanes=u.lanes,ul(u,f,M)}return ef(u,f,y,A,M)}function ao(u,f,y,A){var M=A.children,I=u!==null?u.memoizedState:null;if(u===null&&f.stateNode===null&&(f.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),A.mode==="hidden"){if((f.flags&128)!==0){if(I=I!==null?I.baseLanes|y:y,u!==null){for(A=f.child=u.child,M=0;A!==null;)M=M|A.lanes|A.childLanes,A=A.sibling;A=M&~I}else A=0,f.child=null;return zl(u,f,I,y,A)}if((y&536870912)!==0)f.memoizedState={baseLanes:0,cachePool:null},u!==null&&Xd(f,I!==null?I.cachePool:null),I!==null?db(f,I):fb(),tw(f);else return A=f.lanes=536870912,zl(u,f,I!==null?I.baseLanes|y:y,y,A)}else I!==null?(Xd(f,I.cachePool),db(f,I),Cc(),f.memoizedState=null):(u!==null&&Xd(f,null),fb(),Cc());return xi(u,f,M,y),f.child}function ll(u,f){return u!==null&&u.tag===22||f.stateNode!==null||(f.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),f.sibling}function zl(u,f,y,A,M){var I=kl();return I=I===null?null:{parent:xn._currentValue,pool:I},f.memoizedState={baseLanes:y,cachePool:I},u!==null&&Xd(f,null),fb(),tw(f),u!==null&&Cu(u,f,A,!0),f.childLanes=M,null}function Fo(u,f){return f=tf({mode:f.mode,children:f.children},u.mode),f.ref=u.ref,u.child=f,f.return=u,f}function pa(u,f,y){return Dh(f,u.child,null,y),u=Fo(f,f.pendingProps),u.flags|=2,to(f),f.memoizedState=null,u}function Zp(u,f,y){var A=f.pendingProps,M=(f.flags&128)!==0;if(f.flags&=-129,u===null){if(us){if(A.mode==="hidden")return u=Fo(f,A),f.lanes=536870912,ll(null,u);if(pb(f),(u=Ks)?(u=dF(u,da),u=u!==null&&u.data==="&"?u:null,u!==null&&(f.memoizedState={dehydrated:u,treeContext:Dl!==null?{id:Ol,overflow:Bl}:null,retryLane:536870912,hydrationErrors:null},y=qA(u),y.return=f,f.child=y,ha=f,Ks=null)):u=null,u===null)throw rs(f);return f.lanes=536870912,null}return Fo(f,A)}var I=u.memoizedState;if(I!==null){var G=I.dehydrated;if(pb(f),M)if(f.flags&256)f.flags&=-257,f=pa(u,f,y);else if(f.memoizedState!==null)f.child=u.child,f.flags|=128,f=null;else throw Error(s(558));else if(si||Cu(u,f,y,!1),M=(y&u.childLanes)!==0,si||M){if(A=Os,A!==null&&(G=Oo(A,y),G!==0&&G!==I.retryLane))throw I.retryLane=G,_u(u,G),x(A,u,G),R0;Dn(),f=pa(u,f,y)}else u=I.treeContext,Ks=Wl(G.nextSibling),ha=f,us=!0,vc=null,da=!1,u!==null&&Bp(f,u),f=Fo(f,A),f.flags|=4096;return f}return u=Il(u.child,{mode:A.mode,children:A.children}),u.ref=f.ref,f.child=u,u.return=f,u}function cl(u,f){var y=f.ref;if(y===null)u!==null&&u.ref!==null&&(f.flags|=4194816);else{if(typeof y!="function"&&typeof y!="object")throw Error(s(284));(u===null||u.ref!==y)&&(f.flags|=4194816)}}function ef(u,f,y,A,M){return Nh(f),y=gb(u,f,y,A,void 0,M),A=xb(),u!==null&&!si?(yb(u,f,M),ul(u,f,M)):(us&&A&&l0(f),f.flags|=1,xi(u,f,y,M),f.child)}function Ha(u,f,y,A,M,I){return Nh(f),f.updateQueue=null,y=sw(f,A,y,M),nw(u),A=xb(),u!==null&&!si?(yb(u,f,I),ul(u,f,I)):(us&&A&&l0(f),f.flags|=1,xi(u,f,y,I),f.child)}function Ma(u,f,y,A,M){if(Nh(f),f.stateNode===null){var I=Au,G=y.contextType;typeof G=="object"&&G!==null&&(I=fa(G)),I=new y(A,I),f.memoizedState=I.state!==null&&I.state!==void 0?I.state:null,I.updater=Kp,f.stateNode=I,I._reactInternals=f,I=f.stateNode,I.props=A,I.state=f.memoizedState,I.refs={},cb(f),G=y.contextType,I.context=typeof G=="object"&&G!==null?fa(G):Au,I.state=f.memoizedState,G=y.getDerivedStateFromProps,typeof G=="function"&&(Zd(f,y,G,A),I.state=f.memoizedState),typeof y.getDerivedStateFromProps=="function"||typeof I.getSnapshotBeforeUpdate=="function"||typeof I.UNSAFE_componentWillMount!="function"&&typeof I.componentWillMount!="function"||(G=I.state,typeof I.componentWillMount=="function"&&I.componentWillMount(),typeof I.UNSAFE_componentWillMount=="function"&&I.UNSAFE_componentWillMount(),G!==I.state&&Kp.enqueueReplaceState(I,I.state,null),Oh(f,A,I,M),$p(),I.state=f.memoizedState),typeof I.componentDidMount=="function"&&(f.flags|=4194308),A=!0}else if(u===null){I=f.stateNode;var ne=f.memoizedProps,Ae=Ea(y,ne);I.props=Ae;var $e=I.context,ot=y.contextType;G=Au,typeof ot=="object"&&ot!==null&&(G=fa(ot));var xt=y.getDerivedStateFromProps;ot=typeof xt=="function"||typeof I.getSnapshotBeforeUpdate=="function",ne=f.pendingProps!==ne,ot||typeof I.UNSAFE_componentWillReceiveProps!="function"&&typeof I.componentWillReceiveProps!="function"||(ne||$e!==G)&&Aw(f,I,A,G),Ru=!1;var je=f.memoizedState;I.state=je,Oh(f,A,I,M),$p(),$e=f.memoizedState,ne||je!==$e||Ru?(typeof xt=="function"&&(Zd(f,y,xt,A),$e=f.memoizedState),(Ae=Ru||_w(f,y,Ae,A,je,$e,G))?(ot||typeof I.UNSAFE_componentWillMount!="function"&&typeof I.componentWillMount!="function"||(typeof I.componentWillMount=="function"&&I.componentWillMount(),typeof I.UNSAFE_componentWillMount=="function"&&I.UNSAFE_componentWillMount()),typeof I.componentDidMount=="function"&&(f.flags|=4194308)):(typeof I.componentDidMount=="function"&&(f.flags|=4194308),f.memoizedProps=A,f.memoizedState=$e),I.props=A,I.state=$e,I.context=G,A=Ae):(typeof I.componentDidMount=="function"&&(f.flags|=4194308),A=!1)}else{I=f.stateNode,ub(u,f),G=f.memoizedProps,ot=Ea(y,G),I.props=ot,xt=f.pendingProps,je=I.context,$e=y.contextType,Ae=Au,typeof $e=="object"&&$e!==null&&(Ae=fa($e)),ne=y.getDerivedStateFromProps,($e=typeof ne=="function"||typeof I.getSnapshotBeforeUpdate=="function")||typeof I.UNSAFE_componentWillReceiveProps!="function"&&typeof I.componentWillReceiveProps!="function"||(G!==xt||je!==Ae)&&Aw(f,I,A,Ae),Ru=!1,je=f.memoizedState,I.state=je,Oh(f,A,I,M),$p();var Qe=f.memoizedState;G!==xt||je!==Qe||Ru||u!==null&&u.dependencies!==null&&Wd(u.dependencies)?(typeof ne=="function"&&(Zd(f,y,ne,A),Qe=f.memoizedState),(ot=Ru||_w(f,y,ot,A,je,Qe,Ae)||u!==null&&u.dependencies!==null&&Wd(u.dependencies))?($e||typeof I.UNSAFE_componentWillUpdate!="function"&&typeof I.componentWillUpdate!="function"||(typeof I.componentWillUpdate=="function"&&I.componentWillUpdate(A,Qe,Ae),typeof I.UNSAFE_componentWillUpdate=="function"&&I.UNSAFE_componentWillUpdate(A,Qe,Ae)),typeof I.componentDidUpdate=="function"&&(f.flags|=4),typeof I.getSnapshotBeforeUpdate=="function"&&(f.flags|=1024)):(typeof I.componentDidUpdate!="function"||G===u.memoizedProps&&je===u.memoizedState||(f.flags|=4),typeof I.getSnapshotBeforeUpdate!="function"||G===u.memoizedProps&&je===u.memoizedState||(f.flags|=1024),f.memoizedProps=A,f.memoizedState=Qe),I.props=A,I.state=Qe,I.context=Ae,A=ot):(typeof I.componentDidUpdate!="function"||G===u.memoizedProps&&je===u.memoizedState||(f.flags|=4),typeof I.getSnapshotBeforeUpdate!="function"||G===u.memoizedProps&&je===u.memoizedState||(f.flags|=1024),A=!1)}return I=A,cl(u,f),A=(f.flags&128)!==0,I||A?(I=f.stateNode,y=A&&typeof y.getDerivedStateFromError!="function"?null:I.render(),f.flags|=1,u!==null&&A?(f.child=Dh(f,u.child,null,M),f.child=Dh(f,null,y,M)):xi(u,f,y,M),f.memoizedState=I.state,u=f.child):u=ul(u,f,M),u}function bs(u,f,y,A){return Mh(),f.flags|=256,xi(u,f,y,A),f.child}var ro={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Uo(u){return{baseLanes:u,cachePool:d0()}}function Qp(u,f,y){return u=u!==null?u.childLanes&~y:0,f&&(u|=xs),u}function oo(u,f,y){var A=f.pendingProps,M=!1,I=(f.flags&128)!==0,G;if((G=I)||(G=u!==null&&u.memoizedState===null?!1:(mi.current&2)!==0),G&&(M=!0,f.flags&=-129),G=(f.flags&32)!==0,f.flags&=-33,u===null){if(us){if(M?Du(f):Cc(),(u=Ks)?(u=dF(u,da),u=u!==null&&u.data!=="&"?u:null,u!==null&&(f.memoizedState={dehydrated:u,treeContext:Dl!==null?{id:Ol,overflow:Bl}:null,retryLane:536870912,hydrationErrors:null},y=qA(u),y.return=f,f.child=y,ha=f,Ks=null)):u=null,u===null)throw rs(f);return bR(u)?f.lanes=32:f.lanes=536870912,null}var ne=A.children;return A=A.fallback,M?(Cc(),M=f.mode,ne=tf({mode:"hidden",children:ne},M),A=xc(A,M,y,null),ne.return=f,A.return=f,ne.sibling=A,f.child=ne,A=f.child,A.memoizedState=Uo(y),A.childLanes=Qp(u,G,y),f.memoizedState=ro,ll(null,A)):(Du(f),Ou(f,ne))}var Ae=u.memoizedState;if(Ae!==null&&(ne=Ae.dehydrated,ne!==null)){if(I)f.flags&256?(Du(f),f.flags&=-257,f=nf(u,f,y)):f.memoizedState!==null?(Cc(),f.child=u.child,f.flags|=128,f=null):(Cc(),ne=A.fallback,M=f.mode,A=tf({mode:"visible",children:A.children},M),ne=xc(ne,M,y,null),ne.flags|=2,A.return=f,ne.return=f,A.sibling=ne,f.child=A,Dh(f,u.child,null,y),A=f.child,A.memoizedState=Uo(y),A.childLanes=Qp(u,G,y),f.memoizedState=ro,f=ll(null,A));else if(Du(f),bR(ne)){if(G=ne.nextSibling&&ne.nextSibling.dataset,G)var $e=G.dgst;G=$e,A=Error(s(419)),A.stack="",A.digest=G,kp({value:A,source:null,stack:null}),f=nf(u,f,y)}else if(si||Cu(u,f,y,!1),G=(y&u.childLanes)!==0,si||G){if(G=Os,G!==null&&(A=Oo(G,y),A!==0&&A!==Ae.retryLane))throw Ae.retryLane=A,_u(u,A),x(G,u,A),R0;vR(ne)||Dn(),f=nf(u,f,y)}else vR(ne)?(f.flags|=192,f.child=u.child,f=null):(u=Ae.treeContext,Ks=Wl(ne.nextSibling),ha=f,us=!0,vc=null,da=!1,u!==null&&Bp(f,u),f=Ou(f,A.children),f.flags|=4096);return f}return M?(Cc(),ne=A.fallback,M=f.mode,Ae=u.child,$e=Ae.sibling,A=Il(Ae,{mode:"hidden",children:A.children}),A.subtreeFlags=Ae.subtreeFlags&65011712,$e!==null?ne=Il($e,ne):(ne=xc(ne,M,y,null),ne.flags|=2),ne.return=f,A.return=f,A.sibling=ne,f.child=A,ll(null,A),A=f.child,ne=u.child.memoizedState,ne===null?ne=Uo(y):(M=ne.cachePool,M!==null?(Ae=xn._currentValue,M=M.parent!==Ae?{parent:Ae,pool:Ae}:M):M=d0(),ne={baseLanes:ne.baseLanes|y,cachePool:M}),A.memoizedState=ne,A.childLanes=Qp(u,G,y),f.memoizedState=ro,ll(u.child,A)):(Du(f),y=u.child,u=y.sibling,y=Il(y,{mode:"visible",children:A.children}),y.return=f,y.sibling=null,u!==null&&(G=f.deletions,G===null?(f.deletions=[u],f.flags|=16):G.push(u)),f.child=y,f.memoizedState=null,y)}function Ou(u,f){return f=tf({mode:"visible",children:f},u.mode),f.return=u,u.child=f}function tf(u,f){return u=lr(22,u,null,f),u.lanes=0,u}function nf(u,f,y){return Dh(f,u.child,null,y),u=Ou(f,f.pendingProps.children),u.flags|=2,f.memoizedState=null,u}function Lh(u,f,y){u.lanes|=f;var A=u.alternate;A!==null&&(A.lanes|=f),_c(u.return,f,y)}function em(u,f,y,A,M,I){var G=u.memoizedState;G===null?u.memoizedState={isBackwards:f,rendering:null,renderingStartTime:0,last:A,tail:y,tailMode:M,treeForkCount:I}:(G.isBackwards=f,G.rendering=null,G.renderingStartTime=0,G.last=A,G.tail=y,G.tailMode=M,G.treeForkCount=I)}function tm(u,f,y){var A=f.pendingProps,M=A.revealOrder,I=A.tail;A=A.children;var G=mi.current,ne=(G&2)!==0;if(ne?(G=G&1|2,f.flags|=128):G&=1,he(mi,G),xi(u,f,A,y),A=us?Hd:0,!ne&&u!==null&&(u.flags&128)!==0)e:for(u=f.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&Lh(u,y,f);else if(u.tag===19)Lh(u,y,f);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===f)break e;for(;u.sibling===null;){if(u.return===null||u.return===f)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}switch(M){case"forwards":for(y=f.child,M=null;y!==null;)u=y.alternate,u!==null&&g0(u)===null&&(M=y),y=y.sibling;y=M,y===null?(M=f.child,f.child=null):(M=y.sibling,y.sibling=null),em(f,!1,M,y,I,A);break;case"backwards":case"unstable_legacy-backwards":for(y=null,M=f.child,f.child=null;M!==null;){if(u=M.alternate,u!==null&&g0(u)===null){f.child=M;break}u=M.sibling,M.sibling=y,y=M,M=u}em(f,!0,y,null,I,A);break;case"together":em(f,!1,null,null,void 0,A);break;default:f.memoizedState=null}return f.child}function ul(u,f,y){if(u!==null&&(f.dependencies=u.dependencies),uo|=f.lanes,(y&f.childLanes)===0)if(u!==null){if(Cu(u,f,y,!1),(y&f.childLanes)===0)return null}else return null;if(u!==null&&f.child!==u.child)throw Error(s(153));if(f.child!==null){for(u=f.child,y=Il(u,u.pendingProps),f.child=y,y.return=f;u.sibling!==null;)u=u.sibling,y=y.sibling=Il(u,u.pendingProps),y.return=f;y.sibling=null}return f.child}function Bu(u,f){return(u.lanes&f)!==0?!0:(u=u.dependencies,!!(u!==null&&Wd(u)))}function nm(u,f,y){switch(f.tag){case 3:Ge(f,f.stateNode.containerInfo),Sc(f,xn,u.memoizedState.cache),Mh();break;case 27:case 5:yt(f);break;case 4:Ge(f,f.stateNode.containerInfo);break;case 10:Sc(f,f.type,f.memoizedProps.value);break;case 31:if(f.memoizedState!==null)return f.flags|=128,pb(f),null;break;case 13:var A=f.memoizedState;if(A!==null)return A.dehydrated!==null?(Du(f),f.flags|=128,null):(y&f.child.childLanes)!==0?oo(u,f,y):(Du(f),u=ul(u,f,y),u!==null?u.sibling:null);Du(f);break;case 19:var M=(u.flags&128)!==0;if(A=(y&f.childLanes)!==0,A||(Cu(u,f,y,!1),A=(y&f.childLanes)!==0),M){if(A)return tm(u,f,y);f.flags|=128}if(M=f.memoizedState,M!==null&&(M.rendering=null,M.tail=null,M.lastEffect=null),he(mi,mi.current),A)break;return null;case 22:return f.lanes=0,ao(u,f,y,f.pendingProps);case 24:Sc(f,xn,u.memoizedState.cache)}return ul(u,f,y)}function I0(u,f,y){if(u!==null)if(u.memoizedProps!==f.pendingProps)si=!0;else{if(!Bu(u,y)&&(f.flags&128)===0)return si=!1,nm(u,f,y);si=(u.flags&131072)!==0}else si=!1,us&&(f.flags&1048576)!==0&&Zv(f,Hd,f.index);switch(f.lanes=0,f.tag){case 16:e:{var A=f.pendingProps;if(u=Ih(f.elementType),f.type=u,typeof u=="function")cr(u)?(A=Ea(u,A),f.tag=1,f=Ma(null,f,u,A,y)):(f.tag=0,f=ef(null,f,u,A,y));else{if(u!=null){var M=u.$$typeof;if(M===E){f.tag=11,f=Yp(null,f,u,A,y);break e}else if(M===F){f.tag=14,f=Jp(null,f,u,A,y);break e}}throw f=Z(u)||u,Error(s(306,f,""))}}return f;case 0:return ef(u,f,f.type,f.pendingProps,y);case 1:return A=f.type,M=Ea(A,f.pendingProps),Ma(u,f,A,M,y);case 3:e:{if(Ge(f,f.stateNode.containerInfo),u===null)throw Error(s(387));A=f.pendingProps;var I=f.memoizedState;M=I.element,ub(u,f),Oh(f,A,null,y);var G=f.memoizedState;if(A=G.cache,Sc(f,xn,A),A!==I.cache&&h0(f,[xn],y,!0),$p(),A=G.element,I.isDehydrated)if(I={element:A,isDehydrated:!1,cache:G.cache},f.updateQueue.baseState=I,f.memoizedState=I,f.flags&256){f=bs(u,f,A,y);break e}else if(A!==M){M=Cr(Error(s(424)),f),kp(M),f=bs(u,f,A,y);break e}else{switch(u=f.stateNode.containerInfo,u.nodeType){case 9:u=u.body;break;default:u=u.nodeName==="HTML"?u.ownerDocument.body:u}for(Ks=Wl(u.firstChild),ha=f,us=!0,vc=null,da=!0,y=ew(f,null,A,y),f.child=y;y;)y.flags=y.flags&-3|4096,y=y.sibling}else{if(Mh(),A===M){f=ul(u,f,y);break e}xi(u,f,A,y)}f=f.child}return f;case 26:return cl(u,f),u===null?(y=yF(f.type,null,f.pendingProps,null))?f.memoizedState=y:us||(y=f.type,u=f.pendingProps,A=Ow(fe.current).createElement(y),A[Un]=f,A[j]=u,pr(A,y,u),De(A),f.stateNode=A):f.memoizedState=yF(f.type,u.memoizedProps,f.pendingProps,u.memoizedState),null;case 27:return yt(f),u===null&&us&&(A=f.stateNode=mF(f.type,f.pendingProps,fe.current),ha=f,da=!0,M=Ks,uf(f.type)?(SR=M,Ks=Wl(A.firstChild)):Ks=M),xi(u,f,f.pendingProps.children,y),cl(u,f),u===null&&(f.flags|=4194304),f.child;case 5:return u===null&&us&&((M=A=Ks)&&(A=m7(A,f.type,f.pendingProps,da),A!==null?(f.stateNode=A,ha=f,Ks=Wl(A.firstChild),da=!1,M=!0):M=!1),M||rs(f)),yt(f),M=f.type,I=f.pendingProps,G=u!==null?u.memoizedProps:null,A=I.children,gR(M,I)?A=null:G!==null&&gR(M,G)&&(f.flags|=32),f.memoizedState!==null&&(M=gb(u,f,ZN,null,null,y),Kb._currentValue=M),cl(u,f),xi(u,f,A,y),f.child;case 6:return u===null&&us&&((u=y=Ks)&&(y=g7(y,f.pendingProps,da),y!==null?(f.stateNode=y,ha=f,Ks=null,u=!0):u=!1),u||rs(f)),null;case 13:return oo(u,f,y);case 4:return Ge(f,f.stateNode.containerInfo),A=f.pendingProps,u===null?f.child=Dh(f,null,A,y):xi(u,f,A,y),f.child;case 11:return Yp(u,f,f.type,f.pendingProps,y);case 7:return xi(u,f,f.pendingProps,y),f.child;case 8:return xi(u,f,f.pendingProps.children,y),f.child;case 12:return xi(u,f,f.pendingProps.children,y),f.child;case 10:return A=f.pendingProps,Sc(f,f.type,A.value),xi(u,f,A.children,y),f.child;case 9:return M=f.type._context,A=f.pendingProps.children,Nh(f),M=fa(M),A=A(M),f.flags|=1,xi(u,f,A,y),f.child;case 14:return Jp(u,f,f.type,f.pendingProps,y);case 15:return io(u,f,f.type,f.pendingProps,y);case 19:return tm(u,f,y);case 31:return Zp(u,f,y);case 22:return ao(u,f,y,f.pendingProps);case 24:return Nh(f),A=fa(xn),u===null?(M=kl(),M===null&&(M=Os,I=sb(),M.pooledCache=I,I.refCount++,I!==null&&(M.pooledCacheLanes|=y),M=I),f.memoizedState={parent:A,cache:M},cb(f),Sc(f,xn,M)):((u.lanes&y)!==0&&(ub(u,f),Oh(f,null,null,y),$p()),M=u.memoizedState,I=f.memoizedState,M.parent!==A?(M={parent:A,cache:A},f.memoizedState=M,f.lanes===0&&(f.memoizedState=f.updateQueue.baseState=M),Sc(f,xn,A)):(A=I.cache,Sc(f,xn,A),A!==M.cache&&h0(f,[xn],y,!0))),xi(u,f,f.pendingProps.children,y),f.child;case 29:throw f.pendingProps}throw Error(s(156,f.tag))}function Rr(u){u.flags|=4}function ku(u,f,y,A,M){if((f=(u.mode&32)!==0)&&(f=!1),f){if(u.flags|=16777216,(M&335544128)===M)if(u.stateNode.complete)u.flags|=8192;else if(Ot())u.flags|=8192;else throw An=Up,Fp}else u.flags&=-16777217}function Mc(u,f){if(f.type!=="stylesheet"||(f.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!AF(f))if(Ot())u.flags|=8192;else throw An=Up,Fp}function sf(u,f){f!==null&&(u.flags|=4),u.flags&16384&&(f=u.tag!==22?Wn():536870912,u.lanes|=f,ho|=f)}function sm(u,f){if(!us)switch(u.tailMode){case"hidden":f=u.tail;for(var y=null;f!==null;)f.alternate!==null&&(y=f),f=f.sibling;y===null?u.tail=null:y.sibling=null;break;case"collapsed":y=u.tail;for(var A=null;y!==null;)y.alternate!==null&&(A=y),y=y.sibling;A===null?f||u.tail===null?u.tail=null:u.tail.sibling=null:A.sibling=null}}function Fs(u){var f=u.alternate!==null&&u.alternate.child===u.child,y=0,A=0;if(f)for(var M=u.child;M!==null;)y|=M.lanes|M.childLanes,A|=M.subtreeFlags&65011712,A|=M.flags&65011712,M.return=u,M=M.sibling;else for(M=u.child;M!==null;)y|=M.lanes|M.childLanes,A|=M.subtreeFlags,A|=M.flags,M.return=u,M=M.sibling;return u.subtreeFlags|=A,u.childLanes=y,f}function zb(u,f,y){var A=f.pendingProps;switch(wu(f),f.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Fs(f),null;case 1:return Fs(f),null;case 3:return y=f.stateNode,A=null,u!==null&&(A=u.memoizedState.cache),f.memoizedState.cache!==A&&(f.flags|=2048),ko(xn),nt(),y.pendingContext&&(y.context=y.pendingContext,y.pendingContext=null),(u===null||u.child===null)&&(Eh(f)?Rr(f):u===null||u.memoizedState.isDehydrated&&(f.flags&256)===0||(f.flags|=1024,Qv())),Fs(f),null;case 26:var M=f.type,I=f.memoizedState;return u===null?(Rr(f),I!==null?(Fs(f),Mc(f,I)):(Fs(f),ku(f,M,null,A,y))):I?I!==u.memoizedState?(Rr(f),Fs(f),Mc(f,I)):(Fs(f),f.flags&=-16777217):(u=u.memoizedProps,u!==A&&Rr(f),Fs(f),ku(f,M,u,A,y)),null;case 27:if(Dt(f),y=fe.current,M=f.type,u!==null&&f.stateNode!=null)u.memoizedProps!==A&&Rr(f);else{if(!A){if(f.stateNode===null)throw Error(s(166));return Fs(f),null}u=me.current,Eh(f)?u0(f):(u=mF(M,A,y),f.stateNode=u,Rr(f))}return Fs(f),null;case 5:if(Dt(f),M=f.type,u!==null&&f.stateNode!=null)u.memoizedProps!==A&&Rr(f);else{if(!A){if(f.stateNode===null)throw Error(s(166));return Fs(f),null}if(I=me.current,Eh(f))u0(f);else{var G=Ow(fe.current);switch(I){case 1:I=G.createElementNS("http://www.w3.org/2000/svg",M);break;case 2:I=G.createElementNS("http://www.w3.org/1998/Math/MathML",M);break;default:switch(M){case"svg":I=G.createElementNS("http://www.w3.org/2000/svg",M);break;case"math":I=G.createElementNS("http://www.w3.org/1998/Math/MathML",M);break;case"script":I=G.createElement("div"),I.innerHTML="<script><\/script>",I=I.removeChild(I.firstChild);break;case"select":I=typeof A.is=="string"?G.createElement("select",{is:A.is}):G.createElement("select"),A.multiple?I.multiple=!0:A.size&&(I.size=A.size);break;default:I=typeof A.is=="string"?G.createElement(M,{is:A.is}):G.createElement(M)}}I[Un]=f,I[j]=A;e:for(G=f.child;G!==null;){if(G.tag===5||G.tag===6)I.appendChild(G.stateNode);else if(G.tag!==4&&G.tag!==27&&G.child!==null){G.child.return=G,G=G.child;continue}if(G===f)break e;for(;G.sibling===null;){if(G.return===null||G.return===f)break e;G=G.return}G.sibling.return=G.return,G=G.sibling}f.stateNode=I;e:switch(pr(I,M,A),M){case"button":case"input":case"select":case"textarea":A=!!A.autoFocus;break e;case"img":A=!0;break e;default:A=!1}A&&Rr(f)}}return Fs(f),ku(f,f.type,u===null?null:u.memoizedProps,f.pendingProps,y),null;case 6:if(u&&f.stateNode!=null)u.memoizedProps!==A&&Rr(f);else{if(typeof A!="string"&&f.stateNode===null)throw Error(s(166));if(u=fe.current,Eh(f)){if(u=f.stateNode,y=f.memoizedProps,A=null,M=ha,M!==null)switch(M.tag){case 27:case 5:A=M.memoizedProps}u[Un]=f,u=!!(u.nodeValue===y||A!==null&&A.suppressHydrationWarning===!0||iF(u.nodeValue,y)),u||rs(f,!0)}else u=Ow(u).createTextNode(A),u[Un]=f,f.stateNode=u}return Fs(f),null;case 31:if(y=f.memoizedState,u===null||u.memoizedState!==null){if(A=Eh(f),y!==null){if(u===null){if(!A)throw Error(s(318));if(u=f.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(557));u[Un]=f}else Mh(),(f.flags&128)===0&&(f.memoizedState=null),f.flags|=4;Fs(f),u=!1}else y=Qv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=y),u=!0;if(!u)return f.flags&256?(to(f),f):(to(f),null);if((f.flags&128)!==0)throw Error(s(558))}return Fs(f),null;case 13:if(A=f.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(M=Eh(f),A!==null&&A.dehydrated!==null){if(u===null){if(!M)throw Error(s(318));if(M=f.memoizedState,M=M!==null?M.dehydrated:null,!M)throw Error(s(317));M[Un]=f}else Mh(),(f.flags&128)===0&&(f.memoizedState=null),f.flags|=4;Fs(f),M=!1}else M=Qv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=M),M=!0;if(!M)return f.flags&256?(to(f),f):(to(f),null)}return to(f),(f.flags&128)!==0?(f.lanes=y,f):(y=A!==null,u=u!==null&&u.memoizedState!==null,y&&(A=f.child,M=null,A.alternate!==null&&A.alternate.memoizedState!==null&&A.alternate.memoizedState.cachePool!==null&&(M=A.alternate.memoizedState.cachePool.pool),I=null,A.memoizedState!==null&&A.memoizedState.cachePool!==null&&(I=A.memoizedState.cachePool.pool),I!==M&&(A.flags|=2048)),y!==u&&y&&(f.child.flags|=8192),sf(f,f.updateQueue),Fs(f),null);case 4:return nt(),u===null&&hR(f.stateNode.containerInfo),Fs(f),null;case 10:return ko(f.type),Fs(f),null;case 19:if(re(mi),A=f.memoizedState,A===null)return Fs(f),null;if(M=(f.flags&128)!==0,I=A.rendering,I===null)if(M)sm(A,!1);else{if(Bs!==0||u!==null&&(u.flags&128)!==0)for(u=f.child;u!==null;){if(I=g0(u),I!==null){for(f.flags|=128,sm(A,!1),u=I.updateQueue,f.updateQueue=u,sf(f,u),f.subtreeFlags=0,u=y,y=f.child;y!==null;)$a(y,u),y=y.sibling;return he(mi,mi.current&1|2),us&&yc(f,A.treeForkCount),f.child}u=u.sibling}A.tail!==null&&J()>fo&&(f.flags|=128,M=!0,sm(A,!1),f.lanes=4194304)}else{if(!M)if(u=g0(I),u!==null){if(f.flags|=128,M=!0,u=u.updateQueue,f.updateQueue=u,sf(f,u),sm(A,!0),A.tail===null&&A.tailMode==="hidden"&&!I.alternate&&!us)return Fs(f),null}else 2*J()-A.renderingStartTime>fo&&y!==536870912&&(f.flags|=128,M=!0,sm(A,!1),f.lanes=4194304);A.isBackwards?(I.sibling=f.child,f.child=I):(u=A.last,u!==null?u.sibling=I:f.child=I,A.last=I)}return A.tail!==null?(u=A.tail,A.rendering=u,A.tail=u.sibling,A.renderingStartTime=J(),u.sibling=null,y=mi.current,he(mi,M?y&1|2:y&1),us&&yc(f,A.treeForkCount),u):(Fs(f),null);case 22:case 23:return to(f),Va(),A=f.memoizedState!==null,u!==null?u.memoizedState!==null!==A&&(f.flags|=8192):A&&(f.flags|=8192),A?(y&536870912)!==0&&(f.flags&128)===0&&(Fs(f),f.subtreeFlags&6&&(f.flags|=8192)):Fs(f),y=f.updateQueue,y!==null&&sf(f,y.retryQueue),y=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(y=u.memoizedState.cachePool.pool),A=null,f.memoizedState!==null&&f.memoizedState.cachePool!==null&&(A=f.memoizedState.cachePool.pool),A!==y&&(f.flags|=2048),u!==null&&re(Tu),null;case 24:return y=null,u!==null&&(y=u.memoizedState.cache),f.memoizedState.cache!==y&&(f.flags|=2048),ko(xn),Fs(f),null;case 25:return null;case 30:return null}throw Error(s(156,f.tag))}function D0(u,f){switch(wu(f),f.tag){case 1:return u=f.flags,u&65536?(f.flags=u&-65537|128,f):null;case 3:return ko(xn),nt(),u=f.flags,(u&65536)!==0&&(u&128)===0?(f.flags=u&-65537|128,f):null;case 26:case 27:case 5:return Dt(f),null;case 31:if(f.memoizedState!==null){if(to(f),f.alternate===null)throw Error(s(340));Mh()}return u=f.flags,u&65536?(f.flags=u&-65537|128,f):null;case 13:if(to(f),u=f.memoizedState,u!==null&&u.dehydrated!==null){if(f.alternate===null)throw Error(s(340));Mh()}return u=f.flags,u&65536?(f.flags=u&-65537|128,f):null;case 19:return re(mi),null;case 4:return nt(),null;case 10:return ko(f.type),null;case 22:case 23:return to(f),Va(),u!==null&&re(Tu),u=f.flags,u&65536?(f.flags=u&-65537|128,f):null;case 24:return ko(xn),null;case 25:return null;default:return null}}function Fh(u,f){switch(wu(f),f.tag){case 3:ko(xn),nt();break;case 26:case 27:case 5:Dt(f);break;case 4:nt();break;case 31:f.memoizedState!==null&&to(f);break;case 13:to(f);break;case 19:re(mi);break;case 10:ko(f.type);break;case 22:case 23:to(f),Va(),u!==null&&re(Tu);break;case 24:ko(xn)}}function $l(u,f){try{var y=f.updateQueue,A=y!==null?y.lastEffect:null;if(A!==null){var M=A.next;y=M;do{if((y.tag&u)===u){A=void 0;var I=y.create,G=y.inst;A=I(),G.destroy=A}y=y.next}while(y!==M)}}catch(ne){Ws(f,f.return,ne)}}function Po(u,f,y){try{var A=f.updateQueue,M=A!==null?A.lastEffect:null;if(M!==null){var I=M.next;A=I;do{if((A.tag&u)===u){var G=A.inst,ne=G.destroy;if(ne!==void 0){G.destroy=void 0,M=f;var Ae=y,$e=ne;try{$e()}catch(ot){Ws(M,Ae,ot)}}}A=A.next}while(A!==I)}}catch(ot){Ws(f,f.return,ot)}}function Lu(u){var f=u.updateQueue;if(f!==null){var y=u.stateNode;try{Ca(f,y)}catch(A){Ws(u,u.return,A)}}}function $b(u,f,y){y.props=Ea(u.type,u.memoizedProps),y.state=u.memoizedState;try{y.componentWillUnmount()}catch(A){Ws(u,f,A)}}function Gl(u,f){try{var y=u.ref;if(y!==null){switch(u.tag){case 26:case 27:case 5:var A=u.stateNode;break;case 30:A=u.stateNode;break;default:A=u.stateNode}typeof y=="function"?u.refCleanup=y(A):y.current=A}}catch(M){Ws(u,f,M)}}function lo(u,f){var y=u.ref,A=u.refCleanup;if(y!==null)if(typeof A=="function")try{A()}catch(M){Ws(u,f,M)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof y=="function")try{y(null)}catch(M){Ws(u,f,M)}else y.current=null}function co(u){var f=u.type,y=u.memoizedProps,A=u.stateNode;try{e:switch(f){case"button":case"input":case"select":case"textarea":y.autoFocus&&A.focus();break e;case"img":y.src?A.src=y.src:y.srcSet&&(A.srcset=y.srcSet)}}catch(M){Ws(u,u.return,M)}}function zo(u,f,y){try{var A=u.stateNode;c7(A,u.type,y,f),A[j]=f}catch(M){Ws(u,u.return,M)}}function Gi(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27&&uf(u.type)||u.tag===4}function Vl(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||Gi(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.tag===27&&uf(u.type)||u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function $n(u,f,y){var A=u.tag;if(A===5||A===6)u=u.stateNode,f?(y.nodeType===9?y.body:y.nodeName==="HTML"?y.ownerDocument.body:y).insertBefore(u,f):(f=y.nodeType===9?y.body:y.nodeName==="HTML"?y.ownerDocument.body:y,f.appendChild(u),y=y._reactRootContainer,y!=null||f.onclick!==null||(f.onclick=Ml));else if(A!==4&&(A===27&&uf(u.type)&&(y=u.stateNode,f=null),u=u.child,u!==null))for($n(u,f,y),u=u.sibling;u!==null;)$n(u,f,y),u=u.sibling}function Is(u,f,y){var A=u.tag;if(A===5||A===6)u=u.stateNode,f?y.insertBefore(u,f):y.appendChild(u);else if(A!==4&&(A===27&&uf(u.type)&&(y=u.stateNode),u=u.child,u!==null))for(Is(u,f,y),u=u.sibling;u!==null;)Is(u,f,y),u=u.sibling}function Ii(u){var f=u.stateNode,y=u.memoizedProps;try{for(var A=u.type,M=f.attributes;M.length;)f.removeAttributeNode(M[0]);pr(f,A,y),f[Un]=u,f[j]=y}catch(I){Ws(u,u.return,I)}}var $o=!1,ii=!1,Nc=!1,im=typeof WeakSet=="function"?WeakSet:Set,yi=null;function af(u,f){if(u=u.containerInfo,pR=zw,u=e0(u),Fd(u)){if("selectionStart"in u)var y={start:u.selectionStart,end:u.selectionEnd};else e:{y=(y=u.ownerDocument)&&y.defaultView||window;var A=y.getSelection&&y.getSelection();if(A&&A.rangeCount!==0){y=A.anchorNode;var M=A.anchorOffset,I=A.focusNode;A=A.focusOffset;try{y.nodeType,I.nodeType}catch{y=null;break e}var G=0,ne=-1,Ae=-1,$e=0,ot=0,xt=u,je=null;t:for(;;){for(var Qe;xt!==y||M!==0&&xt.nodeType!==3||(ne=G+M),xt!==I||A!==0&&xt.nodeType!==3||(Ae=G+A),xt.nodeType===3&&(G+=xt.nodeValue.length),(Qe=xt.firstChild)!==null;)je=xt,xt=Qe;for(;;){if(xt===u)break t;if(je===y&&++$e===M&&(ne=G),je===I&&++ot===A&&(Ae=G),(Qe=xt.nextSibling)!==null)break;xt=je,je=xt.parentNode}xt=Qe}y=ne===-1||Ae===-1?null:{start:ne,end:Ae}}else y=null}y=y||{start:0,end:0}}else y=null;for(mR={focusedElem:u,selectionRange:y},zw=!1,yi=f;yi!==null;)if(f=yi,u=f.child,(f.subtreeFlags&1028)!==0&&u!==null)u.return=f,yi=u;else for(;yi!==null;){switch(f=yi,I=f.alternate,u=f.flags,f.tag){case 0:if((u&4)!==0&&(u=f.updateQueue,u=u!==null?u.events:null,u!==null))for(y=0;y<u.length;y++)M=u[y],M.ref.impl=M.nextImpl;break;case 11:case 15:break;case 1:if((u&1024)!==0&&I!==null){u=void 0,y=f,M=I.memoizedProps,I=I.memoizedState,A=y.stateNode;try{var an=Ea(y.type,M);u=A.getSnapshotBeforeUpdate(an,I),A.__reactInternalSnapshotBeforeUpdate=u}catch(Tn){Ws(y,y.return,Tn)}}break;case 3:if((u&1024)!==0){if(u=f.stateNode.containerInfo,y=u.nodeType,y===9)yR(u);else if(y===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":yR(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=f.sibling,u!==null){u.return=f.return,yi=u;break}yi=f.return}}function Tw(u,f,y){var A=y.flags;switch(y.tag){case 0:case 11:case 15:Rc(u,y),A&4&&$l(5,y);break;case 1:if(Rc(u,y),A&4)if(u=y.stateNode,f===null)try{u.componentDidMount()}catch(G){Ws(y,y.return,G)}else{var M=Ea(y.type,f.memoizedProps);f=f.memoizedState;try{u.componentDidUpdate(M,f,u.__reactInternalSnapshotBeforeUpdate)}catch(G){Ws(y,y.return,G)}}A&64&&Lu(y),A&512&&Gl(y,y.return);break;case 3:if(Rc(u,y),A&64&&(u=y.updateQueue,u!==null)){if(f=null,y.child!==null)switch(y.child.tag){case 27:case 5:f=y.child.stateNode;break;case 1:f=y.child.stateNode}try{Ca(u,f)}catch(G){Ws(y,y.return,G)}}break;case 27:f===null&&A&4&&Ii(y);case 26:case 5:Rc(u,y),f===null&&A&4&&co(y),A&512&&Gl(y,y.return);break;case 12:Rc(u,y);break;case 31:Rc(u,y),A&4&&B0(u,y);break;case 13:Rc(u,y),A&4&&Gb(u,y),A&64&&(u=y.memoizedState,u!==null&&(u=u.dehydrated,u!==null&&(y=Jj.bind(null,y),x7(u,y))));break;case 22:if(A=y.memoizedState!==null||$o,!A){f=f!==null&&f.memoizedState!==null||ii,M=$o;var I=ii;$o=A,(ii=f)&&!I?Ds(u,y,(y.subtreeFlags&8772)!==0):Rc(u,y),$o=M,ii=I}break;case 30:break;default:Rc(u,y)}}function O0(u){var f=u.alternate;f!==null&&(u.alternate=null,O0(f)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(f=u.stateNode,f!==null&&wt(f)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var Ss=null,Vi=!1;function Wa(u,f,y){for(y=y.child;y!==null;)Fu(u,f,y),y=y.sibling}function Fu(u,f,y){if(ut&&typeof ut.onCommitFiberUnmount=="function")try{ut.onCommitFiberUnmount(at,y)}catch{}switch(y.tag){case 26:ii||lo(y,f),Wa(u,f,y),y.memoizedState?y.memoizedState.count--:y.stateNode&&(y=y.stateNode,y.parentNode.removeChild(y));break;case 27:ii||lo(y,f);var A=Ss,M=Vi;uf(y.type)&&(Ss=y.stateNode,Vi=!1),Wa(u,f,y),jb(y.stateNode),Ss=A,Vi=M;break;case 5:ii||lo(y,f);case 6:if(A=Ss,M=Vi,Ss=null,Wa(u,f,y),Ss=A,Vi=M,Ss!==null)if(Vi)try{(Ss.nodeType===9?Ss.body:Ss.nodeName==="HTML"?Ss.ownerDocument.body:Ss).removeChild(y.stateNode)}catch(I){Ws(y,f,I)}else try{Ss.removeChild(y.stateNode)}catch(I){Ws(y,f,I)}break;case 18:Ss!==null&&(Vi?(u=Ss,uF(u.nodeType===9?u.body:u.nodeName==="HTML"?u.ownerDocument.body:u,y.stateNode),W0(u)):uF(Ss,y.stateNode));break;case 4:A=Ss,M=Vi,Ss=y.stateNode.containerInfo,Vi=!0,Wa(u,f,y),Ss=A,Vi=M;break;case 0:case 11:case 14:case 15:Po(2,y,f),ii||Po(4,y,f),Wa(u,f,y);break;case 1:ii||(lo(y,f),A=y.stateNode,typeof A.componentWillUnmount=="function"&&$b(y,f,A)),Wa(u,f,y);break;case 21:Wa(u,f,y);break;case 22:ii=(A=ii)||y.memoizedState!==null,Wa(u,f,y),ii=A;break;default:Wa(u,f,y)}}function B0(u,f){if(f.memoizedState===null&&(u=f.alternate,u!==null&&(u=u.memoizedState,u!==null))){u=u.dehydrated;try{W0(u)}catch(y){Ws(f,f.return,y)}}}function Gb(u,f){if(f.memoizedState===null&&(u=f.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{W0(u)}catch(y){Ws(f,f.return,y)}}function Ew(u){switch(u.tag){case 31:case 13:case 19:var f=u.stateNode;return f===null&&(f=u.stateNode=new im),f;case 22:return u=u.stateNode,f=u._retryCache,f===null&&(f=u._retryCache=new im),f;default:throw Error(s(435,u.tag))}}function Di(u,f){var y=Ew(u);f.forEach(function(A){if(!y.has(A)){y.add(A);var M=Zj.bind(null,u,A);A.then(M,M)}})}function ja(u,f){var y=f.deletions;if(y!==null)for(var A=0;A<y.length;A++){var M=y[A],I=u,G=f,ne=G;e:for(;ne!==null;){switch(ne.tag){case 27:if(uf(ne.type)){Ss=ne.stateNode,Vi=!1;break e}break;case 5:Ss=ne.stateNode,Vi=!1;break e;case 3:case 4:Ss=ne.stateNode.containerInfo,Vi=!0;break e}ne=ne.return}if(Ss===null)throw Error(s(160));Fu(I,G,M),Ss=null,Vi=!1,I=M.alternate,I!==null&&(I.return=null),M.return=null}if(f.subtreeFlags&13886)for(f=f.child;f!==null;)Uu(f,u),f=f.sibling}var Ir=null;function Uu(u,f){var y=u.alternate,A=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:ja(f,u),vi(u),A&4&&(Po(3,u,u.return),$l(3,u),Po(5,u,u.return));break;case 1:ja(f,u),vi(u),A&512&&(ii||y===null||lo(y,y.return)),A&64&&$o&&(u=u.updateQueue,u!==null&&(A=u.callbacks,A!==null&&(y=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=y===null?A:y.concat(A))));break;case 26:var M=Ir;if(ja(f,u),vi(u),A&512&&(ii||y===null||lo(y,y.return)),A&4){var I=y!==null?y.memoizedState:null;if(A=u.memoizedState,y===null)if(A===null)if(u.stateNode===null){e:{A=u.type,y=u.memoizedProps,M=M.ownerDocument||M;t:switch(A){case"title":I=M.getElementsByTagName("title")[0],(!I||I[Mt]||I[Un]||I.namespaceURI==="http://www.w3.org/2000/svg"||I.hasAttribute("itemprop"))&&(I=M.createElement(A),M.head.insertBefore(I,M.querySelector("head > title"))),pr(I,A,y),I[Un]=u,De(I),A=I;break e;case"link":var G=SF("link","href",M).get(A+(y.href||""));if(G){for(var ne=0;ne<G.length;ne++)if(I=G[ne],I.getAttribute("href")===(y.href==null||y.href===""?null:y.href)&&I.getAttribute("rel")===(y.rel==null?null:y.rel)&&I.getAttribute("title")===(y.title==null?null:y.title)&&I.getAttribute("crossorigin")===(y.crossOrigin==null?null:y.crossOrigin)){G.splice(ne,1);break t}}I=M.createElement(A),pr(I,A,y),M.head.appendChild(I);break;case"meta":if(G=SF("meta","content",M).get(A+(y.content||""))){for(ne=0;ne<G.length;ne++)if(I=G[ne],I.getAttribute("content")===(y.content==null?null:""+y.content)&&I.getAttribute("name")===(y.name==null?null:y.name)&&I.getAttribute("property")===(y.property==null?null:y.property)&&I.getAttribute("http-equiv")===(y.httpEquiv==null?null:y.httpEquiv)&&I.getAttribute("charset")===(y.charSet==null?null:y.charSet)){G.splice(ne,1);break t}}I=M.createElement(A),pr(I,A,y),M.head.appendChild(I);break;default:throw Error(s(468,A))}I[Un]=u,De(I),A=I}u.stateNode=A}else _F(M,u.type,u.stateNode);else u.stateNode=bF(M,A,u.memoizedProps);else I!==A?(I===null?y.stateNode!==null&&(y=y.stateNode,y.parentNode.removeChild(y)):I.count--,A===null?_F(M,u.type,u.stateNode):bF(M,A,u.memoizedProps)):A===null&&u.stateNode!==null&&zo(u,u.memoizedProps,y.memoizedProps)}break;case 27:ja(f,u),vi(u),A&512&&(ii||y===null||lo(y,y.return)),y!==null&&A&4&&zo(u,u.memoizedProps,y.memoizedProps);break;case 5:if(ja(f,u),vi(u),A&512&&(ii||y===null||lo(y,y.return)),u.flags&32){M=u.stateNode;try{nl(M,"")}catch(an){Ws(u,u.return,an)}}A&4&&u.stateNode!=null&&(M=u.memoizedProps,zo(u,M,y!==null?y.memoizedProps:M)),A&1024&&(Nc=!0);break;case 6:if(ja(f,u),vi(u),A&4){if(u.stateNode===null)throw Error(s(162));A=u.memoizedProps,y=u.stateNode;try{y.nodeValue=A}catch(an){Ws(u,u.return,an)}}break;case 3:if(Lw=null,M=Ir,Ir=Bw(f.containerInfo),ja(f,u),Ir=M,vi(u),A&4&&y!==null&&y.memoizedState.isDehydrated)try{W0(f.containerInfo)}catch(an){Ws(u,u.return,an)}Nc&&(Nc=!1,Mw(u));break;case 4:A=Ir,Ir=Bw(u.stateNode.containerInfo),ja(f,u),vi(u),Ir=A;break;case 12:ja(f,u),vi(u);break;case 31:ja(f,u),vi(u),A&4&&(A=u.updateQueue,A!==null&&(u.updateQueue=null,Di(u,A)));break;case 13:ja(f,u),vi(u),u.child.flags&8192&&u.memoizedState!==null!=(y!==null&&y.memoizedState!==null)&&(Oc=J()),A&4&&(A=u.updateQueue,A!==null&&(u.updateQueue=null,Di(u,A)));break;case 22:M=u.memoizedState!==null;var Ae=y!==null&&y.memoizedState!==null,$e=$o,ot=ii;if($o=$e||M,ii=ot||Ae,ja(f,u),ii=ot,$o=$e,vi(u),A&8192)e:for(f=u.stateNode,f._visibility=M?f._visibility&-2:f._visibility|1,M&&(y===null||Ae||$o||ii||Uh(u)),y=null,f=u;;){if(f.tag===5||f.tag===26){if(y===null){Ae=y=f;try{if(I=Ae.stateNode,M)G=I.style,typeof G.setProperty=="function"?G.setProperty("display","none","important"):G.display="none";else{ne=Ae.stateNode;var xt=Ae.memoizedProps.style,je=xt!=null&&xt.hasOwnProperty("display")?xt.display:null;ne.style.display=je==null||typeof je=="boolean"?"":(""+je).trim()}}catch(an){Ws(Ae,Ae.return,an)}}}else if(f.tag===6){if(y===null){Ae=f;try{Ae.stateNode.nodeValue=M?"":Ae.memoizedProps}catch(an){Ws(Ae,Ae.return,an)}}}else if(f.tag===18){if(y===null){Ae=f;try{var Qe=Ae.stateNode;M?hF(Qe,!0):hF(Ae.stateNode,!1)}catch(an){Ws(Ae,Ae.return,an)}}}else if((f.tag!==22&&f.tag!==23||f.memoizedState===null||f===u)&&f.child!==null){f.child.return=f,f=f.child;continue}if(f===u)break e;for(;f.sibling===null;){if(f.return===null||f.return===u)break e;y===f&&(y=null),f=f.return}y===f&&(y=null),f.sibling.return=f.return,f=f.sibling}A&4&&(A=u.updateQueue,A!==null&&(y=A.retryQueue,y!==null&&(A.retryQueue=null,Di(u,y))));break;case 19:ja(f,u),vi(u),A&4&&(A=u.updateQueue,A!==null&&(u.updateQueue=null,Di(u,A)));break;case 30:break;case 21:break;default:ja(f,u),vi(u)}}function vi(u){var f=u.flags;if(f&2){try{for(var y,A=u.return;A!==null;){if(Gi(A)){y=A;break}A=A.return}if(y==null)throw Error(s(160));switch(y.tag){case 27:var M=y.stateNode,I=Vl(u);Is(u,I,M);break;case 5:var G=y.stateNode;y.flags&32&&(nl(G,""),y.flags&=-33);var ne=Vl(u);Is(u,ne,G);break;case 3:case 4:var Ae=y.stateNode.containerInfo,$e=Vl(u);$n(u,$e,Ae);break;default:throw Error(s(161))}}catch(ot){Ws(u,u.return,ot)}u.flags&=-3}f&4096&&(u.flags&=-4097)}function Mw(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var f=u;Mw(f),f.tag===5&&f.flags&1024&&f.stateNode.reset(),u=u.sibling}}function Rc(u,f){if(f.subtreeFlags&8772)for(f=f.child;f!==null;)Tw(u,f.alternate,f),f=f.sibling}function Uh(u){for(u=u.child;u!==null;){var f=u;switch(f.tag){case 0:case 11:case 14:case 15:Po(4,f,f.return),Uh(f);break;case 1:lo(f,f.return);var y=f.stateNode;typeof y.componentWillUnmount=="function"&&$b(f,f.return,y),Uh(f);break;case 27:jb(f.stateNode);case 26:case 5:lo(f,f.return),Uh(f);break;case 22:f.memoizedState===null&&Uh(f);break;case 30:Uh(f);break;default:Uh(f)}u=u.sibling}}function Ds(u,f,y){for(y=y&&(f.subtreeFlags&8772)!==0,f=f.child;f!==null;){var A=f.alternate,M=u,I=f,G=I.flags;switch(I.tag){case 0:case 11:case 15:Ds(M,I,y),$l(4,I);break;case 1:if(Ds(M,I,y),A=I,M=A.stateNode,typeof M.componentDidMount=="function")try{M.componentDidMount()}catch($e){Ws(A,A.return,$e)}if(A=I,M=A.updateQueue,M!==null){var ne=A.stateNode;try{var Ae=M.shared.hiddenCallbacks;if(Ae!==null)for(M.shared.hiddenCallbacks=null,M=0;M<Ae.length;M++)Fl(Ae[M],ne)}catch($e){Ws(A,A.return,$e)}}y&&G&64&&Lu(I),Gl(I,I.return);break;case 27:Ii(I);case 26:case 5:Ds(M,I,y),y&&A===null&&G&4&&co(I),Gl(I,I.return);break;case 12:Ds(M,I,y);break;case 31:Ds(M,I,y),y&&G&4&&B0(M,I);break;case 13:Ds(M,I,y),y&&G&4&&Gb(M,I);break;case 22:I.memoizedState===null&&Ds(M,I,y),Gl(I,I.return);break;case 30:break;default:Ds(M,I,y)}f=f.sibling}}function k0(u,f){var y=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(y=u.memoizedState.cachePool.pool),u=null,f.memoizedState!==null&&f.memoizedState.cachePool!==null&&(u=f.memoizedState.cachePool.pool),u!==y&&(u!=null&&u.refCount++,y!=null&&wa(y))}function Ic(u,f){u=null,f.alternate!==null&&(u=f.alternate.memoizedState.cache),f=f.memoizedState.cache,f!==u&&(f.refCount++,u!=null&&wa(u))}function ea(u,f,y,A){if(f.subtreeFlags&10256)for(f=f.child;f!==null;)ci(u,f,y,A),f=f.sibling}function ci(u,f,y,A){var M=f.flags;switch(f.tag){case 0:case 11:case 15:ea(u,f,y,A),M&2048&&$l(9,f);break;case 1:ea(u,f,y,A);break;case 3:ea(u,f,y,A),M&2048&&(u=null,f.alternate!==null&&(u=f.alternate.memoizedState.cache),f=f.memoizedState.cache,f!==u&&(f.refCount++,u!=null&&wa(u)));break;case 12:if(M&2048){ea(u,f,y,A),u=f.stateNode;try{var I=f.memoizedProps,G=I.id,ne=I.onPostCommit;typeof ne=="function"&&ne(G,f.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(Ae){Ws(f,f.return,Ae)}}else ea(u,f,y,A);break;case 31:ea(u,f,y,A);break;case 13:ea(u,f,y,A);break;case 23:break;case 22:I=f.stateNode,G=f.alternate,f.memoizedState!==null?I._visibility&2?ea(u,f,y,A):rf(u,f):I._visibility&2?ea(u,f,y,A):(I._visibility|=2,Pu(u,f,y,A,(f.subtreeFlags&10256)!==0||!1)),M&2048&&k0(G,f);break;case 24:ea(u,f,y,A),M&2048&&Ic(f.alternate,f);break;default:ea(u,f,y,A)}}function Pu(u,f,y,A,M){for(M=M&&((f.subtreeFlags&10256)!==0||!1),f=f.child;f!==null;){var I=u,G=f,ne=y,Ae=A,$e=G.flags;switch(G.tag){case 0:case 11:case 15:Pu(I,G,ne,Ae,M),$l(8,G);break;case 23:break;case 22:var ot=G.stateNode;G.memoizedState!==null?ot._visibility&2?Pu(I,G,ne,Ae,M):rf(I,G):(ot._visibility|=2,Pu(I,G,ne,Ae,M)),M&&$e&2048&&k0(G.alternate,G);break;case 24:Pu(I,G,ne,Ae,M),M&&$e&2048&&Ic(G.alternate,G);break;default:Pu(I,G,ne,Ae,M)}f=f.sibling}}function rf(u,f){if(f.subtreeFlags&10256)for(f=f.child;f!==null;){var y=u,A=f,M=A.flags;switch(A.tag){case 22:rf(y,A),M&2048&&k0(A.alternate,A);break;case 24:rf(y,A),M&2048&&Ic(A.alternate,A);break;default:rf(y,A)}f=f.sibling}}var bi=8192;function Ph(u,f,y){if(u.subtreeFlags&bi)for(u=u.child;u!==null;)Oi(u,f,y),u=u.sibling}function Oi(u,f,y){switch(u.tag){case 26:Ph(u,f,y),u.flags&bi&&u.memoizedState!==null&&N7(y,Ir,u.memoizedState,u.memoizedProps);break;case 5:Ph(u,f,y);break;case 3:case 4:var A=Ir;Ir=Bw(u.stateNode.containerInfo),Ph(u,f,y),Ir=A;break;case 22:u.memoizedState===null&&(A=u.alternate,A!==null&&A.memoizedState!==null?(A=bi,bi=16777216,Ph(u,f,y),bi=A):Ph(u,f,y));break;default:Ph(u,f,y)}}function Dr(u){var f=u.alternate;if(f!==null&&(u=f.child,u!==null)){f.child=null;do f=u.sibling,u.sibling=null,u=f;while(u!==null)}}function dr(u){var f=u.deletions;if((u.flags&16)!==0){if(f!==null)for(var y=0;y<f.length;y++){var A=f[y];yi=A,am(A,u)}Dr(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)zh(u),u=u.sibling}function zh(u){switch(u.tag){case 0:case 11:case 15:dr(u),u.flags&2048&&Po(9,u,u.return);break;case 3:dr(u);break;case 12:dr(u);break;case 22:var f=u.stateNode;u.memoizedState!==null&&f._visibility&2&&(u.return===null||u.return.tag!==13)?(f._visibility&=-3,L0(u)):dr(u);break;default:dr(u)}}function L0(u){var f=u.deletions;if((u.flags&16)!==0){if(f!==null)for(var y=0;y<f.length;y++){var A=f[y];yi=A,am(A,u)}Dr(u)}for(u=u.child;u!==null;){switch(f=u,f.tag){case 0:case 11:case 15:Po(8,f,f.return),L0(f);break;case 22:y=f.stateNode,y._visibility&2&&(y._visibility&=-3,L0(f));break;default:L0(f)}u=u.sibling}}function am(u,f){for(;yi!==null;){var y=yi;switch(y.tag){case 0:case 11:case 15:Po(8,y,f);break;case 23:case 22:if(y.memoizedState!==null&&y.memoizedState.cachePool!==null){var A=y.memoizedState.cachePool.pool;A!=null&&A.refCount++}break;case 24:wa(y.memoizedState.cache)}if(A=y.child,A!==null)A.return=y,yi=A;else e:for(y=u;yi!==null;){A=yi;var M=A.sibling,I=A.return;if(O0(A),A===y){yi=null;break e}if(M!==null){M.return=I,yi=M;break e}yi=I}}}var F0={getCacheForType:function(u){var f=fa(xn),y=f.data.get(u);return y===void 0&&(y=u(),f.data.set(u,y)),y},cacheSignal:function(){return fa(xn).controller.signal}},U0=typeof WeakMap=="function"?WeakMap:Map,gs=0,Os=null,Gn=null,os=0,yn=0,ts=null,Bn=!1,Kn=!1,$s=!1,Bi=0,Bs=0,uo=0,Dc=0,hl=0,xs=0,ho=0,dl=null,Xa=null,Or=!1,Oc=0,of=0,fo=1/0,lf=null,Hl=null,ui=0,fl=null,po=null,Go=0,Bc=0,$h=null,P0=null,Gh=0,Vh=null;function fr(){return(gs&2)!==0&&os!==0?os&-os:P.T!==null?oR():ca()}function m(){if(xs===0)if((os&536870912)===0||us){var u=At;At<<=1,(At&3932160)===0&&(At=262144),xs=u}else xs=536870912;return u=Qi.current,u!==null&&(u.flags|=32),xs}function x(u,f,y){(u===Os&&(yn===2||yn===9)||u.cancelPendingCommit!==null)&&(ke(u,0),z(u,os,xs,!1)),ei(u,y),((gs&2)===0||u!==Os)&&(u===Os&&((gs&2)===0&&(Dc|=y),Bs===4&&z(u,os,xs,!1)),zu(u))}function C(u,f,y){if((gs&6)!==0)throw Error(s(327));var A=!y&&(f&127)===0&&(f&u.expiredLanes)===0||Ut(u,f),M=A?Hh(u,f):Br(u,f,!0),I=A;do{if(M===0){Kn&&!A&&z(u,f,0,!1);break}else{if(y=u.current.alternate,I&&!k(y)){M=Br(u,f,!1),I=!1;continue}if(M===2){if(I=f,u.errorRecoveryDisabledLanes&I)var G=0;else G=u.pendingLanes&-536870913,G=G!==0?G:G&536870912?536870912:0;if(G!==0){f=G;e:{var ne=u;M=dl;var Ae=ne.current.memoizedState.isDehydrated;if(Ae&&(ke(ne,G).flags|=256),G=Br(ne,G,!1),G!==2){if($s&&!Ae){ne.errorRecoveryDisabledLanes|=I,Dc|=I,M=4;break e}I=Xa,Xa=M,I!==null&&(Xa===null?Xa=I:Xa.push.apply(Xa,I))}M=G}if(I=!1,M!==2)continue}}if(M===1){ke(u,0),z(u,f,0,!0);break}e:{switch(A=u,I=M,I){case 0:case 1:throw Error(s(345));case 4:if((f&4194048)!==f)break;case 6:z(A,f,xs,!Bn);break e;case 2:Xa=null;break;case 3:case 5:break;default:throw Error(s(329))}if((f&62914560)===f&&(M=Oc+300-J(),10<M)){if(z(A,f,xs,!Bn),dt(A,0,!0)!==0)break e;Go=f,A.timeoutHandle=lF(N.bind(null,A,y,Xa,lf,Or,f,xs,Dc,ho,Bn,I,"Throttled",-0,0),M);break e}N(A,y,Xa,lf,Or,f,xs,Dc,ho,Bn,I,null,-0,0)}}break}while(!0);zu(u)}function N(u,f,y,A,M,I,G,ne,Ae,$e,ot,xt,je,Qe){if(u.timeoutHandle=-1,xt=f.subtreeFlags,xt&8192||(xt&16785408)===16785408){xt={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Ml},Oi(f,I,xt);var an=(I&62914560)===I?Oc-J():(I&4194048)===I?of-J():0;if(an=R7(xt,an),an!==null){Go=I,u.cancelPendingCommit=an(Mn.bind(null,u,f,I,y,A,M,G,ne,Ae,ot,xt,null,je,Qe)),z(u,I,G,!$e);return}}Mn(u,f,I,y,A,M,G,ne,Ae)}function k(u){for(var f=u;;){var y=f.tag;if((y===0||y===11||y===15)&&f.flags&16384&&(y=f.updateQueue,y!==null&&(y=y.stores,y!==null)))for(var A=0;A<y.length;A++){var M=y[A],I=M.getSnapshot;M=M.value;try{if(!ni(I(),M))return!1}catch{return!1}}if(y=f.child,f.subtreeFlags&16384&&y!==null)y.return=f,f=y;else{if(f===u)break;for(;f.sibling===null;){if(f.return===null||f.return===u)return!0;f=f.return}f.sibling.return=f.return,f=f.sibling}}return!0}function z(u,f,y,A){f&=~hl,f&=~Dc,u.suspendedLanes|=f,u.pingedLanes&=~f,A&&(u.warmLanes|=f),A=u.expirationTimes;for(var M=f;0<M;){var I=31-xe(M),G=1<<I;A[I]=-1,M&=~G}y!==0&&xh(u,y,f)}function ie(){return(gs&6)===0?(Vb(0),!1):!0}function _e(){if(Gn!==null){if(yn===0)var u=Gn.return;else u=Gn,Ga=bc=null,vb(u),Mu=null,Nu=0,u=Gn;for(;u!==null;)Fh(u.alternate,u),u=u.return;Gn=null}}function ke(u,f){var y=u.timeoutHandle;y!==-1&&(u.timeoutHandle=-1,d7(y)),y=u.cancelPendingCommit,y!==null&&(u.cancelPendingCommit=null,y()),Go=0,_e(),Os=u,Gn=y=Il(u.current,null),os=f,yn=0,ts=null,Bn=!1,Kn=Ut(u,f),$s=!1,ho=xs=hl=Dc=uo=Bs=0,Xa=dl=null,Or=!1,(f&8)!==0&&(f|=f&32);var A=u.entangledLanes;if(A!==0)for(u=u.entanglements,A&=f;0<A;){var M=31-xe(A),I=1<<M;f|=u[M],A&=~I}return Bi=f,Su(),y}function ht(u,f){En=null,P.H=Xp,f===Eu||f===ol?(f=f0(),yn=3):f===Fp?(f=f0(),yn=4):yn=f===R0?8:f!==null&&typeof f=="object"&&typeof f.then=="function"?6:1,ts=f,Gn===null&&(Bs=1,N0(u,Cr(f,u.current)))}function Ot(){var u=Qi.current;return u===null?!0:(os&4194048)===os?Lo===null:(os&62914560)===os||(os&536870912)!==0?u===Lo:!1}function Vt(){var u=P.H;return P.H=Xp,u===null?Xp:u}function Yt(){var u=P.A;return P.A=F0,u}function Dn(){Bs=4,Bn||(os&4194048)!==os&&Qi.current!==null||(Kn=!0),(uo&134217727)===0&&(Dc&134217727)===0||Os===null||z(Os,os,xs,!1)}function Br(u,f,y){var A=gs;gs|=2;var M=Vt(),I=Yt();(Os!==u||os!==f)&&(lf=null,ke(u,f)),f=!1;var G=Bs;e:do try{if(yn!==0&&Gn!==null){var ne=Gn,Ae=ts;switch(yn){case 8:_e(),G=6;break e;case 3:case 2:case 9:case 6:Qi.current===null&&(f=!0);var $e=yn;if(yn=0,ts=null,Nt(u,ne,Ae,$e),y&&Kn){G=0;break e}break;default:$e=yn,yn=0,ts=null,Nt(u,ne,Ae,$e)}}rm(),G=Bs;break}catch(ot){ht(u,ot)}while(!0);return f&&u.shellSuspendCounter++,Ga=bc=null,gs=A,P.H=M,P.A=I,Gn===null&&(Os=null,os=0,Su()),G}function rm(){for(;Gn!==null;)Oe(Gn)}function Hh(u,f){var y=gs;gs|=2;var A=Vt(),M=Yt();Os!==u||os!==f?(lf=null,fo=J()+500,ke(u,f)):Kn=Ut(u,f);e:do try{if(yn!==0&&Gn!==null){f=Gn;var I=ts;t:switch(yn){case 1:yn=0,ts=null,Nt(u,f,I,1);break;case 2:case 9:if(QA(I)){yn=0,ts=null,Xe(f);break}f=function(){yn!==2&&yn!==9||Os!==u||(yn=7),zu(u)},I.then(f,f);break e;case 3:yn=7;break e;case 4:yn=5;break e;case 7:QA(I)?(yn=0,ts=null,Xe(f)):(yn=0,ts=null,Nt(u,f,I,7));break;case 5:var G=null;switch(Gn.tag){case 26:G=Gn.memoizedState;case 5:case 27:var ne=Gn;if(G?AF(G):ne.stateNode.complete){yn=0,ts=null;var Ae=ne.sibling;if(Ae!==null)Gn=Ae;else{var $e=ne.return;$e!==null?(Gn=$e,pn($e)):Gn=null}break t}}yn=0,ts=null,Nt(u,f,I,5);break;case 6:yn=0,ts=null,Nt(u,f,I,6);break;case 8:_e(),Bs=6;break e;default:throw Error(s(462))}}He();break}catch(ot){ht(u,ot)}while(!0);return Ga=bc=null,P.H=A,P.A=M,gs=y,Gn!==null?0:(Os=null,os=0,Su(),Bs)}function He(){for(;Gn!==null&&!kt();)Oe(Gn)}function Oe(u){var f=I0(u.alternate,u,Bi);u.memoizedProps=u.pendingProps,f===null?pn(u):Gn=f}function Xe(u){var f=u,y=f.alternate;switch(f.tag){case 15:case 0:f=Ha(y,f,f.pendingProps,f.type,void 0,os);break;case 11:f=Ha(y,f,f.pendingProps,f.type.render,f.ref,os);break;case 5:vb(f);default:Fh(y,f),f=Gn=$a(f,Bi),f=I0(y,f,Bi)}u.memoizedProps=u.pendingProps,f===null?pn(u):Gn=f}function Nt(u,f,y,A){Ga=bc=null,vb(f),Mu=null,Nu=0;var M=f.return;try{if(so(u,M,f,y,os)){Bs=1,N0(u,Cr(y,u.current)),Gn=null;return}}catch(I){if(M!==null)throw Gn=M,I;Bs=1,N0(u,Cr(y,u.current)),Gn=null;return}f.flags&32768?(us||A===1?u=!0:Kn||(os&536870912)!==0?u=!1:(Bn=u=!0,(A===2||A===9||A===3||A===6)&&(A=Qi.current,A!==null&&A.tag===13&&(A.flags|=16384))),Ys(f,u)):pn(f)}function pn(u){var f=u;do{if((f.flags&32768)!==0){Ys(f,Bn);return}u=f.return;var y=zb(f.alternate,f,Bi);if(y!==null){Gn=y;return}if(f=f.sibling,f!==null){Gn=f;return}Gn=f=u}while(f!==null);Bs===0&&(Bs=5)}function Ys(u,f){do{var y=D0(u.alternate,u);if(y!==null){y.flags&=32767,Gn=y;return}if(y=u.return,y!==null&&(y.flags|=32768,y.subtreeFlags=0,y.deletions=null),!f&&(u=u.sibling,u!==null)){Gn=u;return}Gn=u=y}while(u!==null);Bs=6,Gn=null}function Mn(u,f,y,A,M,I,G,ne,Ae){u.cancelPendingCommit=null;do z0();while(ui!==0);if((gs&6)!==0)throw Error(s(327));if(f!==null){if(f===u.current)throw Error(s(177));if(I=f.lanes|f.childLanes,I|=a0,Ni(u,y,I,G,ne,Ae),u===Os&&(Gn=Os=null,os=0),po=f,fl=u,Go=y,Bc=I,$h=M,P0=A,(f.subtreeFlags&10256)!==0||(f.flags&10256)!==0?(u.callbackNode=null,u.callbackPriority=0,Qj(Ve,function(){return WL(),null})):(u.callbackNode=null,u.callbackPriority=0),A=(f.flags&13878)!==0,(f.subtreeFlags&13878)!==0||A){A=P.T,P.T=null,M=W.p,W.p=2,G=gs,gs|=4;try{af(u,f,y)}finally{gs=G,W.p=M,P.T=A}}ui=1,_s(),ta(),As()}}function _s(){if(ui===1){ui=0;var u=fl,f=po,y=(f.flags&13878)!==0;if((f.subtreeFlags&13878)!==0||y){y=P.T,P.T=null;var A=W.p;W.p=2;var M=gs;gs|=4;try{Uu(f,u);var I=mR,G=e0(u.containerInfo),ne=I.focusedElem,Ae=I.selectionRange;if(G!==ne&&ne&&ne.ownerDocument&&Qg(ne.ownerDocument.documentElement,ne)){if(Ae!==null&&Fd(ne)){var $e=Ae.start,ot=Ae.end;if(ot===void 0&&(ot=$e),"selectionStart"in ne)ne.selectionStart=$e,ne.selectionEnd=Math.min(ot,ne.value.length);else{var xt=ne.ownerDocument||document,je=xt&&xt.defaultView||window;if(je.getSelection){var Qe=je.getSelection(),an=ne.textContent.length,Tn=Math.min(Ae.start,an),Zs=Ae.end===void 0?Tn:Math.min(Ae.end,an);!Qe.extend&&Tn>Zs&&(G=Zs,Zs=Tn,Tn=G);var Be=qv(ne,Tn),Re=qv(ne,Zs);if(Be&&Re&&(Qe.rangeCount!==1||Qe.anchorNode!==Be.node||Qe.anchorOffset!==Be.offset||Qe.focusNode!==Re.node||Qe.focusOffset!==Re.offset)){var ze=xt.createRange();ze.setStart(Be.node,Be.offset),Qe.removeAllRanges(),Tn>Zs?(Qe.addRange(ze),Qe.extend(Re.node,Re.offset)):(ze.setEnd(Re.node,Re.offset),Qe.addRange(ze))}}}}for(xt=[],Qe=ne;Qe=Qe.parentNode;)Qe.nodeType===1&&xt.push({element:Qe,left:Qe.scrollLeft,top:Qe.scrollTop});for(typeof ne.focus=="function"&&ne.focus(),ne=0;ne<xt.length;ne++){var pt=xt[ne];pt.element.scrollLeft=pt.left,pt.element.scrollTop=pt.top}}zw=!!pR,mR=pR=null}finally{gs=M,W.p=A,P.T=y}}u.current=f,ui=2}}function ta(){if(ui===2){ui=0;var u=fl,f=po,y=(f.flags&8772)!==0;if((f.subtreeFlags&8772)!==0||y){y=P.T,P.T=null;var A=W.p;W.p=2;var M=gs;gs|=4;try{Tw(u,f.alternate,f)}finally{gs=M,W.p=A,P.T=y}}ui=3}}function As(){if(ui===4||ui===3){ui=0,ce();var u=fl,f=po,y=Go,A=P0;(f.subtreeFlags&10256)!==0||(f.flags&10256)!==0?ui=5:(ui=0,po=fl=null,kc(u,u.pendingLanes));var M=u.pendingLanes;if(M===0&&(Hl=null),Ar(y),f=f.stateNode,ut&&typeof ut.onCommitFiberRoot=="function")try{ut.onCommitFiberRoot(at,f,void 0,(f.current.flags&128)===128)}catch{}if(A!==null){f=P.T,M=W.p,W.p=2,P.T=null;try{for(var I=u.onRecoverableError,G=0;G<A.length;G++){var ne=A[G];I(ne.value,{componentStack:ne.stack})}}finally{P.T=f,W.p=M}}(Go&3)!==0&&z0(),zu(u),M=u.pendingLanes,(y&261930)!==0&&(M&42)!==0?u===Vh?Gh++:(Gh=0,Vh=u):Gh=0,Vb(0)}}function kc(u,f){(u.pooledCacheLanes&=f)===0&&(f=u.pooledCache,f!=null&&(u.pooledCache=null,wa(f)))}function z0(){return _s(),ta(),As(),WL()}function WL(){if(ui!==5)return!1;var u=fl,f=Bc;Bc=0;var y=Ar(Go),A=P.T,M=W.p;try{W.p=32>y?32:y,P.T=null,y=$h,$h=null;var I=fl,G=Go;if(ui=0,po=fl=null,Go=0,(gs&6)!==0)throw Error(s(331));var ne=gs;if(gs|=4,zh(I.current),ci(I,I.current,G,y),gs=ne,Vb(0,!1),ut&&typeof ut.onPostCommitFiberRoot=="function")try{ut.onPostCommitFiberRoot(at,I)}catch{}return!0}finally{W.p=M,P.T=A,kc(u,f)}}function jL(u,f,y){f=Cr(y,f),f=Pb(u.stateNode,f,2),u=wc(u,f,2),u!==null&&(ei(u,2),zu(u))}function Ws(u,f,y){if(u.tag===3)jL(u,u,y);else for(;f!==null;){if(f.tag===3){jL(f,u,y);break}else if(f.tag===1){var A=f.stateNode;if(typeof f.type.getDerivedStateFromError=="function"||typeof A.componentDidCatch=="function"&&(Hl===null||!Hl.has(A))){u=Cr(y,u),y=Qd(2),A=wc(f,y,2),A!==null&&(Nr(y,A,f,u),ei(A,2),zu(A));break}}f=f.return}}function iR(u,f,y){var A=u.pingCache;if(A===null){A=u.pingCache=new U0;var M=new Set;A.set(f,M)}else M=A.get(f),M===void 0&&(M=new Set,A.set(f,M));M.has(y)||($s=!0,M.add(y),u=Yj.bind(null,u,f,y),f.then(u,u))}function Yj(u,f,y){var A=u.pingCache;A!==null&&A.delete(f),u.pingedLanes|=u.suspendedLanes&y,u.warmLanes&=~y,Os===u&&(os&y)===y&&(Bs===4||Bs===3&&(os&62914560)===os&&300>J()-Oc?(gs&2)===0&&ke(u,0):hl|=y,ho===os&&(ho=0)),zu(u)}function XL(u,f){f===0&&(f=Wn()),u=_u(u,f),u!==null&&(ei(u,f),zu(u))}function Jj(u){var f=u.memoizedState,y=0;f!==null&&(y=f.retryLane),XL(u,y)}function Zj(u,f){var y=0;switch(u.tag){case 31:case 13:var A=u.stateNode,M=u.memoizedState;M!==null&&(y=M.retryLane);break;case 19:A=u.stateNode;break;case 22:A=u.stateNode._retryCache;break;default:throw Error(s(314))}A!==null&&A.delete(f),XL(u,y)}function Qj(u,f){return Tt(u,f)}var Nw=null,$0=null,aR=!1,Rw=!1,rR=!1,cf=0;function zu(u){u!==$0&&u.next===null&&($0===null?Nw=$0=u:$0=$0.next=u),Rw=!0,aR||(aR=!0,t7())}function Vb(u,f){if(!rR&&Rw){rR=!0;do for(var y=!1,A=Nw;A!==null;){if(u!==0){var M=A.pendingLanes;if(M===0)var I=0;else{var G=A.suspendedLanes,ne=A.pingedLanes;I=(1<<31-xe(42|u)+1)-1,I&=M&~(G&~ne),I=I&201326741?I&201326741|1:I?I|2:0}I!==0&&(y=!0,JL(A,I))}else I=os,I=dt(A,A===Os?I:0,A.cancelPendingCommit!==null||A.timeoutHandle!==-1),(I&3)===0||Ut(A,I)||(y=!0,JL(A,I));A=A.next}while(y);rR=!1}}function e7(){qL()}function qL(){Rw=aR=!1;var u=0;cf!==0&&h7()&&(u=cf);for(var f=J(),y=null,A=Nw;A!==null;){var M=A.next,I=KL(A,f);I===0?(A.next=null,y===null?Nw=M:y.next=M,M===null&&($0=y)):(y=A,(u!==0||(I&3)!==0)&&(Rw=!0)),A=M}ui!==0&&ui!==5||Vb(u),cf!==0&&(cf=0)}function KL(u,f){for(var y=u.suspendedLanes,A=u.pingedLanes,M=u.expirationTimes,I=u.pendingLanes&-62914561;0<I;){var G=31-xe(I),ne=1<<G,Ae=M[G];Ae===-1?((ne&y)===0||(ne&A)!==0)&&(M[G]=cn(ne,f)):Ae<=f&&(u.expiredLanes|=ne),I&=~ne}if(f=Os,y=os,y=dt(u,u===f?y:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),A=u.callbackNode,y===0||u===f&&(yn===2||yn===9)||u.cancelPendingCommit!==null)return A!==null&&A!==null&&Et(A),u.callbackNode=null,u.callbackPriority=0;if((y&3)===0||Ut(u,y)){if(f=y&-y,f===u.callbackPriority)return f;switch(A!==null&&Et(A),Ar(y)){case 2:case 8:y=lt;break;case 32:y=Ve;break;case 268435456:y=Lt;break;default:y=Ve}return A=YL.bind(null,u),y=Tt(y,A),u.callbackPriority=f,u.callbackNode=y,f}return A!==null&&A!==null&&Et(A),u.callbackPriority=2,u.callbackNode=null,2}function YL(u,f){if(ui!==0&&ui!==5)return u.callbackNode=null,u.callbackPriority=0,null;var y=u.callbackNode;if(z0()&&u.callbackNode!==y)return null;var A=os;return A=dt(u,u===Os?A:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),A===0?null:(C(u,A,f),KL(u,J()),u.callbackNode!=null&&u.callbackNode===y?YL.bind(null,u):null)}function JL(u,f){if(z0())return null;C(u,f,!0)}function t7(){f7(function(){(gs&6)!==0?Tt(Ye,e7):qL()})}function oR(){if(cf===0){var u=Ac;u===0&&(u=Ue,Ue<<=1,(Ue&261888)===0&&(Ue=256)),cf=u}return cf}function ZL(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:yp(""+u)}function QL(u,f){var y=f.ownerDocument.createElement("input");return y.name=f.name,y.value=f.value,u.id&&y.setAttribute("form",u.id),f.parentNode.insertBefore(y,f),u=new FormData(u),y.parentNode.removeChild(y),u}function n7(u,f,y,A,M){if(f==="submit"&&y&&y.stateNode===M){var I=ZL((M[j]||null).action),G=A.submitter;G&&(f=(f=G[j]||null)?ZL(f.formAction):G.getAttribute("formAction"),f!==null&&(I=f,G=null));var ne=new _p("action","action",null,A,M);u.push({event:ne,listeners:[{instance:null,listener:function(){if(A.defaultPrevented){if(cf!==0){var Ae=G?QL(M,G):new FormData(M);Bb(y,{pending:!0,data:Ae,method:M.method,action:I},null,Ae)}}else typeof I=="function"&&(ne.preventDefault(),Ae=G?QL(M,G):new FormData(M),Bb(y,{pending:!0,data:Ae,method:M.method,action:I},I,Ae))},currentTarget:M}]})}}for(var lR=0;lR<i0.length;lR++){var cR=i0[lR],s7=cR.toLowerCase(),i7=cR[0].toUpperCase()+cR.slice(1);za(s7,"on"+i7)}za(wr,"onAnimationEnd"),za(Kv,"onAnimationIteration"),za(Rl,"onAnimationStart"),za("dblclick","onDoubleClick"),za("focusin","onFocus"),za("focusout","onBlur"),za($d,"onTransitionRun"),za(vu,"onTransitionStart"),za(Yv,"onTransitionCancel"),za(s0,"onTransitionEnd"),vt("onMouseEnter",["mouseout","mouseover"]),vt("onMouseLeave",["mouseout","mouseover"]),vt("onPointerEnter",["pointerout","pointerover"]),vt("onPointerLeave",["pointerout","pointerover"]),ct("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),ct("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),ct("onBeforeInput",["compositionend","keypress","textInput","paste"]),ct("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),ct("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),ct("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Hb="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),a7=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Hb));function eF(u,f){f=(f&4)!==0;for(var y=0;y<u.length;y++){var A=u[y],M=A.event;A=A.listeners;e:{var I=void 0;if(f)for(var G=A.length-1;0<=G;G--){var ne=A[G],Ae=ne.instance,$e=ne.currentTarget;if(ne=ne.listener,Ae!==I&&M.isPropagationStopped())break e;I=ne,M.currentTarget=$e;try{I(M)}catch(ot){bu(ot)}M.currentTarget=null,I=Ae}else for(G=0;G<A.length;G++){if(ne=A[G],Ae=ne.instance,$e=ne.currentTarget,ne=ne.listener,Ae!==I&&M.isPropagationStopped())break e;I=ne,M.currentTarget=$e;try{I(M)}catch(ot){bu(ot)}M.currentTarget=null,I=Ae}}}}function hs(u,f){var y=f[Ce];y===void 0&&(y=f[Ce]=new Set);var A=u+"__bubble";y.has(A)||(tF(f,u,2,!1),y.add(A))}function uR(u,f,y){var A=0;f&&(A|=4),tF(y,u,A,f)}var Iw="_reactListening"+Math.random().toString(36).slice(2);function hR(u){if(!u[Iw]){u[Iw]=!0,ye.forEach(function(y){y!=="selectionchange"&&(a7.has(y)||uR(y,!1,u),uR(y,!0,u))});var f=u.nodeType===9?u:u.ownerDocument;f===null||f[Iw]||(f[Iw]=!0,uR("selectionchange",!1,f))}}function tF(u,f,y,A){switch(RF(f)){case 2:var M=O7;break;case 8:M=B7;break;default:M=TR}y=M.bind(null,f,y,u),M=void 0,!Vg||f!=="touchstart"&&f!=="touchmove"&&f!=="wheel"||(M=!0),A?M!==void 0?u.addEventListener(f,y,{capture:!0,passive:M}):u.addEventListener(f,y,!0):M!==void 0?u.addEventListener(f,y,{passive:M}):u.addEventListener(f,y,!1)}function dR(u,f,y,A,M){var I=A;if((f&1)===0&&(f&2)===0&&A!==null)e:for(;;){if(A===null)return;var G=A.tag;if(G===3||G===4){var ne=A.stateNode.containerInfo;if(ne===M)break;if(G===4)for(G=A.return;G!==null;){var Ae=G.tag;if((Ae===3||Ae===4)&&G.stateNode.containerInfo===M)return;G=G.return}for(;ne!==null;){if(G=Ct(ne),G===null)return;if(Ae=G.tag,Ae===5||Ae===6||Ae===26||Ae===27){A=I=G;continue e}ne=ne.parentNode}}A=A.return}Iv(function(){var $e=I,ot=$g(y),xt=[];e:{var je=gc.get(u);if(je!==void 0){var Qe=_p,an=u;switch(u){case"keypress":if(bh(y)===0)break e;case"keydown":case"keyup":Qe=Uv;break;case"focusin":an="focus",Qe=qg;break;case"focusout":an="blur",Qe=qg;break;case"beforeblur":case"afterblur":Qe=qg;break;case"click":if(y.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Qe=RA;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Qe=IA;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Qe=pc;break;case wr:case Kv:case Rl:Qe=BA;break;case s0:Qe=YN;break;case"scroll":case"scrollend":Qe=jg;break;case"wheel":Qe=fu;break;case"copy":case"cut":case"paste":Qe=Ov;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Qe=Kg;break;case"toggle":case"beforetoggle":Qe=zv}var Tn=(f&4)!==0,Zs=!Tn&&(u==="scroll"||u==="scrollend"),Be=Tn?je!==null?je+"Capture":null:je;Tn=[];for(var Re=$e,ze;Re!==null;){var pt=Re;if(ze=pt.stateNode,pt=pt.tag,pt!==5&&pt!==26&&pt!==27||ze===null||Be===null||(pt=vh(Re,Be),pt!=null&&Tn.push(Wb(Re,pt,ze))),Zs)break;Re=Re.return}0<Tn.length&&(je=new Qe(je,an,null,y,ot),xt.push({event:je,listeners:Tn}))}}if((f&7)===0){e:{if(je=u==="mouseover"||u==="pointerover",Qe=u==="mouseout"||u==="pointerout",je&&y!==vp&&(an=y.relatedTarget||y.fromElement)&&(Ct(an)||an[ae]))break e;if((Qe||je)&&(je=ot.window===ot?ot:(je=ot.ownerDocument)?je.defaultView||je.parentWindow:window,Qe?(an=y.relatedTarget||y.toElement,Qe=$e,an=an?Ct(an):null,an!==null&&(Zs=a(an),Tn=an.tag,an!==Zs||Tn!==5&&Tn!==27&&Tn!==6)&&(an=null)):(Qe=null,an=$e),Qe!==an)){if(Tn=RA,pt="onMouseLeave",Be="onMouseEnter",Re="mouse",(u==="pointerout"||u==="pointerover")&&(Tn=Kg,pt="onPointerLeave",Be="onPointerEnter",Re="pointer"),Zs=Qe==null?je:de(Qe),ze=an==null?je:de(an),je=new Tn(pt,Re+"leave",Qe,y,ot),je.target=Zs,je.relatedTarget=ze,pt=null,Ct(ot)===$e&&(Tn=new Tn(Be,Re+"enter",an,y,ot),Tn.target=ze,Tn.relatedTarget=Zs,pt=Tn),Zs=pt,Qe&&an)t:{for(Tn=r7,Be=Qe,Re=an,ze=0,pt=Be;pt;pt=Tn(pt))ze++;pt=0;for(var Sn=Re;Sn;Sn=Tn(Sn))pt++;for(;0<ze-pt;)Be=Tn(Be),ze--;for(;0<pt-ze;)Re=Tn(Re),pt--;for(;ze--;){if(Be===Re||Re!==null&&Be===Re.alternate){Tn=Be;break t}Be=Tn(Be),Re=Tn(Re)}Tn=null}else Tn=null;Qe!==null&&nF(xt,je,Qe,Tn,!1),an!==null&&Zs!==null&&nF(xt,Zs,an,Tn,!0)}}e:{if(je=$e?de($e):window,Qe=je.nodeName&&je.nodeName.toLowerCase(),Qe==="select"||Qe==="input"&&je.type==="file")var ks=Wv;else if(Vv(je))if(Mp)ks=WA;else{ks=gu;var fn=Np}else Qe=je.nodeName,!Qe||Qe.toLowerCase()!=="input"||je.type!=="checkbox"&&je.type!=="radio"?$e&&xp($e.elementType)&&(ks=Wv):ks=HA;if(ks&&(ks=ks(u,$e))){Zg(xt,ks,y,ot);break e}fn&&fn(u,je,$e),u==="focusout"&&$e&&je.type==="number"&&$e.memoizedProps.value!=null&&vs(je,"number",je.value)}switch(fn=$e?de($e):window,u){case"focusin":(Vv(fn)||fn.contentEditable==="true")&&(Ud=fn,t0=$e,Pd=null);break;case"focusout":Pd=t0=Ud=null;break;case"mousedown":Zr=!0;break;case"contextmenu":case"mouseup":case"dragend":Zr=!1,n0(xt,y,ot);break;case"selectionchange":if(jA)break;case"keydown":case"keyup":n0(xt,y,ot)}var Yn;if(Sh)e:{switch(u){case"compositionstart":var ys="onCompositionStart";break e;case"compositionend":ys="onCompositionEnd";break e;case"compositionupdate":ys="onCompositionUpdate";break e}ys=void 0}else mu?Yg(u,y)&&(ys="onCompositionEnd"):u==="keydown"&&y.keyCode===229&&(ys="onCompositionStart");ys&&(Aa&&y.locale!=="ko"&&(mu||ys!=="onCompositionStart"?ys==="onCompositionEnd"&&mu&&(Yn=Wg()):(uu=ot,Hg="value"in uu?uu.value:uu.textContent,mu=!0)),fn=Dw($e,ys),0<fn.length&&(ys=new Bv(ys,u,null,y,ot),xt.push({event:ys,listeners:fn}),Yn?ys.data=Yn:(Yn=Dd(y),Yn!==null&&(ys.data=Yn)))),(Yn=_h?Jg(u,y):$A(u,y))&&(ys=Dw($e,"onBeforeInput"),0<ys.length&&(fn=new Bv("onBeforeInput","beforeinput",null,y,ot),xt.push({event:fn,listeners:ys}),fn.data=Yn)),n7(xt,u,$e,y,ot)}eF(xt,f)})}function Wb(u,f,y){return{instance:u,listener:f,currentTarget:y}}function Dw(u,f){for(var y=f+"Capture",A=[];u!==null;){var M=u,I=M.stateNode;if(M=M.tag,M!==5&&M!==26&&M!==27||I===null||(M=vh(u,y),M!=null&&A.unshift(Wb(u,M,I)),M=vh(u,f),M!=null&&A.push(Wb(u,M,I))),u.tag===3)return A;u=u.return}return[]}function r7(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function nF(u,f,y,A,M){for(var I=f._reactName,G=[];y!==null&&y!==A;){var ne=y,Ae=ne.alternate,$e=ne.stateNode;if(ne=ne.tag,Ae!==null&&Ae===A)break;ne!==5&&ne!==26&&ne!==27||$e===null||(Ae=$e,M?($e=vh(y,I),$e!=null&&G.unshift(Wb(y,$e,Ae))):M||($e=vh(y,I),$e!=null&&G.push(Wb(y,$e,Ae)))),y=y.return}G.length!==0&&u.push({event:f,listeners:G})}var o7=/\r\n?/g,l7=/\u0000|\uFFFD/g;function sF(u){return(typeof u=="string"?u:""+u).replace(o7,`
`).replace(l7,"")}function iF(u,f){return f=sF(f),sF(u)===f}function Js(u,f,y,A,M,I){switch(y){case"children":typeof A=="string"?f==="body"||f==="textarea"&&A===""||nl(u,A):(typeof A=="number"||typeof A=="bigint")&&f!=="body"&&nl(u,""+A);break;case"className":In(u,"class",A);break;case"tabIndex":In(u,"tabindex",A);break;case"dir":case"role":case"viewBox":case"width":case"height":In(u,y,A);break;case"style":Nv(u,A,I);break;case"data":if(f!=="object"){In(u,"data",A);break}case"src":case"href":if(A===""&&(f!=="a"||y!=="href")){u.removeAttribute(y);break}if(A==null||typeof A=="function"||typeof A=="symbol"||typeof A=="boolean"){u.removeAttribute(y);break}A=yp(""+A),u.setAttribute(y,A);break;case"action":case"formAction":if(typeof A=="function"){u.setAttribute(y,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof I=="function"&&(y==="formAction"?(f!=="input"&&Js(u,f,"name",M.name,M,null),Js(u,f,"formEncType",M.formEncType,M,null),Js(u,f,"formMethod",M.formMethod,M,null),Js(u,f,"formTarget",M.formTarget,M,null)):(Js(u,f,"encType",M.encType,M,null),Js(u,f,"method",M.method,M,null),Js(u,f,"target",M.target,M,null)));if(A==null||typeof A=="symbol"||typeof A=="boolean"){u.removeAttribute(y);break}A=yp(""+A),u.setAttribute(y,A);break;case"onClick":A!=null&&(u.onclick=Ml);break;case"onScroll":A!=null&&hs("scroll",u);break;case"onScrollEnd":A!=null&&hs("scrollend",u);break;case"dangerouslySetInnerHTML":if(A!=null){if(typeof A!="object"||!("__html"in A))throw Error(s(61));if(y=A.__html,y!=null){if(M.children!=null)throw Error(s(60));u.innerHTML=y}}break;case"multiple":u.multiple=A&&typeof A!="function"&&typeof A!="symbol";break;case"muted":u.muted=A&&typeof A!="function"&&typeof A!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(A==null||typeof A=="function"||typeof A=="boolean"||typeof A=="symbol"){u.removeAttribute("xlink:href");break}y=yp(""+A),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",y);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":A!=null&&typeof A!="function"&&typeof A!="symbol"?u.setAttribute(y,""+A):u.removeAttribute(y);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":A&&typeof A!="function"&&typeof A!="symbol"?u.setAttribute(y,""):u.removeAttribute(y);break;case"capture":case"download":A===!0?u.setAttribute(y,""):A!==!1&&A!=null&&typeof A!="function"&&typeof A!="symbol"?u.setAttribute(y,A):u.removeAttribute(y);break;case"cols":case"rows":case"size":case"span":A!=null&&typeof A!="function"&&typeof A!="symbol"&&!isNaN(A)&&1<=A?u.setAttribute(y,A):u.removeAttribute(y);break;case"rowSpan":case"start":A==null||typeof A=="function"||typeof A=="symbol"||isNaN(A)?u.removeAttribute(y):u.setAttribute(y,A);break;case"popover":hs("beforetoggle",u),hs("toggle",u),Qt(u,"popover",A);break;case"xlinkActuate":hn(u,"http://www.w3.org/1999/xlink","xlink:actuate",A);break;case"xlinkArcrole":hn(u,"http://www.w3.org/1999/xlink","xlink:arcrole",A);break;case"xlinkRole":hn(u,"http://www.w3.org/1999/xlink","xlink:role",A);break;case"xlinkShow":hn(u,"http://www.w3.org/1999/xlink","xlink:show",A);break;case"xlinkTitle":hn(u,"http://www.w3.org/1999/xlink","xlink:title",A);break;case"xlinkType":hn(u,"http://www.w3.org/1999/xlink","xlink:type",A);break;case"xmlBase":hn(u,"http://www.w3.org/XML/1998/namespace","xml:base",A);break;case"xmlLang":hn(u,"http://www.w3.org/XML/1998/namespace","xml:lang",A);break;case"xmlSpace":hn(u,"http://www.w3.org/XML/1998/namespace","xml:space",A);break;case"is":Qt(u,"is",A);break;case"innerText":case"textContent":break;default:(!(2<y.length)||y[0]!=="o"&&y[0]!=="O"||y[1]!=="n"&&y[1]!=="N")&&(y=MA.get(y)||y,Qt(u,y,A))}}function fR(u,f,y,A,M,I){switch(y){case"style":Nv(u,A,I);break;case"dangerouslySetInnerHTML":if(A!=null){if(typeof A!="object"||!("__html"in A))throw Error(s(61));if(y=A.__html,y!=null){if(M.children!=null)throw Error(s(60));u.innerHTML=y}}break;case"children":typeof A=="string"?nl(u,A):(typeof A=="number"||typeof A=="bigint")&&nl(u,""+A);break;case"onScroll":A!=null&&hs("scroll",u);break;case"onScrollEnd":A!=null&&hs("scrollend",u);break;case"onClick":A!=null&&(u.onclick=Ml);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Ke.hasOwnProperty(y))e:{if(y[0]==="o"&&y[1]==="n"&&(M=y.endsWith("Capture"),f=y.slice(2,M?y.length-7:void 0),I=u[j]||null,I=I!=null?I[y]:null,typeof I=="function"&&u.removeEventListener(f,I,M),typeof A=="function")){typeof I!="function"&&I!==null&&(y in u?u[y]=null:u.hasAttribute(y)&&u.removeAttribute(y)),u.addEventListener(f,A,M);break e}y in u?u[y]=A:A===!0?u.setAttribute(y,""):Qt(u,y,A)}}}function pr(u,f,y){switch(f){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":hs("error",u),hs("load",u);var A=!1,M=!1,I;for(I in y)if(y.hasOwnProperty(I)){var G=y[I];if(G!=null)switch(I){case"src":A=!0;break;case"srcSet":M=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,f));default:Js(u,f,I,G,y,null)}}M&&Js(u,f,"srcSet",y.srcSet,y,null),A&&Js(u,f,"src",y.src,y,null);return;case"input":hs("invalid",u);var ne=I=G=M=null,Ae=null,$e=null;for(A in y)if(y.hasOwnProperty(A)){var ot=y[A];if(ot!=null)switch(A){case"name":M=ot;break;case"type":G=ot;break;case"checked":Ae=ot;break;case"defaultChecked":$e=ot;break;case"value":I=ot;break;case"defaultValue":ne=ot;break;case"children":case"dangerouslySetInnerHTML":if(ot!=null)throw Error(s(137,f));break;default:Js(u,f,A,ot,y,null)}}cs(u,I,ne,Ae,$e,G,M,!1);return;case"select":hs("invalid",u),A=G=I=null;for(M in y)if(y.hasOwnProperty(M)&&(ne=y[M],ne!=null))switch(M){case"value":I=ne;break;case"defaultValue":G=ne;break;case"multiple":A=ne;default:Js(u,f,M,ne,y,null)}f=I,y=G,u.multiple=!!A,f!=null?Ps(u,!!A,f,!1):y!=null&&Ps(u,!!A,y,!0);return;case"textarea":hs("invalid",u),I=M=A=null;for(G in y)if(y.hasOwnProperty(G)&&(ne=y[G],ne!=null))switch(G){case"value":A=ne;break;case"defaultValue":M=ne;break;case"children":I=ne;break;case"dangerouslySetInnerHTML":if(ne!=null)throw Error(s(91));break;default:Js(u,f,G,ne,y,null)}pi(u,A,M,I);return;case"option":for(Ae in y)if(y.hasOwnProperty(Ae)&&(A=y[Ae],A!=null))switch(Ae){case"selected":u.selected=A&&typeof A!="function"&&typeof A!="symbol";break;default:Js(u,f,Ae,A,y,null)}return;case"dialog":hs("beforetoggle",u),hs("toggle",u),hs("cancel",u),hs("close",u);break;case"iframe":case"object":hs("load",u);break;case"video":case"audio":for(A=0;A<Hb.length;A++)hs(Hb[A],u);break;case"image":hs("error",u),hs("load",u);break;case"details":hs("toggle",u);break;case"embed":case"source":case"link":hs("error",u),hs("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for($e in y)if(y.hasOwnProperty($e)&&(A=y[$e],A!=null))switch($e){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,f));default:Js(u,f,$e,A,y,null)}return;default:if(xp(f)){for(ot in y)y.hasOwnProperty(ot)&&(A=y[ot],A!==void 0&&fR(u,f,ot,A,y,void 0));return}}for(ne in y)y.hasOwnProperty(ne)&&(A=y[ne],A!=null&&Js(u,f,ne,A,y,null))}function c7(u,f,y,A){switch(f){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var M=null,I=null,G=null,ne=null,Ae=null,$e=null,ot=null;for(Qe in y){var xt=y[Qe];if(y.hasOwnProperty(Qe)&&xt!=null)switch(Qe){case"checked":break;case"value":break;case"defaultValue":Ae=xt;default:A.hasOwnProperty(Qe)||Js(u,f,Qe,null,A,xt)}}for(var je in A){var Qe=A[je];if(xt=y[je],A.hasOwnProperty(je)&&(Qe!=null||xt!=null))switch(je){case"type":I=Qe;break;case"name":M=Qe;break;case"checked":$e=Qe;break;case"defaultChecked":ot=Qe;break;case"value":G=Qe;break;case"defaultValue":ne=Qe;break;case"children":case"dangerouslySetInnerHTML":if(Qe!=null)throw Error(s(137,f));break;default:Qe!==xt&&Js(u,f,je,Qe,A,xt)}}li(u,G,ne,Ae,$e,ot,I,M);return;case"select":Qe=G=ne=je=null;for(I in y)if(Ae=y[I],y.hasOwnProperty(I)&&Ae!=null)switch(I){case"value":break;case"multiple":Qe=Ae;default:A.hasOwnProperty(I)||Js(u,f,I,null,A,Ae)}for(M in A)if(I=A[M],Ae=y[M],A.hasOwnProperty(M)&&(I!=null||Ae!=null))switch(M){case"value":je=I;break;case"defaultValue":ne=I;break;case"multiple":G=I;default:I!==Ae&&Js(u,f,M,I,A,Ae)}f=ne,y=G,A=Qe,je!=null?Ps(u,!!y,je,!1):!!A!=!!y&&(f!=null?Ps(u,!!y,f,!0):Ps(u,!!y,y?[]:"",!1));return;case"textarea":Qe=je=null;for(ne in y)if(M=y[ne],y.hasOwnProperty(ne)&&M!=null&&!A.hasOwnProperty(ne))switch(ne){case"value":break;case"children":break;default:Js(u,f,ne,null,A,M)}for(G in A)if(M=A[G],I=y[G],A.hasOwnProperty(G)&&(M!=null||I!=null))switch(G){case"value":je=M;break;case"defaultValue":Qe=M;break;case"children":break;case"dangerouslySetInnerHTML":if(M!=null)throw Error(s(91));break;default:M!==I&&Js(u,f,G,M,A,I)}Zi(u,je,Qe);return;case"option":for(var an in y)if(je=y[an],y.hasOwnProperty(an)&&je!=null&&!A.hasOwnProperty(an))switch(an){case"selected":u.selected=!1;break;default:Js(u,f,an,null,A,je)}for(Ae in A)if(je=A[Ae],Qe=y[Ae],A.hasOwnProperty(Ae)&&je!==Qe&&(je!=null||Qe!=null))switch(Ae){case"selected":u.selected=je&&typeof je!="function"&&typeof je!="symbol";break;default:Js(u,f,Ae,je,A,Qe)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Tn in y)je=y[Tn],y.hasOwnProperty(Tn)&&je!=null&&!A.hasOwnProperty(Tn)&&Js(u,f,Tn,null,A,je);for($e in A)if(je=A[$e],Qe=y[$e],A.hasOwnProperty($e)&&je!==Qe&&(je!=null||Qe!=null))switch($e){case"children":case"dangerouslySetInnerHTML":if(je!=null)throw Error(s(137,f));break;default:Js(u,f,$e,je,A,Qe)}return;default:if(xp(f)){for(var Zs in y)je=y[Zs],y.hasOwnProperty(Zs)&&je!==void 0&&!A.hasOwnProperty(Zs)&&fR(u,f,Zs,void 0,A,je);for(ot in A)je=A[ot],Qe=y[ot],!A.hasOwnProperty(ot)||je===Qe||je===void 0&&Qe===void 0||fR(u,f,ot,je,A,Qe);return}}for(var Be in y)je=y[Be],y.hasOwnProperty(Be)&&je!=null&&!A.hasOwnProperty(Be)&&Js(u,f,Be,null,A,je);for(xt in A)je=A[xt],Qe=y[xt],!A.hasOwnProperty(xt)||je===Qe||je==null&&Qe==null||Js(u,f,xt,je,A,Qe)}function aF(u){switch(u){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function u7(){if(typeof performance.getEntriesByType=="function"){for(var u=0,f=0,y=performance.getEntriesByType("resource"),A=0;A<y.length;A++){var M=y[A],I=M.transferSize,G=M.initiatorType,ne=M.duration;if(I&&ne&&aF(G)){for(G=0,ne=M.responseEnd,A+=1;A<y.length;A++){var Ae=y[A],$e=Ae.startTime;if($e>ne)break;var ot=Ae.transferSize,xt=Ae.initiatorType;ot&&aF(xt)&&(Ae=Ae.responseEnd,G+=ot*(Ae<ne?1:(ne-$e)/(Ae-$e)))}if(--A,f+=8*(I+G)/(M.duration/1e3),u++,10<u)break}}if(0<u)return f/u/1e6}return navigator.connection&&(u=navigator.connection.downlink,typeof u=="number")?u:5}var pR=null,mR=null;function Ow(u){return u.nodeType===9?u:u.ownerDocument}function rF(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function oF(u,f){if(u===0)switch(f){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&f==="foreignObject"?0:u}function gR(u,f){return u==="textarea"||u==="noscript"||typeof f.children=="string"||typeof f.children=="number"||typeof f.children=="bigint"||typeof f.dangerouslySetInnerHTML=="object"&&f.dangerouslySetInnerHTML!==null&&f.dangerouslySetInnerHTML.__html!=null}var xR=null;function h7(){var u=window.event;return u&&u.type==="popstate"?u===xR?!1:(xR=u,!0):(xR=null,!1)}var lF=typeof setTimeout=="function"?setTimeout:void 0,d7=typeof clearTimeout=="function"?clearTimeout:void 0,cF=typeof Promise=="function"?Promise:void 0,f7=typeof queueMicrotask=="function"?queueMicrotask:typeof cF<"u"?function(u){return cF.resolve(null).then(u).catch(p7)}:lF;function p7(u){setTimeout(function(){throw u})}function uf(u){return u==="head"}function uF(u,f){var y=f,A=0;do{var M=y.nextSibling;if(u.removeChild(y),M&&M.nodeType===8)if(y=M.data,y==="/$"||y==="/&"){if(A===0){u.removeChild(M),W0(f);return}A--}else if(y==="$"||y==="$?"||y==="$~"||y==="$!"||y==="&")A++;else if(y==="html")jb(u.ownerDocument.documentElement);else if(y==="head"){y=u.ownerDocument.head,jb(y);for(var I=y.firstChild;I;){var G=I.nextSibling,ne=I.nodeName;I[Mt]||ne==="SCRIPT"||ne==="STYLE"||ne==="LINK"&&I.rel.toLowerCase()==="stylesheet"||y.removeChild(I),I=G}}else y==="body"&&jb(u.ownerDocument.body);y=M}while(y);W0(f)}function hF(u,f){var y=u;u=0;do{var A=y.nextSibling;if(y.nodeType===1?f?(y._stashedDisplay=y.style.display,y.style.display="none"):(y.style.display=y._stashedDisplay||"",y.getAttribute("style")===""&&y.removeAttribute("style")):y.nodeType===3&&(f?(y._stashedText=y.nodeValue,y.nodeValue=""):y.nodeValue=y._stashedText||""),A&&A.nodeType===8)if(y=A.data,y==="/$"){if(u===0)break;u--}else y!=="$"&&y!=="$?"&&y!=="$~"&&y!=="$!"||u++;y=A}while(y)}function yR(u){var f=u.firstChild;for(f&&f.nodeType===10&&(f=f.nextSibling);f;){var y=f;switch(f=f.nextSibling,y.nodeName){case"HTML":case"HEAD":case"BODY":yR(y),wt(y);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(y.rel.toLowerCase()==="stylesheet")continue}u.removeChild(y)}}function m7(u,f,y,A){for(;u.nodeType===1;){var M=y;if(u.nodeName.toLowerCase()!==f.toLowerCase()){if(!A&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(A){if(!u[Mt])switch(f){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(I=u.getAttribute("rel"),I==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(I!==M.rel||u.getAttribute("href")!==(M.href==null||M.href===""?null:M.href)||u.getAttribute("crossorigin")!==(M.crossOrigin==null?null:M.crossOrigin)||u.getAttribute("title")!==(M.title==null?null:M.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(I=u.getAttribute("src"),(I!==(M.src==null?null:M.src)||u.getAttribute("type")!==(M.type==null?null:M.type)||u.getAttribute("crossorigin")!==(M.crossOrigin==null?null:M.crossOrigin))&&I&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(f==="input"&&u.type==="hidden"){var I=M.name==null?null:""+M.name;if(M.type==="hidden"&&u.getAttribute("name")===I)return u}else return u;if(u=Wl(u.nextSibling),u===null)break}return null}function g7(u,f,y){if(f==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!y||(u=Wl(u.nextSibling),u===null))return null;return u}function dF(u,f){for(;u.nodeType!==8;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!f||(u=Wl(u.nextSibling),u===null))return null;return u}function vR(u){return u.data==="$?"||u.data==="$~"}function bR(u){return u.data==="$!"||u.data==="$?"&&u.ownerDocument.readyState!=="loading"}function x7(u,f){var y=u.ownerDocument;if(u.data==="$~")u._reactRetry=f;else if(u.data!=="$?"||y.readyState!=="loading")f();else{var A=function(){f(),y.removeEventListener("DOMContentLoaded",A)};y.addEventListener("DOMContentLoaded",A),u._reactRetry=A}}function Wl(u){for(;u!=null;u=u.nextSibling){var f=u.nodeType;if(f===1||f===3)break;if(f===8){if(f=u.data,f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"||f==="F!"||f==="F")break;if(f==="/$"||f==="/&")return null}}return u}var SR=null;function fF(u){u=u.nextSibling;for(var f=0;u;){if(u.nodeType===8){var y=u.data;if(y==="/$"||y==="/&"){if(f===0)return Wl(u.nextSibling);f--}else y!=="$"&&y!=="$!"&&y!=="$?"&&y!=="$~"&&y!=="&"||f++}u=u.nextSibling}return null}function pF(u){u=u.previousSibling;for(var f=0;u;){if(u.nodeType===8){var y=u.data;if(y==="$"||y==="$!"||y==="$?"||y==="$~"||y==="&"){if(f===0)return u;f--}else y!=="/$"&&y!=="/&"||f++}u=u.previousSibling}return null}function mF(u,f,y){switch(f=Ow(y),u){case"html":if(u=f.documentElement,!u)throw Error(s(452));return u;case"head":if(u=f.head,!u)throw Error(s(453));return u;case"body":if(u=f.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}function jb(u){for(var f=u.attributes;f.length;)u.removeAttributeNode(f[0]);wt(u)}var jl=new Map,gF=new Set;function Bw(u){return typeof u.getRootNode=="function"?u.getRootNode():u.nodeType===9?u:u.ownerDocument}var Wh=W.d;W.d={f:y7,r:v7,D:b7,C:S7,L:_7,m:A7,X:C7,S:w7,M:T7};function y7(){var u=Wh.f(),f=ie();return u||f}function v7(u){var f=X(u);f!==null&&f.tag===5&&f.type==="form"?kb(f):Wh.r(u)}var G0=typeof document>"u"?null:document;function xF(u,f,y){var A=G0;if(A&&typeof f=="string"&&f){var M=mn(f);M='link[rel="'+u+'"][href="'+M+'"]',typeof y=="string"&&(M+='[crossorigin="'+y+'"]'),gF.has(M)||(gF.add(M),u={rel:u,crossOrigin:y,href:f},A.querySelector(M)===null&&(f=A.createElement("link"),pr(f,"link",u),De(f),A.head.appendChild(f)))}}function b7(u){Wh.D(u),xF("dns-prefetch",u,null)}function S7(u,f){Wh.C(u,f),xF("preconnect",u,f)}function _7(u,f,y){Wh.L(u,f,y);var A=G0;if(A&&u&&f){var M='link[rel="preload"][as="'+mn(f)+'"]';f==="image"&&y&&y.imageSrcSet?(M+='[imagesrcset="'+mn(y.imageSrcSet)+'"]',typeof y.imageSizes=="string"&&(M+='[imagesizes="'+mn(y.imageSizes)+'"]')):M+='[href="'+mn(u)+'"]';var I=M;switch(f){case"style":I=V0(u);break;case"script":I=H0(u)}jl.has(I)||(u=d({rel:"preload",href:f==="image"&&y&&y.imageSrcSet?void 0:u,as:f},y),jl.set(I,u),A.querySelector(M)!==null||f==="style"&&A.querySelector(Xb(I))||f==="script"&&A.querySelector(qb(I))||(f=A.createElement("link"),pr(f,"link",u),De(f),A.head.appendChild(f)))}}function A7(u,f){Wh.m(u,f);var y=G0;if(y&&u){var A=f&&typeof f.as=="string"?f.as:"script",M='link[rel="modulepreload"][as="'+mn(A)+'"][href="'+mn(u)+'"]',I=M;switch(A){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":I=H0(u)}if(!jl.has(I)&&(u=d({rel:"modulepreload",href:u},f),jl.set(I,u),y.querySelector(M)===null)){switch(A){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(y.querySelector(qb(I)))return}A=y.createElement("link"),pr(A,"link",u),De(A),y.head.appendChild(A)}}}function w7(u,f,y){Wh.S(u,f,y);var A=G0;if(A&&u){var M=Se(A).hoistableStyles,I=V0(u);f=f||"default";var G=M.get(I);if(!G){var ne={loading:0,preload:null};if(G=A.querySelector(Xb(I)))ne.loading=5;else{u=d({rel:"stylesheet",href:u,"data-precedence":f},y),(y=jl.get(I))&&_R(u,y);var Ae=G=A.createElement("link");De(Ae),pr(Ae,"link",u),Ae._p=new Promise(function($e,ot){Ae.onload=$e,Ae.onerror=ot}),Ae.addEventListener("load",function(){ne.loading|=1}),Ae.addEventListener("error",function(){ne.loading|=2}),ne.loading|=4,kw(G,f,A)}G={type:"stylesheet",instance:G,count:1,state:ne},M.set(I,G)}}}function C7(u,f){Wh.X(u,f);var y=G0;if(y&&u){var A=Se(y).hoistableScripts,M=H0(u),I=A.get(M);I||(I=y.querySelector(qb(M)),I||(u=d({src:u,async:!0},f),(f=jl.get(M))&&AR(u,f),I=y.createElement("script"),De(I),pr(I,"link",u),y.head.appendChild(I)),I={type:"script",instance:I,count:1,state:null},A.set(M,I))}}function T7(u,f){Wh.M(u,f);var y=G0;if(y&&u){var A=Se(y).hoistableScripts,M=H0(u),I=A.get(M);I||(I=y.querySelector(qb(M)),I||(u=d({src:u,async:!0,type:"module"},f),(f=jl.get(M))&&AR(u,f),I=y.createElement("script"),De(I),pr(I,"link",u),y.head.appendChild(I)),I={type:"script",instance:I,count:1,state:null},A.set(M,I))}}function yF(u,f,y,A){var M=(M=fe.current)?Bw(M):null;if(!M)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof y.precedence=="string"&&typeof y.href=="string"?(f=V0(y.href),y=Se(M).hoistableStyles,A=y.get(f),A||(A={type:"style",instance:null,count:0,state:null},y.set(f,A)),A):{type:"void",instance:null,count:0,state:null};case"link":if(y.rel==="stylesheet"&&typeof y.href=="string"&&typeof y.precedence=="string"){u=V0(y.href);var I=Se(M).hoistableStyles,G=I.get(u);if(G||(M=M.ownerDocument||M,G={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},I.set(u,G),(I=M.querySelector(Xb(u)))&&!I._p&&(G.instance=I,G.state.loading=5),jl.has(u)||(y={rel:"preload",as:"style",href:y.href,crossOrigin:y.crossOrigin,integrity:y.integrity,media:y.media,hrefLang:y.hrefLang,referrerPolicy:y.referrerPolicy},jl.set(u,y),I||E7(M,u,y,G.state))),f&&A===null)throw Error(s(528,""));return G}if(f&&A!==null)throw Error(s(529,""));return null;case"script":return f=y.async,y=y.src,typeof y=="string"&&f&&typeof f!="function"&&typeof f!="symbol"?(f=H0(y),y=Se(M).hoistableScripts,A=y.get(f),A||(A={type:"script",instance:null,count:0,state:null},y.set(f,A)),A):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function V0(u){return'href="'+mn(u)+'"'}function Xb(u){return'link[rel="stylesheet"]['+u+"]"}function vF(u){return d({},u,{"data-precedence":u.precedence,precedence:null})}function E7(u,f,y,A){u.querySelector('link[rel="preload"][as="style"]['+f+"]")?A.loading=1:(f=u.createElement("link"),A.preload=f,f.addEventListener("load",function(){return A.loading|=1}),f.addEventListener("error",function(){return A.loading|=2}),pr(f,"link",y),De(f),u.head.appendChild(f))}function H0(u){return'[src="'+mn(u)+'"]'}function qb(u){return"script[async]"+u}function bF(u,f,y){if(f.count++,f.instance===null)switch(f.type){case"style":var A=u.querySelector('style[data-href~="'+mn(y.href)+'"]');if(A)return f.instance=A,De(A),A;var M=d({},y,{"data-href":y.href,"data-precedence":y.precedence,href:null,precedence:null});return A=(u.ownerDocument||u).createElement("style"),De(A),pr(A,"style",M),kw(A,y.precedence,u),f.instance=A;case"stylesheet":M=V0(y.href);var I=u.querySelector(Xb(M));if(I)return f.state.loading|=4,f.instance=I,De(I),I;A=vF(y),(M=jl.get(M))&&_R(A,M),I=(u.ownerDocument||u).createElement("link"),De(I);var G=I;return G._p=new Promise(function(ne,Ae){G.onload=ne,G.onerror=Ae}),pr(I,"link",A),f.state.loading|=4,kw(I,y.precedence,u),f.instance=I;case"script":return I=H0(y.src),(M=u.querySelector(qb(I)))?(f.instance=M,De(M),M):(A=y,(M=jl.get(I))&&(A=d({},y),AR(A,M)),u=u.ownerDocument||u,M=u.createElement("script"),De(M),pr(M,"link",A),u.head.appendChild(M),f.instance=M);case"void":return null;default:throw Error(s(443,f.type))}else f.type==="stylesheet"&&(f.state.loading&4)===0&&(A=f.instance,f.state.loading|=4,kw(A,y.precedence,u));return f.instance}function kw(u,f,y){for(var A=y.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),M=A.length?A[A.length-1]:null,I=M,G=0;G<A.length;G++){var ne=A[G];if(ne.dataset.precedence===f)I=ne;else if(I!==M)break}I?I.parentNode.insertBefore(u,I.nextSibling):(f=y.nodeType===9?y.head:y,f.insertBefore(u,f.firstChild))}function _R(u,f){u.crossOrigin==null&&(u.crossOrigin=f.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=f.referrerPolicy),u.title==null&&(u.title=f.title)}function AR(u,f){u.crossOrigin==null&&(u.crossOrigin=f.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=f.referrerPolicy),u.integrity==null&&(u.integrity=f.integrity)}var Lw=null;function SF(u,f,y){if(Lw===null){var A=new Map,M=Lw=new Map;M.set(y,A)}else M=Lw,A=M.get(y),A||(A=new Map,M.set(y,A));if(A.has(u))return A;for(A.set(u,null),y=y.getElementsByTagName(u),M=0;M<y.length;M++){var I=y[M];if(!(I[Mt]||I[Un]||u==="link"&&I.getAttribute("rel")==="stylesheet")&&I.namespaceURI!=="http://www.w3.org/2000/svg"){var G=I.getAttribute(f)||"";G=u+G;var ne=A.get(G);ne?ne.push(I):A.set(G,[I])}}return A}function _F(u,f,y){u=u.ownerDocument||u,u.head.insertBefore(y,f==="title"?u.querySelector("head > title"):null)}function M7(u,f,y){if(y===1||f.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof f.precedence!="string"||typeof f.href!="string"||f.href==="")break;return!0;case"link":if(typeof f.rel!="string"||typeof f.href!="string"||f.href===""||f.onLoad||f.onError)break;switch(f.rel){case"stylesheet":return u=f.disabled,typeof f.precedence=="string"&&u==null;default:return!0}case"script":if(f.async&&typeof f.async!="function"&&typeof f.async!="symbol"&&!f.onLoad&&!f.onError&&f.src&&typeof f.src=="string")return!0}return!1}function AF(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}function N7(u,f,y,A){if(y.type==="stylesheet"&&(typeof A.media!="string"||matchMedia(A.media).matches!==!1)&&(y.state.loading&4)===0){if(y.instance===null){var M=V0(A.href),I=f.querySelector(Xb(M));if(I){f=I._p,f!==null&&typeof f=="object"&&typeof f.then=="function"&&(u.count++,u=Fw.bind(u),f.then(u,u)),y.state.loading|=4,y.instance=I,De(I);return}I=f.ownerDocument||f,A=vF(A),(M=jl.get(M))&&_R(A,M),I=I.createElement("link"),De(I);var G=I;G._p=new Promise(function(ne,Ae){G.onload=ne,G.onerror=Ae}),pr(I,"link",A),y.instance=I}u.stylesheets===null&&(u.stylesheets=new Map),u.stylesheets.set(y,f),(f=y.state.preload)&&(y.state.loading&3)===0&&(u.count++,y=Fw.bind(u),f.addEventListener("load",y),f.addEventListener("error",y))}}var wR=0;function R7(u,f){return u.stylesheets&&u.count===0&&Pw(u,u.stylesheets),0<u.count||0<u.imgCount?function(y){var A=setTimeout(function(){if(u.stylesheets&&Pw(u,u.stylesheets),u.unsuspend){var I=u.unsuspend;u.unsuspend=null,I()}},6e4+f);0<u.imgBytes&&wR===0&&(wR=62500*u7());var M=setTimeout(function(){if(u.waitingForImages=!1,u.count===0&&(u.stylesheets&&Pw(u,u.stylesheets),u.unsuspend)){var I=u.unsuspend;u.unsuspend=null,I()}},(u.imgBytes>wR?50:800)+f);return u.unsuspend=y,function(){u.unsuspend=null,clearTimeout(A),clearTimeout(M)}}:null}function Fw(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Pw(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var Uw=null;function Pw(u,f){u.stylesheets=null,u.unsuspend!==null&&(u.count++,Uw=new Map,f.forEach(I7,u),Uw=null,Fw.call(u))}function I7(u,f){if(!(f.state.loading&4)){var y=Uw.get(u);if(y)var A=y.get(null);else{y=new Map,Uw.set(u,y);for(var M=u.querySelectorAll("link[data-precedence],style[data-precedence]"),I=0;I<M.length;I++){var G=M[I];(G.nodeName==="LINK"||G.getAttribute("media")!=="not all")&&(y.set(G.dataset.precedence,G),A=G)}A&&y.set(null,A)}M=f.instance,G=M.getAttribute("data-precedence"),I=y.get(G)||A,I===A&&y.set(null,M),y.set(G,M),this.count++,A=Fw.bind(this),M.addEventListener("load",A),M.addEventListener("error",A),I?I.parentNode.insertBefore(M,I.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(M,u.firstChild)),f.state.loading|=4}}var Kb={$$typeof:T,Provider:null,Consumer:null,_currentValue:q,_currentValue2:q,_threadCount:0};function D7(u,f,y,A,M,I,G,ne,Ae){this.tag=1,this.containerInfo=u,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Fn(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Fn(0),this.hiddenUpdates=Fn(null),this.identifierPrefix=A,this.onUncaughtError=M,this.onCaughtError=I,this.onRecoverableError=G,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=Ae,this.incompleteTransitions=new Map}function wF(u,f,y,A,M,I,G,ne,Ae,$e,ot,xt){return u=new D7(u,f,y,G,Ae,$e,ot,xt,ne),f=1,I===!0&&(f|=24),I=lr(3,null,null,f),u.current=I,I.stateNode=u,f=sb(),f.refCount++,u.pooledCache=f,f.refCount++,I.memoizedState={element:A,isDehydrated:y,cache:f},cb(I),u}function CF(u){return u?(u=Au,u):Au}function TF(u,f,y,A,M,I){M=CF(M),A.context===null?A.context=M:A.pendingContext=M,A=Ll(f),A.payload={element:y},I=I===void 0?null:I,I!==null&&(A.callback=I),y=wc(u,A,f),y!==null&&(x(y,u,f),Iu(y,u,f))}function EF(u,f){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var y=u.retryLane;u.retryLane=y!==0&&y<f?y:f}}function CR(u,f){EF(u,f),(u=u.alternate)&&EF(u,f)}function MF(u){if(u.tag===13||u.tag===31){var f=_u(u,67108864);f!==null&&x(f,u,67108864),CR(u,67108864)}}function NF(u){if(u.tag===13||u.tag===31){var f=fr();f=zi(f);var y=_u(u,f);y!==null&&x(y,u,f),CR(u,f)}}var zw=!0;function O7(u,f,y,A){var M=P.T;P.T=null;var I=W.p;try{W.p=2,TR(u,f,y,A)}finally{W.p=I,P.T=M}}function B7(u,f,y,A){var M=P.T;P.T=null;var I=W.p;try{W.p=8,TR(u,f,y,A)}finally{W.p=I,P.T=M}}function TR(u,f,y,A){if(zw){var M=ER(A);if(M===null)dR(u,f,A,$w,y),IF(u,A);else if(L7(M,u,f,y,A))A.stopPropagation();else if(IF(u,A),f&4&&-1<k7.indexOf(u)){for(;M!==null;){var I=X(M);if(I!==null)switch(I.tag){case 3:if(I=I.stateNode,I.current.memoizedState.isDehydrated){var G=St(I.pendingLanes);if(G!==0){var ne=I;for(ne.pendingLanes|=2,ne.entangledLanes|=2;G;){var Ae=1<<31-xe(G);ne.entanglements[1]|=Ae,G&=~Ae}zu(I),(gs&6)===0&&(fo=J()+500,Vb(0))}}break;case 31:case 13:ne=_u(I,2),ne!==null&&x(ne,I,2),ie(),CR(I,2)}if(I=ER(A),I===null&&dR(u,f,A,$w,y),I===M)break;M=I}M!==null&&A.stopPropagation()}else dR(u,f,A,null,y)}}function ER(u){return u=$g(u),MR(u)}var $w=null;function MR(u){if($w=null,u=Ct(u),u!==null){var f=a(u);if(f===null)u=null;else{var y=f.tag;if(y===13){if(u=r(f),u!==null)return u;u=null}else if(y===31){if(u=o(f),u!==null)return u;u=null}else if(y===3){if(f.stateNode.current.memoizedState.isDehydrated)return f.tag===3?f.stateNode.containerInfo:null;u=null}else f!==u&&(u=null)}}return $w=u,null}function RF(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Ie()){case Ye:return 2;case lt:return 8;case Ve:case Gt:return 32;case Lt:return 268435456;default:return 32}default:return 32}}var NR=!1,hf=null,df=null,ff=null,Yb=new Map,Jb=new Map,pf=[],k7="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function IF(u,f){switch(u){case"focusin":case"focusout":hf=null;break;case"dragenter":case"dragleave":df=null;break;case"mouseover":case"mouseout":ff=null;break;case"pointerover":case"pointerout":Yb.delete(f.pointerId);break;case"gotpointercapture":case"lostpointercapture":Jb.delete(f.pointerId)}}function Zb(u,f,y,A,M,I){return u===null||u.nativeEvent!==I?(u={blockedOn:f,domEventName:y,eventSystemFlags:A,nativeEvent:I,targetContainers:[M]},f!==null&&(f=X(f),f!==null&&MF(f)),u):(u.eventSystemFlags|=A,f=u.targetContainers,M!==null&&f.indexOf(M)===-1&&f.push(M),u)}function L7(u,f,y,A,M){switch(f){case"focusin":return hf=Zb(hf,u,f,y,A,M),!0;case"dragenter":return df=Zb(df,u,f,y,A,M),!0;case"mouseover":return ff=Zb(ff,u,f,y,A,M),!0;case"pointerover":var I=M.pointerId;return Yb.set(I,Zb(Yb.get(I)||null,u,f,y,A,M)),!0;case"gotpointercapture":return I=M.pointerId,Jb.set(I,Zb(Jb.get(I)||null,u,f,y,A,M)),!0}return!1}function DF(u){var f=Ct(u.target);if(f!==null){var y=a(f);if(y!==null){if(f=y.tag,f===13){if(f=r(y),f!==null){u.blockedOn=f,Cn(u.priority,function(){NF(y)});return}}else if(f===31){if(f=o(y),f!==null){u.blockedOn=f,Cn(u.priority,function(){NF(y)});return}}else if(f===3&&y.stateNode.current.memoizedState.isDehydrated){u.blockedOn=y.tag===3?y.stateNode.containerInfo:null;return}}}u.blockedOn=null}function Gw(u){if(u.blockedOn!==null)return!1;for(var f=u.targetContainers;0<f.length;){var y=ER(u.nativeEvent);if(y===null){y=u.nativeEvent;var A=new y.constructor(y.type,y);vp=A,y.target.dispatchEvent(A),vp=null}else return f=X(y),f!==null&&MF(f),u.blockedOn=y,!1;f.shift()}return!0}function OF(u,f,y){Gw(u)&&y.delete(f)}function F7(){NR=!1,hf!==null&&Gw(hf)&&(hf=null),df!==null&&Gw(df)&&(df=null),ff!==null&&Gw(ff)&&(ff=null),Yb.forEach(OF),Jb.forEach(OF)}function Vw(u,f){u.blockedOn===f&&(u.blockedOn=null,NR||(NR=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,F7)))}var Hw=null;function BF(u){Hw!==u&&(Hw=u,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Hw===u&&(Hw=null);for(var f=0;f<u.length;f+=3){var y=u[f],A=u[f+1],M=u[f+2];if(typeof A!="function"){if(MR(A||y)===null)continue;break}var I=X(y);I!==null&&(u.splice(f,3),f-=3,Bb(I,{pending:!0,data:M,method:y.method,action:A},A,M))}}))}function W0(u){function f(Ae){return Vw(Ae,u)}hf!==null&&Vw(hf,u),df!==null&&Vw(df,u),ff!==null&&Vw(ff,u),Yb.forEach(f),Jb.forEach(f);for(var y=0;y<pf.length;y++){var A=pf[y];A.blockedOn===u&&(A.blockedOn=null)}for(;0<pf.length&&(y=pf[0],y.blockedOn===null);)DF(y),y.blockedOn===null&&pf.shift();if(y=(u.ownerDocument||u).$$reactFormReplay,y!=null)for(A=0;A<y.length;A+=3){var M=y[A],I=y[A+1],G=M[j]||null;if(typeof I=="function")G||BF(y);else if(G){var ne=null;if(I&&I.hasAttribute("formAction")){if(M=I,G=I[j]||null)ne=G.formAction;else if(MR(M)!==null)continue}else ne=G.action;typeof ne=="function"?y[A+1]=ne:(y.splice(A,3),A-=3),BF(y)}}}function kF(){function u(I){I.canIntercept&&I.info==="react-transition"&&I.intercept({handler:function(){return new Promise(function(G){return M=G})},focusReset:"manual",scroll:"manual"})}function f(){M!==null&&(M(),M=null),A||setTimeout(y,20)}function y(){if(!A&&!navigation.transition){var I=navigation.currentEntry;I&&I.url!=null&&navigation.navigate(I.url,{state:I.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var A=!1,M=null;return navigation.addEventListener("navigate",u),navigation.addEventListener("navigatesuccess",f),navigation.addEventListener("navigateerror",f),setTimeout(y,100),function(){A=!0,navigation.removeEventListener("navigate",u),navigation.removeEventListener("navigatesuccess",f),navigation.removeEventListener("navigateerror",f),M!==null&&(M(),M=null)}}}function RR(u){this._internalRoot=u}Ww.prototype.render=RR.prototype.render=function(u){var f=this._internalRoot;if(f===null)throw Error(s(409));var y=f.current,A=fr();TF(y,A,u,f,null,null)},Ww.prototype.unmount=RR.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var f=u.containerInfo;TF(u.current,2,null,u,null,null),ie(),f[ae]=null}};function Ww(u){this._internalRoot=u}Ww.prototype.unstable_scheduleHydration=function(u){if(u){var f=ca();u={blockedOn:null,target:u,priority:f};for(var y=0;y<pf.length&&f!==0&&f<pf[y].priority;y++);pf.splice(y,0,u),y===0&&DF(u)}};var LF=e.version;if(LF!=="19.2.0")throw Error(s(527,LF,"19.2.0"));W.findDOMNode=function(u){var f=u._reactInternals;if(f===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=c(f),u=u!==null?h(u):null,u=u===null?null:u.stateNode,u};var U7={bundleType:0,version:"19.2.0",rendererPackageName:"react-dom",currentDispatcherRef:P,reconcilerVersion:"19.2.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var jw=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!jw.isDisabled&&jw.supportsFiber)try{at=jw.inject(U7),ut=jw}catch{}}return e1.createRoot=function(u,f){if(!i(u))throw Error(s(299));var y=!1,A="",M=Ub,I=ww,G=M0;return f!=null&&(f.unstable_strictMode===!0&&(y=!0),f.identifierPrefix!==void 0&&(A=f.identifierPrefix),f.onUncaughtError!==void 0&&(M=f.onUncaughtError),f.onCaughtError!==void 0&&(I=f.onCaughtError),f.onRecoverableError!==void 0&&(G=f.onRecoverableError)),f=wF(u,1,!1,null,null,y,A,null,M,I,G,kF),u[ae]=f.current,hR(u),new RR(f)},e1.hydrateRoot=function(u,f,y){if(!i(u))throw Error(s(299));var A=!1,M="",I=Ub,G=ww,ne=M0,Ae=null;return y!=null&&(y.unstable_strictMode===!0&&(A=!0),y.identifierPrefix!==void 0&&(M=y.identifierPrefix),y.onUncaughtError!==void 0&&(I=y.onUncaughtError),y.onCaughtError!==void 0&&(G=y.onCaughtError),y.onRecoverableError!==void 0&&(ne=y.onRecoverableError),y.formState!==void 0&&(Ae=y.formState)),f=wF(u,1,!0,f,y??null,A,M,Ae,I,G,ne,kF),f.context=CF(null),y=f.current,A=fr(),A=zi(A),M=Ll(A),M.callback=null,wc(y,M,A),y=A,f.current.lanes=y,ei(f,y),zu(f),u[ae]=f.current,hR(u),new Ww(f)},e1.version="19.2.0",e1}var jF;function Y7(){if(jF)return OR.exports;jF=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),OR.exports=K7(),OR.exports}var J7=Y7();var XF="popstate";function Z7(n={}){function e(s,i){let{pathname:a,search:r,hash:o}=s.location;return S3("",{pathname:a,search:r,hash:o},i.state&&i.state.usr||null,i.state&&i.state.key||"default")}function t(s,i){return typeof i=="string"?i:V1(i)}return eX(e,t,null,n)}function Pi(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function Zc(n,e){if(!n){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function Q7(){return Math.random().toString(36).substring(2,10)}function qF(n,e){return{usr:n.state,key:n.key,idx:e}}function S3(n,e,t=null,s){return{pathname:typeof n=="string"?n:n.pathname,search:"",hash:"",...typeof e=="string"?ry(e):e,state:t,key:e&&e.key||s||Q7()}}function V1({pathname:n="/",search:e="",hash:t=""}){return e&&e!=="?"&&(n+=e.charAt(0)==="?"?e:"?"+e),t&&t!=="#"&&(n+=t.charAt(0)==="#"?t:"#"+t),n}function ry(n){let e={};if(n){let t=n.indexOf("#");t>=0&&(e.hash=n.substring(t),n=n.substring(0,t));let s=n.indexOf("?");s>=0&&(e.search=n.substring(s),n=n.substring(0,s)),n&&(e.pathname=n)}return e}function eX(n,e,t,s={}){let{window:i=document.defaultView,v5Compat:a=!1}=s,r=i.history,o="POP",l=null,c=h();c==null&&(c=0,r.replaceState({...r.state,idx:c},""));function h(){return(r.state||{idx:null}).idx}function d(){o="POP";let S=h(),b=S==null?null:S-c;c=S,l&&l({action:o,location:_.location,delta:b})}function p(S,b){o="PUSH";let w=S3(_.location,S,b);c=h()+1;let T=qF(w,c),E=_.createHref(w);try{r.pushState(T,"",E)}catch(R){if(R instanceof DOMException&&R.name==="DataCloneError")throw R;i.location.assign(E)}a&&l&&l({action:o,location:_.location,delta:1})}function g(S,b){o="REPLACE";let w=S3(_.location,S,b);c=h();let T=qF(w,c),E=_.createHref(w);r.replaceState(T,"",E),a&&l&&l({action:o,location:_.location,delta:0})}function v(S){return tX(S)}let _={get action(){return o},get location(){return n(i,r)},listen(S){if(l)throw new Error("A history only accepts one active listener");return i.addEventListener(XF,d),l=S,()=>{i.removeEventListener(XF,d),l=null}},createHref(S){return e(i,S)},createURL:v,encodeLocation(S){let b=v(S);return{pathname:b.pathname,search:b.search,hash:b.hash}},push:p,replace:g,go(S){return r.go(S)}};return _}function tX(n,e=!1){let t="http://localhost";typeof window<"u"&&(t=window.location.origin!=="null"?window.location.origin:window.location.href),Pi(t,"No window.location.(origin|href) available to create URL");let s=typeof n=="string"?n:V1(n);return s=s.replace(/ $/,"%20"),!e&&s.startsWith("//")&&(s=t+s),new URL(s,t)}function Z$(n,e,t="/"){return nX(n,e,t,!1)}function nX(n,e,t,s){let i=typeof e=="string"?ry(e):e,a=fd(i.pathname||"/",t);if(a==null)return null;let r=Q$(n);sX(r);let o=null;for(let l=0;o==null&&l<r.length;++l){let c=pX(a);o=dX(r[l],c,s)}return o}function Q$(n,e=[],t=[],s="",i=!1){let a=(r,o,l=i,c)=>{let h={relativePath:c===void 0?r.path||"":c,caseSensitive:r.caseSensitive===!0,childrenIndex:o,route:r};if(h.relativePath.startsWith("/")){if(!h.relativePath.startsWith(s)&&l)return;Pi(h.relativePath.startsWith(s),`Absolute route path "${h.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),h.relativePath=h.relativePath.slice(s.length)}let d=cd([s,h.relativePath]),p=t.concat(h);r.children&&r.children.length>0&&(Pi(r.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${d}".`),Q$(r.children,e,p,d,l)),!(r.path==null&&!r.index)&&e.push({path:d,score:uX(d,r.index),routesMeta:p})};return n.forEach((r,o)=>{if(r.path===""||!r.path?.includes("?"))a(r,o);else for(let l of e4(r.path))a(r,o,!0,l)}),e}function e4(n){let e=n.split("/");if(e.length===0)return[];let[t,...s]=e,i=t.endsWith("?"),a=t.replace(/\?$/,"");if(s.length===0)return i?[a,""]:[a];let r=e4(s.join("/")),o=[];return o.push(...r.map(l=>l===""?a:[a,l].join("/"))),i&&o.push(...r),o.map(l=>n.startsWith("/")&&l===""?"/":l)}function sX(n){n.sort((e,t)=>e.score!==t.score?t.score-e.score:hX(e.routesMeta.map(s=>s.childrenIndex),t.routesMeta.map(s=>s.childrenIndex)))}var iX=/^:[\w-]+$/,aX=3,rX=2,oX=1,lX=10,cX=-2,KF=n=>n==="*";function uX(n,e){let t=n.split("/"),s=t.length;return t.some(KF)&&(s+=cX),e&&(s+=rX),t.filter(i=>!KF(i)).reduce((i,a)=>i+(iX.test(a)?aX:a===""?oX:lX),s)}function hX(n,e){return n.length===e.length&&n.slice(0,-1).every((s,i)=>s===e[i])?n[n.length-1]-e[e.length-1]:0}function dX(n,e,t=!1){let{routesMeta:s}=n,i={},a="/",r=[];for(let o=0;o<s.length;++o){let l=s[o],c=o===s.length-1,h=a==="/"?e:e.slice(a.length)||"/",d=wT({path:l.relativePath,caseSensitive:l.caseSensitive,end:c},h),p=l.route;if(!d&&c&&t&&!s[s.length-1].route.index&&(d=wT({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},h)),!d)return null;Object.assign(i,d.params),r.push({params:i,pathname:cd([a,d.pathname]),pathnameBase:vX(cd([a,d.pathnameBase])),route:p}),d.pathnameBase!=="/"&&(a=cd([a,d.pathnameBase]))}return r}function wT(n,e){typeof n=="string"&&(n={path:n,caseSensitive:!1,end:!0});let[t,s]=fX(n.path,n.caseSensitive,n.end),i=e.match(t);if(!i)return null;let a=i[0],r=a.replace(/(.)\/+$/,"$1"),o=i.slice(1);return{params:s.reduce((c,{paramName:h,isOptional:d},p)=>{if(h==="*"){let v=o[p]||"";r=a.slice(0,a.length-v.length).replace(/(.)\/+$/,"$1")}const g=o[p];return d&&!g?c[h]=void 0:c[h]=(g||"").replace(/%2F/g,"/"),c},{}),pathname:a,pathnameBase:r,pattern:n}}function fX(n,e=!1,t=!0){Zc(n==="*"||!n.endsWith("*")||n.endsWith("/*"),`Route path "${n}" will be treated as if it were "${n.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/,"/*")}".`);let s=[],i="^"+n.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(r,o,l)=>(s.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return n.endsWith("*")?(s.push({paramName:"*"}),i+=n==="*"||n==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?i+="\\/*$":n!==""&&n!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,e?void 0:"i"),s]}function pX(n){try{return n.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return Zc(!1,`The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),n}}function fd(n,e){if(e==="/")return n;if(!n.toLowerCase().startsWith(e.toLowerCase()))return null;let t=e.endsWith("/")?e.length-1:e.length,s=n.charAt(t);return s&&s!=="/"?null:n.slice(t)||"/"}var mX=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,gX=n=>mX.test(n);function xX(n,e="/"){let{pathname:t,search:s="",hash:i=""}=typeof n=="string"?ry(n):n,a;if(t)if(gX(t))a=t;else{if(t.includes("//")){let r=t;t=t.replace(/\/\/+/g,"/"),Zc(!1,`Pathnames cannot have embedded double slashes - normalizing ${r} -> ${t}`)}t.startsWith("/")?a=YF(t.substring(1),"/"):a=YF(t,e)}else a=e;return{pathname:a,search:bX(s),hash:SX(i)}}function YF(n,e){let t=e.replace(/\/+$/,"").split("/");return n.split("/").forEach(i=>{i===".."?t.length>1&&t.pop():i!=="."&&t.push(i)}),t.length>1?t.join("/"):"/"}function FR(n,e,t,s){return`Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function yX(n){return n.filter((e,t)=>t===0||e.route.path&&e.route.path.length>0)}function t4(n){let e=yX(n);return e.map((t,s)=>s===e.length-1?t.pathname:t.pathnameBase)}function n4(n,e,t,s=!1){let i;typeof n=="string"?i=ry(n):(i={...n},Pi(!i.pathname||!i.pathname.includes("?"),FR("?","pathname","search",i)),Pi(!i.pathname||!i.pathname.includes("#"),FR("#","pathname","hash",i)),Pi(!i.search||!i.search.includes("#"),FR("#","search","hash",i)));let a=n===""||i.pathname==="",r=a?"/":i.pathname,o;if(r==null)o=t;else{let d=e.length-1;if(!s&&r.startsWith("..")){let p=r.split("/");for(;p[0]==="..";)p.shift(),d-=1;i.pathname=p.join("/")}o=d>=0?e[d]:"/"}let l=xX(i,o),c=r&&r!=="/"&&r.endsWith("/"),h=(a||r===".")&&t.endsWith("/");return!l.pathname.endsWith("/")&&(c||h)&&(l.pathname+="/"),l}var cd=n=>n.join("/").replace(/\/\/+/g,"/"),vX=n=>n.replace(/\/+$/,"").replace(/^\/*/,"/"),bX=n=>!n||n==="?"?"":n.startsWith("?")?n:"?"+n,SX=n=>!n||n==="#"?"":n.startsWith("#")?n:"#"+n;function _X(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.internal=="boolean"&&"data"in n}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var s4=["POST","PUT","PATCH","DELETE"];new Set(s4);var AX=["GET",...s4];new Set(AX);var oy=pe.createContext(null);oy.displayName="DataRouter";var YE=pe.createContext(null);YE.displayName="DataRouterState";pe.createContext(!1);var i4=pe.createContext({isTransitioning:!1});i4.displayName="ViewTransition";var wX=pe.createContext(new Map);wX.displayName="Fetchers";var CX=pe.createContext(null);CX.displayName="Await";var fh=pe.createContext(null);fh.displayName="Navigation";var _S=pe.createContext(null);_S.displayName="Location";var Sd=pe.createContext({outlet:null,matches:[],isDataRoute:!1});Sd.displayName="Route";var HD=pe.createContext(null);HD.displayName="RouteError";function TX(n,{relative:e}={}){Pi(AS(),"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:s}=pe.useContext(fh),{hash:i,pathname:a,search:r}=wS(n,{relative:e}),o=a;return t!=="/"&&(o=a==="/"?t:cd([t,a])),s.createHref({pathname:o,search:r,hash:i})}function AS(){return pe.useContext(_S)!=null}function ep(){return Pi(AS(),"useLocation() may be used only in the context of a <Router> component."),pe.useContext(_S).location}var a4="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function r4(n){pe.useContext(fh).static||pe.useLayoutEffect(n)}function ly(){let{isDataRoute:n}=pe.useContext(Sd);return n?PX():EX()}function EX(){Pi(AS(),"useNavigate() may be used only in the context of a <Router> component.");let n=pe.useContext(oy),{basename:e,navigator:t}=pe.useContext(fh),{matches:s}=pe.useContext(Sd),{pathname:i}=ep(),a=JSON.stringify(t4(s)),r=pe.useRef(!1);return r4(()=>{r.current=!0}),pe.useCallback((l,c={})=>{if(Zc(r.current,a4),!r.current)return;if(typeof l=="number"){t.go(l);return}let h=n4(l,JSON.parse(a),i,c.relative==="path");n==null&&e!=="/"&&(h.pathname=h.pathname==="/"?e:cd([e,h.pathname])),(c.replace?t.replace:t.push)(h,c.state,c)},[e,t,a,i,n])}pe.createContext(null);function wS(n,{relative:e}={}){let{matches:t}=pe.useContext(Sd),{pathname:s}=ep(),i=JSON.stringify(t4(t));return pe.useMemo(()=>n4(n,JSON.parse(i),s,e==="path"),[n,i,s,e])}function MX(n,e){return o4(n,e)}function o4(n,e,t,s,i){Pi(AS(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:a}=pe.useContext(fh),{matches:r}=pe.useContext(Sd),o=r[r.length-1],l=o?o.params:{},c=o?o.pathname:"/",h=o?o.pathnameBase:"/",d=o&&o.route;{let w=d&&d.path||"";l4(c,!d||w.endsWith("*")||w.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${w}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${w}"> to <Route path="${w==="/"?"*":`${w}/*`}">.`)}let p=ep(),g;if(e){let w=typeof e=="string"?ry(e):e;Pi(h==="/"||w.pathname?.startsWith(h),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${h}" but pathname "${w.pathname}" was given in the \`location\` prop.`),g=w}else g=p;let v=g.pathname||"/",_=v;if(h!=="/"){let w=h.replace(/^\//,"").split("/");_="/"+v.replace(/^\//,"").split("/").slice(w.length).join("/")}let S=Z$(n,{pathname:_});Zc(d||S!=null,`No routes matched location "${g.pathname}${g.search}${g.hash}" `),Zc(S==null||S[S.length-1].route.element!==void 0||S[S.length-1].route.Component!==void 0||S[S.length-1].route.lazy!==void 0,`Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let b=OX(S&&S.map(w=>Object.assign({},w,{params:Object.assign({},l,w.params),pathname:cd([h,a.encodeLocation?a.encodeLocation(w.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:w.pathname]),pathnameBase:w.pathnameBase==="/"?h:cd([h,a.encodeLocation?a.encodeLocation(w.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:w.pathnameBase])})),r,t,s,i);return e&&b?pe.createElement(_S.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...g},navigationType:"POP"}},b):b}function NX(){let n=UX(),e=_X(n)?`${n.status} ${n.statusText}`:n instanceof Error?n.message:JSON.stringify(n),t=n instanceof Error?n.stack:null,s="rgba(200,200,200, 0.5)",i={padding:"0.5rem",backgroundColor:s},a={padding:"2px 4px",backgroundColor:s},r=null;return console.error("Error handled by React Router default ErrorBoundary:",n),r=pe.createElement(pe.Fragment,null,pe.createElement("p",null," Hey developer "),pe.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",pe.createElement("code",{style:a},"ErrorBoundary")," or"," ",pe.createElement("code",{style:a},"errorElement")," prop on your route.")),pe.createElement(pe.Fragment,null,pe.createElement("h2",null,"Unexpected Application Error!"),pe.createElement("h3",{style:{fontStyle:"italic"}},e),t?pe.createElement("pre",{style:i},t):null,r)}var RX=pe.createElement(NX,null),IX=class extends pe.Component{constructor(n){super(n),this.state={location:n.location,revalidation:n.revalidation,error:n.error}}static getDerivedStateFromError(n){return{error:n}}static getDerivedStateFromProps(n,e){return e.location!==n.location||e.revalidation!=="idle"&&n.revalidation==="idle"?{error:n.error,location:n.location,revalidation:n.revalidation}:{error:n.error!==void 0?n.error:e.error,location:e.location,revalidation:n.revalidation||e.revalidation}}componentDidCatch(n,e){this.props.onError?this.props.onError(n,e):console.error("React Router caught the following error during render",n)}render(){return this.state.error!==void 0?pe.createElement(Sd.Provider,{value:this.props.routeContext},pe.createElement(HD.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function DX({routeContext:n,match:e,children:t}){let s=pe.useContext(oy);return s&&s.static&&s.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=e.route.id),pe.createElement(Sd.Provider,{value:n},t)}function OX(n,e=[],t=null,s=null,i=null){if(n==null){if(!t)return null;if(t.errors)n=t.matches;else if(e.length===0&&!t.initialized&&t.matches.length>0)n=t.matches;else return null}let a=n,r=t?.errors;if(r!=null){let h=a.findIndex(d=>d.route.id&&r?.[d.route.id]!==void 0);Pi(h>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(r).join(",")}`),a=a.slice(0,Math.min(a.length,h+1))}let o=!1,l=-1;if(t)for(let h=0;h<a.length;h++){let d=a[h];if((d.route.HydrateFallback||d.route.hydrateFallbackElement)&&(l=h),d.route.id){let{loaderData:p,errors:g}=t,v=d.route.loader&&!p.hasOwnProperty(d.route.id)&&(!g||g[d.route.id]===void 0);if(d.route.lazy||v){o=!0,l>=0?a=a.slice(0,l+1):a=[a[0]];break}}}let c=t&&s?(h,d)=>{s(h,{location:t.location,params:t.matches?.[0]?.params??{},errorInfo:d})}:void 0;return a.reduceRight((h,d,p)=>{let g,v=!1,_=null,S=null;t&&(g=r&&d.route.id?r[d.route.id]:void 0,_=d.route.errorElement||RX,o&&(l<0&&p===0?(l4("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),v=!0,S=null):l===p&&(v=!0,S=d.route.hydrateFallbackElement||null)));let b=e.concat(a.slice(0,p+1)),w=()=>{let T;return g?T=_:v?T=S:d.route.Component?T=pe.createElement(d.route.Component,null):d.route.element?T=d.route.element:T=h,pe.createElement(DX,{match:d,routeContext:{outlet:h,matches:b,isDataRoute:t!=null},children:T})};return t&&(d.route.ErrorBoundary||d.route.errorElement||p===0)?pe.createElement(IX,{location:t.location,revalidation:t.revalidation,component:_,error:g,children:w(),routeContext:{outlet:null,matches:b,isDataRoute:!0},onError:c}):w()},null)}function WD(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function BX(n){let e=pe.useContext(oy);return Pi(e,WD(n)),e}function kX(n){let e=pe.useContext(YE);return Pi(e,WD(n)),e}function LX(n){let e=pe.useContext(Sd);return Pi(e,WD(n)),e}function jD(n){let e=LX(n),t=e.matches[e.matches.length-1];return Pi(t.route.id,`${n} can only be used on routes that contain a unique "id"`),t.route.id}function FX(){return jD("useRouteId")}function UX(){let n=pe.useContext(HD),e=kX("useRouteError"),t=jD("useRouteError");return n!==void 0?n:e.errors?.[t]}function PX(){let{router:n}=BX("useNavigate"),e=jD("useNavigate"),t=pe.useRef(!1);return r4(()=>{t.current=!0}),pe.useCallback(async(i,a={})=>{Zc(t.current,a4),t.current&&(typeof i=="number"?n.navigate(i):await n.navigate(i,{fromRouteId:e,...a}))},[n,e])}var JF={};function l4(n,e,t){!e&&!JF[n]&&(JF[n]=!0,Zc(!1,t))}pe.memo(zX);function zX({routes:n,future:e,state:t,unstable_onError:s}){return o4(n,void 0,t,s,e)}function go(n){Pi(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function $X({basename:n="/",children:e=null,location:t,navigationType:s="POP",navigator:i,static:a=!1}){Pi(!AS(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let r=n.replace(/^\/*/,"/"),o=pe.useMemo(()=>({basename:r,navigator:i,static:a,future:{}}),[r,i,a]);typeof t=="string"&&(t=ry(t));let{pathname:l="/",search:c="",hash:h="",state:d=null,key:p="default"}=t,g=pe.useMemo(()=>{let v=fd(l,r);return v==null?null:{location:{pathname:v,search:c,hash:h,state:d,key:p},navigationType:s}},[r,l,c,h,d,p,s]);return Zc(g!=null,`<Router basename="${r}"> is not able to match the URL "${l}${c}${h}" because it does not start with the basename, so the <Router> won't render anything.`),g==null?null:pe.createElement(fh.Provider,{value:o},pe.createElement(_S.Provider,{children:e,value:g}))}function GX({children:n,location:e}){return MX(_3(n),e)}function _3(n,e=[]){let t=[];return pe.Children.forEach(n,(s,i)=>{if(!pe.isValidElement(s))return;let a=[...e,i];if(s.type===pe.Fragment){t.push.apply(t,_3(s.props.children,a));return}Pi(s.type===go,`[${typeof s.type=="string"?s.type:s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),Pi(!s.props.index||!s.props.children,"An index route cannot have child routes.");let r={id:s.props.id||a.join("-"),caseSensitive:s.props.caseSensitive,element:s.props.element,Component:s.props.Component,index:s.props.index,path:s.props.path,middleware:s.props.middleware,loader:s.props.loader,action:s.props.action,hydrateFallbackElement:s.props.hydrateFallbackElement,HydrateFallback:s.props.HydrateFallback,errorElement:s.props.errorElement,ErrorBoundary:s.props.ErrorBoundary,hasErrorBoundary:s.props.hasErrorBoundary===!0||s.props.ErrorBoundary!=null||s.props.errorElement!=null,shouldRevalidate:s.props.shouldRevalidate,handle:s.props.handle,lazy:s.props.lazy};s.props.children&&(r.children=_3(s.props.children,a)),t.push(r)}),t}var rT="get",oT="application/x-www-form-urlencoded";function JE(n){return n!=null&&typeof n.tagName=="string"}function VX(n){return JE(n)&&n.tagName.toLowerCase()==="button"}function HX(n){return JE(n)&&n.tagName.toLowerCase()==="form"}function WX(n){return JE(n)&&n.tagName.toLowerCase()==="input"}function jX(n){return!!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)}function XX(n,e){return n.button===0&&(!e||e==="_self")&&!jX(n)}var Xw=null;function qX(){if(Xw===null)try{new FormData(document.createElement("form"),0),Xw=!1}catch{Xw=!0}return Xw}var KX=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function UR(n){return n!=null&&!KX.has(n)?(Zc(!1,`"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${oT}"`),null):n}function YX(n,e){let t,s,i,a,r;if(HX(n)){let o=n.getAttribute("action");s=o?fd(o,e):null,t=n.getAttribute("method")||rT,i=UR(n.getAttribute("enctype"))||oT,a=new FormData(n)}else if(VX(n)||WX(n)&&(n.type==="submit"||n.type==="image")){let o=n.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let l=n.getAttribute("formaction")||o.getAttribute("action");if(s=l?fd(l,e):null,t=n.getAttribute("formmethod")||o.getAttribute("method")||rT,i=UR(n.getAttribute("formenctype"))||UR(o.getAttribute("enctype"))||oT,a=new FormData(o,n),!qX()){let{name:c,type:h,value:d}=n;if(h==="image"){let p=c?`${c}.`:"";a.append(`${p}x`,"0"),a.append(`${p}y`,"0")}else c&&a.append(c,d)}}else{if(JE(n))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');t=rT,s=null,i=oT,r=n}return a&&i==="text/plain"&&(r=a,a=void 0),{action:s,method:t.toLowerCase(),encType:i,formData:a,body:r}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function XD(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function JX(n,e,t){let s=typeof n=="string"?new URL(n,typeof window>"u"?"server://singlefetch/":window.location.origin):n;return s.pathname==="/"?s.pathname=`_root.${t}`:e&&fd(s.pathname,e)==="/"?s.pathname=`${e.replace(/\/$/,"")}/_root.${t}`:s.pathname=`${s.pathname.replace(/\/$/,"")}.${t}`,s}async function ZX(n,e){if(n.id in e)return e[n.id];try{let t=await import(n.module);return e[n.id]=t,t}catch(t){return console.error(`Error loading route module \`${n.module}\`, reloading page...`),console.error(t),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function QX(n){return n==null?!1:n.href==null?n.rel==="preload"&&typeof n.imageSrcSet=="string"&&typeof n.imageSizes=="string":typeof n.rel=="string"&&typeof n.href=="string"}async function eq(n,e,t){let s=await Promise.all(n.map(async i=>{let a=e.routes[i.route.id];if(a){let r=await ZX(a,t);return r.links?r.links():[]}return[]}));return iq(s.flat(1).filter(QX).filter(i=>i.rel==="stylesheet"||i.rel==="preload").map(i=>i.rel==="stylesheet"?{...i,rel:"prefetch",as:"style"}:{...i,rel:"prefetch"}))}function ZF(n,e,t,s,i,a){let r=(l,c)=>t[c]?l.route.id!==t[c].route.id:!0,o=(l,c)=>t[c].pathname!==l.pathname||t[c].route.path?.endsWith("*")&&t[c].params["*"]!==l.params["*"];return a==="assets"?e.filter((l,c)=>r(l,c)||o(l,c)):a==="data"?e.filter((l,c)=>{let h=s.routes[l.route.id];if(!h||!h.hasLoader)return!1;if(r(l,c)||o(l,c))return!0;if(l.route.shouldRevalidate){let d=l.route.shouldRevalidate({currentUrl:new URL(i.pathname+i.search+i.hash,window.origin),currentParams:t[0]?.params||{},nextUrl:new URL(n,window.origin),nextParams:l.params,defaultShouldRevalidate:!0});if(typeof d=="boolean")return d}return!0}):[]}function tq(n,e,{includeHydrateFallback:t}={}){return nq(n.map(s=>{let i=e.routes[s.route.id];if(!i)return[];let a=[i.module];return i.clientActionModule&&(a=a.concat(i.clientActionModule)),i.clientLoaderModule&&(a=a.concat(i.clientLoaderModule)),t&&i.hydrateFallbackModule&&(a=a.concat(i.hydrateFallbackModule)),i.imports&&(a=a.concat(i.imports)),a}).flat(1))}function nq(n){return[...new Set(n)]}function sq(n){let e={},t=Object.keys(n).sort();for(let s of t)e[s]=n[s];return e}function iq(n,e){let t=new Set;return new Set(e),n.reduce((s,i)=>{let a=JSON.stringify(sq(i));return t.has(a)||(t.add(a),s.push({key:a,link:i})),s},[])}function c4(){let n=pe.useContext(oy);return XD(n,"You must render this element inside a <DataRouterContext.Provider> element"),n}function aq(){let n=pe.useContext(YE);return XD(n,"You must render this element inside a <DataRouterStateContext.Provider> element"),n}var qD=pe.createContext(void 0);qD.displayName="FrameworkContext";function u4(){let n=pe.useContext(qD);return XD(n,"You must render this element inside a <HydratedRouter> element"),n}function rq(n,e){let t=pe.useContext(qD),[s,i]=pe.useState(!1),[a,r]=pe.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:c,onMouseLeave:h,onTouchStart:d}=e,p=pe.useRef(null);pe.useEffect(()=>{if(n==="render"&&r(!0),n==="viewport"){let _=b=>{b.forEach(w=>{r(w.isIntersecting)})},S=new IntersectionObserver(_,{threshold:.5});return p.current&&S.observe(p.current),()=>{S.disconnect()}}},[n]),pe.useEffect(()=>{if(s){let _=setTimeout(()=>{r(!0)},100);return()=>{clearTimeout(_)}}},[s]);let g=()=>{i(!0)},v=()=>{i(!1),r(!1)};return t?n!=="intent"?[a,p,{}]:[a,p,{onFocus:t1(o,g),onBlur:t1(l,v),onMouseEnter:t1(c,g),onMouseLeave:t1(h,v),onTouchStart:t1(d,g)}]:[!1,p,{}]}function t1(n,e){return t=>{n&&n(t),t.defaultPrevented||e(t)}}function oq({page:n,...e}){let{router:t}=c4(),s=pe.useMemo(()=>Z$(t.routes,n,t.basename),[t.routes,n,t.basename]);return s?pe.createElement(cq,{page:n,matches:s,...e}):null}function lq(n){let{manifest:e,routeModules:t}=u4(),[s,i]=pe.useState([]);return pe.useEffect(()=>{let a=!1;return eq(n,e,t).then(r=>{a||i(r)}),()=>{a=!0}},[n,e,t]),s}function cq({page:n,matches:e,...t}){let s=ep(),{manifest:i,routeModules:a}=u4(),{basename:r}=c4(),{loaderData:o,matches:l}=aq(),c=pe.useMemo(()=>ZF(n,e,l,i,s,"data"),[n,e,l,i,s]),h=pe.useMemo(()=>ZF(n,e,l,i,s,"assets"),[n,e,l,i,s]),d=pe.useMemo(()=>{if(n===s.pathname+s.search+s.hash)return[];let v=new Set,_=!1;if(e.forEach(b=>{let w=i.routes[b.route.id];!w||!w.hasLoader||(!c.some(T=>T.route.id===b.route.id)&&b.route.id in o&&a[b.route.id]?.shouldRevalidate||w.hasClientLoader?_=!0:v.add(b.route.id))}),v.size===0)return[];let S=JX(n,r,"data");return _&&v.size>0&&S.searchParams.set("_routes",e.filter(b=>v.has(b.route.id)).map(b=>b.route.id).join(",")),[S.pathname+S.search]},[r,o,s,i,c,e,n,a]),p=pe.useMemo(()=>tq(h,i),[h,i]),g=lq(h);return pe.createElement(pe.Fragment,null,d.map(v=>pe.createElement("link",{key:v,rel:"prefetch",as:"fetch",href:v,...t})),p.map(v=>pe.createElement("link",{key:v,rel:"modulepreload",href:v,...t})),g.map(({key:v,link:_})=>pe.createElement("link",{key:v,nonce:t.nonce,..._})))}function uq(...n){return e=>{n.forEach(t=>{typeof t=="function"?t(e):t!=null&&(t.current=e)})}}var h4=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{h4&&(window.__reactRouterVersion="7.9.6")}catch{}function hq({basename:n,children:e,window:t}){let s=pe.useRef();s.current==null&&(s.current=Z7({window:t,v5Compat:!0}));let i=s.current,[a,r]=pe.useState({action:i.action,location:i.location}),o=pe.useCallback(l=>{pe.startTransition(()=>r(l))},[r]);return pe.useLayoutEffect(()=>i.listen(o),[i,o]),pe.createElement($X,{basename:n,children:e,location:a.location,navigationType:a.action,navigator:i})}var d4=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,So=pe.forwardRef(function({onClick:e,discover:t="render",prefetch:s="none",relative:i,reloadDocument:a,replace:r,state:o,target:l,to:c,preventScrollReset:h,viewTransition:d,...p},g){let{basename:v}=pe.useContext(fh),_=typeof c=="string"&&d4.test(c),S,b=!1;if(typeof c=="string"&&_&&(S=c,h4))try{let O=new URL(window.location.href),B=c.startsWith("//")?new URL(O.protocol+c):new URL(c),L=fd(B.pathname,v);B.origin===O.origin&&L!=null?c=L+B.search+B.hash:b=!0}catch{Zc(!1,`<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let w=TX(c,{relative:i}),[T,E,R]=rq(s,p),D=mq(c,{replace:r,state:o,target:l,preventScrollReset:h,relative:i,viewTransition:d});function F(O){e&&e(O),O.defaultPrevented||D(O)}let U=pe.createElement("a",{...p,...R,href:S||w,onClick:b||a?e:F,ref:uq(g,E),target:l,"data-discover":!_&&t==="render"?"true":void 0});return T&&!_?pe.createElement(pe.Fragment,null,U,pe.createElement(oq,{page:w})):U});So.displayName="Link";var dq=pe.forwardRef(function({"aria-current":e="page",caseSensitive:t=!1,className:s="",end:i=!1,style:a,to:r,viewTransition:o,children:l,...c},h){let d=wS(r,{relative:c.relative}),p=ep(),g=pe.useContext(YE),{navigator:v,basename:_}=pe.useContext(fh),S=g!=null&&bq(d)&&o===!0,b=v.encodeLocation?v.encodeLocation(d).pathname:d.pathname,w=p.pathname,T=g&&g.navigation&&g.navigation.location?g.navigation.location.pathname:null;t||(w=w.toLowerCase(),T=T?T.toLowerCase():null,b=b.toLowerCase()),T&&_&&(T=fd(T,_)||T);const E=b!=="/"&&b.endsWith("/")?b.length-1:b.length;let R=w===b||!i&&w.startsWith(b)&&w.charAt(E)==="/",D=T!=null&&(T===b||!i&&T.startsWith(b)&&T.charAt(b.length)==="/"),F={isActive:R,isPending:D,isTransitioning:S},U=R?e:void 0,O;typeof s=="function"?O=s(F):O=[s,R?"active":null,D?"pending":null,S?"transitioning":null].filter(Boolean).join(" ");let B=typeof a=="function"?a(F):a;return pe.createElement(So,{...c,"aria-current":U,className:O,ref:h,style:B,to:r,viewTransition:o},typeof l=="function"?l(F):l)});dq.displayName="NavLink";var fq=pe.forwardRef(({discover:n="render",fetcherKey:e,navigate:t,reloadDocument:s,replace:i,state:a,method:r=rT,action:o,onSubmit:l,relative:c,preventScrollReset:h,viewTransition:d,...p},g)=>{let v=yq(),_=vq(o,{relative:c}),S=r.toLowerCase()==="get"?"get":"post",b=typeof o=="string"&&d4.test(o),w=T=>{if(l&&l(T),T.defaultPrevented)return;T.preventDefault();let E=T.nativeEvent.submitter,R=E?.getAttribute("formmethod")||r;v(E||T.currentTarget,{fetcherKey:e,method:R,navigate:t,replace:i,state:a,relative:c,preventScrollReset:h,viewTransition:d})};return pe.createElement("form",{ref:g,method:S,action:_,onSubmit:s?l:w,...p,"data-discover":!b&&n==="render"?"true":void 0})});fq.displayName="Form";function pq(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function f4(n){let e=pe.useContext(oy);return Pi(e,pq(n)),e}function mq(n,{target:e,replace:t,state:s,preventScrollReset:i,relative:a,viewTransition:r}={}){let o=ly(),l=ep(),c=wS(n,{relative:a});return pe.useCallback(h=>{if(XX(h,e)){h.preventDefault();let d=t!==void 0?t:V1(l)===V1(c);o(n,{replace:d,state:s,preventScrollReset:i,relative:a,viewTransition:r})}},[l,o,c,t,s,e,n,i,a,r])}var gq=0,xq=()=>`__${String(++gq)}__`;function yq(){let{router:n}=f4("useSubmit"),{basename:e}=pe.useContext(fh),t=FX();return pe.useCallback(async(s,i={})=>{let{action:a,method:r,encType:o,formData:l,body:c}=YX(s,e);if(i.navigate===!1){let h=i.fetcherKey||xq();await n.fetch(h,t,i.action||a,{preventScrollReset:i.preventScrollReset,formData:l,body:c,formMethod:i.method||r,formEncType:i.encType||o,flushSync:i.flushSync})}else await n.navigate(i.action||a,{preventScrollReset:i.preventScrollReset,formData:l,body:c,formMethod:i.method||r,formEncType:i.encType||o,replace:i.replace,state:i.state,fromRouteId:t,flushSync:i.flushSync,viewTransition:i.viewTransition})},[n,e,t])}function vq(n,{relative:e}={}){let{basename:t}=pe.useContext(fh),s=pe.useContext(Sd);Pi(s,"useFormAction must be used inside a RouteContext");let[i]=s.matches.slice(-1),a={...wS(n||".",{relative:e})},r=ep();if(n==null){a.search=r.search;let o=new URLSearchParams(a.search),l=o.getAll("index");if(l.some(h=>h==="")){o.delete("index"),l.filter(d=>d).forEach(d=>o.append("index",d));let h=o.toString();a.search=h?`?${h}`:""}}return(!n||n===".")&&i.route.index&&(a.search=a.search?a.search.replace(/^\?/,"?index&"):"?index"),t!=="/"&&(a.pathname=a.pathname==="/"?t:cd([t,a.pathname])),V1(a)}function bq(n,{relative:e}={}){let t=pe.useContext(i4);Pi(t!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:s}=f4("useViewTransitionState"),i=wS(n,{relative:e});if(!t.isTransitioning)return!1;let a=fd(t.currentLocation.pathname,s)||t.currentLocation.pathname,r=fd(t.nextLocation.pathname,s)||t.nextLocation.pathname;return wT(i.pathname,r)!=null||wT(i.pathname,a)!=null}function Sq(){return V.jsxs("section",{className:"hero-section",children:[V.jsx("div",{className:"particles"}),V.jsx("div",{className:"circuit-overlay"}),V.jsx("div",{className:"robot-silhouette"}),V.jsx("h1",{className:"hero-title rgb-gradient neon-border",children:"Robotics Developer & Python Engineer"}),V.jsx("p",{className:"hero-subtitle fade-in-delayed",children:"I build robots that see, talk, and move. Specializing in Python, Linux, Arduino, and computer vision."}),V.jsx(So,{to:"/control-hub",className:"hero-button neon-hover",children:"Enter Control Hub"})]})}const _q=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),Aq=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,s)=>s?s.toUpperCase():t.toLowerCase()),QF=n=>{const e=Aq(n);return e.charAt(0).toUpperCase()+e.slice(1)},p4=(...n)=>n.filter((e,t,s)=>!!e&&e.trim()!==""&&s.indexOf(e)===t).join(" ").trim(),wq=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var Cq={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const Tq=pe.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:t=2,absoluteStrokeWidth:s,className:i="",children:a,iconNode:r,...o},l)=>pe.createElement("svg",{ref:l,...Cq,width:e,height:e,stroke:n,strokeWidth:s?Number(t)*24/Number(e):t,className:p4("lucide",i),...!a&&!wq(o)&&{"aria-hidden":"true"},...o},[...r.map(([c,h])=>pe.createElement(c,h)),...Array.isArray(a)?a:[a]]));const cy=(n,e)=>{const t=pe.forwardRef(({className:s,...i},a)=>pe.createElement(Tq,{ref:a,iconNode:e,className:p4(`lucide-${_q(QF(n))}`,`lucide-${n}`,s),...i}));return t.displayName=QF(n),t};const Eq=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],Mq=cy("cpu",Eq);const Nq=[["path",{d:"M12 19v3",key:"npa21l"}],["path",{d:"M19 10v2a7 7 0 0 1-14 0v-2",key:"1vc78b"}],["rect",{x:"9",y:"2",width:"6",height:"13",rx:"3",key:"s6n7sd"}]],m4=cy("mic",Nq);const Rq=[["rect",{x:"16",y:"16",width:"6",height:"6",rx:"1",key:"4q2zg0"}],["rect",{x:"2",y:"16",width:"6",height:"6",rx:"1",key:"8cvhb9"}],["rect",{x:"9",y:"2",width:"6",height:"6",rx:"1",key:"1egb70"}],["path",{d:"M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3",key:"1jsf9p"}],["path",{d:"M12 12V8",key:"2874zd"}]],Iq=cy("network",Rq);const Dq=[["path",{d:"M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",key:"1ffxy3"}],["path",{d:"m21.854 2.147-10.94 10.939",key:"12cjpa"}]],Oq=cy("send",Dq);const Bq=[["path",{d:"M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",key:"uqj9uw"}],["path",{d:"M16 9a5 5 0 0 1 0 6",key:"1q6k2b"}],["path",{d:"M19.364 18.364a9 9 0 0 0 0-12.728",key:"ijwkga"}]],kq=cy("volume-2",Bq);const Lq=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],Fq=cy("zap",Lq);function Uq(){const n=[{name:"Movement Module",icon:V.jsx(Mq,{size:28}),path:"/movement-module"},{name:"Voice Module",icon:V.jsx(m4,{size:28}),path:"/voice-module"},{name:"Power System",icon:V.jsx(Fq,{size:28}),path:"/power-module"},{name:"Network System",icon:V.jsx(Iq,{size:28}),path:"/network-module"}];return V.jsxs("section",{className:"dashboard-section neon-border",children:[V.jsx("h2",{className:"section-title rgb-gradient",children:"Robot Control Dashboard"}),V.jsx("div",{className:"modules-grid",children:n.map(e=>V.jsxs(So,{to:e.path,className:"module-card",children:[V.jsx("div",{className:"module-icon",children:e.icon}),V.jsx("h3",{children:e.name})]},e.name))})]})}function Pq(){const n=[{name:"InMoov Humanoid Robot",github:"https://github.com/Robotech83/Offline-Voice-Assistant"},{name:"Face Recognition System",github:"https://github.com/yourusername/face-recognition"},{name:"Arduino Servo Controller",github:"https://github.com/yourusername/arduino-servo"},{name:"React Robot Dashboard",github:"https://github.com/yourusername/react-robot-dashboard"},{name:"Voice Assistant",github:"https://github.com/Robotech83/Sonny-Voice"}];return V.jsxs("section",{className:"projects-section",id:"projects",children:[V.jsx("h2",{className:"section-title",children:"Projects"}),V.jsx("div",{className:"projects-grid",children:n.map(e=>V.jsx("a",{href:e.github,target:"_blank",rel:"noopener noreferrer",className:"project-card neon-border",children:V.jsx("h3",{children:e.name})},e.name))})]})}function zq(){const n=[{name:"Python",link:"https://github.com/yourusername/python-projects"},{name:"Linux",link:"https://github.com/yourusername/linux-scripts"},{name:"Bash",link:"https://github.com/yourusername/bash-scripts"},{name:"JavaScript",link:"https://github.com/yourusername/js-projects"},{name:"Arduino",link:"https://github.com/yourusername/arduino-projects"},{name:"React",link:"https://github.com/yourusername/react-projects"},{name:"Robotics",link:"https://github.com/yourusername/robotics"},{name:"Machine Vision",link:"https://github.com/yourusername/machine-vision"}];return V.jsxs("section",{className:"skills-section",id:"skills",children:[V.jsx("h2",{className:"section-title",children:"Skills"}),V.jsx("div",{className:"skills-groups",children:n.map(e=>V.jsx("a",{href:e.link,target:"_blank",rel:"noopener noreferrer",className:"skill-chip",children:e.name},e.name))})]})}function $q(){const n=[{title:"",details:"Diagrams for Arduino Mega  PCA9685 wiring."},{title:"Pi  Arduino Comm",details:"Serial communication setup between Raspberry Pi and Arduino."},{title:"Face Recognition Pipeline",details:"How camera input is processed and analyzed for detection."},{title:"Power Distribution",details:"Battery setup, voltage regulation, and distribution notes."}],[e,t]=pe.useState(null);return V.jsxs("section",{className:"lab-section",id:"lab",children:[V.jsx("h2",{className:"section-title",children:"Robotics Lab Notebook"}),V.jsx("div",{className:"notes-grid",children:n.map((s,i)=>V.jsxs("div",{className:`note-card ${e===i?"expanded":""}`,onClick:()=>t(e===i?null:i),children:[V.jsx("h3",{children:s.title}),e===i&&V.jsx("p",{children:s.details})]},s.title))})]})}function Gq(){return V.jsxs("section",{className:"contact-section",id:"contact",children:[V.jsx("h2",{className:"section-title",children:"Contact Terminal"}),V.jsxs("div",{className:"terminal-box",children:[V.jsx("p",{children:"> connect --email"}),V.jsx("input",{className:"terminal-input",placeholder:"Type your message..."})]})]})}function Vq(){return V.jsxs(So,{to:"/about",className:"floating-about-btn",children:[V.jsx("span",{className:"label",children:"About Me"}),V.jsx("span",{className:"ring"})]})}function Hq(){const{pathname:n}=ep();return pe.useEffect(()=>{window.scrollTo(0,0)},[n]),null}function KD({target:n="/",label:e="Home",variant:t="default",floating:s=!1,className:i=""}){const a=ly(),r=`back-button ${t} ${s?"floating":""} ${i}`.trim();return V.jsx("button",{onClick:()=>a(n),className:r,children:e})}function Wq(){return V.jsxs("div",{className:"control-hub-container",children:[V.jsx("h1",{className:"control-hub-title",children:"Control Hub"}),V.jsx("p",{className:"control-hub-subtitle",children:"Select a module to begin"}),V.jsx(KD,{}),V.jsxs("div",{className:"control-hub-grid",children:[V.jsxs(So,{to:"/robotstudio",className:"control-hub-card",children:[V.jsx("h2",{className:"control-hub-card-title",children:"Virtual Robot Studio"}),V.jsx("p",{className:"control-hub-card-text",children:"3D Viewer + Movement Controls"})]}),V.jsxs(So,{to:"/object-scanner",className:"control-hub-card",children:[V.jsx("h2",{className:"control-hub-card-title",children:"Object Detection Studio"}),V.jsx("p",{className:"control-hub-card-text",children:"Real-time Object Scanner"})]}),V.jsxs(So,{to:"/sensors",className:"control-hub-card",children:[V.jsx("h2",{className:"control-hub-card-title",children:"Sensor Monitor"}),V.jsx("p",{className:"control-hub-card-text",children:"Real-time robot telemetry"})]}),V.jsxs(So,{to:"/AIAssistant",className:"control-hub-card",children:[V.jsx("h2",{className:"control-hub-card-title",children:"AI Assistant"}),V.jsx("p",{className:"control-hub-card-text",children:"Voice and text-based AI assistant"})]})]})]})}function jq(){return V.jsxs("div",{className:"about-page",children:[V.jsx(KD,{}),V.jsx("h1",{className:"about-title",children:"About Me"}),V.jsx("div",{className:"holo-profile",children:V.jsxs("div",{className:"holo-frame",children:[V.jsx("img",{src:"/profile.jpg",alt:"Profile",className:"holo-img"}),V.jsx("div",{className:"scanlines"})]})}),V.jsxs("div",{className:"about-content",children:[V.jsx("p",{children:"Hi, I'm Keneshia  a self-taught robotics builder, programmer, and creative engineer. I specialize in mixing hardware, embedded systems, and expressive movement to bring humanoid robotics into the real world."}),V.jsx("p",{children:"My biggest ongoing project is Sonny, a full InMoov humanoid robot built from scratch using Raspberry Pi, multiple Arduinos, PCA9685 servo controllers, and a completely offline voice + motion system."}),V.jsx("p",{children:"I learn by building  solving real engineering problems, wiring real circuits, and breaking things (then fixing them again)."}),V.jsxs("p",{className:"mission",children:["My mission: ",V.jsx("strong",{children:"create robotics that feel alive."})]})]}),V.jsxs("div",{className:"stats-panel",children:[V.jsx("div",{className:"stat-chip",children:"5+ Robotics Systems Built"}),V.jsx("div",{className:"stat-chip",children:"3D Printing & CAD"}),V.jsx("div",{className:"stat-chip",children:"Servo Motion Engineering"}),V.jsx("div",{className:"stat-chip",children:"Raspberry Pi & Arduino"}),V.jsx("div",{className:"stat-chip",children:"Offline AI & Vision"})]}),V.jsxs("div",{className:"timeline",children:[V.jsx("h2",{className:"timeline-title",children:"Robotics Journey"}),V.jsx("div",{className:"timeline-item left",children:"Started robotics exploration"}),V.jsx("div",{className:"timeline-item right",children:"First Arduino servo project"}),V.jsx("div",{className:"timeline-item left",children:"Face tracking + Pi  Arduino control"}),V.jsx("div",{className:"timeline-item right",children:"InMoov humanoid build begins"}),V.jsx("div",{className:"timeline-item left",children:"Offline voice assistant + vision system"}),V.jsx("div",{className:"timeline-item right",children:"Robot Control Hub development"})]})]})}var PR={exports:{}},jh={};var eU;function Xq(){return eU||(eU=1,jh.ConcurrentRoot=1,jh.ContinuousEventPriority=8,jh.DefaultEventPriority=32,jh.DiscreteEventPriority=2,jh.IdleEventPriority=268435456,jh.LegacyRoot=0,jh.NoEventPriority=0),jh}var tU;function qq(){return tU||(tU=1,PR.exports=Xq()),PR.exports}var lT=qq();const uy="181",Cm={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Tm={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},g4=0,A3=1,x4=2,Kq=3,y4=0,ZE=1,D1=2,Gc=3,ih=0,Ao=1,Ql=2,ic=0,Wm=1,w3=2,C3=3,T3=4,v4=5,Tf=100,b4=101,S4=102,_4=103,A4=104,w4=200,C4=201,T4=202,E4=203,CT=204,TT=205,M4=206,N4=207,R4=208,I4=209,D4=210,O4=211,B4=212,k4=213,L4=214,ET=0,MT=1,NT=2,Qm=3,RT=4,IT=5,DT=6,OT=7,CS=0,F4=1,U4=2,Ju=0,P4=1,z4=2,$4=3,YD=4,G4=5,V4=6,H4=7,E3="attached",W4="detached",Ff=300,ah=301,Uf=302,Rx=303,H1=304,hy=306,Pf=1e3,Fi=1001,Ix=1002,Ja=1003,QE=1004,Yq=1004,Lm=1005,Jq=1005,is=1006,Sx=1007,Zq=1007,tc=1008,M3=1008,Co=1009,e2=1010,t2=1011,eg=1012,TS=1013,rh=1014,wi=1015,Wi=1016,n2=1017,s2=1018,Dx=1020,JD=35902,ZD=35899,QD=1021,eO=1022,ra=1023,tg=1026,Ox=1027,ES=1028,MS=1029,i2=1030,a2=1031,Qq=1032,r2=1033,O1=33776,B1=33777,k1=33778,L1=33779,BT=35840,kT=35841,LT=35842,FT=35843,UT=36196,PT=37492,zT=37496,$T=37808,GT=37809,VT=37810,HT=37811,WT=37812,jT=37813,XT=37814,qT=37815,KT=37816,YT=37817,JT=37818,ZT=37819,QT=37820,eE=37821,tE=36492,nE=36494,sE=36495,iE=36283,aE=36284,rE=36285,oE=36286,j4=2200,X4=2201,q4=2202,Bx=2300,kx=2301,cT=2302,Fm=2400,Um=2401,W1=2402,o2=2500,tO=2501,K4=0,nO=1,lE=2,Y4=3200,J4=3201,eK=3202,tK=3203,tp=0,Z4=1,id="",mr="srgb",Qc="srgb-linear",j1="linear",js="srgb",nK=0,Em=7680,sK=7681,iK=7682,aK=7683,rK=34055,oK=34056,lK=5386,cK=512,uK=513,hK=514,dK=515,fK=516,pK=517,mK=518,N3=519,Q4=512,eG=513,tG=514,sO=515,nG=516,sG=517,iG=518,aG=519,X1=35044,gK=35048,xK=35040,yK=35045,vK=35049,bK=35041,SK=35046,_K=35050,AK=35042,wK="100",R3="300 es",yl=2e3,Lx=2001,CK={COMPUTE:"compute",RENDER:"render"},TK={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},EK={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};function rG(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const MK={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function bx(n,e){return new MK[n](e)}function q1(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function oG(){const n=q1("canvas");return n.style.display="block",n}const nU={};let zf=null;function NK(n){zf=n}function RK(){return zf}function K1(...n){const e="THREE."+n.shift();zf?zf("log",e,...n):console.log(e,...n)}function Wt(...n){const e="THREE."+n.shift();zf?zf("warn",e,...n):console.warn(e,...n)}function On(...n){const e="THREE."+n.shift();zf?zf("error",e,...n):console.error(e,...n)}function Fx(...n){const e=n.join(" ");e in nU||(nU[e]=!0,Wt(...n))}function IK(n,e,t){return new Promise(function(s,i){function a(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:i();break;case n.TIMEOUT_EXPIRED:setTimeout(a,t);break;default:s()}}setTimeout(a,t)})}let ph=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){const s=this._listeners;return s===void 0?!1:s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){const s=this._listeners;if(s===void 0)return;const i=s[e];if(i!==void 0){const a=i.indexOf(t);a!==-1&&i.splice(a,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const s=t[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let a=0,r=i.length;a<r;a++)i[a].call(this,e);e.target=null}}};const Lr=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let sU=1234567;const jm=Math.PI/180,Ux=180/Math.PI;function Sl(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(Lr[n&255]+Lr[n>>8&255]+Lr[n>>16&255]+Lr[n>>24&255]+"-"+Lr[e&255]+Lr[e>>8&255]+"-"+Lr[e>>16&15|64]+Lr[e>>24&255]+"-"+Lr[t&63|128]+Lr[t>>8&255]+"-"+Lr[t>>16&255]+Lr[t>>24&255]+Lr[s&255]+Lr[s>>8&255]+Lr[s>>16&255]+Lr[s>>24&255]).toLowerCase()}function Rn(n,e,t){return Math.max(e,Math.min(t,n))}function iO(n,e){return(n%e+e)%e}function DK(n,e,t,s,i){return s+(n-e)*(i-s)/(t-e)}function OK(n,e,t){return n!==e?(t-n)/(e-n):0}function F1(n,e,t){return(1-t)*n+t*e}function BK(n,e,t,s){return F1(n,e,1-Math.exp(-t*s))}function kK(n,e=1){return e-Math.abs(iO(n,e*2)-e)}function LK(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function FK(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function UK(n,e){return n+Math.floor(Math.random()*(e-n+1))}function PK(n,e){return n+Math.random()*(e-n)}function zK(n){return n*(.5-Math.random())}function $K(n){n!==void 0&&(sU=n);let e=sU+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function GK(n){return n*jm}function VK(n){return n*Ux}function HK(n){return(n&n-1)===0&&n!==0}function WK(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function jK(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function XK(n,e,t,s,i){const a=Math.cos,r=Math.sin,o=a(t/2),l=r(t/2),c=a((e+s)/2),h=r((e+s)/2),d=a((e-s)/2),p=r((e-s)/2),g=a((s-e)/2),v=r((s-e)/2);switch(i){case"XYX":n.set(o*h,l*d,l*p,o*c);break;case"YZY":n.set(l*p,o*h,l*d,o*c);break;case"ZXZ":n.set(l*d,l*p,o*h,o*c);break;case"XZX":n.set(o*h,l*v,l*g,o*c);break;case"YXY":n.set(l*g,o*h,l*v,o*c);break;case"ZYZ":n.set(l*v,l*g,o*h,o*c);break;default:Wt("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function bo(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Xn(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const lG={DEG2RAD:jm,RAD2DEG:Ux,generateUUID:Sl,clamp:Rn,euclideanModulo:iO,mapLinear:DK,inverseLerp:OK,lerp:F1,damp:BK,pingpong:kK,smoothstep:LK,smootherstep:FK,randInt:UK,randFloat:PK,randFloatSpread:zK,seededRandom:$K,degToRad:GK,radToDeg:VK,isPowerOfTwo:HK,ceilPowerOfTwo:WK,floorPowerOfTwo:jK,setQuaternionFromProperEuler:XK,normalize:Xn,denormalize:bo};class rt{constructor(e=0,t=0){rt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6],this.y=i[1]*t+i[4]*s+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Rn(this.x,e.x,t.x),this.y=Rn(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=Rn(this.x,e,t),this.y=Rn(this.y,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Rn(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Rn(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),i=Math.sin(t),a=this.x-e.x,r=this.y-e.y;return this.x=a*s-r*i+e.x,this.y=a*i+r*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Za{constructor(e=0,t=0,s=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=i}static slerpFlat(e,t,s,i,a,r,o){let l=s[i+0],c=s[i+1],h=s[i+2],d=s[i+3],p=a[r+0],g=a[r+1],v=a[r+2],_=a[r+3];if(o<=0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d;return}if(o>=1){e[t+0]=p,e[t+1]=g,e[t+2]=v,e[t+3]=_;return}if(d!==_||l!==p||c!==g||h!==v){let S=l*p+c*g+h*v+d*_;S<0&&(p=-p,g=-g,v=-v,_=-_,S=-S);let b=1-o;if(S<.9995){const w=Math.acos(S),T=Math.sin(w);b=Math.sin(b*w)/T,o=Math.sin(o*w)/T,l=l*b+p*o,c=c*b+g*o,h=h*b+v*o,d=d*b+_*o}else{l=l*b+p*o,c=c*b+g*o,h=h*b+v*o,d=d*b+_*o;const w=1/Math.sqrt(l*l+c*c+h*h+d*d);l*=w,c*=w,h*=w,d*=w}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d}static multiplyQuaternionsFlat(e,t,s,i,a,r){const o=s[i],l=s[i+1],c=s[i+2],h=s[i+3],d=a[r],p=a[r+1],g=a[r+2],v=a[r+3];return e[t]=o*v+h*d+l*g-c*p,e[t+1]=l*v+h*p+c*d-o*g,e[t+2]=c*v+h*g+o*p-l*d,e[t+3]=h*v-o*d-l*p-c*g,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,i){return this._x=e,this._y=t,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const s=e._x,i=e._y,a=e._z,r=e._order,o=Math.cos,l=Math.sin,c=o(s/2),h=o(i/2),d=o(a/2),p=l(s/2),g=l(i/2),v=l(a/2);switch(r){case"XYZ":this._x=p*h*d+c*g*v,this._y=c*g*d-p*h*v,this._z=c*h*v+p*g*d,this._w=c*h*d-p*g*v;break;case"YXZ":this._x=p*h*d+c*g*v,this._y=c*g*d-p*h*v,this._z=c*h*v-p*g*d,this._w=c*h*d+p*g*v;break;case"ZXY":this._x=p*h*d-c*g*v,this._y=c*g*d+p*h*v,this._z=c*h*v+p*g*d,this._w=c*h*d-p*g*v;break;case"ZYX":this._x=p*h*d-c*g*v,this._y=c*g*d+p*h*v,this._z=c*h*v-p*g*d,this._w=c*h*d+p*g*v;break;case"YZX":this._x=p*h*d+c*g*v,this._y=c*g*d+p*h*v,this._z=c*h*v-p*g*d,this._w=c*h*d-p*g*v;break;case"XZY":this._x=p*h*d-c*g*v,this._y=c*g*d-p*h*v,this._z=c*h*v+p*g*d,this._w=c*h*d+p*g*v;break;default:Wt("Quaternion: .setFromEuler() encountered an unknown order: "+r)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,i=Math.sin(s);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],a=t[8],r=t[1],o=t[5],l=t[9],c=t[2],h=t[6],d=t[10],p=s+o+d;if(p>0){const g=.5/Math.sqrt(p+1);this._w=.25/g,this._x=(h-l)*g,this._y=(a-c)*g,this._z=(r-i)*g}else if(s>o&&s>d){const g=2*Math.sqrt(1+s-o-d);this._w=(h-l)/g,this._x=.25*g,this._y=(i+r)/g,this._z=(a+c)/g}else if(o>d){const g=2*Math.sqrt(1+o-s-d);this._w=(a-c)/g,this._x=(i+r)/g,this._y=.25*g,this._z=(l+h)/g}else{const g=2*Math.sqrt(1+d-s-o);this._w=(r-i)/g,this._x=(a+c)/g,this._y=(l+h)/g,this._z=.25*g}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<1e-8?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Rn(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const i=Math.min(1,t/s);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,i=e._y,a=e._z,r=e._w,o=t._x,l=t._y,c=t._z,h=t._w;return this._x=s*h+r*o+i*c-a*l,this._y=i*h+r*l+a*o-s*c,this._z=a*h+r*c+s*l-i*o,this._w=r*h-s*o-i*l-a*c,this._onChangeCallback(),this}slerp(e,t){if(t<=0)return this;if(t>=1)return this.copy(e);let s=e._x,i=e._y,a=e._z,r=e._w,o=this.dot(e);o<0&&(s=-s,i=-i,a=-a,r=-r,o=-o);let l=1-t;if(o<.9995){const c=Math.acos(o),h=Math.sin(c);l=Math.sin(l*c)/h,t=Math.sin(t*c)/h,this._x=this._x*l+s*t,this._y=this._y*l+i*t,this._z=this._z*l+a*t,this._w=this._w*l+r*t,this._onChangeCallback()}else this._x=this._x*l+s*t,this._y=this._y*l+i*t,this._z=this._z*l+a*t,this._w=this._w*l+r*t,this.normalize();return this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),s=Math.random(),i=Math.sqrt(1-s),a=Math.sqrt(s);return this.set(i*Math.sin(e),i*Math.cos(e),a*Math.sin(t),a*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ue{constructor(e=0,t=0,s=0){ue.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(iU.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(iU.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,i=this.z,a=e.elements;return this.x=a[0]*t+a[3]*s+a[6]*i,this.y=a[1]*t+a[4]*s+a[7]*i,this.z=a[2]*t+a[5]*s+a[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,a=e.elements,r=1/(a[3]*t+a[7]*s+a[11]*i+a[15]);return this.x=(a[0]*t+a[4]*s+a[8]*i+a[12])*r,this.y=(a[1]*t+a[5]*s+a[9]*i+a[13])*r,this.z=(a[2]*t+a[6]*s+a[10]*i+a[14])*r,this}applyQuaternion(e){const t=this.x,s=this.y,i=this.z,a=e.x,r=e.y,o=e.z,l=e.w,c=2*(r*i-o*s),h=2*(o*t-a*i),d=2*(a*s-r*t);return this.x=t+l*c+r*d-o*h,this.y=s+l*h+o*c-a*d,this.z=i+l*d+a*h-r*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,i=this.z,a=e.elements;return this.x=a[0]*t+a[4]*s+a[8]*i,this.y=a[1]*t+a[5]*s+a[9]*i,this.z=a[2]*t+a[6]*s+a[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Rn(this.x,e.x,t.x),this.y=Rn(this.y,e.y,t.y),this.z=Rn(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=Rn(this.x,e,t),this.y=Rn(this.y,e,t),this.z=Rn(this.z,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Rn(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,i=e.y,a=e.z,r=t.x,o=t.y,l=t.z;return this.x=i*l-a*o,this.y=a*r-s*l,this.z=s*o-i*r,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return zR.copy(this).projectOnVector(e),this.sub(zR)}reflect(e){return this.sub(zR.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Rn(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,i=this.z-e.z;return t*t+s*s+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const i=Math.sin(t)*e;return this.x=i*Math.sin(s),this.y=Math.cos(t)*e,this.z=i*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,s=Math.sqrt(1-t*t);return this.x=s*Math.cos(e),this.y=t,this.z=s*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const zR=new ue,iU=new Za;class Vn{constructor(e,t,s,i,a,r,o,l,c){Vn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,i,a,r,o,l,c)}set(e,t,s,i,a,r,o,l,c){const h=this.elements;return h[0]=e,h[1]=i,h[2]=o,h[3]=t,h[4]=a,h[5]=l,h[6]=s,h[7]=r,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,a=this.elements,r=s[0],o=s[3],l=s[6],c=s[1],h=s[4],d=s[7],p=s[2],g=s[5],v=s[8],_=i[0],S=i[3],b=i[6],w=i[1],T=i[4],E=i[7],R=i[2],D=i[5],F=i[8];return a[0]=r*_+o*w+l*R,a[3]=r*S+o*T+l*D,a[6]=r*b+o*E+l*F,a[1]=c*_+h*w+d*R,a[4]=c*S+h*T+d*D,a[7]=c*b+h*E+d*F,a[2]=p*_+g*w+v*R,a[5]=p*S+g*T+v*D,a[8]=p*b+g*E+v*F,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],i=e[2],a=e[3],r=e[4],o=e[5],l=e[6],c=e[7],h=e[8];return t*r*h-t*o*c-s*a*h+s*o*l+i*a*c-i*r*l}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],a=e[3],r=e[4],o=e[5],l=e[6],c=e[7],h=e[8],d=h*r-o*c,p=o*l-h*a,g=c*a-r*l,v=t*d+s*p+i*g;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const _=1/v;return e[0]=d*_,e[1]=(i*c-h*s)*_,e[2]=(o*s-i*r)*_,e[3]=p*_,e[4]=(h*t-i*l)*_,e[5]=(i*a-o*t)*_,e[6]=g*_,e[7]=(s*l-c*t)*_,e[8]=(r*t-s*a)*_,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,i,a,r,o){const l=Math.cos(a),c=Math.sin(a);return this.set(s*l,s*c,-s*(l*r+c*o)+r+e,-i*c,i*l,-i*(-c*r+l*o)+o+t,0,0,1),this}scale(e,t){return this.premultiply($R.makeScale(e,t)),this}rotate(e){return this.premultiply($R.makeRotation(-e)),this}translate(e,t){return this.premultiply($R.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<9;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const $R=new Vn,aU=new Vn().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),rU=new Vn().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function qK(){const n={enabled:!0,workingColorSpace:Qc,spaces:{},convert:function(i,a,r){return this.enabled===!1||a===r||!a||!r||(this.spaces[a].transfer===js&&(i.r=ud(i.r),i.g=ud(i.g),i.b=ud(i.b)),this.spaces[a].primaries!==this.spaces[r].primaries&&(i.applyMatrix3(this.spaces[a].toXYZ),i.applyMatrix3(this.spaces[r].fromXYZ)),this.spaces[r].transfer===js&&(i.r=_x(i.r),i.g=_x(i.g),i.b=_x(i.b))),i},workingToColorSpace:function(i,a){return this.convert(i,this.workingColorSpace,a)},colorSpaceToWorking:function(i,a){return this.convert(i,a,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===id?j1:this.spaces[i].transfer},getToneMappingMode:function(i){return this.spaces[i].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(i,a=this.workingColorSpace){return i.fromArray(this.spaces[a].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,a,r){return i.copy(this.spaces[a].toXYZ).multiply(this.spaces[r].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,a){return Fx("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),n.workingToColorSpace(i,a)},toWorkingColorSpace:function(i,a){return Fx("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),n.colorSpaceToWorking(i,a)}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],s=[.3127,.329];return n.define({[Qc]:{primaries:e,whitePoint:s,transfer:j1,toXYZ:aU,fromXYZ:rU,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:mr},outputColorSpaceConfig:{drawingBufferColorSpace:mr}},[mr]:{primaries:e,whitePoint:s,transfer:js,toXYZ:aU,fromXYZ:rU,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:mr}}}),n}const ws=qK();function ud(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function _x(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let j0;class cG{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let s;if(e instanceof HTMLCanvasElement)s=e;else{j0===void 0&&(j0=q1("canvas")),j0.width=e.width,j0.height=e.height;const i=j0.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),s=j0}return s.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=q1("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const i=s.getImageData(0,0,e.width,e.height),a=i.data;for(let r=0;r<a.length;r++)a[r]=ud(a[r]/255)*255;return s.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(ud(t[s]/255)*255):t[s]=ud(t[s]);return{data:t,width:e.width,height:e.height}}else return Wt("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let KK=0;class Ef{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:KK++}),this.uuid=Sl(),this.data=e,this.dataReady=!0,this.version=0}getSize(e){const t=this.data;return typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement?e.set(t.videoWidth,t.videoHeight,0):t instanceof VideoFrame?e.set(t.displayHeight,t.displayWidth,0):t!==null?e.set(t.width,t.height,t.depth||0):e.set(0,0,0),e}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let a;if(Array.isArray(i)){a=[];for(let r=0,o=i.length;r<o;r++)i[r].isDataTexture?a.push(GR(i[r].image)):a.push(GR(i[r]))}else a=GR(i);s.url=a}return t||(e.images[this.uuid]=s),s}}function GR(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?cG.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(Wt("Texture: Unable to serialize Texture."),{})}let YK=0;const VR=new ue;class Vs extends ph{constructor(e=Vs.DEFAULT_IMAGE,t=Vs.DEFAULT_MAPPING,s=Fi,i=Fi,a=is,r=tc,o=ra,l=Co,c=Vs.DEFAULT_ANISOTROPY,h=id){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:YK++}),this.uuid=Sl(),this.name="",this.source=new Ef(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=a,this.minFilter=r,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new rt(0,0),this.repeat=new rt(1,1),this.center=new rt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Vn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(e&&e.depth&&e.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(VR).x}get height(){return this.source.getSize(VR).y}get depth(){return this.source.getSize(VR).z}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isArrayTexture=e.isArrayTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}setValues(e){for(const t in e){const s=e[t];if(s===void 0){Wt(`Texture.setValues(): parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){Wt(`Texture.setValues(): property '${t}' does not exist.`);continue}i&&s&&i.isVector2&&s.isVector2||i&&s&&i.isVector3&&s.isVector3||i&&s&&i.isMatrix3&&s.isMatrix3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Ff)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Pf:e.x=e.x-Math.floor(e.x);break;case Fi:e.x=e.x<0?0:1;break;case Ix:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Pf:e.y=e.y-Math.floor(e.y);break;case Fi:e.y=e.y<0?0:1;break;case Ix:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}Vs.DEFAULT_IMAGE=null;Vs.DEFAULT_MAPPING=Ff;Vs.DEFAULT_ANISOTROPY=1;class Cs{constructor(e=0,t=0,s=0,i=1){Cs.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,a=this.w,r=e.elements;return this.x=r[0]*t+r[4]*s+r[8]*i+r[12]*a,this.y=r[1]*t+r[5]*s+r[9]*i+r[13]*a,this.z=r[2]*t+r[6]*s+r[10]*i+r[14]*a,this.w=r[3]*t+r[7]*s+r[11]*i+r[15]*a,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,i,a;const l=e.elements,c=l[0],h=l[4],d=l[8],p=l[1],g=l[5],v=l[9],_=l[2],S=l[6],b=l[10];if(Math.abs(h-p)<.01&&Math.abs(d-_)<.01&&Math.abs(v-S)<.01){if(Math.abs(h+p)<.1&&Math.abs(d+_)<.1&&Math.abs(v+S)<.1&&Math.abs(c+g+b-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const T=(c+1)/2,E=(g+1)/2,R=(b+1)/2,D=(h+p)/4,F=(d+_)/4,U=(v+S)/4;return T>E&&T>R?T<.01?(s=0,i=.707106781,a=.707106781):(s=Math.sqrt(T),i=D/s,a=F/s):E>R?E<.01?(s=.707106781,i=0,a=.707106781):(i=Math.sqrt(E),s=D/i,a=U/i):R<.01?(s=.707106781,i=.707106781,a=0):(a=Math.sqrt(R),s=F/a,i=U/a),this.set(s,i,a,t),this}let w=Math.sqrt((S-v)*(S-v)+(d-_)*(d-_)+(p-h)*(p-h));return Math.abs(w)<.001&&(w=1),this.x=(S-v)/w,this.y=(d-_)/w,this.z=(p-h)/w,this.w=Math.acos((c+g+b-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Rn(this.x,e.x,t.x),this.y=Rn(this.y,e.y,t.y),this.z=Rn(this.z,e.z,t.z),this.w=Rn(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=Rn(this.x,e,t),this.y=Rn(this.y,e,t),this.z=Rn(this.z,e,t),this.w=Rn(this.w,e,t),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Rn(s,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class aO extends ph{constructor(e=1,t=1,s={}){super(),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:is,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},s),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=s.depth,this.scissor=new Cs(0,0,e,t),this.scissorTest=!1,this.viewport=new Cs(0,0,e,t);const i={width:e,height:t,depth:s.depth},a=new Vs(i);this.textures=[];const r=s.count;for(let o=0;o<r;o++)this.textures[o]=a.clone(),this.textures[o].isRenderTargetTexture=!0,this.textures[o].renderTarget=this;this._setTextureOptions(s),this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=s.depthTexture,this.samples=s.samples,this.multiview=s.multiview}_setTextureOptions(e={}){const t={minFilter:is,generateMipmaps:!1,flipY:!1,internalFormat:null};e.mapping!==void 0&&(t.mapping=e.mapping),e.wrapS!==void 0&&(t.wrapS=e.wrapS),e.wrapT!==void 0&&(t.wrapT=e.wrapT),e.wrapR!==void 0&&(t.wrapR=e.wrapR),e.magFilter!==void 0&&(t.magFilter=e.magFilter),e.minFilter!==void 0&&(t.minFilter=e.minFilter),e.format!==void 0&&(t.format=e.format),e.type!==void 0&&(t.type=e.type),e.anisotropy!==void 0&&(t.anisotropy=e.anisotropy),e.colorSpace!==void 0&&(t.colorSpace=e.colorSpace),e.flipY!==void 0&&(t.flipY=e.flipY),e.generateMipmaps!==void 0&&(t.generateMipmaps=e.generateMipmaps),e.internalFormat!==void 0&&(t.internalFormat=e.internalFormat);for(let s=0;s<this.textures.length;s++)this.textures[s].setValues(t)}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let i=0,a=this.textures.length;i<a;i++)this.textures[i].image.width=e,this.textures[i].image.height=t,this.textures[i].image.depth=s,this.textures[i].isData3DTexture!==!0&&(this.textures[i].isArrayTexture=this.textures[i].image.depth>1);this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,s=e.textures.length;t<s;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const i=Object.assign({},e.textures[t].image);this.textures[t].source=new Ef(i)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Wr extends aO{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class l2 extends Vs{constructor(e=null,t=1,s=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=Ja,this.minFilter=Ja,this.wrapR=Fi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class JK extends Wr{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isWebGLArrayRenderTarget=!0,this.depth=s,this.texture=new l2(null,e,t,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class c2 extends Vs{constructor(e=null,t=1,s=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=Ja,this.minFilter=Ja,this.wrapR=Fi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ZK extends Wr{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isWebGL3DRenderTarget=!0,this.depth=s,this.texture=new c2(null,e,t,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class yr{constructor(e=new ue(1/0,1/0,1/0),t=new ue(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(Lc.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(Lc.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=Lc.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const a=s.getAttribute("position");if(t===!0&&a!==void 0&&e.isInstancedMesh!==!0)for(let r=0,o=a.count;r<o;r++)e.isMesh===!0?e.getVertexPosition(r,Lc):Lc.fromBufferAttribute(a,r),Lc.applyMatrix4(e.matrixWorld),this.expandByPoint(Lc);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),qw.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),qw.copy(s.boundingBox)),qw.applyMatrix4(e.matrixWorld),this.union(qw)}const i=e.children;for(let a=0,r=i.length;a<r;a++)this.expandByObject(i[a],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Lc),Lc.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(n1),Kw.subVectors(this.max,n1),X0.subVectors(e.a,n1),q0.subVectors(e.b,n1),K0.subVectors(e.c,n1),gf.subVectors(q0,X0),xf.subVectors(K0,q0),om.subVectors(X0,K0);let t=[0,-gf.z,gf.y,0,-xf.z,xf.y,0,-om.z,om.y,gf.z,0,-gf.x,xf.z,0,-xf.x,om.z,0,-om.x,-gf.y,gf.x,0,-xf.y,xf.x,0,-om.y,om.x,0];return!HR(t,X0,q0,K0,Kw)||(t=[1,0,0,0,1,0,0,0,1],!HR(t,X0,q0,K0,Kw))?!1:(Yw.crossVectors(gf,xf),t=[Yw.x,Yw.y,Yw.z],HR(t,X0,q0,K0,Kw))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Lc).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Lc).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Xh[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Xh[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Xh[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Xh[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Xh[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Xh[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Xh[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Xh[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Xh),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(e){return this.min.fromArray(e.min),this.max.fromArray(e.max),this}}const Xh=[new ue,new ue,new ue,new ue,new ue,new ue,new ue,new ue],Lc=new ue,qw=new yr,X0=new ue,q0=new ue,K0=new ue,gf=new ue,xf=new ue,om=new ue,n1=new ue,Kw=new ue,Yw=new ue,lm=new ue;function HR(n,e,t,s,i){for(let a=0,r=n.length-3;a<=r;a+=3){lm.fromArray(n,a);const o=i.x*Math.abs(lm.x)+i.y*Math.abs(lm.y)+i.z*Math.abs(lm.z),l=e.dot(lm),c=t.dot(lm),h=s.dot(lm);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>o)return!1}return!0}const QK=new yr,s1=new ue,WR=new ue;class Qa{constructor(e=new ue,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):QK.setFromPoints(e).getCenter(s);let i=0;for(let a=0,r=e.length;a<r;a++)i=Math.max(i,s.distanceToSquared(e[a]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;s1.subVectors(e,this.center);const t=s1.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),i=(s-this.radius)*.5;this.center.addScaledVector(s1,i/s),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(WR.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(s1.copy(e.center).add(WR)),this.expandByPoint(s1.copy(e.center).sub(WR))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(e){return this.radius=e.radius,this.center.fromArray(e.center),this}}const qh=new ue,jR=new ue,Jw=new ue,yf=new ue,XR=new ue,Zw=new ue,qR=new ue;class Ag{constructor(e=new ue,t=new ue(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,qh)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=qh.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(qh.copy(this.origin).addScaledVector(this.direction,t),qh.distanceToSquared(e))}distanceSqToSegment(e,t,s,i){jR.copy(e).add(t).multiplyScalar(.5),Jw.copy(t).sub(e).normalize(),yf.copy(this.origin).sub(jR);const a=e.distanceTo(t)*.5,r=-this.direction.dot(Jw),o=yf.dot(this.direction),l=-yf.dot(Jw),c=yf.lengthSq(),h=Math.abs(1-r*r);let d,p,g,v;if(h>0)if(d=r*l-o,p=r*o-l,v=a*h,d>=0)if(p>=-v)if(p<=v){const _=1/h;d*=_,p*=_,g=d*(d+r*p+2*o)+p*(r*d+p+2*l)+c}else p=a,d=Math.max(0,-(r*p+o)),g=-d*d+p*(p+2*l)+c;else p=-a,d=Math.max(0,-(r*p+o)),g=-d*d+p*(p+2*l)+c;else p<=-v?(d=Math.max(0,-(-r*a+o)),p=d>0?-a:Math.min(Math.max(-a,-l),a),g=-d*d+p*(p+2*l)+c):p<=v?(d=0,p=Math.min(Math.max(-a,-l),a),g=p*(p+2*l)+c):(d=Math.max(0,-(r*a+o)),p=d>0?a:Math.min(Math.max(-a,-l),a),g=-d*d+p*(p+2*l)+c);else p=r>0?-a:a,d=Math.max(0,-(r*p+o)),g=-d*d+p*(p+2*l)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(jR).addScaledVector(Jw,p),g}intersectSphere(e,t){qh.subVectors(e.center,this.origin);const s=qh.dot(this.direction),i=qh.dot(qh)-s*s,a=e.radius*e.radius;if(i>a)return null;const r=Math.sqrt(a-i),o=s-r,l=s+r;return l<0?null:o<0?this.at(l,t):this.at(o,t)}intersectsSphere(e){return e.radius<0?!1:this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,i,a,r,o,l;const c=1/this.direction.x,h=1/this.direction.y,d=1/this.direction.z,p=this.origin;return c>=0?(s=(e.min.x-p.x)*c,i=(e.max.x-p.x)*c):(s=(e.max.x-p.x)*c,i=(e.min.x-p.x)*c),h>=0?(a=(e.min.y-p.y)*h,r=(e.max.y-p.y)*h):(a=(e.max.y-p.y)*h,r=(e.min.y-p.y)*h),s>r||a>i||((a>s||isNaN(s))&&(s=a),(r<i||isNaN(i))&&(i=r),d>=0?(o=(e.min.z-p.z)*d,l=(e.max.z-p.z)*d):(o=(e.max.z-p.z)*d,l=(e.min.z-p.z)*d),s>l||o>i)||((o>s||s!==s)&&(s=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(s>=0?s:i,t)}intersectsBox(e){return this.intersectBox(e,qh)!==null}intersectTriangle(e,t,s,i,a){XR.subVectors(t,e),Zw.subVectors(s,e),qR.crossVectors(XR,Zw);let r=this.direction.dot(qR),o;if(r>0){if(i)return null;o=1}else if(r<0)o=-1,r=-r;else return null;yf.subVectors(this.origin,e);const l=o*this.direction.dot(Zw.crossVectors(yf,Zw));if(l<0)return null;const c=o*this.direction.dot(XR.cross(yf));if(c<0||l+c>r)return null;const h=-o*yf.dot(qR);return h<0?null:this.at(h/r,a)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class _n{constructor(e,t,s,i,a,r,o,l,c,h,d,p,g,v,_,S){_n.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,i,a,r,o,l,c,h,d,p,g,v,_,S)}set(e,t,s,i,a,r,o,l,c,h,d,p,g,v,_,S){const b=this.elements;return b[0]=e,b[4]=t,b[8]=s,b[12]=i,b[1]=a,b[5]=r,b[9]=o,b[13]=l,b[2]=c,b[6]=h,b[10]=d,b[14]=p,b[3]=g,b[7]=v,b[11]=_,b[15]=S,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new _n().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,i=1/Y0.setFromMatrixColumn(e,0).length(),a=1/Y0.setFromMatrixColumn(e,1).length(),r=1/Y0.setFromMatrixColumn(e,2).length();return t[0]=s[0]*i,t[1]=s[1]*i,t[2]=s[2]*i,t[3]=0,t[4]=s[4]*a,t[5]=s[5]*a,t[6]=s[6]*a,t[7]=0,t[8]=s[8]*r,t[9]=s[9]*r,t[10]=s[10]*r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,i=e.y,a=e.z,r=Math.cos(s),o=Math.sin(s),l=Math.cos(i),c=Math.sin(i),h=Math.cos(a),d=Math.sin(a);if(e.order==="XYZ"){const p=r*h,g=r*d,v=o*h,_=o*d;t[0]=l*h,t[4]=-l*d,t[8]=c,t[1]=g+v*c,t[5]=p-_*c,t[9]=-o*l,t[2]=_-p*c,t[6]=v+g*c,t[10]=r*l}else if(e.order==="YXZ"){const p=l*h,g=l*d,v=c*h,_=c*d;t[0]=p+_*o,t[4]=v*o-g,t[8]=r*c,t[1]=r*d,t[5]=r*h,t[9]=-o,t[2]=g*o-v,t[6]=_+p*o,t[10]=r*l}else if(e.order==="ZXY"){const p=l*h,g=l*d,v=c*h,_=c*d;t[0]=p-_*o,t[4]=-r*d,t[8]=v+g*o,t[1]=g+v*o,t[5]=r*h,t[9]=_-p*o,t[2]=-r*c,t[6]=o,t[10]=r*l}else if(e.order==="ZYX"){const p=r*h,g=r*d,v=o*h,_=o*d;t[0]=l*h,t[4]=v*c-g,t[8]=p*c+_,t[1]=l*d,t[5]=_*c+p,t[9]=g*c-v,t[2]=-c,t[6]=o*l,t[10]=r*l}else if(e.order==="YZX"){const p=r*l,g=r*c,v=o*l,_=o*c;t[0]=l*h,t[4]=_-p*d,t[8]=v*d+g,t[1]=d,t[5]=r*h,t[9]=-o*h,t[2]=-c*h,t[6]=g*d+v,t[10]=p-_*d}else if(e.order==="XZY"){const p=r*l,g=r*c,v=o*l,_=o*c;t[0]=l*h,t[4]=-d,t[8]=c*h,t[1]=p*d+_,t[5]=r*h,t[9]=g*d-v,t[2]=v*d-g,t[6]=o*h,t[10]=_*d+p}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(eY,e,tY)}lookAt(e,t,s){const i=this.elements;return pl.subVectors(e,t),pl.lengthSq()===0&&(pl.z=1),pl.normalize(),vf.crossVectors(s,pl),vf.lengthSq()===0&&(Math.abs(s.z)===1?pl.x+=1e-4:pl.z+=1e-4,pl.normalize(),vf.crossVectors(s,pl)),vf.normalize(),Qw.crossVectors(pl,vf),i[0]=vf.x,i[4]=Qw.x,i[8]=pl.x,i[1]=vf.y,i[5]=Qw.y,i[9]=pl.y,i[2]=vf.z,i[6]=Qw.z,i[10]=pl.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,a=this.elements,r=s[0],o=s[4],l=s[8],c=s[12],h=s[1],d=s[5],p=s[9],g=s[13],v=s[2],_=s[6],S=s[10],b=s[14],w=s[3],T=s[7],E=s[11],R=s[15],D=i[0],F=i[4],U=i[8],O=i[12],B=i[1],L=i[5],H=i[9],K=i[13],Z=i[2],Q=i[6],P=i[10],W=i[14],q=i[3],se=i[7],le=i[11],Y=i[15];return a[0]=r*D+o*B+l*Z+c*q,a[4]=r*F+o*L+l*Q+c*se,a[8]=r*U+o*H+l*P+c*le,a[12]=r*O+o*K+l*W+c*Y,a[1]=h*D+d*B+p*Z+g*q,a[5]=h*F+d*L+p*Q+g*se,a[9]=h*U+d*H+p*P+g*le,a[13]=h*O+d*K+p*W+g*Y,a[2]=v*D+_*B+S*Z+b*q,a[6]=v*F+_*L+S*Q+b*se,a[10]=v*U+_*H+S*P+b*le,a[14]=v*O+_*K+S*W+b*Y,a[3]=w*D+T*B+E*Z+R*q,a[7]=w*F+T*L+E*Q+R*se,a[11]=w*U+T*H+E*P+R*le,a[15]=w*O+T*K+E*W+R*Y,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],i=e[8],a=e[12],r=e[1],o=e[5],l=e[9],c=e[13],h=e[2],d=e[6],p=e[10],g=e[14],v=e[3],_=e[7],S=e[11],b=e[15];return v*(+a*l*d-i*c*d-a*o*p+s*c*p+i*o*g-s*l*g)+_*(+t*l*g-t*c*p+a*r*p-i*r*g+i*c*h-a*l*h)+S*(+t*c*d-t*o*g-a*r*d+s*r*g+a*o*h-s*c*h)+b*(-i*o*h-t*l*d+t*o*p+i*r*d-s*r*p+s*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],a=e[3],r=e[4],o=e[5],l=e[6],c=e[7],h=e[8],d=e[9],p=e[10],g=e[11],v=e[12],_=e[13],S=e[14],b=e[15],w=d*S*c-_*p*c+_*l*g-o*S*g-d*l*b+o*p*b,T=v*p*c-h*S*c-v*l*g+r*S*g+h*l*b-r*p*b,E=h*_*c-v*d*c+v*o*g-r*_*g-h*o*b+r*d*b,R=v*d*l-h*_*l-v*o*p+r*_*p+h*o*S-r*d*S,D=t*w+s*T+i*E+a*R;if(D===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const F=1/D;return e[0]=w*F,e[1]=(_*p*a-d*S*a-_*i*g+s*S*g+d*i*b-s*p*b)*F,e[2]=(o*S*a-_*l*a+_*i*c-s*S*c-o*i*b+s*l*b)*F,e[3]=(d*l*a-o*p*a-d*i*c+s*p*c+o*i*g-s*l*g)*F,e[4]=T*F,e[5]=(h*S*a-v*p*a+v*i*g-t*S*g-h*i*b+t*p*b)*F,e[6]=(v*l*a-r*S*a-v*i*c+t*S*c+r*i*b-t*l*b)*F,e[7]=(r*p*a-h*l*a+h*i*c-t*p*c-r*i*g+t*l*g)*F,e[8]=E*F,e[9]=(v*d*a-h*_*a-v*s*g+t*_*g+h*s*b-t*d*b)*F,e[10]=(r*_*a-v*o*a+v*s*c-t*_*c-r*s*b+t*o*b)*F,e[11]=(h*o*a-r*d*a-h*s*c+t*d*c+r*s*g-t*o*g)*F,e[12]=R*F,e[13]=(h*_*i-v*d*i+v*s*p-t*_*p-h*s*S+t*d*S)*F,e[14]=(v*o*i-r*_*i-v*s*l+t*_*l+r*s*S-t*o*S)*F,e[15]=(r*d*i-h*o*i+h*s*l-t*d*l-r*s*p+t*o*p)*F,this}scale(e){const t=this.elements,s=e.x,i=e.y,a=e.z;return t[0]*=s,t[4]*=i,t[8]*=a,t[1]*=s,t[5]*=i,t[9]*=a,t[2]*=s,t[6]*=i,t[10]*=a,t[3]*=s,t[7]*=i,t[11]*=a,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),i=Math.sin(t),a=1-s,r=e.x,o=e.y,l=e.z,c=a*r,h=a*o;return this.set(c*r+s,c*o-i*l,c*l+i*o,0,c*o+i*l,h*o+s,h*l-i*r,0,c*l-i*o,h*l+i*r,a*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,i,a,r){return this.set(1,s,a,0,e,1,r,0,t,i,1,0,0,0,0,1),this}compose(e,t,s){const i=this.elements,a=t._x,r=t._y,o=t._z,l=t._w,c=a+a,h=r+r,d=o+o,p=a*c,g=a*h,v=a*d,_=r*h,S=r*d,b=o*d,w=l*c,T=l*h,E=l*d,R=s.x,D=s.y,F=s.z;return i[0]=(1-(_+b))*R,i[1]=(g+E)*R,i[2]=(v-T)*R,i[3]=0,i[4]=(g-E)*D,i[5]=(1-(p+b))*D,i[6]=(S+w)*D,i[7]=0,i[8]=(v+T)*F,i[9]=(S-w)*F,i[10]=(1-(p+_))*F,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,s){const i=this.elements;let a=Y0.set(i[0],i[1],i[2]).length();const r=Y0.set(i[4],i[5],i[6]).length(),o=Y0.set(i[8],i[9],i[10]).length();this.determinant()<0&&(a=-a),e.x=i[12],e.y=i[13],e.z=i[14],Fc.copy(this);const c=1/a,h=1/r,d=1/o;return Fc.elements[0]*=c,Fc.elements[1]*=c,Fc.elements[2]*=c,Fc.elements[4]*=h,Fc.elements[5]*=h,Fc.elements[6]*=h,Fc.elements[8]*=d,Fc.elements[9]*=d,Fc.elements[10]*=d,t.setFromRotationMatrix(Fc),s.x=a,s.y=r,s.z=o,this}makePerspective(e,t,s,i,a,r,o=yl,l=!1){const c=this.elements,h=2*a/(t-e),d=2*a/(s-i),p=(t+e)/(t-e),g=(s+i)/(s-i);let v,_;if(l)v=a/(r-a),_=r*a/(r-a);else if(o===yl)v=-(r+a)/(r-a),_=-2*r*a/(r-a);else if(o===Lx)v=-r/(r-a),_=-r*a/(r-a);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return c[0]=h,c[4]=0,c[8]=p,c[12]=0,c[1]=0,c[5]=d,c[9]=g,c[13]=0,c[2]=0,c[6]=0,c[10]=v,c[14]=_,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(e,t,s,i,a,r,o=yl,l=!1){const c=this.elements,h=2/(t-e),d=2/(s-i),p=-(t+e)/(t-e),g=-(s+i)/(s-i);let v,_;if(l)v=1/(r-a),_=r/(r-a);else if(o===yl)v=-2/(r-a),_=-(r+a)/(r-a);else if(o===Lx)v=-1/(r-a),_=-a/(r-a);else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return c[0]=h,c[4]=0,c[8]=0,c[12]=p,c[1]=0,c[5]=d,c[9]=0,c[13]=g,c[2]=0,c[6]=0,c[10]=v,c[14]=_,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<16;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const Y0=new ue,Fc=new _n,eY=new ue(0,0,0),tY=new ue(1,1,1),vf=new ue,Qw=new ue,pl=new ue,oU=new _n,lU=new Za;class wl{constructor(e=0,t=0,s=0,i=wl.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,i=this._order){return this._x=e,this._y=t,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const i=e.elements,a=i[0],r=i[4],o=i[8],l=i[1],c=i[5],h=i[9],d=i[2],p=i[6],g=i[10];switch(t){case"XYZ":this._y=Math.asin(Rn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,g),this._z=Math.atan2(-r,a)):(this._x=Math.atan2(p,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Rn(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(o,g),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-d,a),this._z=0);break;case"ZXY":this._x=Math.asin(Rn(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-d,g),this._z=Math.atan2(-r,c)):(this._y=0,this._z=Math.atan2(l,a));break;case"ZYX":this._y=Math.asin(-Rn(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(p,g),this._z=Math.atan2(l,a)):(this._x=0,this._z=Math.atan2(-r,c));break;case"YZX":this._z=Math.asin(Rn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-d,a)):(this._x=0,this._y=Math.atan2(o,g));break;case"XZY":this._z=Math.asin(-Rn(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(p,c),this._y=Math.atan2(o,a)):(this._x=Math.atan2(-h,g),this._y=0);break;default:Wt("Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return oU.makeRotationFromQuaternion(e),this.setFromRotationMatrix(oU,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return lU.setFromEuler(this),this.setFromQuaternion(lU,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}wl.DEFAULT_ORDER="XYZ";class Px{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let nY=0;const cU=new ue,J0=new Za,Kh=new _n,eC=new ue,i1=new ue,sY=new ue,iY=new Za,uU=new ue(1,0,0),hU=new ue(0,1,0),dU=new ue(0,0,1),fU={type:"added"},aY={type:"removed"},Z0={type:"childadded",child:null},KR={type:"childremoved",child:null};class Ts extends ph{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:nY++}),this.uuid=Sl(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ts.DEFAULT_UP.clone();const e=new ue,t=new wl,s=new Za,i=new ue(1,1,1);function a(){s.setFromEuler(t,!1)}function r(){t.setFromQuaternion(s,void 0,!1)}t._onChange(a),s._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new _n},normalMatrix:{value:new Vn}}),this.matrix=new _n,this.matrixWorld=new _n,this.matrixAutoUpdate=Ts.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Ts.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Px,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return J0.setFromAxisAngle(e,t),this.quaternion.multiply(J0),this}rotateOnWorldAxis(e,t){return J0.setFromAxisAngle(e,t),this.quaternion.premultiply(J0),this}rotateX(e){return this.rotateOnAxis(uU,e)}rotateY(e){return this.rotateOnAxis(hU,e)}rotateZ(e){return this.rotateOnAxis(dU,e)}translateOnAxis(e,t){return cU.copy(e).applyQuaternion(this.quaternion),this.position.add(cU.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(uU,e)}translateY(e){return this.translateOnAxis(hU,e)}translateZ(e){return this.translateOnAxis(dU,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Kh.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?eC.copy(e):eC.set(e,t,s);const i=this.parent;this.updateWorldMatrix(!0,!1),i1.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Kh.lookAt(i1,eC,this.up):Kh.lookAt(eC,i1,this.up),this.quaternion.setFromRotationMatrix(Kh),i&&(Kh.extractRotation(i.matrixWorld),J0.setFromRotationMatrix(Kh),this.quaternion.premultiply(J0.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(On("Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(fU),Z0.child=e,this.dispatchEvent(Z0),Z0.child=null):On("Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(aY),KR.child=e,this.dispatchEvent(KR),KR.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Kh.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Kh.multiply(e.parent.matrixWorld)),e.applyMatrix4(Kh),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(fU),Z0.child=e,this.dispatchEvent(Z0),Z0.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,i=this.children.length;s<i;s++){const r=this.children[s].getObjectByProperty(e,t);if(r!==void 0)return r}}getObjectsByProperty(e,t,s=[]){this[e]===t&&s.push(this);const i=this.children;for(let a=0,r=i.length;a<r;a++)i[a].getObjectsByProperty(e,t,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(i1,e,sY),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(i1,iY,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].updateMatrixWorld(e)}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const i=this.children;for(let a=0,r=i.length;a<r;a++)i[a].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.geometryInfo=this._geometryInfo.map(o=>({...o,boundingBox:o.boundingBox?o.boundingBox.toJSON():void 0,boundingSphere:o.boundingSphere?o.boundingSphere.toJSON():void 0})),i.instanceInfo=this._instanceInfo.map(o=>({...o})),i.availableInstanceIds=this._availableInstanceIds.slice(),i.availableGeometryIds=this._availableGeometryIds.slice(),i.nextIndexStart=this._nextIndexStart,i.nextVertexStart=this._nextVertexStart,i.geometryCount=this._geometryCount,i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.matricesTexture=this._matricesTexture.toJSON(e),i.indirectTexture=this._indirectTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(i.boundingBox=this.boundingBox.toJSON()));function a(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=a(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const d=l[c];a(e.shapes,d)}else a(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(a(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(a(e.materials,this.material[l]));i.material=o}else i.material=a(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(a(e.animations,l))}}if(t){const o=r(e.geometries),l=r(e.materials),c=r(e.textures),h=r(e.images),d=r(e.shapes),p=r(e.skeletons),g=r(e.animations),v=r(e.nodes);o.length>0&&(s.geometries=o),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),h.length>0&&(s.images=h),d.length>0&&(s.shapes=d),p.length>0&&(s.skeletons=p),g.length>0&&(s.animations=g),v.length>0&&(s.nodes=v)}return s.object=i,s;function r(o){const l=[];for(const c in o){const h=o[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const i=e.children[s];this.add(i.clone())}return this}}Ts.DEFAULT_UP=new ue(0,1,0);Ts.DEFAULT_MATRIX_AUTO_UPDATE=!0;Ts.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Uc=new ue,Yh=new ue,YR=new ue,Jh=new ue,Q0=new ue,ex=new ue,pU=new ue,JR=new ue,ZR=new ue,QR=new ue,eI=new Cs,tI=new Cs,nI=new Cs;class qo{constructor(e=new ue,t=new ue,s=new ue){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,i){i.subVectors(s,t),Uc.subVectors(e,t),i.cross(Uc);const a=i.lengthSq();return a>0?i.multiplyScalar(1/Math.sqrt(a)):i.set(0,0,0)}static getBarycoord(e,t,s,i,a){Uc.subVectors(i,t),Yh.subVectors(s,t),YR.subVectors(e,t);const r=Uc.dot(Uc),o=Uc.dot(Yh),l=Uc.dot(YR),c=Yh.dot(Yh),h=Yh.dot(YR),d=r*c-o*o;if(d===0)return a.set(0,0,0),null;const p=1/d,g=(c*l-o*h)*p,v=(r*h-o*l)*p;return a.set(1-g-v,v,g)}static containsPoint(e,t,s,i){return this.getBarycoord(e,t,s,i,Jh)===null?!1:Jh.x>=0&&Jh.y>=0&&Jh.x+Jh.y<=1}static getInterpolation(e,t,s,i,a,r,o,l){return this.getBarycoord(e,t,s,i,Jh)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(a,Jh.x),l.addScaledVector(r,Jh.y),l.addScaledVector(o,Jh.z),l)}static getInterpolatedAttribute(e,t,s,i,a,r){return eI.setScalar(0),tI.setScalar(0),nI.setScalar(0),eI.fromBufferAttribute(e,t),tI.fromBufferAttribute(e,s),nI.fromBufferAttribute(e,i),r.setScalar(0),r.addScaledVector(eI,a.x),r.addScaledVector(tI,a.y),r.addScaledVector(nI,a.z),r}static isFrontFacing(e,t,s,i){return Uc.subVectors(s,t),Yh.subVectors(e,t),Uc.cross(Yh).dot(i)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,i){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,s,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Uc.subVectors(this.c,this.b),Yh.subVectors(this.a,this.b),Uc.cross(Yh).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return qo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return qo.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,s,i,a){return qo.getInterpolation(e,this.a,this.b,this.c,t,s,i,a)}containsPoint(e){return qo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return qo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,i=this.b,a=this.c;let r,o;Q0.subVectors(i,s),ex.subVectors(a,s),JR.subVectors(e,s);const l=Q0.dot(JR),c=ex.dot(JR);if(l<=0&&c<=0)return t.copy(s);ZR.subVectors(e,i);const h=Q0.dot(ZR),d=ex.dot(ZR);if(h>=0&&d<=h)return t.copy(i);const p=l*d-h*c;if(p<=0&&l>=0&&h<=0)return r=l/(l-h),t.copy(s).addScaledVector(Q0,r);QR.subVectors(e,a);const g=Q0.dot(QR),v=ex.dot(QR);if(v>=0&&g<=v)return t.copy(a);const _=g*c-l*v;if(_<=0&&c>=0&&v<=0)return o=c/(c-v),t.copy(s).addScaledVector(ex,o);const S=h*v-g*d;if(S<=0&&d-h>=0&&g-v>=0)return pU.subVectors(a,i),o=(d-h)/(d-h+(g-v)),t.copy(i).addScaledVector(pU,o);const b=1/(S+_+p);return r=_*b,o=p*b,t.copy(s).addScaledVector(Q0,r).addScaledVector(ex,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const uG={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},bf={h:0,s:0,l:0},tC={h:0,s:0,l:0};function sI(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class $t{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=mr){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,ws.colorSpaceToWorking(this,t),this}setRGB(e,t,s,i=ws.workingColorSpace){return this.r=e,this.g=t,this.b=s,ws.colorSpaceToWorking(this,i),this}setHSL(e,t,s,i=ws.workingColorSpace){if(e=iO(e,1),t=Rn(t,0,1),s=Rn(s,0,1),t===0)this.r=this.g=this.b=s;else{const a=s<=.5?s*(1+t):s+t-s*t,r=2*s-a;this.r=sI(r,a,e+1/3),this.g=sI(r,a,e),this.b=sI(r,a,e-1/3)}return ws.colorSpaceToWorking(this,i),this}setStyle(e,t=mr){function s(a){a!==void 0&&parseFloat(a)<1&&Wt("Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let a;const r=i[1],o=i[2];switch(r){case"rgb":case"rgba":if(a=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(a[4]),this.setRGB(Math.min(255,parseInt(a[1],10))/255,Math.min(255,parseInt(a[2],10))/255,Math.min(255,parseInt(a[3],10))/255,t);if(a=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(a[4]),this.setRGB(Math.min(100,parseInt(a[1],10))/100,Math.min(100,parseInt(a[2],10))/100,Math.min(100,parseInt(a[3],10))/100,t);break;case"hsl":case"hsla":if(a=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(a[4]),this.setHSL(parseFloat(a[1])/360,parseFloat(a[2])/100,parseFloat(a[3])/100,t);break;default:Wt("Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const a=i[1],r=a.length;if(r===3)return this.setRGB(parseInt(a.charAt(0),16)/15,parseInt(a.charAt(1),16)/15,parseInt(a.charAt(2),16)/15,t);if(r===6)return this.setHex(parseInt(a,16),t);Wt("Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=mr){const s=uG[e.toLowerCase()];return s!==void 0?this.setHex(s,t):Wt("Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=ud(e.r),this.g=ud(e.g),this.b=ud(e.b),this}copyLinearToSRGB(e){return this.r=_x(e.r),this.g=_x(e.g),this.b=_x(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=mr){return ws.workingToColorSpace(Fr.copy(this),e),Math.round(Rn(Fr.r*255,0,255))*65536+Math.round(Rn(Fr.g*255,0,255))*256+Math.round(Rn(Fr.b*255,0,255))}getHexString(e=mr){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=ws.workingColorSpace){ws.workingToColorSpace(Fr.copy(this),t);const s=Fr.r,i=Fr.g,a=Fr.b,r=Math.max(s,i,a),o=Math.min(s,i,a);let l,c;const h=(o+r)/2;if(o===r)l=0,c=0;else{const d=r-o;switch(c=h<=.5?d/(r+o):d/(2-r-o),r){case s:l=(i-a)/d+(i<a?6:0);break;case i:l=(a-s)/d+2;break;case a:l=(s-i)/d+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=ws.workingColorSpace){return ws.workingToColorSpace(Fr.copy(this),t),e.r=Fr.r,e.g=Fr.g,e.b=Fr.b,e}getStyle(e=mr){ws.workingToColorSpace(Fr.copy(this),e);const t=Fr.r,s=Fr.g,i=Fr.b;return e!==mr?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(i*255)})`}offsetHSL(e,t,s){return this.getHSL(bf),this.setHSL(bf.h+e,bf.s+t,bf.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(bf),e.getHSL(tC);const s=F1(bf.h,tC.h,t),i=F1(bf.s,tC.s,t),a=F1(bf.l,tC.l,t);return this.setHSL(s,i,a),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,i=this.b,a=e.elements;return this.r=a[0]*t+a[3]*s+a[6]*i,this.g=a[1]*t+a[4]*s+a[7]*i,this.b=a[2]*t+a[5]*s+a[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Fr=new $t;$t.NAMES=uG;let rY=0;class Da extends ph{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:rY++}),this.uuid=Sl(),this.name="",this.type="Material",this.blending=Wm,this.side=ih,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=CT,this.blendDst=TT,this.blendEquation=Tf,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new $t(0,0,0),this.blendAlpha=0,this.depthFunc=Qm,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=N3,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Em,this.stencilZFail=Em,this.stencilZPass=Em,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){Wt(`Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){Wt(`Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(s.sheenColorMap=this.sheenColorMap.toJSON(e).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(s.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(e).uuid),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==Wm&&(s.blending=this.blending),this.side!==ih&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==CT&&(s.blendSrc=this.blendSrc),this.blendDst!==TT&&(s.blendDst=this.blendDst),this.blendEquation!==Tf&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==Qm&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==N3&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Em&&(s.stencilFail=this.stencilFail),this.stencilZFail!==Em&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==Em&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function i(a){const r=[];for(const o in a){const l=a[o];delete l.metadata,r.push(l)}return r}if(t){const a=i(e.textures),r=i(e.images);a.length>0&&(s.textures=a),r.length>0&&(s.images=r)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const i=t.length;s=new Array(i);for(let a=0;a!==i;++a)s[a]=t[a].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class Yo extends Da{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new $t(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new wl,this.combine=CS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const ad=oY();function oY(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),s=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(s[l]=0,s[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(s[l]=1024>>-c-14,s[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(s[l]=c+15<<10,s[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(s[l]=31744,s[l|256]=64512,i[l]=24,i[l|256]=24):(s[l]=31744,s[l|256]=64512,i[l]=13,i[l|256]=13)}const a=new Uint32Array(2048),r=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;(c&8388608)===0;)c<<=1,h-=8388608;c&=-8388609,h+=947912704,a[l]=c|h}for(let l=1024;l<2048;++l)a[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)r[l]=l<<23;r[31]=1199570944,r[32]=2147483648;for(let l=33;l<63;++l)r[l]=2147483648+(l-32<<23);r[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(o[l]=1024);return{floatView:e,uint32View:t,baseTable:s,shiftTable:i,mantissaTable:a,exponentTable:r,offsetTable:o}}function Wo(n){Math.abs(n)>65504&&Wt("DataUtils.toHalfFloat(): Value out of range."),n=Rn(n,-65504,65504),ad.floatView[0]=n;const e=ad.uint32View[0],t=e>>23&511;return ad.baseTable[t]+((e&8388607)>>ad.shiftTable[t])}function _1(n){const e=n>>10;return ad.uint32View[0]=ad.mantissaTable[ad.offsetTable[e]+(n&1023)]+ad.exponentTable[e],ad.floatView[0]}class Pm{static toHalfFloat(e){return Wo(e)}static fromHalfFloat(e){return _1(e)}}const ma=new ue,nC=new rt;let lY=0;class Es{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:lY++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=X1,this.updateRanges=[],this.gpuType=wi,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let i=0,a=this.itemSize;i<a;i++)this.array[e+i]=t.array[s+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)nC.fromBufferAttribute(this,t),nC.applyMatrix3(e),this.setXY(t,nC.x,nC.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)ma.fromBufferAttribute(this,t),ma.applyMatrix3(e),this.setXYZ(t,ma.x,ma.y,ma.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)ma.fromBufferAttribute(this,t),ma.applyMatrix4(e),this.setXYZ(t,ma.x,ma.y,ma.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)ma.fromBufferAttribute(this,t),ma.applyNormalMatrix(e),this.setXYZ(t,ma.x,ma.y,ma.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)ma.fromBufferAttribute(this,t),ma.transformDirection(e),this.setXYZ(t,ma.x,ma.y,ma.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=bo(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Xn(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=bo(t,this.array)),t}setX(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=bo(t,this.array)),t}setY(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=bo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=bo(t,this.array)),t}setW(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array),i=Xn(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this}setXYZW(e,t,s,i,a){return e*=this.itemSize,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array),i=Xn(i,this.array),a=Xn(a,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this.array[e+3]=a,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==X1&&(e.usage=this.usage),e}}class cY extends Es{constructor(e,t,s){super(new Int8Array(e),t,s)}}class uY extends Es{constructor(e,t,s){super(new Uint8Array(e),t,s)}}class hY extends Es{constructor(e,t,s){super(new Uint8ClampedArray(e),t,s)}}class dY extends Es{constructor(e,t,s){super(new Int16Array(e),t,s)}}class rO extends Es{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class fY extends Es{constructor(e,t,s){super(new Int32Array(e),t,s)}}class oO extends Es{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class pY extends Es{constructor(e,t,s){super(new Uint16Array(e),t,s),this.isFloat16BufferAttribute=!0}getX(e){let t=_1(this.array[e*this.itemSize]);return this.normalized&&(t=bo(t,this.array)),t}setX(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize]=Wo(t),this}getY(e){let t=_1(this.array[e*this.itemSize+1]);return this.normalized&&(t=bo(t,this.array)),t}setY(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize+1]=Wo(t),this}getZ(e){let t=_1(this.array[e*this.itemSize+2]);return this.normalized&&(t=bo(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize+2]=Wo(t),this}getW(e){let t=_1(this.array[e*this.itemSize+3]);return this.normalized&&(t=bo(t,this.array)),t}setW(e,t){return this.normalized&&(t=Xn(t,this.array)),this.array[e*this.itemSize+3]=Wo(t),this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array)),this.array[e+0]=Wo(t),this.array[e+1]=Wo(s),this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array),i=Xn(i,this.array)),this.array[e+0]=Wo(t),this.array[e+1]=Wo(s),this.array[e+2]=Wo(i),this}setXYZW(e,t,s,i,a){return e*=this.itemSize,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array),i=Xn(i,this.array),a=Xn(a,this.array)),this.array[e+0]=Wo(t),this.array[e+1]=Wo(s),this.array[e+2]=Wo(i),this.array[e+3]=Wo(a),this}}class on extends Es{constructor(e,t,s){super(new Float32Array(e),t,s)}}let mY=0;const Xl=new _n,iI=new Ts,tx=new ue,ml=new yr,a1=new yr,qa=new ue;class Ln extends ph{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:mY++}),this.uuid=Sl(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(rG(e)?oO:rO)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const a=new Vn().getNormalMatrix(e);s.applyNormalMatrix(a),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Xl.makeRotationFromQuaternion(e),this.applyMatrix4(Xl),this}rotateX(e){return Xl.makeRotationX(e),this.applyMatrix4(Xl),this}rotateY(e){return Xl.makeRotationY(e),this.applyMatrix4(Xl),this}rotateZ(e){return Xl.makeRotationZ(e),this.applyMatrix4(Xl),this}translate(e,t,s){return Xl.makeTranslation(e,t,s),this.applyMatrix4(Xl),this}scale(e,t,s){return Xl.makeScale(e,t,s),this.applyMatrix4(Xl),this}lookAt(e){return iI.lookAt(e),iI.updateMatrix(),this.applyMatrix4(iI.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(tx).negate(),this.translate(tx.x,tx.y,tx.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const s=[];for(let i=0,a=e.length;i<a;i++){const r=e[i];s.push(r.x,r.y,r.z||0)}this.setAttribute("position",new on(s,3))}else{const s=Math.min(e.length,t.count);for(let i=0;i<s;i++){const a=e[i];t.setXYZ(i,a.x,a.y,a.z||0)}e.length>t.count&&Wt("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new yr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){On("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new ue(-1/0,-1/0,-1/0),new ue(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,i=t.length;s<i;s++){const a=t[s];ml.setFromBufferAttribute(a),this.morphTargetsRelative?(qa.addVectors(this.boundingBox.min,ml.min),this.boundingBox.expandByPoint(qa),qa.addVectors(this.boundingBox.max,ml.max),this.boundingBox.expandByPoint(qa)):(this.boundingBox.expandByPoint(ml.min),this.boundingBox.expandByPoint(ml.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&On('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Qa);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){On("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new ue,1/0);return}if(e){const s=this.boundingSphere.center;if(ml.setFromBufferAttribute(e),t)for(let a=0,r=t.length;a<r;a++){const o=t[a];a1.setFromBufferAttribute(o),this.morphTargetsRelative?(qa.addVectors(ml.min,a1.min),ml.expandByPoint(qa),qa.addVectors(ml.max,a1.max),ml.expandByPoint(qa)):(ml.expandByPoint(a1.min),ml.expandByPoint(a1.max))}ml.getCenter(s);let i=0;for(let a=0,r=e.count;a<r;a++)qa.fromBufferAttribute(e,a),i=Math.max(i,s.distanceToSquared(qa));if(t)for(let a=0,r=t.length;a<r;a++){const o=t[a],l=this.morphTargetsRelative;for(let c=0,h=o.count;c<h;c++)qa.fromBufferAttribute(o,c),l&&(tx.fromBufferAttribute(e,c),qa.add(tx)),i=Math.max(i,s.distanceToSquared(qa))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&On('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){On("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=t.position,i=t.normal,a=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Es(new Float32Array(4*s.count),4));const r=this.getAttribute("tangent"),o=[],l=[];for(let U=0;U<s.count;U++)o[U]=new ue,l[U]=new ue;const c=new ue,h=new ue,d=new ue,p=new rt,g=new rt,v=new rt,_=new ue,S=new ue;function b(U,O,B){c.fromBufferAttribute(s,U),h.fromBufferAttribute(s,O),d.fromBufferAttribute(s,B),p.fromBufferAttribute(a,U),g.fromBufferAttribute(a,O),v.fromBufferAttribute(a,B),h.sub(c),d.sub(c),g.sub(p),v.sub(p);const L=1/(g.x*v.y-v.x*g.y);isFinite(L)&&(_.copy(h).multiplyScalar(v.y).addScaledVector(d,-g.y).multiplyScalar(L),S.copy(d).multiplyScalar(g.x).addScaledVector(h,-v.x).multiplyScalar(L),o[U].add(_),o[O].add(_),o[B].add(_),l[U].add(S),l[O].add(S),l[B].add(S))}let w=this.groups;w.length===0&&(w=[{start:0,count:e.count}]);for(let U=0,O=w.length;U<O;++U){const B=w[U],L=B.start,H=B.count;for(let K=L,Z=L+H;K<Z;K+=3)b(e.getX(K+0),e.getX(K+1),e.getX(K+2))}const T=new ue,E=new ue,R=new ue,D=new ue;function F(U){R.fromBufferAttribute(i,U),D.copy(R);const O=o[U];T.copy(O),T.sub(R.multiplyScalar(R.dot(O))).normalize(),E.crossVectors(D,O);const L=E.dot(l[U])<0?-1:1;r.setXYZW(U,T.x,T.y,T.z,L)}for(let U=0,O=w.length;U<O;++U){const B=w[U],L=B.start,H=B.count;for(let K=L,Z=L+H;K<Z;K+=3)F(e.getX(K+0)),F(e.getX(K+1)),F(e.getX(K+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Es(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let p=0,g=s.count;p<g;p++)s.setXYZ(p,0,0,0);const i=new ue,a=new ue,r=new ue,o=new ue,l=new ue,c=new ue,h=new ue,d=new ue;if(e)for(let p=0,g=e.count;p<g;p+=3){const v=e.getX(p+0),_=e.getX(p+1),S=e.getX(p+2);i.fromBufferAttribute(t,v),a.fromBufferAttribute(t,_),r.fromBufferAttribute(t,S),h.subVectors(r,a),d.subVectors(i,a),h.cross(d),o.fromBufferAttribute(s,v),l.fromBufferAttribute(s,_),c.fromBufferAttribute(s,S),o.add(h),l.add(h),c.add(h),s.setXYZ(v,o.x,o.y,o.z),s.setXYZ(_,l.x,l.y,l.z),s.setXYZ(S,c.x,c.y,c.z)}else for(let p=0,g=t.count;p<g;p+=3)i.fromBufferAttribute(t,p+0),a.fromBufferAttribute(t,p+1),r.fromBufferAttribute(t,p+2),h.subVectors(r,a),d.subVectors(i,a),h.cross(d),s.setXYZ(p+0,h.x,h.y,h.z),s.setXYZ(p+1,h.x,h.y,h.z),s.setXYZ(p+2,h.x,h.y,h.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)qa.fromBufferAttribute(e,t),qa.normalize(),e.setXYZ(t,qa.x,qa.y,qa.z)}toNonIndexed(){function e(o,l){const c=o.array,h=o.itemSize,d=o.normalized,p=new c.constructor(l.length*h);let g=0,v=0;for(let _=0,S=l.length;_<S;_++){o.isInterleavedBufferAttribute?g=l[_]*o.data.stride+o.offset:g=l[_]*h;for(let b=0;b<h;b++)p[v++]=c[g++]}return new Es(p,h,d)}if(this.index===null)return Wt("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Ln,s=this.index.array,i=this.attributes;for(const o in i){const l=i[o],c=e(l,s);t.setAttribute(o,c)}const a=this.morphAttributes;for(const o in a){const l=[],c=a[o];for(let h=0,d=c.length;h<d;h++){const p=c[h],g=e(p,s);l.push(g)}t.morphAttributes[o]=l}t.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let o=0,l=r.length;o<l;o++){const c=r[o];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let a=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let d=0,p=c.length;d<p;d++){const g=c[d];h.push(g.toJSON(e.data))}h.length>0&&(i[l]=h,a=!0)}a&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(e.data.groups=JSON.parse(JSON.stringify(r)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere=o.toJSON()),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone());const i=e.attributes;for(const c in i){const h=i[c];this.setAttribute(c,h.clone(t))}const a=e.morphAttributes;for(const c in a){const h=[],d=a[c];for(let p=0,g=d.length;p<g;p++)h.push(d[p].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const r=e.groups;for(let c=0,h=r.length;c<h;c++){const d=r[c];this.addGroup(d.start,d.count,d.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const mU=new _n,cm=new Ag,sC=new Qa,gU=new ue,iC=new ue,aC=new ue,rC=new ue,aI=new ue,oC=new ue,xU=new ue,lC=new ue;class Ti extends Ts{constructor(e=new Ln,t=new Yo){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,r=i.length;a<r;a++){const o=i[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=a}}}}getVertexPosition(e,t){const s=this.geometry,i=s.attributes.position,a=s.morphAttributes.position,r=s.morphTargetsRelative;t.fromBufferAttribute(i,e);const o=this.morphTargetInfluences;if(a&&o){oC.set(0,0,0);for(let l=0,c=a.length;l<c;l++){const h=o[l],d=a[l];h!==0&&(aI.fromBufferAttribute(d,e),r?oC.addScaledVector(aI,h):oC.addScaledVector(aI.sub(t),h))}t.add(oC)}return t}raycast(e,t){const s=this.geometry,i=this.material,a=this.matrixWorld;i!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),sC.copy(s.boundingSphere),sC.applyMatrix4(a),cm.copy(e.ray).recast(e.near),!(sC.containsPoint(cm.origin)===!1&&(cm.intersectSphere(sC,gU)===null||cm.origin.distanceToSquared(gU)>(e.far-e.near)**2))&&(mU.copy(a).invert(),cm.copy(e.ray).applyMatrix4(mU),!(s.boundingBox!==null&&cm.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,cm)))}_computeIntersections(e,t,s){let i;const a=this.geometry,r=this.material,o=a.index,l=a.attributes.position,c=a.attributes.uv,h=a.attributes.uv1,d=a.attributes.normal,p=a.groups,g=a.drawRange;if(o!==null)if(Array.isArray(r))for(let v=0,_=p.length;v<_;v++){const S=p[v],b=r[S.materialIndex],w=Math.max(S.start,g.start),T=Math.min(o.count,Math.min(S.start+S.count,g.start+g.count));for(let E=w,R=T;E<R;E+=3){const D=o.getX(E),F=o.getX(E+1),U=o.getX(E+2);i=cC(this,b,e,s,c,h,d,D,F,U),i&&(i.faceIndex=Math.floor(E/3),i.face.materialIndex=S.materialIndex,t.push(i))}}else{const v=Math.max(0,g.start),_=Math.min(o.count,g.start+g.count);for(let S=v,b=_;S<b;S+=3){const w=o.getX(S),T=o.getX(S+1),E=o.getX(S+2);i=cC(this,r,e,s,c,h,d,w,T,E),i&&(i.faceIndex=Math.floor(S/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(r))for(let v=0,_=p.length;v<_;v++){const S=p[v],b=r[S.materialIndex],w=Math.max(S.start,g.start),T=Math.min(l.count,Math.min(S.start+S.count,g.start+g.count));for(let E=w,R=T;E<R;E+=3){const D=E,F=E+1,U=E+2;i=cC(this,b,e,s,c,h,d,D,F,U),i&&(i.faceIndex=Math.floor(E/3),i.face.materialIndex=S.materialIndex,t.push(i))}}else{const v=Math.max(0,g.start),_=Math.min(l.count,g.start+g.count);for(let S=v,b=_;S<b;S+=3){const w=S,T=S+1,E=S+2;i=cC(this,r,e,s,c,h,d,w,T,E),i&&(i.faceIndex=Math.floor(S/3),t.push(i))}}}}function gY(n,e,t,s,i,a,r,o){let l;if(e.side===Ao?l=s.intersectTriangle(r,a,i,!0,o):l=s.intersectTriangle(i,a,r,e.side===ih,o),l===null)return null;lC.copy(o),lC.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(lC);return c<t.near||c>t.far?null:{distance:c,point:lC.clone(),object:n}}function cC(n,e,t,s,i,a,r,o,l,c){n.getVertexPosition(o,iC),n.getVertexPosition(l,aC),n.getVertexPosition(c,rC);const h=gY(n,e,t,s,iC,aC,rC,xU);if(h){const d=new ue;qo.getBarycoord(xU,iC,aC,rC,d),i&&(h.uv=qo.getInterpolatedAttribute(i,o,l,c,d,new rt)),a&&(h.uv1=qo.getInterpolatedAttribute(a,o,l,c,d,new rt)),r&&(h.normal=qo.getInterpolatedAttribute(r,o,l,c,d,new ue),h.normal.dot(s.direction)>0&&h.normal.multiplyScalar(-1));const p={a:o,b:l,c,normal:new ue,materialIndex:0};qo.getNormal(iC,aC,rC,p.normal),h.face=p,h.barycoord=d}return h}class wg extends Ln{constructor(e=1,t=1,s=1,i=1,a=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:i,heightSegments:a,depthSegments:r};const o=this;i=Math.floor(i),a=Math.floor(a),r=Math.floor(r);const l=[],c=[],h=[],d=[];let p=0,g=0;v("z","y","x",-1,-1,s,t,e,r,a,0),v("z","y","x",1,-1,s,t,-e,r,a,1),v("x","z","y",1,1,e,s,t,i,r,2),v("x","z","y",1,-1,e,s,-t,i,r,3),v("x","y","z",1,-1,e,t,s,i,a,4),v("x","y","z",-1,-1,e,t,-s,i,a,5),this.setIndex(l),this.setAttribute("position",new on(c,3)),this.setAttribute("normal",new on(h,3)),this.setAttribute("uv",new on(d,2));function v(_,S,b,w,T,E,R,D,F,U,O){const B=E/F,L=R/U,H=E/2,K=R/2,Z=D/2,Q=F+1,P=U+1;let W=0,q=0;const se=new ue;for(let le=0;le<P;le++){const Y=le*L-K;for(let re=0;re<Q;re++){const he=re*B-H;se[_]=he*w,se[S]=Y*T,se[b]=Z,c.push(se.x,se.y,se.z),se[_]=0,se[S]=0,se[b]=D>0?1:-1,h.push(se.x,se.y,se.z),d.push(re/F),d.push(1-le/U),W+=1}}for(let le=0;le<U;le++)for(let Y=0;Y<F;Y++){const re=p+Y+Q*le,he=p+Y+Q*(le+1),me=p+(Y+1)+Q*(le+1),Ne=p+(Y+1)+Q*le;l.push(re,he,Ne),l.push(he,me,Ne),q+=6}o.addGroup(g,q,O),g+=q,p+=W}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new wg(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function zx(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const i=n[t][s];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(Wt("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=i.clone():Array.isArray(i)?e[t][s]=i.slice():e[t][s]=i}}return e}function xo(n){const e={};for(let t=0;t<n.length;t++){const s=zx(n[t]);for(const i in s)e[i]=s[i]}return e}function xY(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function hG(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:ws.workingColorSpace}const dG={clone:zx,merge:xo};var yY=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,vY=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class jr extends Da{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=yY,this.fragmentShader=vY,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=zx(e.uniforms),this.uniformsGroups=xY(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const r=this.uniforms[i].value;r&&r.isTexture?t.uniforms[i]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[i]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[i]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[i]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[i]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[i]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[i]={type:"m4",value:r.toArray()}:t.uniforms[i]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const i in this.extensions)this.extensions[i]===!0&&(s[i]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class NS extends Ts{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new _n,this.projectionMatrix=new _n,this.projectionMatrixInverse=new _n,this.coordinateSystem=yl,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Sf=new ue,yU=new rt,vU=new rt;let ki=class extends NS{constructor(e=50,t=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Ux*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(jm*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Ux*2*Math.atan(Math.tan(jm*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,s){Sf.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(Sf.x,Sf.y).multiplyScalar(-e/Sf.z),Sf.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(Sf.x,Sf.y).multiplyScalar(-e/Sf.z)}getViewSize(e,t){return this.getViewBounds(e,yU,vU),t.subVectors(vU,yU)}setViewOffset(e,t,s,i,a,r){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=a,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(jm*.5*this.fov)/this.zoom,s=2*t,i=this.aspect*s,a=-.5*i;const r=this.view;if(this.view!==null&&this.view.enabled){const l=r.fullWidth,c=r.fullHeight;a+=r.offsetX*i/l,t-=r.offsetY*s/c,i*=r.width/l,s*=r.height/c}const o=this.filmOffset;o!==0&&(a+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(a,a+i,t,t-s,e,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}};const nx=-90,sx=1;class fG extends Ts{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new ki(nx,sx,e,t);i.layers=this.layers,this.add(i);const a=new ki(nx,sx,e,t);a.layers=this.layers,this.add(a);const r=new ki(nx,sx,e,t);r.layers=this.layers,this.add(r);const o=new ki(nx,sx,e,t);o.layers=this.layers,this.add(o);const l=new ki(nx,sx,e,t);l.layers=this.layers,this.add(l);const c=new ki(nx,sx,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,i,a,r,o,l]=t;for(const c of t)this.remove(c);if(e===yl)s.up.set(0,1,0),s.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),a.up.set(0,0,-1),a.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===Lx)s.up.set(0,-1,0),s.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),a.up.set(0,0,1),a.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[a,r,o,l,c,h]=this.children,d=e.getRenderTarget(),p=e.getActiveCubeFace(),g=e.getActiveMipmapLevel(),v=e.xr.enabled;e.xr.enabled=!1;const _=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,i),e.render(t,a),e.setRenderTarget(s,1,i),e.render(t,r),e.setRenderTarget(s,2,i),e.render(t,o),e.setRenderTarget(s,3,i),e.render(t,l),e.setRenderTarget(s,4,i),e.render(t,c),s.texture.generateMipmaps=_,e.setRenderTarget(s,5,i),e.render(t,h),e.setRenderTarget(d,p,g),e.xr.enabled=v,s.texture.needsPMREMUpdate=!0}}class RS extends Vs{constructor(e=[],t=ah,s,i,a,r,o,l,c,h){super(e,t,s,i,a,r,o,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class lO extends Wr{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},i=[s,s,s,s,s,s];this.texture=new RS(i),this._setTextureOptions(t),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new wg(5,5,5),a=new jr({name:"CubemapFromEquirect",uniforms:zx(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:Ao,blending:ic});a.uniforms.tEquirect.value=t;const r=new Ti(i,a),o=t.minFilter;return t.minFilter===tc&&(t.minFilter=is),new fG(1,10,this).update(e,r),t.minFilter=o,r.geometry.dispose(),r.material.dispose(),this}clear(e,t=!0,s=!0,i=!0){const a=e.getRenderTarget();for(let r=0;r<6;r++)e.setRenderTarget(this,r),e.clear(t,s,i);e.setRenderTarget(a)}}class ld extends Ts{constructor(){super(),this.isGroup=!0,this.type="Group"}}const bY={type:"move"};class uT{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new ld,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new ld,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ue,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ue),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new ld,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ue,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ue),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let i=null,a=null,r=null;const o=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){r=!0;for(const _ of e.hand.values()){const S=t.getJointPose(_,s),b=this._getHandJoint(c,_);S!==null&&(b.matrix.fromArray(S.transform.matrix),b.matrix.decompose(b.position,b.rotation,b.scale),b.matrixWorldNeedsUpdate=!0,b.jointRadius=S.radius),b.visible=S!==null}const h=c.joints["index-finger-tip"],d=c.joints["thumb-tip"],p=h.position.distanceTo(d.position),g=.02,v=.005;c.inputState.pinching&&p>g+v?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&p<=g-v&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(a=t.getPose(e.gripSpace,s),a!==null&&(l.matrix.fromArray(a.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,a.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(a.linearVelocity)):l.hasLinearVelocity=!1,a.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(a.angularVelocity)):l.hasAngularVelocity=!1));o!==null&&(i=t.getPose(e.targetRaySpace,s),i===null&&a!==null&&(i=a),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(bY)))}return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=a!==null),c!==null&&(c.visible=r!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new ld;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class u2{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new $t(e),this.density=t}clone(){return new u2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class h2{constructor(e,t=1,s=1e3){this.isFog=!0,this.name="",this.color=new $t(e),this.near=t,this.far=s}clone(){return new h2(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class dy extends Ts{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new wl,this.environmentIntensity=1,this.environmentRotation=new wl,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class IS{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=X1,this.updateRanges=[],this.version=0,this.uuid=Sl()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let i=0,a=this.stride;i<a;i++)this.array[e+i]=t.array[s+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Sl()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Sl()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const mo=new ue;class $f{constructor(e,t,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)mo.fromBufferAttribute(this,t),mo.applyMatrix4(e),this.setXYZ(t,mo.x,mo.y,mo.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)mo.fromBufferAttribute(this,t),mo.applyNormalMatrix(e),this.setXYZ(t,mo.x,mo.y,mo.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)mo.fromBufferAttribute(this,t),mo.transformDirection(e),this.setXYZ(t,mo.x,mo.y,mo.z);return this}getComponent(e,t){let s=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(s=bo(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Xn(s,this.array)),this.data.array[e*this.data.stride+this.offset+t]=s,this}setX(e,t){return this.normalized&&(t=Xn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Xn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Xn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Xn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=bo(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=bo(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=bo(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=bo(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array),i=Xn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this}setXYZW(e,t,s,i,a){return e=e*this.data.stride+this.offset,this.normalized&&(t=Xn(t,this.array),s=Xn(s,this.array),i=Xn(i,this.array),a=Xn(a,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this.data.array[e+3]=a,this}clone(e){if(e===void 0){K1("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let a=0;a<this.itemSize;a++)t.push(this.data.array[i+a])}return new Es(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new $f(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){K1("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let a=0;a<this.itemSize;a++)t.push(this.data.array[i+a])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class cO extends Da{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new $t(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let ix;const r1=new ue,ax=new ue,rx=new ue,ox=new rt,o1=new rt,pG=new _n,uC=new ue,l1=new ue,hC=new ue,bU=new rt,rI=new rt,SU=new rt;class mG extends Ts{constructor(e=new cO){if(super(),this.isSprite=!0,this.type="Sprite",ix===void 0){ix=new Ln;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new IS(t,5);ix.setIndex([0,1,2,0,2,3]),ix.setAttribute("position",new $f(s,3,0,!1)),ix.setAttribute("uv",new $f(s,2,3,!1))}this.geometry=ix,this.material=e,this.center=new rt(.5,.5),this.count=1}raycast(e,t){e.camera===null&&On('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),ax.setFromMatrixScale(this.matrixWorld),pG.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),rx.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&ax.multiplyScalar(-rx.z);const s=this.material.rotation;let i,a;s!==0&&(a=Math.cos(s),i=Math.sin(s));const r=this.center;dC(uC.set(-.5,-.5,0),rx,r,ax,i,a),dC(l1.set(.5,-.5,0),rx,r,ax,i,a),dC(hC.set(.5,.5,0),rx,r,ax,i,a),bU.set(0,0),rI.set(1,0),SU.set(1,1);let o=e.ray.intersectTriangle(uC,l1,hC,!1,r1);if(o===null&&(dC(l1.set(-.5,.5,0),rx,r,ax,i,a),rI.set(0,1),o=e.ray.intersectTriangle(uC,hC,l1,!1,r1),o===null))return;const l=e.ray.origin.distanceTo(r1);l<e.near||l>e.far||t.push({distance:l,point:r1.clone(),uv:qo.getInterpolation(r1,uC,l1,hC,bU,rI,SU,new rt),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function dC(n,e,t,s,i,a){ox.subVectors(n,t).addScalar(.5).multiply(s),i!==void 0?(o1.x=a*ox.x-i*ox.y,o1.y=i*ox.x+a*ox.y):o1.copy(ox),n.copy(e),n.x+=o1.x,n.y+=o1.y,n.applyMatrix4(pG)}const fC=new ue,_U=new ue;class gG extends Ts{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let s=0,i=t.length;s<i;s++){const a=t[s];this.addLevel(a.object.clone(),a.distance,a.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,s=0){t=Math.abs(t);const i=this.levels;let a;for(a=0;a<i.length&&!(t<i[a].distance);a++);return i.splice(a,0,{distance:t,hysteresis:s,object:e}),this.add(e),this}removeLevel(e){const t=this.levels;for(let s=0;s<t.length;s++)if(t[s].distance===e){const i=t.splice(s,1);return this.remove(i[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let s,i;for(s=1,i=t.length;s<i;s++){let a=t[s].distance;if(t[s].object.visible&&(a-=a*t[s].hysteresis),e<a)break}return t[s-1].object}return null}raycast(e,t){if(this.levels.length>0){fC.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(fC);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){fC.setFromMatrixPosition(e.matrixWorld),_U.setFromMatrixPosition(this.matrixWorld);const s=fC.distanceTo(_U)/e.zoom;t[0].object.visible=!0;let i,a;for(i=1,a=t.length;i<a;i++){let r=t[i].distance;if(t[i].object.visible&&(r-=r*t[i].hysteresis),s>=r)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<a;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const s=this.levels;for(let i=0,a=s.length;i<a;i++){const r=s[i];t.object.levels.push({object:r.object.uuid,distance:r.distance,hysteresis:r.hysteresis})}return t}}const AU=new ue,wU=new Cs,CU=new Cs,SY=new ue,TU=new _n,pC=new ue,oI=new Qa,EU=new _n,lI=new Ag;class uO extends Ti{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=E3,this.bindMatrix=new _n,this.bindMatrixInverse=new _n,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new yr),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,pC),this.boundingBox.expandByPoint(pC)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Qa),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,pC),this.boundingSphere.expandByPoint(pC)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const s=this.material,i=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),oI.copy(this.boundingSphere),oI.applyMatrix4(i),e.ray.intersectsSphere(oI)!==!1&&(EU.copy(i).invert(),lI.copy(e.ray).applyMatrix4(EU),!(this.boundingBox!==null&&lI.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,lI)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Cs,t=this.geometry.attributes.skinWeight;for(let s=0,i=t.count;s<i;s++){e.fromBufferAttribute(t,s);const a=1/e.manhattanLength();a!==1/0?e.multiplyScalar(a):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===E3?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===W4?this.bindMatrixInverse.copy(this.bindMatrix).invert():Wt("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const s=this.skeleton,i=this.geometry;wU.fromBufferAttribute(i.attributes.skinIndex,e),CU.fromBufferAttribute(i.attributes.skinWeight,e),AU.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let a=0;a<4;a++){const r=CU.getComponent(a);if(r!==0){const o=wU.getComponent(a);TU.multiplyMatrices(s.bones[o].matrixWorld,s.boneInverses[o]),t.addScaledVector(SY.copy(AU).applyMatrix4(TU),r)}}return t.applyMatrix4(this.bindMatrixInverse)}}class d2 extends Ts{constructor(){super(),this.isBone=!0,this.type="Bone"}}class ac extends Vs{constructor(e=null,t=1,s=1,i,a,r,o,l,c=Ja,h=Ja,d,p){super(null,r,o,l,c,h,i,a,d,p),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const MU=new _n,_Y=new _n;class DS{constructor(e=[],t=[]){this.uuid=Sl(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){Wt("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,i=this.bones.length;s<i;s++)this.boneInverses.push(new _n)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new _n;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,i=this.boneTexture;for(let a=0,r=e.length;a<r;a++){const o=e[a]?e[a].matrixWorld:_Y;MU.multiplyMatrices(o,t[a]),MU.toArray(s,a*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new DS(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new ac(t,e,e,ra,wi);return s.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=s,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,i=e.bones.length;s<i;s++){const a=e.bones[s];let r=t[a];r===void 0&&(Wt("Skeleton: No bone found with UUID:",a),r=new d2),this.bones.push(r),this.boneInverses.push(new _n().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let i=0,a=t.length;i<a;i++){const r=t[i];e.bones.push(r.uuid);const o=s[i];e.boneInverses.push(o.toArray())}return e}}class ng extends Es{constructor(e,t,s,i=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const lx=new _n,NU=new _n,mC=[],RU=new yr,AY=new _n,c1=new Ti,u1=new Qa;class hO extends Ti{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new ng(new Float32Array(s*16),16),this.instanceColor=null,this.morphTexture=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<s;i++)this.setMatrixAt(i,AY)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new yr),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,lx),RU.copy(e.boundingBox).applyMatrix4(lx),this.boundingBox.union(RU)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new Qa),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,lx),u1.copy(e.boundingSphere).applyMatrix4(lx),this.boundingSphere.union(u1)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const s=t.morphTargetInfluences,i=this.morphTexture.source.data.data,a=s.length+1,r=e*a+1;for(let o=0;o<s.length;o++)s[o]=i[r+o]}raycast(e,t){const s=this.matrixWorld,i=this.count;if(c1.geometry=this.geometry,c1.material=this.material,c1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),u1.copy(this.boundingSphere),u1.applyMatrix4(s),e.ray.intersectsSphere(u1)!==!1))for(let a=0;a<i;a++){this.getMatrixAt(a,lx),NU.multiplyMatrices(s,lx),c1.matrixWorld=NU,c1.raycast(e,mC);for(let r=0,o=mC.length;r<o;r++){const l=mC[r];l.instanceId=a,l.object=this,t.push(l)}mC.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new ng(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const s=t.morphTargetInfluences,i=s.length+1;this.morphTexture===null&&(this.morphTexture=new ac(new Float32Array(i*this.count),i,this.count,ES,wi));const a=this.morphTexture.source.data.data;let r=0;for(let c=0;c<s.length;c++)r+=s[c];const o=this.geometry.morphTargetsRelative?1:1-r,l=i*e;a[l]=o,a.set(s,l+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const cI=new ue,wY=new ue,CY=new Vn;class Vu{constructor(e=new ue(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,i){return this.normal.set(e,t,s),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const i=cI.subVectors(s,t).cross(wY.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(cI),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const a=-(e.start.dot(this.normal)+this.constant)/i;return a<0||a>1?null:t.copy(e.start).addScaledVector(s,a)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||CY.getNormalMatrix(e),i=this.coplanarPoint(cI).applyMatrix4(e),a=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(a),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const um=new Qa,TY=new rt(.5,.5),gC=new ue;class fy{constructor(e=new Vu,t=new Vu,s=new Vu,i=new Vu,a=new Vu,r=new Vu){this.planes=[e,t,s,i,a,r]}set(e,t,s,i,a,r){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(s),o[3].copy(i),o[4].copy(a),o[5].copy(r),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=yl,s=!1){const i=this.planes,a=e.elements,r=a[0],o=a[1],l=a[2],c=a[3],h=a[4],d=a[5],p=a[6],g=a[7],v=a[8],_=a[9],S=a[10],b=a[11],w=a[12],T=a[13],E=a[14],R=a[15];if(i[0].setComponents(c-r,g-h,b-v,R-w).normalize(),i[1].setComponents(c+r,g+h,b+v,R+w).normalize(),i[2].setComponents(c+o,g+d,b+_,R+T).normalize(),i[3].setComponents(c-o,g-d,b-_,R-T).normalize(),s)i[4].setComponents(l,p,S,E).normalize(),i[5].setComponents(c-l,g-p,b-S,R-E).normalize();else if(i[4].setComponents(c-l,g-p,b-S,R-E).normalize(),t===yl)i[5].setComponents(c+l,g+p,b+S,R+E).normalize();else if(t===Lx)i[5].setComponents(l,p,S,E).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),um.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),um.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(um)}intersectsSprite(e){um.center.set(0,0,0);const t=TY.distanceTo(e.center);return um.radius=.7071067811865476+t,um.applyMatrix4(e.matrixWorld),this.intersectsSphere(um)}intersectsSphere(e){const t=this.planes,s=e.center,i=-e.radius;for(let a=0;a<6;a++)if(t[a].distanceToPoint(s)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const i=t[s];if(gC.x=i.normal.x>0?e.max.x:e.min.x,gC.y=i.normal.y>0?e.max.y:e.min.y,gC.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(gC)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const $u=new _n,Gu=new fy;class f2{constructor(){this.coordinateSystem=yl}intersectsObject(e,t){if(!t.isArrayCamera||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if($u.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Gu.setFromProjectionMatrix($u,i.coordinateSystem,i.reversedDepth),Gu.intersectsObject(e))return!0}return!1}intersectsSprite(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if($u.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Gu.setFromProjectionMatrix($u,i.coordinateSystem,i.reversedDepth),Gu.intersectsSprite(e))return!0}return!1}intersectsSphere(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if($u.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Gu.setFromProjectionMatrix($u,i.coordinateSystem,i.reversedDepth),Gu.intersectsSphere(e))return!0}return!1}intersectsBox(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if($u.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Gu.setFromProjectionMatrix($u,i.coordinateSystem,i.reversedDepth),Gu.intersectsBox(e))return!0}return!1}containsPoint(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let s=0;s<t.cameras.length;s++){const i=t.cameras[s];if($u.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),Gu.setFromProjectionMatrix($u,i.coordinateSystem,i.reversedDepth),Gu.containsPoint(e))return!0}return!1}clone(){return new f2}}function uI(n,e){return n-e}function EY(n,e){return n.z-e.z}function MY(n,e){return e.z-n.z}class NY{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t,s,i){const a=this.pool,r=this.list;this.index>=a.length&&a.push({start:-1,count:-1,z:-1,index:-1});const o=a[this.index];r.push(o),this.index++,o.start=e,o.count=t,o.z=s,o.index=i}reset(){this.list.length=0,this.index=0}}const Vo=new _n,RY=new $t(1,1,1),IU=new fy,IY=new f2,xC=new yr,hm=new Qa,h1=new ue,DU=new ue,DY=new ue,hI=new NY,Ur=new Ti,yC=[];function OY(n,e,t=0){const s=e.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==e.array.constructor){const i=n.count;for(let a=0;a<i;a++)for(let r=0;r<s;r++)e.setComponent(a+t,r,n.getComponent(a,r))}else e.array.set(n.array,t*s);e.needsUpdate=!0}function dm(n,e){if(n.constructor!==e.constructor){const t=Math.min(n.length,e.length);for(let s=0;s<t;s++)e[s]=n[s]}else{const t=Math.min(n.length,e.length);e.set(new n.constructor(n.buffer,0,t))}}class xG extends Ti{constructor(e,t,s=t*2,i){super(new Ln,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=t,this._maxIndexCount=s,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),s=new ac(t,e,e,ra,wi);this._matricesTexture=s}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Uint32Array(e*e),s=new ac(t,e,e,MS,rh);this._indirectTexture=s}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Float32Array(e*e*4).fill(1),s=new ac(t,e,e,ra,wi);s.colorSpace=ws.workingColorSpace,this._colorsTexture=s}_initializeGeometry(e){const t=this.geometry,s=this._maxVertexCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const a in e.attributes){const r=e.getAttribute(a),{array:o,itemSize:l,normalized:c}=r,h=new o.constructor(s*l),d=new Es(h,l,c);t.setAttribute(a,d)}if(e.getIndex()!==null){const a=s>65535?new Uint32Array(i):new Uint16Array(i);t.setIndex(new Es(a,1))}this._geometryInitialized=!0}}_validateGeometry(e){const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const s in t.attributes){if(!e.hasAttribute(s))throw new Error(`THREE.BatchedMesh: Added geometry missing "${s}". All geometries must have consistent attributes.`);const i=e.getAttribute(s),a=t.getAttribute(s);if(i.itemSize!==a.itemSize||i.normalized!==a.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const t=this._instanceInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const t=this._geometryInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new yr);const e=this.boundingBox,t=this._instanceInfo;e.makeEmpty();for(let s=0,i=t.length;s<i;s++){if(t[s].active===!1)continue;const a=t[s].geometryIndex;this.getMatrixAt(s,Vo),this.getBoundingBoxAt(a,xC).applyMatrix4(Vo),e.union(xC)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Qa);const e=this.boundingSphere,t=this._instanceInfo;e.makeEmpty();for(let s=0,i=t.length;s<i;s++){if(t[s].active===!1)continue;const a=t[s].geometryIndex;this.getMatrixAt(s,Vo),this.getBoundingSphereAt(a,hm).applyMatrix4(Vo),e.union(hm)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const s={visible:!0,active:!0,geometryIndex:e};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(uI),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=s):(i=this._instanceInfo.length,this._instanceInfo.push(s));const a=this._matricesTexture;Vo.identity().toArray(a.image.data,i*16),a.needsUpdate=!0;const r=this._colorsTexture;return r&&(RY.toArray(r.image.data,i*4),r.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(e,t=-1,s=-1){this._initializeGeometry(e),this._validateGeometry(e);const i={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},a=this._geometryInfo;i.vertexStart=this._nextVertexStart,i.reservedVertexCount=t===-1?e.getAttribute("position").count:t;const r=e.getIndex();if(r!==null&&(i.indexStart=this._nextIndexStart,i.reservedIndexCount=s===-1?r.count:s),i.indexStart!==-1&&i.indexStart+i.reservedIndexCount>this._maxIndexCount||i.vertexStart+i.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let l;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(uI),l=this._availableGeometryIds.shift(),a[l]=i):(l=this._geometryCount,this._geometryCount++,a.push(i)),this.setGeometryAt(l,e),this._nextIndexStart=i.indexStart+i.reservedIndexCount,this._nextVertexStart=i.vertexStart+i.reservedVertexCount,l}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const s=this.geometry,i=s.getIndex()!==null,a=s.getIndex(),r=t.getIndex(),o=this._geometryInfo[e];if(i&&r.count>o.reservedIndexCount||t.attributes.position.count>o.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const l=o.vertexStart,c=o.reservedVertexCount;o.vertexCount=t.getAttribute("position").count;for(const h in s.attributes){const d=t.getAttribute(h),p=s.getAttribute(h);OY(d,p,l);const g=d.itemSize;for(let v=d.count,_=c;v<_;v++){const S=l+v;for(let b=0;b<g;b++)p.setComponent(S,b,0)}p.needsUpdate=!0,p.addUpdateRange(l*g,c*g)}if(i){const h=o.indexStart,d=o.reservedIndexCount;o.indexCount=t.getIndex().count;for(let p=0;p<r.count;p++)a.setX(h+p,l+r.getX(p));for(let p=r.count,g=d;p<g;p++)a.setX(h+p,l);a.needsUpdate=!0,a.addUpdateRange(h,o.reservedIndexCount)}return o.start=i?o.indexStart:o.vertexStart,o.count=i?o.indexCount:o.vertexCount,o.boundingBox=null,t.boundingBox!==null&&(o.boundingBox=t.boundingBox.clone()),o.boundingSphere=null,t.boundingSphere!==null&&(o.boundingSphere=t.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._geometryInfo;if(e>=t.length||t[e].active===!1)return this;const s=this._instanceInfo;for(let i=0,a=s.length;i<a;i++)s[i].active&&s[i].geometryIndex===e&&this.deleteInstance(i);return t[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,t=0;const s=this._geometryInfo,i=s.map((r,o)=>o).sort((r,o)=>s[r].vertexStart-s[o].vertexStart),a=this.geometry;for(let r=0,o=s.length;r<o;r++){const l=i[r],c=s[l];if(c.active!==!1){if(a.index!==null){if(c.indexStart!==t){const{indexStart:h,vertexStart:d,reservedIndexCount:p}=c,g=a.index,v=g.array,_=e-d;for(let S=h;S<h+p;S++)v[S]=v[S]+_;g.array.copyWithin(t,h,h+p),g.addUpdateRange(t,p),c.indexStart=t}t+=c.reservedIndexCount}if(c.vertexStart!==e){const{vertexStart:h,reservedVertexCount:d}=c,p=a.attributes;for(const g in p){const v=p[g],{array:_,itemSize:S}=v;_.copyWithin(e*S,h*S,(h+d)*S),v.addUpdateRange(e*S,d*S)}c.vertexStart=e}e+=c.reservedVertexCount,c.start=a.index?c.indexStart:c.vertexStart,this._nextIndexStart=a.index?c.indexStart+c.reservedIndexCount:0,this._nextVertexStart=c.vertexStart+c.reservedVertexCount}}return this}getBoundingBoxAt(e,t){if(e>=this._geometryCount)return null;const s=this.geometry,i=this._geometryInfo[e];if(i.boundingBox===null){const a=new yr,r=s.index,o=s.attributes.position;for(let l=i.start,c=i.start+i.count;l<c;l++){let h=l;r&&(h=r.getX(h)),a.expandByPoint(h1.fromBufferAttribute(o,h))}i.boundingBox=a}return t.copy(i.boundingBox),t}getBoundingSphereAt(e,t){if(e>=this._geometryCount)return null;const s=this.geometry,i=this._geometryInfo[e];if(i.boundingSphere===null){const a=new Qa;this.getBoundingBoxAt(e,xC),xC.getCenter(a.center);const r=s.index,o=s.attributes.position;let l=0;for(let c=i.start,h=i.start+i.count;c<h;c++){let d=c;r&&(d=r.getX(d)),h1.fromBufferAttribute(o,d),l=Math.max(l,a.center.distanceToSquared(h1))}a.radius=Math.sqrt(l),i.boundingSphere=a}return t.copy(i.boundingSphere),t}setMatrixAt(e,t){this.validateInstanceId(e);const s=this._matricesTexture,i=this._matricesTexture.image.data;return t.toArray(i,e*16),s.needsUpdate=!0,this}getMatrixAt(e,t){return this.validateInstanceId(e),t.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,t){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),t.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,t){return this.validateInstanceId(e),t.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,t){return this.validateInstanceId(e),this._instanceInfo[e].visible===t?this:(this._instanceInfo[e].visible=t,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,t){return this.validateInstanceId(e),this.validateGeometryId(t),this._instanceInfo[e].geometryIndex=t,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,t={}){this.validateGeometryId(e);const s=this._geometryInfo[e];return t.vertexStart=s.vertexStart,t.vertexCount=s.vertexCount,t.reservedVertexCount=s.reservedVertexCount,t.indexStart=s.indexStart,t.indexCount=s.indexCount,t.reservedIndexCount=s.reservedIndexCount,t.start=s.start,t.count=s.count,t}setInstanceCount(e){const t=this._availableInstanceIds,s=this._instanceInfo;for(t.sort(uI);t[t.length-1]===s.length-1;)s.pop(),t.pop();if(e<s.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const i=new Int32Array(e),a=new Int32Array(e);dm(this._multiDrawCounts,i),dm(this._multiDrawStarts,a),this._multiDrawCounts=i,this._multiDrawStarts=a,this._maxInstanceCount=e;const r=this._indirectTexture,o=this._matricesTexture,l=this._colorsTexture;r.dispose(),this._initIndirectTexture(),dm(r.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),dm(o.image.data,this._matricesTexture.image.data),l&&(l.dispose(),this._initColorsTexture(),dm(l.image.data,this._colorsTexture.image.data))}setGeometrySize(e,t){const s=[...this._geometryInfo].filter(o=>o.active);if(Math.max(...s.map(o=>o.vertexStart+o.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...s.map(l=>l.indexStart+l.reservedIndexCount))>t)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);const a=this.geometry;a.dispose(),this._maxVertexCount=e,this._maxIndexCount=t,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new Ln,this._initializeGeometry(a));const r=this.geometry;a.index&&dm(a.index.array,r.index.array);for(const o in a.attributes)dm(a.attributes[o].array,r.attributes[o].array)}raycast(e,t){const s=this._instanceInfo,i=this._geometryInfo,a=this.matrixWorld,r=this.geometry;Ur.material=this.material,Ur.geometry.index=r.index,Ur.geometry.attributes=r.attributes,Ur.geometry.boundingBox===null&&(Ur.geometry.boundingBox=new yr),Ur.geometry.boundingSphere===null&&(Ur.geometry.boundingSphere=new Qa);for(let o=0,l=s.length;o<l;o++){if(!s[o].visible||!s[o].active)continue;const c=s[o].geometryIndex,h=i[c];Ur.geometry.setDrawRange(h.start,h.count),this.getMatrixAt(o,Ur.matrixWorld).premultiply(a),this.getBoundingBoxAt(c,Ur.geometry.boundingBox),this.getBoundingSphereAt(c,Ur.geometry.boundingSphere),Ur.raycast(e,yC);for(let d=0,p=yC.length;d<p;d++){const g=yC[d];g.object=this,g.batchId=o,t.push(g)}yC.length=0}Ur.material=null,Ur.geometry.index=null,Ur.geometry.attributes={},Ur.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox!==null?t.boundingBox.clone():null,boundingSphere:t.boundingSphere!==null?t.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(t=>({...t})),this._availableInstanceIds=e._availableInstanceIds.slice(),this._availableGeometryIds=e._availableGeometryIds.slice(),this._nextIndexStart=e._nextIndexStart,this._nextVertexStart=e._nextVertexStart,this._geometryCount=e._geometryCount,this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._indirectTexture=e._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(e,t,s,i,a){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const r=i.getIndex(),o=r===null?1:r.array.BYTES_PER_ELEMENT,l=this._instanceInfo,c=this._multiDrawStarts,h=this._multiDrawCounts,d=this._geometryInfo,p=this.perObjectFrustumCulled,g=this._indirectTexture,v=g.image.data,_=s.isArrayCamera?IY:IU;p&&!s.isArrayCamera&&(Vo.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse).multiply(this.matrixWorld),IU.setFromProjectionMatrix(Vo,s.coordinateSystem,s.reversedDepth));let S=0;if(this.sortObjects){Vo.copy(this.matrixWorld).invert(),h1.setFromMatrixPosition(s.matrixWorld).applyMatrix4(Vo),DU.set(0,0,-1).transformDirection(s.matrixWorld).transformDirection(Vo);for(let T=0,E=l.length;T<E;T++)if(l[T].visible&&l[T].active){const R=l[T].geometryIndex;this.getMatrixAt(T,Vo),this.getBoundingSphereAt(R,hm).applyMatrix4(Vo);let D=!1;if(p&&(D=!_.intersectsSphere(hm,s)),!D){const F=d[R],U=DY.subVectors(hm.center,h1).dot(DU);hI.push(F.start,F.count,U,T)}}const b=hI.list,w=this.customSort;w===null?b.sort(a.transparent?MY:EY):w.call(this,b,s);for(let T=0,E=b.length;T<E;T++){const R=b[T];c[S]=R.start*o,h[S]=R.count,v[S]=R.index,S++}hI.reset()}else for(let b=0,w=l.length;b<w;b++)if(l[b].visible&&l[b].active){const T=l[b].geometryIndex;let E=!1;if(p&&(this.getMatrixAt(b,Vo),this.getBoundingSphereAt(T,hm).applyMatrix4(Vo),E=!_.intersectsSphere(hm,s)),!E){const R=d[T];c[S]=R.start*o,h[S]=R.count,v[S]=b,S++}}g.needsUpdate=!0,this._multiDrawCount=S,this._visibilityChanged=!1}onBeforeShadow(e,t,s,i,a,r){this.onBeforeRender(e,null,i,a,r)}}class qr extends Da{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new $t(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const cE=new ue,uE=new ue,OU=new _n,d1=new Ag,vC=new Qa,dI=new ue,BU=new ue;class pd extends Ts{constructor(e=new Ln,t=new qr){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let i=1,a=t.count;i<a;i++)cE.fromBufferAttribute(t,i-1),uE.fromBufferAttribute(t,i),s[i]=s[i-1],s[i]+=cE.distanceTo(uE);e.setAttribute("lineDistance",new on(s,1))}else Wt("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,a=e.params.Line.threshold,r=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),vC.copy(s.boundingSphere),vC.applyMatrix4(i),vC.radius+=a,e.ray.intersectsSphere(vC)===!1)return;OU.copy(i).invert(),d1.copy(e.ray).applyMatrix4(OU);const o=a/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=this.isLineSegments?2:1,h=s.index,p=s.attributes.position;if(h!==null){const g=Math.max(0,r.start),v=Math.min(h.count,r.start+r.count);for(let _=g,S=v-1;_<S;_+=c){const b=h.getX(_),w=h.getX(_+1),T=bC(this,e,d1,l,b,w,_);T&&t.push(T)}if(this.isLineLoop){const _=h.getX(v-1),S=h.getX(g),b=bC(this,e,d1,l,_,S,v-1);b&&t.push(b)}}else{const g=Math.max(0,r.start),v=Math.min(p.count,r.start+r.count);for(let _=g,S=v-1;_<S;_+=c){const b=bC(this,e,d1,l,_,_+1,_);b&&t.push(b)}if(this.isLineLoop){const _=bC(this,e,d1,l,v-1,g,v-1);_&&t.push(_)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,r=i.length;a<r;a++){const o=i[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=a}}}}}function bC(n,e,t,s,i,a,r){const o=n.geometry.attributes.position;if(cE.fromBufferAttribute(o,i),uE.fromBufferAttribute(o,a),t.distanceSqToSegment(cE,uE,dI,BU)>s)return;dI.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(dI);if(!(c<e.near||c>e.far))return{distance:c,point:BU.clone().applyMatrix4(n.matrixWorld),index:r,face:null,faceIndex:null,barycoord:null,object:n}}const kU=new ue,LU=new ue;class iu extends pd{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let i=0,a=t.count;i<a;i+=2)kU.fromBufferAttribute(t,i),LU.fromBufferAttribute(t,i+1),s[i]=i===0?0:s[i-1],s[i+1]=s[i]+kU.distanceTo(LU);e.setAttribute("lineDistance",new on(s,1))}else Wt("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class dO extends pd{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class p2 extends Da{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new $t(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const FU=new _n,I3=new Ag,SC=new Qa,_C=new ue;class fO extends Ts{constructor(e=new Ln,t=new p2){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,a=e.params.Points.threshold,r=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),SC.copy(s.boundingSphere),SC.applyMatrix4(i),SC.radius+=a,e.ray.intersectsSphere(SC)===!1)return;FU.copy(i).invert(),I3.copy(e.ray).applyMatrix4(FU);const o=a/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=s.index,d=s.attributes.position;if(c!==null){const p=Math.max(0,r.start),g=Math.min(c.count,r.start+r.count);for(let v=p,_=g;v<_;v++){const S=c.getX(v);_C.fromBufferAttribute(d,S),UU(_C,S,l,i,e,t,this)}}else{const p=Math.max(0,r.start),g=Math.min(d.count,r.start+r.count);for(let v=p,_=g;v<_;v++)_C.fromBufferAttribute(d,v),UU(_C,v,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let a=0,r=i.length;a<r;a++){const o=i[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=a}}}}}function UU(n,e,t,s,i,a,r){const o=I3.distanceSqToPoint(n);if(o<t){const l=new ue;I3.closestPointToPoint(n,l),l.applyMatrix4(s);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;a.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,faceIndex:null,barycoord:null,object:r})}}class yG extends Vs{constructor(e,t,s,i,a=is,r=is,o,l,c){super(e,t,s,i,a,r,o,l,c),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const h=this;function d(){h.needsUpdate=!0,h._requestVideoFrameCallbackId=e.requestVideoFrameCallback(d)}"requestVideoFrameCallback"in e&&(this._requestVideoFrameCallbackId=e.requestVideoFrameCallback(d))}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){this._requestVideoFrameCallbackId!==0&&(this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),this._requestVideoFrameCallbackId=0),super.dispose()}}class BY extends yG{constructor(e,t,s,i,a,r,o,l){super({},e,t,s,i,a,r,o,l),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class kY extends Vs{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=Ja,this.minFilter=Ja,this.generateMipmaps=!1,this.needsUpdate=!0}}class m2 extends Vs{constructor(e,t,s,i,a,r,o,l,c,h,d,p){super(null,r,o,l,c,h,i,a,d,p),this.isCompressedTexture=!0,this.image={width:t,height:s},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class LY extends m2{constructor(e,t,s,i,a,r){super(e,t,s,a,r),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=Fi,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class FY extends m2{constructor(e,t,s){super(void 0,e[0].width,e[0].height,t,s,ah),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class UY extends Vs{constructor(e,t,s,i,a,r,o,l,c){super(e,t,s,i,a,r,o,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class OS extends Vs{constructor(e,t,s=rh,i,a,r,o=Ja,l=Ja,c,h=tg,d=1){if(h!==tg&&h!==Ox)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const p={width:e,height:t,depth:d};super(p,i,a,r,o,l,h,s,c),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new Ef(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class pO extends Vs{constructor(e=null){super(),this.sourceTexture=e,this.isExternalTexture=!0}copy(e){return super.copy(e),this.sourceTexture=e.sourceTexture,this}}class g2 extends Ln{constructor(e=1,t=1,s=4,i=8,a=1){super(),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:s,radialSegments:i,heightSegments:a},t=Math.max(0,t),s=Math.max(1,Math.floor(s)),i=Math.max(3,Math.floor(i)),a=Math.max(1,Math.floor(a));const r=[],o=[],l=[],c=[],h=t/2,d=Math.PI/2*e,p=t,g=2*d+p,v=s*2+a,_=i+1,S=new ue,b=new ue;for(let w=0;w<=v;w++){let T=0,E=0,R=0,D=0;if(w<=s){const O=w/s,B=O*Math.PI/2;E=-h-e*Math.cos(B),R=e*Math.sin(B),D=-e*Math.cos(B),T=O*d}else if(w<=s+a){const O=(w-s)/a;E=-h+O*t,R=e,D=0,T=d+O*p}else{const O=(w-s-a)/s,B=O*Math.PI/2;E=h+e*Math.sin(B),R=e*Math.cos(B),D=e*Math.sin(B),T=d+p+O*d}const F=Math.max(0,Math.min(1,T/g));let U=0;w===0?U=.5/i:w===v&&(U=-.5/i);for(let O=0;O<=i;O++){const B=O/i,L=B*Math.PI*2,H=Math.sin(L),K=Math.cos(L);b.x=-R*K,b.y=E,b.z=R*H,o.push(b.x,b.y,b.z),S.set(-R*K,D,R*H),S.normalize(),l.push(S.x,S.y,S.z),c.push(B+U,F)}if(w>0){const O=(w-1)*_;for(let B=0;B<i;B++){const L=O+B,H=O+B+1,K=w*_+B,Z=w*_+B+1;r.push(L,H,K),r.push(H,Z,K)}}}this.setIndex(r),this.setAttribute("position",new on(o,3)),this.setAttribute("normal",new on(l,3)),this.setAttribute("uv",new on(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new g2(e.radius,e.height,e.capSegments,e.radialSegments,e.heightSegments)}}class x2 extends Ln{constructor(e=1,t=32,s=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:s,thetaLength:i},t=Math.max(3,t);const a=[],r=[],o=[],l=[],c=new ue,h=new rt;r.push(0,0,0),o.push(0,0,1),l.push(.5,.5);for(let d=0,p=3;d<=t;d++,p+=3){const g=s+d/t*i;c.x=e*Math.cos(g),c.y=e*Math.sin(g),r.push(c.x,c.y,c.z),o.push(0,0,1),h.x=(r[p]/e+1)/2,h.y=(r[p+1]/e+1)/2,l.push(h.x,h.y)}for(let d=1;d<=t;d++)a.push(d,d+1,0);this.setIndex(a),this.setAttribute("position",new on(r,3)),this.setAttribute("normal",new on(o,3)),this.setAttribute("uv",new on(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new x2(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class BS extends Ln{constructor(e=1,t=1,s=1,i=32,a=1,r=!1,o=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:s,radialSegments:i,heightSegments:a,openEnded:r,thetaStart:o,thetaLength:l};const c=this;i=Math.floor(i),a=Math.floor(a);const h=[],d=[],p=[],g=[];let v=0;const _=[],S=s/2;let b=0;w(),r===!1&&(e>0&&T(!0),t>0&&T(!1)),this.setIndex(h),this.setAttribute("position",new on(d,3)),this.setAttribute("normal",new on(p,3)),this.setAttribute("uv",new on(g,2));function w(){const E=new ue,R=new ue;let D=0;const F=(t-e)/s;for(let U=0;U<=a;U++){const O=[],B=U/a,L=B*(t-e)+e;for(let H=0;H<=i;H++){const K=H/i,Z=K*l+o,Q=Math.sin(Z),P=Math.cos(Z);R.x=L*Q,R.y=-B*s+S,R.z=L*P,d.push(R.x,R.y,R.z),E.set(Q,F,P).normalize(),p.push(E.x,E.y,E.z),g.push(K,1-B),O.push(v++)}_.push(O)}for(let U=0;U<i;U++)for(let O=0;O<a;O++){const B=_[O][U],L=_[O+1][U],H=_[O+1][U+1],K=_[O][U+1];(e>0||O!==0)&&(h.push(B,L,K),D+=3),(t>0||O!==a-1)&&(h.push(L,H,K),D+=3)}c.addGroup(b,D,0),b+=D}function T(E){const R=v,D=new rt,F=new ue;let U=0;const O=E===!0?e:t,B=E===!0?1:-1;for(let H=1;H<=i;H++)d.push(0,S*B,0),p.push(0,B,0),g.push(.5,.5),v++;const L=v;for(let H=0;H<=i;H++){const Z=H/i*l+o,Q=Math.cos(Z),P=Math.sin(Z);F.x=O*P,F.y=S*B,F.z=O*Q,d.push(F.x,F.y,F.z),p.push(0,B,0),D.x=Q*.5+.5,D.y=P*.5*B+.5,g.push(D.x,D.y),v++}for(let H=0;H<i;H++){const K=R+H,Z=L+H;E===!0?h.push(Z,Z+1,K):h.push(Z+1,Z,K),U+=3}c.addGroup(b,U,E===!0?1:2),b+=U}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new BS(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class kS extends BS{constructor(e=1,t=1,s=32,i=1,a=!1,r=0,o=Math.PI*2){super(0,e,t,s,i,a,r,o),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:s,heightSegments:i,openEnded:a,thetaStart:r,thetaLength:o}}static fromJSON(e){return new kS(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class np extends Ln{constructor(e=[],t=[],s=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:s,detail:i};const a=[],r=[];o(i),c(s),h(),this.setAttribute("position",new on(a,3)),this.setAttribute("normal",new on(a.slice(),3)),this.setAttribute("uv",new on(r,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function o(w){const T=new ue,E=new ue,R=new ue;for(let D=0;D<t.length;D+=3)g(t[D+0],T),g(t[D+1],E),g(t[D+2],R),l(T,E,R,w)}function l(w,T,E,R){const D=R+1,F=[];for(let U=0;U<=D;U++){F[U]=[];const O=w.clone().lerp(E,U/D),B=T.clone().lerp(E,U/D),L=D-U;for(let H=0;H<=L;H++)H===0&&U===D?F[U][H]=O:F[U][H]=O.clone().lerp(B,H/L)}for(let U=0;U<D;U++)for(let O=0;O<2*(D-U)-1;O++){const B=Math.floor(O/2);O%2===0?(p(F[U][B+1]),p(F[U+1][B]),p(F[U][B])):(p(F[U][B+1]),p(F[U+1][B+1]),p(F[U+1][B]))}}function c(w){const T=new ue;for(let E=0;E<a.length;E+=3)T.x=a[E+0],T.y=a[E+1],T.z=a[E+2],T.normalize().multiplyScalar(w),a[E+0]=T.x,a[E+1]=T.y,a[E+2]=T.z}function h(){const w=new ue;for(let T=0;T<a.length;T+=3){w.x=a[T+0],w.y=a[T+1],w.z=a[T+2];const E=S(w)/2/Math.PI+.5,R=b(w)/Math.PI+.5;r.push(E,1-R)}v(),d()}function d(){for(let w=0;w<r.length;w+=6){const T=r[w+0],E=r[w+2],R=r[w+4],D=Math.max(T,E,R),F=Math.min(T,E,R);D>.9&&F<.1&&(T<.2&&(r[w+0]+=1),E<.2&&(r[w+2]+=1),R<.2&&(r[w+4]+=1))}}function p(w){a.push(w.x,w.y,w.z)}function g(w,T){const E=w*3;T.x=e[E+0],T.y=e[E+1],T.z=e[E+2]}function v(){const w=new ue,T=new ue,E=new ue,R=new ue,D=new rt,F=new rt,U=new rt;for(let O=0,B=0;O<a.length;O+=9,B+=6){w.set(a[O+0],a[O+1],a[O+2]),T.set(a[O+3],a[O+4],a[O+5]),E.set(a[O+6],a[O+7],a[O+8]),D.set(r[B+0],r[B+1]),F.set(r[B+2],r[B+3]),U.set(r[B+4],r[B+5]),R.copy(w).add(T).add(E).divideScalar(3);const L=S(R);_(D,B+0,w,L),_(F,B+2,T,L),_(U,B+4,E,L)}}function _(w,T,E,R){R<0&&w.x===1&&(r[T]=w.x-1),E.x===0&&E.z===0&&(r[T]=R/2/Math.PI+.5)}function S(w){return Math.atan2(w.z,-w.x)}function b(w){return Math.atan2(-w.y,Math.sqrt(w.x*w.x+w.z*w.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new np(e.vertices,e.indices,e.radius,e.details)}}class y2 extends np{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,i=1/s,a=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-s,0,-i,s,0,i,-s,0,i,s,-i,-s,0,-i,s,0,i,-s,0,i,s,0,-s,0,-i,s,0,-i,-s,0,i,s,0,i],r=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(a,r,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new y2(e.radius,e.detail)}}const AC=new ue,wC=new ue,fI=new ue,CC=new qo;class vG extends Ln{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),a=Math.cos(jm*t),r=e.getIndex(),o=e.getAttribute("position"),l=r?r.count:o.count,c=[0,0,0],h=["a","b","c"],d=new Array(3),p={},g=[];for(let v=0;v<l;v+=3){r?(c[0]=r.getX(v),c[1]=r.getX(v+1),c[2]=r.getX(v+2)):(c[0]=v,c[1]=v+1,c[2]=v+2);const{a:_,b:S,c:b}=CC;if(_.fromBufferAttribute(o,c[0]),S.fromBufferAttribute(o,c[1]),b.fromBufferAttribute(o,c[2]),CC.getNormal(fI),d[0]=`${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`,d[1]=`${Math.round(S.x*i)},${Math.round(S.y*i)},${Math.round(S.z*i)}`,d[2]=`${Math.round(b.x*i)},${Math.round(b.y*i)},${Math.round(b.z*i)}`,!(d[0]===d[1]||d[1]===d[2]||d[2]===d[0]))for(let w=0;w<3;w++){const T=(w+1)%3,E=d[w],R=d[T],D=CC[h[w]],F=CC[h[T]],U=`${E}_${R}`,O=`${R}_${E}`;O in p&&p[O]?(fI.dot(p[O].normal)<=a&&(g.push(D.x,D.y,D.z),g.push(F.x,F.y,F.z)),p[O]=null):U in p||(p[U]={index0:c[w],index1:c[T],normal:fI.clone()})}}for(const v in p)if(p[v]){const{index0:_,index1:S}=p[v];AC.fromBufferAttribute(o,_),wC.fromBufferAttribute(o,S),g.push(AC.x,AC.y,AC.z),g.push(wC.x,wC.y,wC.z)}this.setAttribute("position",new on(g,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class au{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){Wt("Curve: .getPoint() not implemented.")}getPointAt(e,t){const s=this.getUtoTmapping(e);return this.getPoint(s,t)}getPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return t}getSpacedPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPointAt(s/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let s,i=this.getPoint(0),a=0;t.push(0);for(let r=1;r<=e;r++)s=this.getPoint(r/e),a+=s.distanceTo(i),t.push(a),i=s;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t=null){const s=this.getLengths();let i=0;const a=s.length;let r;t?r=t:r=e*s[a-1];let o=0,l=a-1,c;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),c=s[i]-r,c<0)o=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,s[i]===r)return i/(a-1);const h=s[i],p=s[i+1]-h,g=(r-h)/p;return(i+g)/(a-1)}getTangent(e,t){let i=e-1e-4,a=e+1e-4;i<0&&(i=0),a>1&&(a=1);const r=this.getPoint(i),o=this.getPoint(a),l=t||(r.isVector2?new rt:new ue);return l.copy(o).sub(r).normalize(),l}getTangentAt(e,t){const s=this.getUtoTmapping(e);return this.getTangent(s,t)}computeFrenetFrames(e,t=!1){const s=new ue,i=[],a=[],r=[],o=new ue,l=new _n;for(let g=0;g<=e;g++){const v=g/e;i[g]=this.getTangentAt(v,new ue)}a[0]=new ue,r[0]=new ue;let c=Number.MAX_VALUE;const h=Math.abs(i[0].x),d=Math.abs(i[0].y),p=Math.abs(i[0].z);h<=c&&(c=h,s.set(1,0,0)),d<=c&&(c=d,s.set(0,1,0)),p<=c&&s.set(0,0,1),o.crossVectors(i[0],s).normalize(),a[0].crossVectors(i[0],o),r[0].crossVectors(i[0],a[0]);for(let g=1;g<=e;g++){if(a[g]=a[g-1].clone(),r[g]=r[g-1].clone(),o.crossVectors(i[g-1],i[g]),o.length()>Number.EPSILON){o.normalize();const v=Math.acos(Rn(i[g-1].dot(i[g]),-1,1));a[g].applyMatrix4(l.makeRotationAxis(o,v))}r[g].crossVectors(i[g],a[g])}if(t===!0){let g=Math.acos(Rn(a[0].dot(a[e]),-1,1));g/=e,i[0].dot(o.crossVectors(a[0],a[e]))>0&&(g=-g);for(let v=1;v<=e;v++)a[v].applyMatrix4(l.makeRotationAxis(i[v],g*v)),r[v].crossVectors(i[v],a[v])}return{tangents:i,normals:a,binormals:r}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class v2 extends au{constructor(e=0,t=0,s=1,i=1,a=0,r=Math.PI*2,o=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=s,this.yRadius=i,this.aStartAngle=a,this.aEndAngle=r,this.aClockwise=o,this.aRotation=l}getPoint(e,t=new rt){const s=t,i=Math.PI*2;let a=this.aEndAngle-this.aStartAngle;const r=Math.abs(a)<Number.EPSILON;for(;a<0;)a+=i;for(;a>i;)a-=i;a<Number.EPSILON&&(r?a=0:a=i),this.aClockwise===!0&&!r&&(a===i?a=-i:a=a-i);const o=this.aStartAngle+e*a;let l=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const h=Math.cos(this.aRotation),d=Math.sin(this.aRotation),p=l-this.aX,g=c-this.aY;l=p*h-g*d+this.aX,c=p*d+g*h+this.aY}return s.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class bG extends v2{constructor(e,t,s,i,a,r){super(e,t,s,s,i,a,r),this.isArcCurve=!0,this.type="ArcCurve"}}function mO(){let n=0,e=0,t=0,s=0;function i(a,r,o,l){n=a,e=o,t=-3*a+3*r-2*o-l,s=2*a-2*r+o+l}return{initCatmullRom:function(a,r,o,l,c){i(r,o,c*(o-a),c*(l-r))},initNonuniformCatmullRom:function(a,r,o,l,c,h,d){let p=(r-a)/c-(o-a)/(c+h)+(o-r)/h,g=(o-r)/h-(l-r)/(h+d)+(l-o)/d;p*=h,g*=h,i(r,o,p,g)},calc:function(a){const r=a*a,o=r*a;return n+e*a+t*r+s*o}}}const TC=new ue,pI=new mO,mI=new mO,gI=new mO;class SG extends au{constructor(e=[],t=!1,s="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=s,this.tension=i}getPoint(e,t=new ue){const s=t,i=this.points,a=i.length,r=(a-(this.closed?0:1))*e;let o=Math.floor(r),l=r-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/a)+1)*a:l===0&&o===a-1&&(o=a-2,l=1);let c,h;this.closed||o>0?c=i[(o-1)%a]:(TC.subVectors(i[0],i[1]).add(i[0]),c=TC);const d=i[o%a],p=i[(o+1)%a];if(this.closed||o+2<a?h=i[(o+2)%a]:(TC.subVectors(i[a-1],i[a-2]).add(i[a-1]),h=TC),this.curveType==="centripetal"||this.curveType==="chordal"){const g=this.curveType==="chordal"?.5:.25;let v=Math.pow(c.distanceToSquared(d),g),_=Math.pow(d.distanceToSquared(p),g),S=Math.pow(p.distanceToSquared(h),g);_<1e-4&&(_=1),v<1e-4&&(v=_),S<1e-4&&(S=_),pI.initNonuniformCatmullRom(c.x,d.x,p.x,h.x,v,_,S),mI.initNonuniformCatmullRom(c.y,d.y,p.y,h.y,v,_,S),gI.initNonuniformCatmullRom(c.z,d.z,p.z,h.z,v,_,S)}else this.curveType==="catmullrom"&&(pI.initCatmullRom(c.x,d.x,p.x,h.x,this.tension),mI.initCatmullRom(c.y,d.y,p.y,h.y,this.tension),gI.initCatmullRom(c.z,d.z,p.z,h.z,this.tension));return s.set(pI.calc(l),mI.calc(l),gI.calc(l)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(new ue().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function PU(n,e,t,s,i){const a=(s-e)*.5,r=(i-t)*.5,o=n*n,l=n*o;return(2*t-2*s+a+r)*l+(-3*t+3*s-2*a-r)*o+a*n+t}function PY(n,e){const t=1-n;return t*t*e}function zY(n,e){return 2*(1-n)*n*e}function $Y(n,e){return n*n*e}function U1(n,e,t,s){return PY(n,e)+zY(n,t)+$Y(n,s)}function GY(n,e){const t=1-n;return t*t*t*e}function VY(n,e){const t=1-n;return 3*t*t*n*e}function HY(n,e){return 3*(1-n)*n*n*e}function WY(n,e){return n*n*n*e}function P1(n,e,t,s,i){return GY(n,e)+VY(n,t)+HY(n,s)+WY(n,i)}class gO extends au{constructor(e=new rt,t=new rt,s=new rt,i=new rt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=s,this.v3=i}getPoint(e,t=new rt){const s=t,i=this.v0,a=this.v1,r=this.v2,o=this.v3;return s.set(P1(e,i.x,a.x,r.x,o.x),P1(e,i.y,a.y,r.y,o.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class _G extends au{constructor(e=new ue,t=new ue,s=new ue,i=new ue){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=s,this.v3=i}getPoint(e,t=new ue){const s=t,i=this.v0,a=this.v1,r=this.v2,o=this.v3;return s.set(P1(e,i.x,a.x,r.x,o.x),P1(e,i.y,a.y,r.y,o.y),P1(e,i.z,a.z,r.z,o.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class xO extends au{constructor(e=new rt,t=new rt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new rt){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new rt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class AG extends au{constructor(e=new ue,t=new ue){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new ue){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new ue){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class yO extends au{constructor(e=new rt,t=new rt,s=new rt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new rt){const s=t,i=this.v0,a=this.v1,r=this.v2;return s.set(U1(e,i.x,a.x,r.x),U1(e,i.y,a.y,r.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class vO extends au{constructor(e=new ue,t=new ue,s=new ue){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new ue){const s=t,i=this.v0,a=this.v1,r=this.v2;return s.set(U1(e,i.x,a.x,r.x),U1(e,i.y,a.y,r.y),U1(e,i.z,a.z,r.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class bO extends au{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new rt){const s=t,i=this.points,a=(i.length-1)*e,r=Math.floor(a),o=a-r,l=i[r===0?r:r-1],c=i[r],h=i[r>i.length-2?i.length-1:r+1],d=i[r>i.length-3?i.length-1:r+2];return s.set(PU(o,l.x,c.x,h.x,d.x),PU(o,l.y,c.y,h.y,d.y)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(new rt().fromArray(i))}return this}}var hE=Object.freeze({__proto__:null,ArcCurve:bG,CatmullRomCurve3:SG,CubicBezierCurve:gO,CubicBezierCurve3:_G,EllipseCurve:v2,LineCurve:xO,LineCurve3:AG,QuadraticBezierCurve:yO,QuadraticBezierCurve3:vO,SplineCurve:bO});class wG extends au{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const s=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new hE[s](t,e))}return this}getPoint(e,t){const s=e*this.getLength(),i=this.getCurveLengths();let a=0;for(;a<i.length;){if(i[a]>=s){const r=i[a]-s,o=this.curves[a],l=o.getLength(),c=l===0?0:1-r/l;return o.getPointAt(c,t)}a++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let s=0,i=this.curves.length;s<i;s++)t+=this.curves[s].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let s;for(let i=0,a=this.curves;i<a.length;i++){const r=a[i],o=r.isEllipseCurve?e*2:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?e*r.points.length:e,l=r.getPoints(o);for(let c=0;c<l.length;c++){const h=l[c];s&&s.equals(h)||(t.push(h),s=h)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,s=this.curves.length;t<s;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const i=e.curves[t];this.curves.push(new hE[i.type]().fromJSON(i))}return this}}class dE extends wG{constructor(e){super(),this.type="Path",this.currentPoint=new rt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,s=e.length;t<s;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const s=new xO(this.currentPoint.clone(),new rt(e,t));return this.curves.push(s),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,s,i){const a=new yO(this.currentPoint.clone(),new rt(e,t),new rt(s,i));return this.curves.push(a),this.currentPoint.set(s,i),this}bezierCurveTo(e,t,s,i,a,r){const o=new gO(this.currentPoint.clone(),new rt(e,t),new rt(s,i),new rt(a,r));return this.curves.push(o),this.currentPoint.set(a,r),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),s=new bO(t);return this.curves.push(s),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,s,i,a,r){const o=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+o,t+l,s,i,a,r),this}absarc(e,t,s,i,a,r){return this.absellipse(e,t,s,s,i,a,r),this}ellipse(e,t,s,i,a,r,o,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(e+c,t+h,s,i,a,r,o,l),this}absellipse(e,t,s,i,a,r,o,l){const c=new v2(e,t,s,i,a,r,o,l);if(this.curves.length>0){const d=c.getPoint(0);d.equals(this.currentPoint)||this.lineTo(d.x,d.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Xm extends dE{constructor(e){super(e),this.uuid=Sl(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let s=0,i=this.holes.length;s<i;s++)t[s]=this.holes[s].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,s=this.holes.length;t<s;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const i=e.holes[t];this.holes.push(new dE().fromJSON(i))}return this}}function jY(n,e,t=2){const s=e&&e.length,i=s?e[0]*t:n.length;let a=CG(n,0,i,t,!0);const r=[];if(!a||a.next===a.prev)return r;let o,l,c;if(s&&(a=JY(n,e,a,t)),n.length>80*t){o=n[0],l=n[1];let h=o,d=l;for(let p=t;p<i;p+=t){const g=n[p],v=n[p+1];g<o&&(o=g),v<l&&(l=v),g>h&&(h=g),v>d&&(d=v)}c=Math.max(h-o,d-l),c=c!==0?32767/c:0}return Y1(a,r,t,o,l,c,0),r}function CG(n,e,t,s,i){let a;if(i===lJ(n,e,t,s)>0)for(let r=e;r<t;r+=s)a=zU(r/s|0,n[r],n[r+1],a);else for(let r=t-s;r>=e;r-=s)a=zU(r/s|0,n[r],n[r+1],a);return a&&$x(a,a.next)&&(Z1(a),a=a.next),a}function sg(n,e){if(!n)return n;e||(e=n);let t=n,s;do if(s=!1,!t.steiner&&($x(t,t.next)||Li(t.prev,t,t.next)===0)){if(Z1(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function Y1(n,e,t,s,i,a,r){if(!n)return;!r&&a&&nJ(n,s,i,a);let o=n;for(;n.prev!==n.next;){const l=n.prev,c=n.next;if(a?qY(n,s,i,a):XY(n)){e.push(l.i,n.i,c.i),Z1(n),n=c.next,o=c.next;continue}if(n=c,n===o){r?r===1?(n=KY(sg(n),e),Y1(n,e,t,s,i,a,2)):r===2&&YY(n,e,t,s,i,a):Y1(sg(n),e,t,s,i,a,1);break}}}function XY(n){const e=n.prev,t=n,s=n.next;if(Li(e,t,s)>=0)return!1;const i=e.x,a=t.x,r=s.x,o=e.y,l=t.y,c=s.y,h=Math.min(i,a,r),d=Math.min(o,l,c),p=Math.max(i,a,r),g=Math.max(o,l,c);let v=s.next;for(;v!==e;){if(v.x>=h&&v.x<=p&&v.y>=d&&v.y<=g&&A1(i,o,a,l,r,c,v.x,v.y)&&Li(v.prev,v,v.next)>=0)return!1;v=v.next}return!0}function qY(n,e,t,s){const i=n.prev,a=n,r=n.next;if(Li(i,a,r)>=0)return!1;const o=i.x,l=a.x,c=r.x,h=i.y,d=a.y,p=r.y,g=Math.min(o,l,c),v=Math.min(h,d,p),_=Math.max(o,l,c),S=Math.max(h,d,p),b=D3(g,v,e,t,s),w=D3(_,S,e,t,s);let T=n.prevZ,E=n.nextZ;for(;T&&T.z>=b&&E&&E.z<=w;){if(T.x>=g&&T.x<=_&&T.y>=v&&T.y<=S&&T!==i&&T!==r&&A1(o,h,l,d,c,p,T.x,T.y)&&Li(T.prev,T,T.next)>=0||(T=T.prevZ,E.x>=g&&E.x<=_&&E.y>=v&&E.y<=S&&E!==i&&E!==r&&A1(o,h,l,d,c,p,E.x,E.y)&&Li(E.prev,E,E.next)>=0))return!1;E=E.nextZ}for(;T&&T.z>=b;){if(T.x>=g&&T.x<=_&&T.y>=v&&T.y<=S&&T!==i&&T!==r&&A1(o,h,l,d,c,p,T.x,T.y)&&Li(T.prev,T,T.next)>=0)return!1;T=T.prevZ}for(;E&&E.z<=w;){if(E.x>=g&&E.x<=_&&E.y>=v&&E.y<=S&&E!==i&&E!==r&&A1(o,h,l,d,c,p,E.x,E.y)&&Li(E.prev,E,E.next)>=0)return!1;E=E.nextZ}return!0}function KY(n,e){let t=n;do{const s=t.prev,i=t.next.next;!$x(s,i)&&EG(s,t,t.next,i)&&J1(s,i)&&J1(i,s)&&(e.push(s.i,t.i,i.i),Z1(t),Z1(t.next),t=n=i),t=t.next}while(t!==n);return sg(t)}function YY(n,e,t,s,i,a){let r=n;do{let o=r.next.next;for(;o!==r.prev;){if(r.i!==o.i&&aJ(r,o)){let l=MG(r,o);r=sg(r,r.next),l=sg(l,l.next),Y1(r,e,t,s,i,a,0),Y1(l,e,t,s,i,a,0);return}o=o.next}r=r.next}while(r!==n)}function JY(n,e,t,s){const i=[];for(let a=0,r=e.length;a<r;a++){const o=e[a]*s,l=a<r-1?e[a+1]*s:n.length,c=CG(n,o,l,s,!1);c===c.next&&(c.steiner=!0),i.push(iJ(c))}i.sort(ZY);for(let a=0;a<i.length;a++)t=QY(i[a],t);return t}function ZY(n,e){let t=n.x-e.x;if(t===0&&(t=n.y-e.y,t===0)){const s=(n.next.y-n.y)/(n.next.x-n.x),i=(e.next.y-e.y)/(e.next.x-e.x);t=s-i}return t}function QY(n,e){const t=eJ(n,e);if(!t)return e;const s=MG(t,n);return sg(s,s.next),sg(t,t.next)}function eJ(n,e){let t=e;const s=n.x,i=n.y;let a=-1/0,r;if($x(n,t))return t;do{if($x(n,t.next))return t.next;if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const d=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=s&&d>a&&(a=d,r=t.x<t.next.x?t:t.next,d===s))return r}t=t.next}while(t!==e);if(!r)return null;const o=r,l=r.x,c=r.y;let h=1/0;t=r;do{if(s>=t.x&&t.x>=l&&s!==t.x&&TG(i<c?s:a,i,l,c,i<c?a:s,i,t.x,t.y)){const d=Math.abs(i-t.y)/(s-t.x);J1(t,n)&&(d<h||d===h&&(t.x>r.x||t.x===r.x&&tJ(r,t)))&&(r=t,h=d)}t=t.next}while(t!==o);return r}function tJ(n,e){return Li(n.prev,n,e.prev)<0&&Li(e.next,n,n.next)<0}function nJ(n,e,t,s){let i=n;do i.z===0&&(i.z=D3(i.x,i.y,e,t,s)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==n);i.prevZ.nextZ=null,i.prevZ=null,sJ(i)}function sJ(n){let e,t=1;do{let s=n,i;n=null;let a=null;for(e=0;s;){e++;let r=s,o=0;for(let c=0;c<t&&(o++,r=r.nextZ,!!r);c++);let l=t;for(;o>0||l>0&&r;)o!==0&&(l===0||!r||s.z<=r.z)?(i=s,s=s.nextZ,o--):(i=r,r=r.nextZ,l--),a?a.nextZ=i:n=i,i.prevZ=a,a=i;s=r}a.nextZ=null,t*=2}while(e>1);return n}function D3(n,e,t,s,i){return n=(n-t)*i|0,e=(e-s)*i|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function iJ(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function TG(n,e,t,s,i,a,r,o){return(i-r)*(e-o)>=(n-r)*(a-o)&&(n-r)*(s-o)>=(t-r)*(e-o)&&(t-r)*(a-o)>=(i-r)*(s-o)}function A1(n,e,t,s,i,a,r,o){return!(n===r&&e===o)&&TG(n,e,t,s,i,a,r,o)}function aJ(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!rJ(n,e)&&(J1(n,e)&&J1(e,n)&&oJ(n,e)&&(Li(n.prev,n,e.prev)||Li(n,e.prev,e))||$x(n,e)&&Li(n.prev,n,n.next)>0&&Li(e.prev,e,e.next)>0)}function Li(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function $x(n,e){return n.x===e.x&&n.y===e.y}function EG(n,e,t,s){const i=MC(Li(n,e,t)),a=MC(Li(n,e,s)),r=MC(Li(t,s,n)),o=MC(Li(t,s,e));return!!(i!==a&&r!==o||i===0&&EC(n,t,e)||a===0&&EC(n,s,e)||r===0&&EC(t,n,s)||o===0&&EC(t,e,s))}function EC(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function MC(n){return n>0?1:n<0?-1:0}function rJ(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&EG(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function J1(n,e){return Li(n.prev,n,n.next)<0?Li(n,e,n.next)>=0&&Li(n,n.prev,e)>=0:Li(n,e,n.prev)<0||Li(n,n.next,e)<0}function oJ(n,e){let t=n,s=!1;const i=(n.x+e.x)/2,a=(n.y+e.y)/2;do t.y>a!=t.next.y>a&&t.next.y!==t.y&&i<(t.next.x-t.x)*(a-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==n);return s}function MG(n,e){const t=O3(n.i,n.x,n.y),s=O3(e.i,e.x,e.y),i=n.next,a=e.prev;return n.next=e,e.prev=n,t.next=i,i.prev=t,s.next=t,t.prev=s,a.next=s,s.prev=a,s}function zU(n,e,t,s){const i=O3(n,e,t);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function Z1(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function O3(n,e,t){return{i:n,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function lJ(n,e,t,s){let i=0;for(let a=e,r=t-s;a<t;a+=s)i+=(n[r]-n[a])*(n[a+1]+n[r+1]),r=a;return i}class cJ{static triangulate(e,t,s=2){return jY(e,t,s)}}class Xc{static area(e){const t=e.length;let s=0;for(let i=t-1,a=0;a<t;i=a++)s+=e[i].x*e[a].y-e[a].x*e[i].y;return s*.5}static isClockWise(e){return Xc.area(e)<0}static triangulateShape(e,t){const s=[],i=[],a=[];$U(e),GU(s,e);let r=e.length;t.forEach($U);for(let l=0;l<t.length;l++)i.push(r),r+=t[l].length,GU(s,t[l]);const o=cJ.triangulate(s,i);for(let l=0;l<o.length;l+=3)a.push(o.slice(l,l+3));return a}}function $U(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function GU(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class b2 extends Ln{constructor(e=new Xm([new rt(.5,.5),new rt(-.5,.5),new rt(-.5,-.5),new rt(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const s=this,i=[],a=[];for(let o=0,l=e.length;o<l;o++){const c=e[o];r(c)}this.setAttribute("position",new on(i,3)),this.setAttribute("uv",new on(a,2)),this.computeVertexNormals();function r(o){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,h=t.steps!==void 0?t.steps:1,d=t.depth!==void 0?t.depth:1;let p=t.bevelEnabled!==void 0?t.bevelEnabled:!0,g=t.bevelThickness!==void 0?t.bevelThickness:.2,v=t.bevelSize!==void 0?t.bevelSize:g-.1,_=t.bevelOffset!==void 0?t.bevelOffset:0,S=t.bevelSegments!==void 0?t.bevelSegments:3;const b=t.extrudePath,w=t.UVGenerator!==void 0?t.UVGenerator:uJ;let T,E=!1,R,D,F,U;b&&(T=b.getSpacedPoints(h),E=!0,p=!1,R=b.computeFrenetFrames(h,!1),D=new ue,F=new ue,U=new ue),p||(S=0,g=0,v=0,_=0);const O=o.extractPoints(c);let B=O.shape;const L=O.holes;if(!Xc.isClockWise(B)){B=B.reverse();for(let Je=0,oe=L.length;Je<oe;Je++){const Ze=L[Je];Xc.isClockWise(Ze)&&(L[Je]=Ze.reverse())}}function K(Je){const Ze=10000000000000001e-36;let it=Je[0];for(let ft=1;ft<=Je.length;ft++){const gt=ft%Je.length,Tt=Je[gt],Et=Tt.x-it.x,kt=Tt.y-it.y,ce=Et*Et+kt*kt,J=Math.max(Math.abs(Tt.x),Math.abs(Tt.y),Math.abs(it.x),Math.abs(it.y)),Ie=Ze*J*J;if(ce<=Ie){Je.splice(gt,1),ft--;continue}it=Tt}}K(B),L.forEach(K);const Z=L.length,Q=B;for(let Je=0;Je<Z;Je++){const oe=L[Je];B=B.concat(oe)}function P(Je,oe,Ze){return oe||On("ExtrudeGeometry: vec does not exist"),Je.clone().addScaledVector(oe,Ze)}const W=B.length;function q(Je,oe,Ze){let it,ft,gt;const Tt=Je.x-oe.x,Et=Je.y-oe.y,kt=Ze.x-Je.x,ce=Ze.y-Je.y,J=Tt*Tt+Et*Et,Ie=Tt*ce-Et*kt;if(Math.abs(Ie)>Number.EPSILON){const Ye=Math.sqrt(J),lt=Math.sqrt(kt*kt+ce*ce),Ve=oe.x-Et/Ye,Gt=oe.y+Tt/Ye,Lt=Ze.x-ce/lt,tn=Ze.y+kt/lt,Jt=((Lt-Ve)*ce-(tn-Gt)*kt)/(Tt*ce-Et*kt);it=Ve+Tt*Jt-Je.x,ft=Gt+Et*Jt-Je.y;const at=it*it+ft*ft;if(at<=2)return new rt(it,ft);gt=Math.sqrt(at/2)}else{let Ye=!1;Tt>Number.EPSILON?kt>Number.EPSILON&&(Ye=!0):Tt<-Number.EPSILON?kt<-Number.EPSILON&&(Ye=!0):Math.sign(Et)===Math.sign(ce)&&(Ye=!0),Ye?(it=-Et,ft=Tt,gt=Math.sqrt(J)):(it=Tt,ft=Et,gt=Math.sqrt(J/2))}return new rt(it/gt,ft/gt)}const se=[];for(let Je=0,oe=Q.length,Ze=oe-1,it=Je+1;Je<oe;Je++,Ze++,it++)Ze===oe&&(Ze=0),it===oe&&(it=0),se[Je]=q(Q[Je],Q[Ze],Q[it]);const le=[];let Y,re=se.concat();for(let Je=0,oe=Z;Je<oe;Je++){const Ze=L[Je];Y=[];for(let it=0,ft=Ze.length,gt=ft-1,Tt=it+1;it<ft;it++,gt++,Tt++)gt===ft&&(gt=0),Tt===ft&&(Tt=0),Y[it]=q(Ze[it],Ze[gt],Ze[Tt]);le.push(Y),re=re.concat(Y)}let he;if(S===0)he=Xc.triangulateShape(Q,L);else{const Je=[],oe=[];for(let Ze=0;Ze<S;Ze++){const it=Ze/S,ft=g*Math.cos(it*Math.PI/2),gt=v*Math.sin(it*Math.PI/2)+_;for(let Tt=0,Et=Q.length;Tt<Et;Tt++){const kt=P(Q[Tt],se[Tt],gt);nt(kt.x,kt.y,-ft),it===0&&Je.push(kt)}for(let Tt=0,Et=Z;Tt<Et;Tt++){const kt=L[Tt];Y=le[Tt];const ce=[];for(let J=0,Ie=kt.length;J<Ie;J++){const Ye=P(kt[J],Y[J],gt);nt(Ye.x,Ye.y,-ft),it===0&&ce.push(Ye)}it===0&&oe.push(ce)}}he=Xc.triangulateShape(Je,oe)}const me=he.length,Ne=v+_;for(let Je=0;Je<W;Je++){const oe=p?P(B[Je],re[Je],Ne):B[Je];E?(F.copy(R.normals[0]).multiplyScalar(oe.x),D.copy(R.binormals[0]).multiplyScalar(oe.y),U.copy(T[0]).add(F).add(D),nt(U.x,U.y,U.z)):nt(oe.x,oe.y,0)}for(let Je=1;Je<=h;Je++)for(let oe=0;oe<W;oe++){const Ze=p?P(B[oe],re[oe],Ne):B[oe];E?(F.copy(R.normals[Je]).multiplyScalar(Ze.x),D.copy(R.binormals[Je]).multiplyScalar(Ze.y),U.copy(T[Je]).add(F).add(D),nt(U.x,U.y,U.z)):nt(Ze.x,Ze.y,d/h*Je)}for(let Je=S-1;Je>=0;Je--){const oe=Je/S,Ze=g*Math.cos(oe*Math.PI/2),it=v*Math.sin(oe*Math.PI/2)+_;for(let ft=0,gt=Q.length;ft<gt;ft++){const Tt=P(Q[ft],se[ft],it);nt(Tt.x,Tt.y,d+Ze)}for(let ft=0,gt=L.length;ft<gt;ft++){const Tt=L[ft];Y=le[ft];for(let Et=0,kt=Tt.length;Et<kt;Et++){const ce=P(Tt[Et],Y[Et],it);E?nt(ce.x,ce.y+T[h-1].y,T[h-1].x+Ze):nt(ce.x,ce.y,d+Ze)}}}fe(),Te();function fe(){const Je=i.length/3;if(p){let oe=0,Ze=W*oe;for(let it=0;it<me;it++){const ft=he[it];yt(ft[2]+Ze,ft[1]+Ze,ft[0]+Ze)}oe=h+S*2,Ze=W*oe;for(let it=0;it<me;it++){const ft=he[it];yt(ft[0]+Ze,ft[1]+Ze,ft[2]+Ze)}}else{for(let oe=0;oe<me;oe++){const Ze=he[oe];yt(Ze[2],Ze[1],Ze[0])}for(let oe=0;oe<me;oe++){const Ze=he[oe];yt(Ze[0]+W*h,Ze[1]+W*h,Ze[2]+W*h)}}s.addGroup(Je,i.length/3-Je,0)}function Te(){const Je=i.length/3;let oe=0;Ge(Q,oe),oe+=Q.length;for(let Ze=0,it=L.length;Ze<it;Ze++){const ft=L[Ze];Ge(ft,oe),oe+=ft.length}s.addGroup(Je,i.length/3-Je,1)}function Ge(Je,oe){let Ze=Je.length;for(;--Ze>=0;){const it=Ze;let ft=Ze-1;ft<0&&(ft=Je.length-1);for(let gt=0,Tt=h+S*2;gt<Tt;gt++){const Et=W*gt,kt=W*(gt+1),ce=oe+it+Et,J=oe+ft+Et,Ie=oe+ft+kt,Ye=oe+it+kt;Dt(ce,J,Ie,Ye)}}}function nt(Je,oe,Ze){l.push(Je),l.push(oe),l.push(Ze)}function yt(Je,oe,Ze){qt(Je),qt(oe),qt(Ze);const it=i.length/3,ft=w.generateTopUV(s,i,it-3,it-2,it-1);Bt(ft[0]),Bt(ft[1]),Bt(ft[2])}function Dt(Je,oe,Ze,it){qt(Je),qt(oe),qt(it),qt(oe),qt(Ze),qt(it);const ft=i.length/3,gt=w.generateSideWallUV(s,i,ft-6,ft-3,ft-2,ft-1);Bt(gt[0]),Bt(gt[1]),Bt(gt[3]),Bt(gt[1]),Bt(gt[2]),Bt(gt[3])}function qt(Je){i.push(l[Je*3+0]),i.push(l[Je*3+1]),i.push(l[Je*3+2])}function Bt(Je){a.push(Je.x),a.push(Je.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,s=this.parameters.options;return hJ(t,s,e)}static fromJSON(e,t){const s=[];for(let a=0,r=e.shapes.length;a<r;a++){const o=t[e.shapes[a]];s.push(o)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new hE[i.type]().fromJSON(i)),new b2(s,e.options)}}const uJ={generateTopUV:function(n,e,t,s,i){const a=e[t*3],r=e[t*3+1],o=e[s*3],l=e[s*3+1],c=e[i*3],h=e[i*3+1];return[new rt(a,r),new rt(o,l),new rt(c,h)]},generateSideWallUV:function(n,e,t,s,i,a){const r=e[t*3],o=e[t*3+1],l=e[t*3+2],c=e[s*3],h=e[s*3+1],d=e[s*3+2],p=e[i*3],g=e[i*3+1],v=e[i*3+2],_=e[a*3],S=e[a*3+1],b=e[a*3+2];return Math.abs(o-h)<Math.abs(r-c)?[new rt(r,1-l),new rt(c,1-d),new rt(p,1-v),new rt(_,1-b)]:[new rt(o,1-l),new rt(h,1-d),new rt(g,1-v),new rt(S,1-b)]}};function hJ(n,e,t){if(t.shapes=[],Array.isArray(n))for(let s=0,i=n.length;s<i;s++){const a=n[s];t.shapes.push(a.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class LS extends np{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,i=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,a,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new LS(e.radius,e.detail)}}class S2 extends Ln{constructor(e=[new rt(0,-.5),new rt(.5,0),new rt(0,.5)],t=12,s=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:s,phiLength:i},t=Math.floor(t),i=Rn(i,0,Math.PI*2);const a=[],r=[],o=[],l=[],c=[],h=1/t,d=new ue,p=new rt,g=new ue,v=new ue,_=new ue;let S=0,b=0;for(let w=0;w<=e.length-1;w++)switch(w){case 0:S=e[w+1].x-e[w].x,b=e[w+1].y-e[w].y,g.x=b*1,g.y=-S,g.z=b*0,_.copy(g),g.normalize(),l.push(g.x,g.y,g.z);break;case e.length-1:l.push(_.x,_.y,_.z);break;default:S=e[w+1].x-e[w].x,b=e[w+1].y-e[w].y,g.x=b*1,g.y=-S,g.z=b*0,v.copy(g),g.x+=_.x,g.y+=_.y,g.z+=_.z,g.normalize(),l.push(g.x,g.y,g.z),_.copy(v)}for(let w=0;w<=t;w++){const T=s+w*h*i,E=Math.sin(T),R=Math.cos(T);for(let D=0;D<=e.length-1;D++){d.x=e[D].x*E,d.y=e[D].y,d.z=e[D].x*R,r.push(d.x,d.y,d.z),p.x=w/t,p.y=D/(e.length-1),o.push(p.x,p.y);const F=l[3*D+0]*E,U=l[3*D+1],O=l[3*D+0]*R;c.push(F,U,O)}}for(let w=0;w<t;w++)for(let T=0;T<e.length-1;T++){const E=T+w*e.length,R=E,D=E+e.length,F=E+e.length+1,U=E+1;a.push(R,D,U),a.push(F,U,D)}this.setIndex(a),this.setAttribute("position",new on(r,3)),this.setAttribute("uv",new on(o,2)),this.setAttribute("normal",new on(c,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new S2(e.points,e.segments,e.phiStart,e.phiLength)}}class FS extends np{constructor(e=1,t=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new FS(e.radius,e.detail)}}class sp extends Ln{constructor(e=1,t=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:i};const a=e/2,r=t/2,o=Math.floor(s),l=Math.floor(i),c=o+1,h=l+1,d=e/o,p=t/l,g=[],v=[],_=[],S=[];for(let b=0;b<h;b++){const w=b*p-r;for(let T=0;T<c;T++){const E=T*d-a;v.push(E,-w,0),_.push(0,0,1),S.push(T/o),S.push(1-b/l)}}for(let b=0;b<l;b++)for(let w=0;w<o;w++){const T=w+c*b,E=w+c*(b+1),R=w+1+c*(b+1),D=w+1+c*b;g.push(T,E,D),g.push(E,R,D)}this.setIndex(g),this.setAttribute("position",new on(v,3)),this.setAttribute("normal",new on(_,3)),this.setAttribute("uv",new on(S,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new sp(e.width,e.height,e.widthSegments,e.heightSegments)}}class _2 extends Ln{constructor(e=.5,t=1,s=32,i=1,a=0,r=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:s,phiSegments:i,thetaStart:a,thetaLength:r},s=Math.max(3,s),i=Math.max(1,i);const o=[],l=[],c=[],h=[];let d=e;const p=(t-e)/i,g=new ue,v=new rt;for(let _=0;_<=i;_++){for(let S=0;S<=s;S++){const b=a+S/s*r;g.x=d*Math.cos(b),g.y=d*Math.sin(b),l.push(g.x,g.y,g.z),c.push(0,0,1),v.x=(g.x/t+1)/2,v.y=(g.y/t+1)/2,h.push(v.x,v.y)}d+=p}for(let _=0;_<i;_++){const S=_*(s+1);for(let b=0;b<s;b++){const w=b+S,T=w,E=w+s+1,R=w+s+2,D=w+1;o.push(T,E,D),o.push(E,R,D)}}this.setIndex(o),this.setAttribute("position",new on(l,3)),this.setAttribute("normal",new on(c,3)),this.setAttribute("uv",new on(h,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new _2(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class A2 extends Ln{constructor(e=new Xm([new rt(0,.5),new rt(-.5,-.5),new rt(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const s=[],i=[],a=[],r=[];let o=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let h=0;h<e.length;h++)c(e[h]),this.addGroup(o,l,h),o+=l,l=0;this.setIndex(s),this.setAttribute("position",new on(i,3)),this.setAttribute("normal",new on(a,3)),this.setAttribute("uv",new on(r,2));function c(h){const d=i.length/3,p=h.extractPoints(t);let g=p.shape;const v=p.holes;Xc.isClockWise(g)===!1&&(g=g.reverse());for(let S=0,b=v.length;S<b;S++){const w=v[S];Xc.isClockWise(w)===!0&&(v[S]=w.reverse())}const _=Xc.triangulateShape(g,v);for(let S=0,b=v.length;S<b;S++){const w=v[S];g=g.concat(w)}for(let S=0,b=g.length;S<b;S++){const w=g[S];i.push(w.x,w.y,0),a.push(0,0,1),r.push(w.x,w.y)}for(let S=0,b=_.length;S<b;S++){const w=_[S],T=w[0]+d,E=w[1]+d,R=w[2]+d;s.push(T,E,R),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return dJ(t,e)}static fromJSON(e,t){const s=[];for(let i=0,a=e.shapes.length;i<a;i++){const r=t[e.shapes[i]];s.push(r)}return new A2(s,e.curveSegments)}}function dJ(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,s=n.length;t<s;t++){const i=n[t];e.shapes.push(i.uuid)}else e.shapes.push(n.uuid);return e}class US extends Ln{constructor(e=1,t=32,s=16,i=0,a=Math.PI*2,r=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:s,phiStart:i,phiLength:a,thetaStart:r,thetaLength:o},t=Math.max(3,Math.floor(t)),s=Math.max(2,Math.floor(s));const l=Math.min(r+o,Math.PI);let c=0;const h=[],d=new ue,p=new ue,g=[],v=[],_=[],S=[];for(let b=0;b<=s;b++){const w=[],T=b/s;let E=0;b===0&&r===0?E=.5/t:b===s&&l===Math.PI&&(E=-.5/t);for(let R=0;R<=t;R++){const D=R/t;d.x=-e*Math.cos(i+D*a)*Math.sin(r+T*o),d.y=e*Math.cos(r+T*o),d.z=e*Math.sin(i+D*a)*Math.sin(r+T*o),v.push(d.x,d.y,d.z),p.copy(d).normalize(),_.push(p.x,p.y,p.z),S.push(D+E,1-T),w.push(c++)}h.push(w)}for(let b=0;b<s;b++)for(let w=0;w<t;w++){const T=h[b][w+1],E=h[b][w],R=h[b+1][w],D=h[b+1][w+1];(b!==0||r>0)&&g.push(T,E,D),(b!==s-1||l<Math.PI)&&g.push(E,R,D)}this.setIndex(g),this.setAttribute("position",new on(v,3)),this.setAttribute("normal",new on(_,3)),this.setAttribute("uv",new on(S,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new US(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class w2 extends np{constructor(e=1,t=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new w2(e.radius,e.detail)}}class C2 extends Ln{constructor(e=1,t=.4,s=12,i=48,a=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:s,tubularSegments:i,arc:a},s=Math.floor(s),i=Math.floor(i);const r=[],o=[],l=[],c=[],h=new ue,d=new ue,p=new ue;for(let g=0;g<=s;g++)for(let v=0;v<=i;v++){const _=v/i*a,S=g/s*Math.PI*2;d.x=(e+t*Math.cos(S))*Math.cos(_),d.y=(e+t*Math.cos(S))*Math.sin(_),d.z=t*Math.sin(S),o.push(d.x,d.y,d.z),h.x=e*Math.cos(_),h.y=e*Math.sin(_),p.subVectors(d,h).normalize(),l.push(p.x,p.y,p.z),c.push(v/i),c.push(g/s)}for(let g=1;g<=s;g++)for(let v=1;v<=i;v++){const _=(i+1)*g+v-1,S=(i+1)*(g-1)+v-1,b=(i+1)*(g-1)+v,w=(i+1)*g+v;r.push(_,S,w),r.push(S,b,w)}this.setIndex(r),this.setAttribute("position",new on(o,3)),this.setAttribute("normal",new on(l,3)),this.setAttribute("uv",new on(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new C2(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class T2 extends Ln{constructor(e=1,t=.4,s=64,i=8,a=2,r=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:s,radialSegments:i,p:a,q:r},s=Math.floor(s),i=Math.floor(i);const o=[],l=[],c=[],h=[],d=new ue,p=new ue,g=new ue,v=new ue,_=new ue,S=new ue,b=new ue;for(let T=0;T<=s;++T){const E=T/s*a*Math.PI*2;w(E,a,r,e,g),w(E+.01,a,r,e,v),S.subVectors(v,g),b.addVectors(v,g),_.crossVectors(S,b),b.crossVectors(_,S),_.normalize(),b.normalize();for(let R=0;R<=i;++R){const D=R/i*Math.PI*2,F=-t*Math.cos(D),U=t*Math.sin(D);d.x=g.x+(F*b.x+U*_.x),d.y=g.y+(F*b.y+U*_.y),d.z=g.z+(F*b.z+U*_.z),l.push(d.x,d.y,d.z),p.subVectors(d,g).normalize(),c.push(p.x,p.y,p.z),h.push(T/s),h.push(R/i)}}for(let T=1;T<=s;T++)for(let E=1;E<=i;E++){const R=(i+1)*(T-1)+(E-1),D=(i+1)*T+(E-1),F=(i+1)*T+E,U=(i+1)*(T-1)+E;o.push(R,D,U),o.push(D,F,U)}this.setIndex(o),this.setAttribute("position",new on(l,3)),this.setAttribute("normal",new on(c,3)),this.setAttribute("uv",new on(h,2));function w(T,E,R,D,F){const U=Math.cos(T),O=Math.sin(T),B=R/E*T,L=Math.cos(B);F.x=D*(2+L)*.5*U,F.y=D*(2+L)*O*.5,F.z=D*Math.sin(B)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new T2(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class E2 extends Ln{constructor(e=new vO(new ue(-1,-1,0),new ue(-1,1,0),new ue(1,1,0)),t=64,s=1,i=8,a=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:s,radialSegments:i,closed:a};const r=e.computeFrenetFrames(t,a);this.tangents=r.tangents,this.normals=r.normals,this.binormals=r.binormals;const o=new ue,l=new ue,c=new rt;let h=new ue;const d=[],p=[],g=[],v=[];_(),this.setIndex(v),this.setAttribute("position",new on(d,3)),this.setAttribute("normal",new on(p,3)),this.setAttribute("uv",new on(g,2));function _(){for(let T=0;T<t;T++)S(T);S(a===!1?t:0),w(),b()}function S(T){h=e.getPointAt(T/t,h);const E=r.normals[T],R=r.binormals[T];for(let D=0;D<=i;D++){const F=D/i*Math.PI*2,U=Math.sin(F),O=-Math.cos(F);l.x=O*E.x+U*R.x,l.y=O*E.y+U*R.y,l.z=O*E.z+U*R.z,l.normalize(),p.push(l.x,l.y,l.z),o.x=h.x+s*l.x,o.y=h.y+s*l.y,o.z=h.z+s*l.z,d.push(o.x,o.y,o.z)}}function b(){for(let T=1;T<=t;T++)for(let E=1;E<=i;E++){const R=(i+1)*(T-1)+(E-1),D=(i+1)*T+(E-1),F=(i+1)*T+E,U=(i+1)*(T-1)+E;v.push(R,D,U),v.push(D,F,U)}}function w(){for(let T=0;T<=t;T++)for(let E=0;E<=i;E++)c.x=T/t,c.y=E/i,g.push(c.x,c.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new E2(new hE[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class NG extends Ln{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],s=new Set,i=new ue,a=new ue;if(e.index!==null){const r=e.attributes.position,o=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:o.count,materialIndex:0}]);for(let c=0,h=l.length;c<h;++c){const d=l[c],p=d.start,g=d.count;for(let v=p,_=p+g;v<_;v+=3)for(let S=0;S<3;S++){const b=o.getX(v+S),w=o.getX(v+(S+1)%3);i.fromBufferAttribute(r,b),a.fromBufferAttribute(r,w),VU(i,a,s)===!0&&(t.push(i.x,i.y,i.z),t.push(a.x,a.y,a.z))}}}else{const r=e.attributes.position;for(let o=0,l=r.count/3;o<l;o++)for(let c=0;c<3;c++){const h=3*o+c,d=3*o+(c+1)%3;i.fromBufferAttribute(r,h),a.fromBufferAttribute(r,d),VU(i,a,s)===!0&&(t.push(i.x,i.y,i.z),t.push(a.x,a.y,a.z))}}this.setAttribute("position",new on(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function VU(n,e,t){const s=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(s)===!0||t.has(i)===!0?!1:(t.add(s),t.add(i),!0)}var HU=Object.freeze({__proto__:null,BoxGeometry:wg,CapsuleGeometry:g2,CircleGeometry:x2,ConeGeometry:kS,CylinderGeometry:BS,DodecahedronGeometry:y2,EdgesGeometry:vG,ExtrudeGeometry:b2,IcosahedronGeometry:LS,LatheGeometry:S2,OctahedronGeometry:FS,PlaneGeometry:sp,PolyhedronGeometry:np,RingGeometry:_2,ShapeGeometry:A2,SphereGeometry:US,TetrahedronGeometry:w2,TorusGeometry:C2,TorusKnotGeometry:T2,TubeGeometry:E2,WireframeGeometry:NG});class RG extends Da{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new $t(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class IG extends jr{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class py extends Da{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new $t(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=tp,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new wl,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class lc extends py{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new rt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Rn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new $t(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new $t(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new $t(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class DG extends Da{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new $t(16777215),this.specular=new $t(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=tp,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new wl,this.combine=CS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class OG extends Da{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new $t(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=tp,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class BG extends Da{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=tp,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class kG extends Da{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new $t(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $t(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=tp,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new wl,this.combine=CS,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class SO extends Da{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Y4,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class _O extends Da{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class LG extends Da{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new $t(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=tp,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this.fog=e.fog,this}}class FG extends qr{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function zm(n,e){return!n||n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function UG(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function PG(n){function e(i,a){return n[i]-n[a]}const t=n.length,s=new Array(t);for(let i=0;i!==t;++i)s[i]=i;return s.sort(e),s}function B3(n,e,t){const s=n.length,i=new n.constructor(s);for(let a=0,r=0;r!==s;++a){const o=t[a]*e;for(let l=0;l!==e;++l)i[r++]=n[o+l]}return i}function AO(n,e,t,s){let i=1,a=n[0];for(;a!==void 0&&a[s]===void 0;)a=n[i++];if(a===void 0)return;let r=a[s];if(r!==void 0)if(Array.isArray(r))do r=a[s],r!==void 0&&(e.push(a.time),t.push(...r)),a=n[i++];while(a!==void 0);else if(r.toArray!==void 0)do r=a[s],r!==void 0&&(e.push(a.time),r.toArray(t,t.length)),a=n[i++];while(a!==void 0);else do r=a[s],r!==void 0&&(e.push(a.time),t.push(r)),a=n[i++];while(a!==void 0)}function fJ(n,e,t,s,i=30){const a=n.clone();a.name=e;const r=[];for(let l=0;l<a.tracks.length;++l){const c=a.tracks[l],h=c.getValueSize(),d=[],p=[];for(let g=0;g<c.times.length;++g){const v=c.times[g]*i;if(!(v<t||v>=s)){d.push(c.times[g]);for(let _=0;_<h;++_)p.push(c.values[g*h+_])}}d.length!==0&&(c.times=zm(d,c.times.constructor),c.values=zm(p,c.values.constructor),r.push(c))}a.tracks=r;let o=1/0;for(let l=0;l<a.tracks.length;++l)o>a.tracks[l].times[0]&&(o=a.tracks[l].times[0]);for(let l=0;l<a.tracks.length;++l)a.tracks[l].shift(-1*o);return a.resetDuration(),a}function pJ(n,e=0,t=n,s=30){s<=0&&(s=30);const i=t.tracks.length,a=e/s;for(let r=0;r<i;++r){const o=t.tracks[r],l=o.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(b){return b.name===o.name&&b.ValueTypeName===l});if(c===void 0)continue;let h=0;const d=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=d/3);let p=0;const g=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=g/3);const v=o.times.length-1;let _;if(a<=o.times[0]){const b=h,w=d-h;_=o.values.slice(b,w)}else if(a>=o.times[v]){const b=v*d+h,w=b+d-h;_=o.values.slice(b,w)}else{const b=o.createInterpolant(),w=h,T=d-h;b.evaluate(a),_=b.resultBuffer.slice(w,T)}l==="quaternion"&&new Za().fromArray(_).normalize().conjugate().toArray(_);const S=c.times.length;for(let b=0;b<S;++b){const w=b*g+p;if(l==="quaternion")Za.multiplyQuaternionsFlat(c.values,w,_,0,c.values,w);else{const T=g-p*2;for(let E=0;E<T;++E)c.values[w+E]-=_[E]}}}return n.blendMode=tO,n}class mJ{static convertArray(e,t){return zm(e,t)}static isTypedArray(e){return UG(e)}static getKeyframeOrder(e){return PG(e)}static sortedArray(e,t,s){return B3(e,t,s)}static flattenJSON(e,t,s,i){AO(e,t,s,i)}static subclip(e,t,s,i,a=30){return fJ(e,t,s,i,a)}static makeClipAdditive(e,t=0,s=e,i=30){return pJ(e,t,s,i)}}class my{constructor(e,t,s,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,i=t[s],a=t[s-1];e:{t:{let r;n:{s:if(!(e<i)){for(let o=s+2;;){if(i===void 0){if(e<a)break s;return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===o)break;if(a=i,i=t[++s],e<i)break t}r=t.length;break n}if(!(e>=a)){const o=t[1];e<o&&(s=2,a=o);for(let l=s-2;;){if(a===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(i=a,a=t[--s-1],e>=a)break t}r=s,s=0;break n}break e}for(;s<r;){const o=s+r>>>1;e<t[o]?r=o:s=o+1}if(i=t[s],a=t[s-1],a===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,a,i)}return this.interpolate_(s,a,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,a=e*i;for(let r=0;r!==i;++r)t[r]=s[a+r];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class zG extends my{constructor(e,t,s,i){super(e,t,s,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Fm,endingEnd:Fm}}intervalChanged_(e,t,s){const i=this.parameterPositions;let a=e-2,r=e+1,o=i[a],l=i[r];if(o===void 0)switch(this.getSettings_().endingStart){case Um:a=e,o=2*t-s;break;case W1:a=i.length-2,o=t+i[a]-i[a+1];break;default:a=e,o=s}if(l===void 0)switch(this.getSettings_().endingEnd){case Um:r=e,l=2*s-t;break;case W1:r=1,l=s+i[1]-i[0];break;default:r=e-1,l=t}const c=(s-t)*.5,h=this.valueSize;this._weightPrev=c/(t-o),this._weightNext=c/(l-s),this._offsetPrev=a*h,this._offsetNext=r*h}interpolate_(e,t,s,i){const a=this.resultBuffer,r=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,h=this._offsetPrev,d=this._offsetNext,p=this._weightPrev,g=this._weightNext,v=(s-t)/(i-t),_=v*v,S=_*v,b=-p*S+2*p*_-p*v,w=(1+p)*S+(-1.5-2*p)*_+(-.5+p)*v+1,T=(-1-g)*S+(1.5+g)*_+.5*v,E=g*S-g*_;for(let R=0;R!==o;++R)a[R]=b*r[h+R]+w*r[c+R]+T*r[l+R]+E*r[d+R];return a}}class wO extends my{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const a=this.resultBuffer,r=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,h=(s-t)/(i-t),d=1-h;for(let p=0;p!==o;++p)a[p]=r[c+p]*d+r[l+p]*h;return a}}class $G extends my{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class cc{constructor(e,t,s,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=zm(t,this.TimeBufferType),this.values=zm(s,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:zm(e.times,Array),values:zm(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(s.interpolation=i)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new $G(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new wO(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new zG(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Bx:t=this.InterpolantFactoryMethodDiscrete;break;case kx:t=this.InterpolantFactoryMethodLinear;break;case cT:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return Wt("KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Bx;case this.InterpolantFactoryMethodLinear:return kx;case this.InterpolantFactoryMethodSmooth:return cT}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]*=e}return this}trim(e,t){const s=this.times,i=s.length;let a=0,r=i-1;for(;a!==i&&s[a]<e;)++a;for(;r!==-1&&s[r]>t;)--r;if(++r,a!==0||r!==i){a>=r&&(r=Math.max(r,1),a=r-1);const o=this.getValueSize();this.times=s.slice(a,r),this.values=this.values.slice(a*o,r*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(On("KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,i=this.values,a=s.length;a===0&&(On("KeyframeTrack: Track is empty.",this),e=!1);let r=null;for(let o=0;o!==a;o++){const l=s[o];if(typeof l=="number"&&isNaN(l)){On("KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(r!==null&&r>l){On("KeyframeTrack: Out of order keys.",this,o,l,r),e=!1;break}r=l}if(i!==void 0&&UG(i))for(let o=0,l=i.length;o!==l;++o){const c=i[o];if(isNaN(c)){On("KeyframeTrack: Value is not a valid number.",this,o,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),s=this.getValueSize(),i=this.getInterpolation()===cT,a=e.length-1;let r=1;for(let o=1;o<a;++o){let l=!1;const c=e[o],h=e[o+1];if(c!==h&&(o!==1||c!==e[0]))if(i)l=!0;else{const d=o*s,p=d-s,g=d+s;for(let v=0;v!==s;++v){const _=t[d+v];if(_!==t[p+v]||_!==t[g+v]){l=!0;break}}}if(l){if(o!==r){e[r]=e[o];const d=o*s,p=r*s;for(let g=0;g!==s;++g)t[p+g]=t[d+g]}++r}}if(a>0){e[r]=e[a];for(let o=a*s,l=r*s,c=0;c!==s;++c)t[l+c]=t[o+c];++r}return r!==e.length?(this.times=e.slice(0,r),this.values=t.slice(0,r*s)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),s=this.constructor,i=new s(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}cc.prototype.ValueTypeName="";cc.prototype.TimeBufferType=Float32Array;cc.prototype.ValueBufferType=Float32Array;cc.prototype.DefaultInterpolation=kx;class Cg extends cc{constructor(e,t,s){super(e,t,s)}}Cg.prototype.ValueTypeName="bool";Cg.prototype.ValueBufferType=Array;Cg.prototype.DefaultInterpolation=Bx;Cg.prototype.InterpolantFactoryMethodLinear=void 0;Cg.prototype.InterpolantFactoryMethodSmooth=void 0;class CO extends cc{constructor(e,t,s,i){super(e,t,s,i)}}CO.prototype.ValueTypeName="color";class ig extends cc{constructor(e,t,s,i){super(e,t,s,i)}}ig.prototype.ValueTypeName="number";class GG extends my{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const a=this.resultBuffer,r=this.sampleValues,o=this.valueSize,l=(s-t)/(i-t);let c=e*o;for(let h=c+o;c!==h;c+=4)Za.slerpFlat(a,0,r,c-o,r,c,l);return a}}class ag extends cc{constructor(e,t,s,i){super(e,t,s,i)}InterpolantFactoryMethodLinear(e){return new GG(this.times,this.values,this.getValueSize(),e)}}ag.prototype.ValueTypeName="quaternion";ag.prototype.InterpolantFactoryMethodSmooth=void 0;class Tg extends cc{constructor(e,t,s){super(e,t,s)}}Tg.prototype.ValueTypeName="string";Tg.prototype.ValueBufferType=Array;Tg.prototype.DefaultInterpolation=Bx;Tg.prototype.InterpolantFactoryMethodLinear=void 0;Tg.prototype.InterpolantFactoryMethodSmooth=void 0;class rg extends cc{constructor(e,t,s,i){super(e,t,s,i)}}rg.prototype.ValueTypeName="vector";class Gx{constructor(e="",t=-1,s=[],i=o2){this.name=e,this.tracks=s,this.duration=t,this.blendMode=i,this.uuid=Sl(),this.userData={},this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,i=1/(e.fps||1);for(let r=0,o=s.length;r!==o;++r)t.push(xJ(s[r]).scale(i));const a=new this(e.name,e.duration,t,e.blendMode);return a.uuid=e.uuid,a.userData=JSON.parse(e.userData||"{}"),a}static toJSON(e){const t=[],s=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode,userData:JSON.stringify(e.userData)};for(let a=0,r=s.length;a!==r;++a)t.push(cc.toJSON(s[a]));return i}static CreateFromMorphTargetSequence(e,t,s,i){const a=t.length,r=[];for(let o=0;o<a;o++){let l=[],c=[];l.push((o+a-1)%a,o,(o+1)%a),c.push(0,1,0);const h=PG(l);l=B3(l,1,h),c=B3(c,1,h),!i&&l[0]===0&&(l.push(a),c.push(c[0])),r.push(new ig(".morphTargetInfluences["+t[o].name+"]",l,c).scale(1/s))}return new this(e,-1,r)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const i=e;s=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<s.length;i++)if(s[i].name===t)return s[i];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const i={},a=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const c=e[o],h=c.name.match(a);if(h&&h.length>1){const d=h[1];let p=i[d];p||(i[d]=p=[]),p.push(c)}}const r=[];for(const o in i)r.push(this.CreateFromMorphTargetSequence(o,i[o],t,s));return r}static parseAnimation(e,t){if(Wt("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!e)return On("AnimationClip: No animation in JSONLoader data."),null;const s=function(d,p,g,v,_){if(g.length!==0){const S=[],b=[];AO(g,S,b,v),S.length!==0&&_.push(new d(p,S,b))}},i=[],a=e.name||"default",r=e.fps||30,o=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let d=0;d<c.length;d++){const p=c[d].keys;if(!(!p||p.length===0))if(p[0].morphTargets){const g={};let v;for(v=0;v<p.length;v++)if(p[v].morphTargets)for(let _=0;_<p[v].morphTargets.length;_++)g[p[v].morphTargets[_]]=-1;for(const _ in g){const S=[],b=[];for(let w=0;w!==p[v].morphTargets.length;++w){const T=p[v];S.push(T.time),b.push(T.morphTarget===_?1:0)}i.push(new ig(".morphTargetInfluence["+_+"]",S,b))}l=g.length*r}else{const g=".bones["+t[d].name+"]";s(rg,g+".position",p,"pos",i),s(ag,g+".quaternion",p,"rot",i),s(rg,g+".scale",p,"scl",i)}}return i.length===0?null:new this(a,l,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,i=e.length;s!==i;++s){const a=this.tracks[s];t=Math.max(t,a.times[a.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let s=0;s<this.tracks.length;s++)e.push(this.tracks[s].clone());const t=new this.constructor(this.name,this.duration,e,this.blendMode);return t.userData=JSON.parse(JSON.stringify(this.userData)),t}toJSON(){return this.constructor.toJSON(this)}}function gJ(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ig;case"vector":case"vector2":case"vector3":case"vector4":return rg;case"color":return CO;case"quaternion":return ag;case"bool":case"boolean":return Cg;case"string":return Tg}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function xJ(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=gJ(n.type);if(n.times===void 0){const t=[],s=[];AO(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const qu={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class M2{constructor(e,t,s){const i=this;let a=!1,r=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this._abortController=null,this.itemStart=function(h){o++,a===!1&&i.onStart!==void 0&&i.onStart(h,r,o),a=!0},this.itemEnd=function(h){r++,i.onProgress!==void 0&&i.onProgress(h,r,o),r===o&&(a=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(h){i.onError!==void 0&&i.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,d){return c.push(h,d),this},this.removeHandler=function(h){const d=c.indexOf(h);return d!==-1&&c.splice(d,2),this},this.getHandler=function(h){for(let d=0,p=c.length;d<p;d+=2){const g=c[d],v=c[d+1];if(g.global&&(g.lastIndex=0),g.test(h))return v}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){return this._abortController||(this._abortController=new AbortController),this._abortController}}const VG=new M2;class br{constructor(e){this.manager=e!==void 0?e:VG,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(i,a){s.load(e,i,t,a)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}abort(){return this}}br.DEFAULT_MATERIAL_NAME="__DEFAULT";const Zh={};class yJ extends Error{constructor(e,t){super(e),this.response=t}}class vr extends br{constructor(e){super(e),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const a=qu.get(`file:${e}`);if(a!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(a),this.manager.itemEnd(e)},0),a;if(Zh[e]!==void 0){Zh[e].push({onLoad:t,onProgress:s,onError:i});return}Zh[e]=[],Zh[e].push({onLoad:t,onProgress:s,onError:i});const r=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),o=this.mimeType,l=this.responseType;fetch(r).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&Wt("FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const h=Zh[e],d=c.body.getReader(),p=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),g=p?parseInt(p):0,v=g!==0;let _=0;const S=new ReadableStream({start(b){w();function w(){d.read().then(({done:T,value:E})=>{if(T)b.close();else{_+=E.byteLength;const R=new ProgressEvent("progress",{lengthComputable:v,loaded:_,total:g});for(let D=0,F=h.length;D<F;D++){const U=h[D];U.onProgress&&U.onProgress(R)}b.enqueue(E),w()}},T=>{b.error(T)})}}});return new Response(S)}else throw new yJ(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(h=>new DOMParser().parseFromString(h,o));case"json":return c.json();default:if(o==="")return c.text();{const d=/charset="?([^;"\s]*)"?/i.exec(o),p=d&&d[1]?d[1].toLowerCase():void 0,g=new TextDecoder(p);return c.arrayBuffer().then(v=>g.decode(v))}}}).then(c=>{qu.add(`file:${e}`,c);const h=Zh[e];delete Zh[e];for(let d=0,p=h.length;d<p;d++){const g=h[d];g.onLoad&&g.onLoad(c)}}).catch(c=>{const h=Zh[e];if(h===void 0)throw this.manager.itemError(e),c;delete Zh[e];for(let d=0,p=h.length;d<p;d++){const g=h[d];g.onError&&g.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class vJ extends br{constructor(e){super(e)}load(e,t,s,i){const a=this,r=new vr(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(o){try{t(a.parse(JSON.parse(o)))}catch(l){i?i(l):On(l),a.manager.itemError(e)}},s,i)}parse(e){const t=[];for(let s=0;s<e.length;s++){const i=Gx.parse(e[s]);t.push(i)}return t}}class bJ extends br{constructor(e){super(e)}load(e,t,s,i){const a=this,r=[],o=new m2,l=new vr(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(a.withCredentials);let c=0;function h(d){l.load(e[d],function(p){const g=a.parse(p,!0);r[d]={width:g.width,height:g.height,format:g.format,mipmaps:g.mipmaps},c+=1,c===6&&(g.mipmapCount===1&&(o.minFilter=is),o.image=r,o.format=g.format,o.needsUpdate=!0,t&&t(o))},s,i)}if(Array.isArray(e))for(let d=0,p=e.length;d<p;++d)h(d);else l.load(e,function(d){const p=a.parse(d,!0);if(p.isCubemap){const g=p.mipmaps.length/p.mipmapCount;for(let v=0;v<g;v++){r[v]={mipmaps:[]};for(let _=0;_<p.mipmapCount;_++)r[v].mipmaps.push(p.mipmaps[v*p.mipmapCount+_]),r[v].format=p.format,r[v].width=p.width,r[v].height=p.height}o.image=r}else o.image.width=p.width,o.image.height=p.height,o.mipmaps=p.mipmaps;p.mipmapCount===1&&(o.minFilter=is),o.format=p.format,o.needsUpdate=!0,t&&t(o)},s,i);return o}}const cx=new WeakMap;class Q1 extends br{constructor(e){super(e)}load(e,t,s,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const a=this,r=qu.get(`image:${e}`);if(r!==void 0){if(r.complete===!0)a.manager.itemStart(e),setTimeout(function(){t&&t(r),a.manager.itemEnd(e)},0);else{let d=cx.get(r);d===void 0&&(d=[],cx.set(r,d)),d.push({onLoad:t,onError:i})}return r}const o=q1("img");function l(){h(),t&&t(this);const d=cx.get(this)||[];for(let p=0;p<d.length;p++){const g=d[p];g.onLoad&&g.onLoad(this)}cx.delete(this),a.manager.itemEnd(e)}function c(d){h(),i&&i(d),qu.remove(`image:${e}`);const p=cx.get(this)||[];for(let g=0;g<p.length;g++){const v=p[g];v.onError&&v.onError(d)}cx.delete(this),a.manager.itemError(e),a.manager.itemEnd(e)}function h(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),qu.add(`image:${e}`,o),a.manager.itemStart(e),o.src=e,o}}class HG extends br{constructor(e){super(e)}load(e,t,s,i){const a=new RS;a.colorSpace=mr;const r=new Q1(this.manager);r.setCrossOrigin(this.crossOrigin),r.setPath(this.path);let o=0;function l(c){r.load(e[c],function(h){a.images[c]=h,o++,o===6&&(a.needsUpdate=!0,t&&t(a))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return a}}class TO extends br{constructor(e){super(e)}load(e,t,s,i){const a=this,r=new ac,o=new vr(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(a.withCredentials),o.load(e,function(l){let c;try{c=a.parse(l)}catch(h){if(i!==void 0)i(h);else{h(h);return}}c.image!==void 0?r.image=c.image:c.data!==void 0&&(r.image.width=c.width,r.image.height=c.height,r.image.data=c.data),r.wrapS=c.wrapS!==void 0?c.wrapS:Fi,r.wrapT=c.wrapT!==void 0?c.wrapT:Fi,r.magFilter=c.magFilter!==void 0?c.magFilter:is,r.minFilter=c.minFilter!==void 0?c.minFilter:is,r.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0&&(r.colorSpace=c.colorSpace),c.flipY!==void 0&&(r.flipY=c.flipY),c.format!==void 0&&(r.format=c.format),c.type!==void 0&&(r.type=c.type),c.mipmaps!==void 0&&(r.mipmaps=c.mipmaps,r.minFilter=tc),c.mipmapCount===1&&(r.minFilter=is),c.generateMipmaps!==void 0&&(r.generateMipmaps=c.generateMipmaps),r.needsUpdate=!0,t&&t(r,c)},s,i),r}}class WG extends br{constructor(e){super(e)}load(e,t,s,i){const a=new Vs,r=new Q1(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(e,function(o){a.image=o,a.needsUpdate=!0,t!==void 0&&t(a)},s,i),a}}class ip extends Ts{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new $t(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}class jG extends ip{constructor(e,t,s){super(e,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Ts.DEFAULT_UP),this.updateMatrix(),this.groundColor=new $t(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const xI=new _n,WU=new ue,jU=new ue;class EO{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new rt(512,512),this.mapType=Co,this.map=null,this.mapPass=null,this.matrix=new _n,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new fy,this._frameExtents=new rt(1,1),this._viewportCount=1,this._viewports=[new Cs(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;WU.setFromMatrixPosition(e.matrixWorld),t.position.copy(WU),jU.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(jU),t.updateMatrixWorld(),xI.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xI,t.coordinateSystem,t.reversedDepth),t.reversedDepth?s.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(xI)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class SJ extends EO{constructor(){super(new ki(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(e){const t=this.camera,s=Ux*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height*this.aspect,a=e.distance||t.far;(s!==t.fov||i!==t.aspect||a!==t.far)&&(t.fov=s,t.aspect=i,t.far=a,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class MO extends ip{constructor(e,t,s=0,i=Math.PI/3,a=0,r=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Ts.DEFAULT_UP),this.updateMatrix(),this.target=new Ts,this.distance=s,this.angle=i,this.penumbra=a,this.decay=r,this.map=null,this.shadow=new SJ}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const XU=new _n,f1=new ue,yI=new ue;class _J extends EO{constructor(){super(new ki(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new rt(4,2),this._viewportCount=6,this._viewports=[new Cs(2,1,1,1),new Cs(0,1,1,1),new Cs(3,1,1,1),new Cs(1,1,1,1),new Cs(3,0,1,1),new Cs(1,0,1,1)],this._cubeDirections=[new ue(1,0,0),new ue(-1,0,0),new ue(0,0,1),new ue(0,0,-1),new ue(0,1,0),new ue(0,-1,0)],this._cubeUps=[new ue(0,1,0),new ue(0,1,0),new ue(0,1,0),new ue(0,1,0),new ue(0,0,1),new ue(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,i=this.matrix,a=e.distance||s.far;a!==s.far&&(s.far=a,s.updateProjectionMatrix()),f1.setFromMatrixPosition(e.matrixWorld),s.position.copy(f1),yI.copy(s.position),yI.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(yI),s.updateMatrixWorld(),i.makeTranslation(-f1.x,-f1.y,-f1.z),XU.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(XU,s.coordinateSystem,s.reversedDepth)}}class NO extends ip{constructor(e,t,s=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=i,this.shadow=new _J}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class Zu extends NS{constructor(e=-1,t=1,s=1,i=-1,a=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=i,this.near=a,this.far=r,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,i,a,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=a,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let a=s-e,r=s+e,o=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a+=c*this.view.offsetX,r=a+c*this.view.width,o-=h*this.view.offsetY,l=o-h*this.view.height}this.projectionMatrix.makeOrthographic(a,r,o,l,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class AJ extends EO{constructor(){super(new Zu(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class RO extends ip{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Ts.DEFAULT_UP),this.updateMatrix(),this.target=new Ts,this.shadow=new AJ}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class XG extends ip{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class qG extends ip{constructor(e,t,s=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class KG{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new ue)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const s=e.x,i=e.y,a=e.z,r=this.coefficients;return t.copy(r[0]).multiplyScalar(.282095),t.addScaledVector(r[1],.488603*i),t.addScaledVector(r[2],.488603*a),t.addScaledVector(r[3],.488603*s),t.addScaledVector(r[4],1.092548*(s*i)),t.addScaledVector(r[5],1.092548*(i*a)),t.addScaledVector(r[6],.315392*(3*a*a-1)),t.addScaledVector(r[7],1.092548*(s*a)),t.addScaledVector(r[8],.546274*(s*s-i*i)),t}getIrradianceAt(e,t){const s=e.x,i=e.y,a=e.z,r=this.coefficients;return t.copy(r[0]).multiplyScalar(.886227),t.addScaledVector(r[1],2*.511664*i),t.addScaledVector(r[2],2*.511664*a),t.addScaledVector(r[3],2*.511664*s),t.addScaledVector(r[4],2*.429043*s*i),t.addScaledVector(r[5],2*.429043*i*a),t.addScaledVector(r[6],.743125*a*a-.247708),t.addScaledVector(r[7],2*.429043*s*a),t.addScaledVector(r[8],.429043*(s*s-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const s=e.x,i=e.y,a=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*a,t[3]=.488603*s,t[4]=1.092548*s*i,t[5]=1.092548*i*a,t[6]=.315392*(3*a*a-1),t[7]=1.092548*s*a,t[8]=.546274*(s*s-i*i)}}class YG extends ip{constructor(e=new KG,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class N2 extends br{constructor(e){super(e),this.textures={}}load(e,t,s,i){const a=this,r=new vr(a.manager);r.setPath(a.path),r.setRequestHeader(a.requestHeader),r.setWithCredentials(a.withCredentials),r.load(e,function(o){try{t(a.parse(JSON.parse(o)))}catch(l){i?i(l):On(l),a.manager.itemError(e)}},s,i)}parse(e){const t=this.textures;function s(a){return t[a]===void 0&&Wt("MaterialLoader: Undefined texture",a),t[a]}const i=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new $t().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(i.dispersion=e.dispersion),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const a in e.uniforms){const r=e.uniforms[a];switch(i.uniforms[a]={},r.type){case"t":i.uniforms[a].value=s(r.value);break;case"c":i.uniforms[a].value=new $t().setHex(r.value);break;case"v2":i.uniforms[a].value=new rt().fromArray(r.value);break;case"v3":i.uniforms[a].value=new ue().fromArray(r.value);break;case"v4":i.uniforms[a].value=new Cs().fromArray(r.value);break;case"m3":i.uniforms[a].value=new Vn().fromArray(r.value);break;case"m4":i.uniforms[a].value=new _n().fromArray(r.value);break;default:i.uniforms[a].value=r.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const a in e.extensions)i.extensions[a]=e.extensions[a];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=s(e.map)),e.matcap!==void 0&&(i.matcap=s(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=s(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=s(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=s(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let a=e.normalScale;Array.isArray(a)===!1&&(a=[a,a]),i.normalScale=new rt().fromArray(a)}return e.displacementMap!==void 0&&(i.displacementMap=s(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=s(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=s(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=s(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=s(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=s(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=s(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=s(e.envMap)),e.envMapRotation!==void 0&&i.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=s(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=s(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=s(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=s(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=s(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=s(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new rt().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=s(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=s(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=s(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=s(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=s(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=s(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=s(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return N2.createMaterialFromType(e)}static createMaterialFromType(e){const t={ShadowMaterial:RG,SpriteMaterial:cO,RawShaderMaterial:IG,ShaderMaterial:jr,PointsMaterial:p2,MeshPhysicalMaterial:lc,MeshStandardMaterial:py,MeshPhongMaterial:DG,MeshToonMaterial:OG,MeshNormalMaterial:BG,MeshLambertMaterial:kG,MeshDepthMaterial:SO,MeshDistanceMaterial:_O,MeshBasicMaterial:Yo,MeshMatcapMaterial:LG,LineDashedMaterial:FG,LineBasicMaterial:qr,Material:Da};return new t[e]}}class Of{static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class JG extends Ln{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class ZG extends br{constructor(e){super(e)}load(e,t,s,i){const a=this,r=new vr(a.manager);r.setPath(a.path),r.setRequestHeader(a.requestHeader),r.setWithCredentials(a.withCredentials),r.load(e,function(o){try{t(a.parse(JSON.parse(o)))}catch(l){i?i(l):On(l),a.manager.itemError(e)}},s,i)}parse(e){const t={},s={};function i(g,v){if(t[v]!==void 0)return t[v];const S=g.interleavedBuffers[v],b=a(g,S.buffer),w=bx(S.type,b),T=new IS(w,S.stride);return T.uuid=S.uuid,t[v]=T,T}function a(g,v){if(s[v]!==void 0)return s[v];const S=g.arrayBuffers[v],b=new Uint32Array(S).buffer;return s[v]=b,b}const r=e.isInstancedBufferGeometry?new JG:new Ln,o=e.data.index;if(o!==void 0){const g=bx(o.type,o.array);r.setIndex(new Es(g,1))}const l=e.data.attributes;for(const g in l){const v=l[g];let _;if(v.isInterleavedBufferAttribute){const S=i(e.data,v.data);_=new $f(S,v.itemSize,v.offset,v.normalized)}else{const S=bx(v.type,v.array),b=v.isInstancedBufferAttribute?ng:Es;_=new b(S,v.itemSize,v.normalized)}v.name!==void 0&&(_.name=v.name),v.usage!==void 0&&_.setUsage(v.usage),r.setAttribute(g,_)}const c=e.data.morphAttributes;if(c)for(const g in c){const v=c[g],_=[];for(let S=0,b=v.length;S<b;S++){const w=v[S];let T;if(w.isInterleavedBufferAttribute){const E=i(e.data,w.data);T=new $f(E,w.itemSize,w.offset,w.normalized)}else{const E=bx(w.type,w.array);T=new Es(E,w.itemSize,w.normalized)}w.name!==void 0&&(T.name=w.name),_.push(T)}r.morphAttributes[g]=_}e.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const d=e.data.groups||e.data.drawcalls||e.data.offsets;if(d!==void 0)for(let g=0,v=d.length;g!==v;++g){const _=d[g];r.addGroup(_.start,_.count,_.materialIndex)}const p=e.data.boundingSphere;return p!==void 0&&(r.boundingSphere=new Qa().fromJSON(p)),e.name&&(r.name=e.name),e.userData&&(r.userData=e.userData),r}}class wJ extends br{constructor(e){super(e)}load(e,t,s,i){const a=this,r=this.path===""?Of.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const o=new vr(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(d){i!==void 0&&i(d),d("ObjectLoader: Can't parse "+e+".",d.message);return}const h=c.metadata;if(h===void 0||h.type===void 0||h.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),On("ObjectLoader: Can't load "+e);return}a.parse(c,t)},s,i)}async loadAsync(e,t){const s=this,i=this.path===""?Of.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const a=new vr(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials);const r=await a.loadAsync(e,t),o=JSON.parse(r),l=o.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await s.parseAsync(o)}parse(e,t){const s=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),a=this.parseGeometries(e.geometries,i),r=this.parseImages(e.images,function(){t!==void 0&&t(c)}),o=this.parseTextures(e.textures,r),l=this.parseMaterials(e.materials,o),c=this.parseObject(e.object,a,l,o,s),h=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,h),this.bindLightTargets(c),t!==void 0){let d=!1;for(const p in r)if(r[p].data instanceof HTMLImageElement){d=!0;break}d===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),a=await this.parseImagesAsync(e.images),r=this.parseTextures(e.textures,a),o=this.parseMaterials(e.materials,r),l=this.parseObject(e.object,i,o,r,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),this.bindLightTargets(l),l}parseShapes(e){const t={};if(e!==void 0)for(let s=0,i=e.length;s<i;s++){const a=new Xm().fromJSON(e[s]);t[a.uuid]=a}return t}parseSkeletons(e,t){const s={},i={};if(t.traverse(function(a){a.isBone&&(i[a.uuid]=a)}),e!==void 0)for(let a=0,r=e.length;a<r;a++){const o=new DS().fromJSON(e[a],i);s[o.uuid]=o}return s}parseGeometries(e,t){const s={};if(e!==void 0){const i=new ZG;for(let a=0,r=e.length;a<r;a++){let o;const l=e[a];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":o=i.parse(l);break;default:l.type in HU?o=HU[l.type].fromJSON(l,t):Wt(`ObjectLoader: Unsupported geometry type "${l.type}"`)}o.uuid=l.uuid,l.name!==void 0&&(o.name=l.name),l.userData!==void 0&&(o.userData=l.userData),s[l.uuid]=o}}return s}parseMaterials(e,t){const s={},i={};if(e!==void 0){const a=new N2;a.setTextures(t);for(let r=0,o=e.length;r<o;r++){const l=e[r];s[l.uuid]===void 0&&(s[l.uuid]=a.parse(l)),i[l.uuid]=s[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let s=0;s<e.length;s++){const i=e[s],a=Gx.parse(i);t[a.uuid]=a}return t}parseImages(e,t){const s=this,i={};let a;function r(l){return s.manager.itemStart(l),a.load(l,function(){s.manager.itemEnd(l)},void 0,function(){s.manager.itemError(l),s.manager.itemEnd(l)})}function o(l){if(typeof l=="string"){const c=l,h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:s.resourcePath+c;return r(h)}else return l.data?{data:bx(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new M2(t);a=new Q1(l),a.setCrossOrigin(this.crossOrigin);for(let c=0,h=e.length;c<h;c++){const d=e[c],p=d.url;if(Array.isArray(p)){const g=[];for(let v=0,_=p.length;v<_;v++){const S=p[v],b=o(S);b!==null&&(b instanceof HTMLImageElement?g.push(b):g.push(new ac(b.data,b.width,b.height)))}i[d.uuid]=new Ef(g)}else{const g=o(d.url);i[d.uuid]=new Ef(g)}}}return i}async parseImagesAsync(e){const t=this,s={};let i;async function a(r){if(typeof r=="string"){const o=r,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:t.resourcePath+o;return await i.loadAsync(l)}else return r.data?{data:bx(r.type,r.data),width:r.width,height:r.height}:null}if(e!==void 0&&e.length>0){i=new Q1(this.manager),i.setCrossOrigin(this.crossOrigin);for(let r=0,o=e.length;r<o;r++){const l=e[r],c=l.url;if(Array.isArray(c)){const h=[];for(let d=0,p=c.length;d<p;d++){const g=c[d],v=await a(g);v!==null&&(v instanceof HTMLImageElement?h.push(v):h.push(new ac(v.data,v.width,v.height)))}s[l.uuid]=new Ef(h)}else{const h=await a(l.url);s[l.uuid]=new Ef(h)}}}return s}parseTextures(e,t){function s(a,r){return typeof a=="number"?a:(Wt("ObjectLoader.parseTexture: Constant should be in numeric form.",a),r[a])}const i={};if(e!==void 0)for(let a=0,r=e.length;a<r;a++){const o=e[a];o.image===void 0&&Wt('ObjectLoader: No "image" specified for',o.uuid),t[o.image]===void 0&&Wt("ObjectLoader: Undefined image",o.image);const l=t[o.image],c=l.data;let h;Array.isArray(c)?(h=new RS,c.length===6&&(h.needsUpdate=!0)):(c&&c.data?h=new ac:h=new Vs,c&&(h.needsUpdate=!0)),h.source=l,h.uuid=o.uuid,o.name!==void 0&&(h.name=o.name),o.mapping!==void 0&&(h.mapping=s(o.mapping,CJ)),o.channel!==void 0&&(h.channel=o.channel),o.offset!==void 0&&h.offset.fromArray(o.offset),o.repeat!==void 0&&h.repeat.fromArray(o.repeat),o.center!==void 0&&h.center.fromArray(o.center),o.rotation!==void 0&&(h.rotation=o.rotation),o.wrap!==void 0&&(h.wrapS=s(o.wrap[0],qU),h.wrapT=s(o.wrap[1],qU)),o.format!==void 0&&(h.format=o.format),o.internalFormat!==void 0&&(h.internalFormat=o.internalFormat),o.type!==void 0&&(h.type=o.type),o.colorSpace!==void 0&&(h.colorSpace=o.colorSpace),o.minFilter!==void 0&&(h.minFilter=s(o.minFilter,KU)),o.magFilter!==void 0&&(h.magFilter=s(o.magFilter,KU)),o.anisotropy!==void 0&&(h.anisotropy=o.anisotropy),o.flipY!==void 0&&(h.flipY=o.flipY),o.generateMipmaps!==void 0&&(h.generateMipmaps=o.generateMipmaps),o.premultiplyAlpha!==void 0&&(h.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(h.unpackAlignment=o.unpackAlignment),o.compareFunction!==void 0&&(h.compareFunction=o.compareFunction),o.userData!==void 0&&(h.userData=o.userData),i[o.uuid]=h}return i}parseObject(e,t,s,i,a){let r;function o(p){return t[p]===void 0&&Wt("ObjectLoader: Undefined geometry",p),t[p]}function l(p){if(p!==void 0){if(Array.isArray(p)){const g=[];for(let v=0,_=p.length;v<_;v++){const S=p[v];s[S]===void 0&&Wt("ObjectLoader: Undefined material",S),g.push(s[S])}return g}return s[p]===void 0&&Wt("ObjectLoader: Undefined material",p),s[p]}}function c(p){return i[p]===void 0&&Wt("ObjectLoader: Undefined texture",p),i[p]}let h,d;switch(e.type){case"Scene":r=new dy,e.background!==void 0&&(Number.isInteger(e.background)?r.background=new $t(e.background):r.background=c(e.background)),e.environment!==void 0&&(r.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?r.fog=new h2(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(r.fog=new u2(e.fog.color,e.fog.density)),e.fog.name!==""&&(r.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(r.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(r.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&r.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(r.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&r.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":r=new ki(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(r.focus=e.focus),e.zoom!==void 0&&(r.zoom=e.zoom),e.filmGauge!==void 0&&(r.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(r.filmOffset=e.filmOffset),e.view!==void 0&&(r.view=Object.assign({},e.view));break;case"OrthographicCamera":r=new Zu(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(r.zoom=e.zoom),e.view!==void 0&&(r.view=Object.assign({},e.view));break;case"AmbientLight":r=new XG(e.color,e.intensity);break;case"DirectionalLight":r=new RO(e.color,e.intensity),r.target=e.target||"";break;case"PointLight":r=new NO(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":r=new qG(e.color,e.intensity,e.width,e.height);break;case"SpotLight":r=new MO(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),r.target=e.target||"";break;case"HemisphereLight":r=new jG(e.color,e.groundColor,e.intensity);break;case"LightProbe":r=new YG().fromJSON(e);break;case"SkinnedMesh":h=o(e.geometry),d=l(e.material),r=new uO(h,d),e.bindMode!==void 0&&(r.bindMode=e.bindMode),e.bindMatrix!==void 0&&r.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(r.skeleton=e.skeleton);break;case"Mesh":h=o(e.geometry),d=l(e.material),r=new Ti(h,d);break;case"InstancedMesh":h=o(e.geometry),d=l(e.material);const p=e.count,g=e.instanceMatrix,v=e.instanceColor;r=new hO(h,d,p),r.instanceMatrix=new ng(new Float32Array(g.array),16),v!==void 0&&(r.instanceColor=new ng(new Float32Array(v.array),v.itemSize));break;case"BatchedMesh":h=o(e.geometry),d=l(e.material),r=new xG(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,d),r.geometry=h,r.perObjectFrustumCulled=e.perObjectFrustumCulled,r.sortObjects=e.sortObjects,r._drawRanges=e.drawRanges,r._reservedRanges=e.reservedRanges,r._geometryInfo=e.geometryInfo.map(_=>{let S=null,b=null;return _.boundingBox!==void 0&&(S=new yr().fromJSON(_.boundingBox)),_.boundingSphere!==void 0&&(b=new Qa().fromJSON(_.boundingSphere)),{..._,boundingBox:S,boundingSphere:b}}),r._instanceInfo=e.instanceInfo,r._availableInstanceIds=e._availableInstanceIds,r._availableGeometryIds=e._availableGeometryIds,r._nextIndexStart=e.nextIndexStart,r._nextVertexStart=e.nextVertexStart,r._geometryCount=e.geometryCount,r._maxInstanceCount=e.maxInstanceCount,r._maxVertexCount=e.maxVertexCount,r._maxIndexCount=e.maxIndexCount,r._geometryInitialized=e.geometryInitialized,r._matricesTexture=c(e.matricesTexture.uuid),r._indirectTexture=c(e.indirectTexture.uuid),e.colorsTexture!==void 0&&(r._colorsTexture=c(e.colorsTexture.uuid)),e.boundingSphere!==void 0&&(r.boundingSphere=new Qa().fromJSON(e.boundingSphere)),e.boundingBox!==void 0&&(r.boundingBox=new yr().fromJSON(e.boundingBox));break;case"LOD":r=new gG;break;case"Line":r=new pd(o(e.geometry),l(e.material));break;case"LineLoop":r=new dO(o(e.geometry),l(e.material));break;case"LineSegments":r=new iu(o(e.geometry),l(e.material));break;case"PointCloud":case"Points":r=new fO(o(e.geometry),l(e.material));break;case"Sprite":r=new mG(l(e.material));break;case"Group":r=new ld;break;case"Bone":r=new d2;break;default:r=new Ts}if(r.uuid=e.uuid,e.name!==void 0&&(r.name=e.name),e.matrix!==void 0?(r.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(r.matrixAutoUpdate=e.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(e.position!==void 0&&r.position.fromArray(e.position),e.rotation!==void 0&&r.rotation.fromArray(e.rotation),e.quaternion!==void 0&&r.quaternion.fromArray(e.quaternion),e.scale!==void 0&&r.scale.fromArray(e.scale)),e.up!==void 0&&r.up.fromArray(e.up),e.castShadow!==void 0&&(r.castShadow=e.castShadow),e.receiveShadow!==void 0&&(r.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(r.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(r.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(r.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(r.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&r.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(r.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(r.visible=e.visible),e.frustumCulled!==void 0&&(r.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(r.renderOrder=e.renderOrder),e.userData!==void 0&&(r.userData=e.userData),e.layers!==void 0&&(r.layers.mask=e.layers),e.children!==void 0){const p=e.children;for(let g=0;g<p.length;g++)r.add(this.parseObject(p[g],t,s,i,a))}if(e.animations!==void 0){const p=e.animations;for(let g=0;g<p.length;g++){const v=p[g];r.animations.push(a[v])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(r.autoUpdate=e.autoUpdate);const p=e.levels;for(let g=0;g<p.length;g++){const v=p[g],_=r.getObjectByProperty("uuid",v.object);_!==void 0&&r.addLevel(_,v.distance,v.hysteresis)}}return r}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(s){if(s.isSkinnedMesh===!0&&s.skeleton!==void 0){const i=t[s.skeleton];i===void 0?Wt("ObjectLoader: No skeleton found with UUID:",s.skeleton):s.bind(i,s.bindMatrix)}})}bindLightTargets(e){e.traverse(function(t){if(t.isDirectionalLight||t.isSpotLight){const s=t.target,i=e.getObjectByProperty("uuid",s);i!==void 0?t.target=i:t.target=new Ts}})}}const CJ={UVMapping:Ff,CubeReflectionMapping:ah,CubeRefractionMapping:Uf,EquirectangularReflectionMapping:Rx,EquirectangularRefractionMapping:H1,CubeUVReflectionMapping:hy},qU={RepeatWrapping:Pf,ClampToEdgeWrapping:Fi,MirroredRepeatWrapping:Ix},KU={NearestFilter:Ja,NearestMipmapNearestFilter:QE,NearestMipmapLinearFilter:Lm,LinearFilter:is,LinearMipmapNearestFilter:Sx,LinearMipmapLinearFilter:tc},vI=new WeakMap;class QG extends br{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&Wt("ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&Wt("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(e){return this.options=e,this}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const a=this,r=qu.get(`image-bitmap:${e}`);if(r!==void 0){if(a.manager.itemStart(e),r.then){r.then(c=>{if(vI.has(r)===!0)i&&i(vI.get(r)),a.manager.itemError(e),a.manager.itemEnd(e);else return t&&t(c),a.manager.itemEnd(e),c});return}return setTimeout(function(){t&&t(r),a.manager.itemEnd(e)},0),r}const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,o.signal=typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const l=fetch(e,o).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(a.options,{colorSpaceConversion:"none"}))}).then(function(c){return qu.add(`image-bitmap:${e}`,c),t&&t(c),a.manager.itemEnd(e),c}).catch(function(c){i&&i(c),vI.set(l,c),qu.remove(`image-bitmap:${e}`),a.manager.itemError(e),a.manager.itemEnd(e)});qu.add(`image-bitmap:${e}`,l),a.manager.itemStart(e)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}let NC;class IO{static getContext(){return NC===void 0&&(NC=new(window.AudioContext||window.webkitAudioContext)),NC}static setContext(e){NC=e}}class TJ extends br{constructor(e){super(e)}load(e,t,s,i){const a=this,r=new vr(this.manager);r.setResponseType("arraybuffer"),r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(l){try{const c=l.slice(0);IO.getContext().decodeAudioData(c,function(d){t(d)}).catch(o)}catch(c){o(c)}},s,i);function o(l){i?i(l):On(l),a.manager.itemError(e)}}}const YU=new _n,JU=new _n,fm=new _n;class EJ{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ki,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ki,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,fm.copy(e.projectionMatrix);const i=t.eyeSep/2,a=i*t.near/t.focus,r=t.near*Math.tan(jm*t.fov*.5)/t.zoom;let o,l;JU.elements[12]=-i,YU.elements[12]=i,o=-r*t.aspect+a,l=r*t.aspect+a,fm.elements[0]=2*t.near/(l-o),fm.elements[8]=(l+o)/(l-o),this.cameraL.projectionMatrix.copy(fm),o=-r*t.aspect-a,l=r*t.aspect-a,fm.elements[0]=2*t.near/(l-o),fm.elements[8]=(l+o)/(l-o),this.cameraR.projectionMatrix.copy(fm)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(JU),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(YU)}}class eV extends ki{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class DO{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=performance.now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}const pm=new ue,bI=new Za,MJ=new ue,mm=new ue,gm=new ue;class NJ extends Ts{constructor(){super(),this.type="AudioListener",this.context=IO.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new DO}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(pm,bI,MJ),mm.set(0,0,-1).applyQuaternion(bI),gm.set(0,1,0).applyQuaternion(bI),t.positionX){const s=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(pm.x,s),t.positionY.linearRampToValueAtTime(pm.y,s),t.positionZ.linearRampToValueAtTime(pm.z,s),t.forwardX.linearRampToValueAtTime(mm.x,s),t.forwardY.linearRampToValueAtTime(mm.y,s),t.forwardZ.linearRampToValueAtTime(mm.z,s),t.upX.linearRampToValueAtTime(gm.x,s),t.upY.linearRampToValueAtTime(gm.y,s),t.upZ.linearRampToValueAtTime(gm.z,s)}else t.setPosition(pm.x,pm.y,pm.z),t.setOrientation(mm.x,mm.y,mm.z,gm.x,gm.y,gm.z)}}class tV extends Ts{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){Wt("Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){Wt("Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){Wt("Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){Wt("Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){Wt("Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(Wt("Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){Wt("Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,t){return super.copy(e,t),e.sourceType!=="buffer"?(Wt("Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const xm=new ue,ZU=new Za,RJ=new ue,ym=new ue;class IJ extends tV{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,s){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=s,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(xm,ZU,RJ),ym.set(0,0,1).applyQuaternion(ZU);const t=this.panner;if(t.positionX){const s=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(xm.x,s),t.positionY.linearRampToValueAtTime(xm.y,s),t.positionZ.linearRampToValueAtTime(xm.z,s),t.orientationX.linearRampToValueAtTime(ym.x,s),t.orientationY.linearRampToValueAtTime(ym.y,s),t.orientationZ.linearRampToValueAtTime(ym.z,s)}else t.setPosition(xm.x,xm.y,xm.z),t.setOrientation(ym.x,ym.y,ym.z)}}class DJ{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let s=0;s<t.length;s++)e+=t[s];return e/t.length}}class nV{constructor(e,t,s){this.binding=e,this.valueSize=s;let i,a,r;switch(t){case"quaternion":i=this._slerp,a=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":i=this._select,a=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:i=this._lerp,a=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=a,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const s=this.buffer,i=this.valueSize,a=e*i+i;let r=this.cumulativeWeight;if(r===0){for(let o=0;o!==i;++o)s[a+o]=s[o];r=t}else{r+=t;const o=t/r;this._mixBufferRegion(s,a,0,o,i)}this.cumulativeWeight=r}accumulateAdditive(e){const t=this.buffer,s=this.valueSize,i=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,s=this.buffer,i=e*t+t,a=this.cumulativeWeight,r=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,a<1){const l=t*this._origIndex;this._mixBufferRegion(s,i,l,1-a,t)}r>0&&this._mixBufferRegionAdditive(s,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(s[l]!==s[l+t]){o.setValue(s,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,s=this.valueSize,i=s*this._origIndex;e.getValue(t,i);for(let a=s,r=i;a!==r;++a)t[a]=t[i+a%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let s=e;s<t;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[t+s]=this.buffer[e+s]}_select(e,t,s,i,a){if(i>=.5)for(let r=0;r!==a;++r)e[t+r]=e[s+r]}_slerp(e,t,s,i){Za.slerpFlat(e,t,e,t,e,s,i)}_slerpAdditive(e,t,s,i,a){const r=this._workIndex*a;Za.multiplyQuaternionsFlat(e,r,e,t,e,s),Za.slerpFlat(e,t,e,t,e,r,i)}_lerp(e,t,s,i,a){const r=1-i;for(let o=0;o!==a;++o){const l=t+o;e[l]=e[l]*r+e[s+o]*i}}_lerpAdditive(e,t,s,i,a){for(let r=0;r!==a;++r){const o=t+r;e[o]=e[o]+e[s+r]*i}}}const OO="\\[\\]\\.:\\/",OJ=new RegExp("["+OO+"]","g"),BO="[^"+OO+"]",BJ="[^"+OO.replace("\\.","")+"]",kJ=/((?:WC+[\/:])*)/.source.replace("WC",BO),LJ=/(WCOD+)?/.source.replace("WCOD",BJ),FJ=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",BO),UJ=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",BO),PJ=new RegExp("^"+kJ+LJ+FJ+UJ+"$"),zJ=["material","materials","bones","map"];class $J{constructor(e,t,s){const i=s||Ns.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,i=this._bindings[s];i!==void 0&&i.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let i=this._targetGroup.nCachedObjects_,a=s.length;i!==a;++i)s[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class Ns{constructor(e,t,s){this.path=t,this.parsedPath=s||Ns.parseTrackName(t),this.node=Ns.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new Ns.Composite(e,t,s):new Ns(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(OJ,"")}static parseTrackName(e){const t=PJ.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=s.nodeName&&s.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const a=s.nodeName.substring(i+1);zJ.indexOf(a)!==-1&&(s.nodeName=s.nodeName.substring(0,i),s.objectName=a)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(a){for(let r=0;r<a.length;r++){const o=a[r];if(o.name===t||o.uuid===t)return o;const l=s(o.children);if(l)return l}return null},i=s(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let i=0,a=s.length;i!==a;++i)e[t++]=s[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let i=0,a=s.length;i!==a;++i)s[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,a=s.length;i!==a;++i)s[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,a=s.length;i!==a;++i)s[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,i=t.propertyName;let a=t.propertyIndex;if(e||(e=Ns.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){Wt("PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let c=t.objectIndex;switch(s){case"materials":if(!e.material){On("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){On("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){On("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let h=0;h<e.length;h++)if(e[h].name===c){c=h;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){On("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){On("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){On("PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(c!==void 0){if(e[c]===void 0){On("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const r=e[i];if(r===void 0){const c=t.nodeName;On("PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?o=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(a!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){On("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){On("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[a]!==void 0&&(a=e.morphTargetDictionary[a])}l=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=a}else r.fromArray!==void 0&&r.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(l=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Ns.Composite=$J;Ns.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ns.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ns.prototype.GetterByBindingType=[Ns.prototype._getValue_direct,Ns.prototype._getValue_array,Ns.prototype._getValue_arrayElement,Ns.prototype._getValue_toArray];Ns.prototype.SetterByBindingTypeAndVersioning=[[Ns.prototype._setValue_direct,Ns.prototype._setValue_direct_setNeedsUpdate,Ns.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ns.prototype._setValue_array,Ns.prototype._setValue_array_setNeedsUpdate,Ns.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ns.prototype._setValue_arrayElement,Ns.prototype._setValue_arrayElement_setNeedsUpdate,Ns.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ns.prototype._setValue_fromArray,Ns.prototype._setValue_fromArray_setNeedsUpdate,Ns.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class GJ{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Sl(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let s=0,i=arguments.length;s!==i;++s)e[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,s=this._paths,i=this._parsedPaths,a=this._bindings,r=a.length;let o,l=e.length,c=this.nCachedObjects_;for(let h=0,d=arguments.length;h!==d;++h){const p=arguments[h],g=p.uuid;let v=t[g];if(v===void 0){v=l++,t[g]=v,e.push(p);for(let _=0,S=r;_!==S;++_)a[_].push(new Ns(p,s[_],i[_]))}else if(v<c){o=e[v];const _=--c,S=e[_];t[S.uuid]=v,e[v]=S,t[g]=_,e[_]=p;for(let b=0,w=r;b!==w;++b){const T=a[b],E=T[_];let R=T[v];T[v]=E,R===void 0&&(R=new Ns(p,s[b],i[b])),T[_]=R}}else e[v]!==o&&On("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,i=s.length;let a=this.nCachedObjects_;for(let r=0,o=arguments.length;r!==o;++r){const l=arguments[r],c=l.uuid,h=t[c];if(h!==void 0&&h>=a){const d=a++,p=e[d];t[p.uuid]=h,e[h]=p,t[c]=d,e[d]=l;for(let g=0,v=i;g!==v;++g){const _=s[g],S=_[d],b=_[h];_[h]=S,_[d]=b}}}this.nCachedObjects_=a}uncache(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,i=s.length;let a=this.nCachedObjects_,r=e.length;for(let o=0,l=arguments.length;o!==l;++o){const c=arguments[o],h=c.uuid,d=t[h];if(d!==void 0)if(delete t[h],d<a){const p=--a,g=e[p],v=--r,_=e[v];t[g.uuid]=d,e[d]=g,t[_.uuid]=p,e[p]=_,e.pop();for(let S=0,b=i;S!==b;++S){const w=s[S],T=w[p],E=w[v];w[d]=T,w[p]=E,w.pop()}}else{const p=--r,g=e[p];p>0&&(t[g.uuid]=d),e[d]=g,e.pop();for(let v=0,_=i;v!==_;++v){const S=s[v];S[d]=S[p],S.pop()}}}this.nCachedObjects_=a}subscribe_(e,t){const s=this._bindingsIndicesByPath;let i=s[e];const a=this._bindings;if(i!==void 0)return a[i];const r=this._paths,o=this._parsedPaths,l=this._objects,c=l.length,h=this.nCachedObjects_,d=new Array(c);i=a.length,s[e]=i,r.push(e),o.push(t),a.push(d);for(let p=h,g=l.length;p!==g;++p){const v=l[p];d[p]=new Ns(v,e,t)}return d}unsubscribe_(e){const t=this._bindingsIndicesByPath,s=t[e];if(s!==void 0){const i=this._paths,a=this._parsedPaths,r=this._bindings,o=r.length-1,l=r[o],c=e[o];t[c]=s,r[s]=l,r.pop(),a[s]=a[o],a.pop(),i[s]=i[o],i.pop()}}}class sV{constructor(e,t,s=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=s,this.blendMode=i;const a=t.tracks,r=a.length,o=new Array(r),l={endingStart:Fm,endingEnd:Fm};for(let c=0;c!==r;++c){const h=a[c].createInterpolant(null);o[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=X4,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,s=!1){if(e.fadeOut(t),this.fadeIn(t),s===!0){const i=this._clip.duration,a=e._clip.duration,r=a/i,o=i/a;e.warp(1,r,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,s=!1){return e.crossFadeFrom(this,t,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,s){const i=this._mixer,a=i.time,r=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=a,l[1]=a+s,c[0]=e/r,c[1]=t/r,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,s,i){if(!this.enabled){this._updateWeight(e);return}const a=this._startTime;if(a!==null){const l=(e-a)*s;l<0||s===0?t=0:(this._startTime=null,t=s*l)}t*=this._updateTimeScale(e);const r=this._updateTime(t),o=this._updateWeight(e);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case tO:for(let h=0,d=l.length;h!==d;++h)l[h].evaluate(r),c[h].accumulateAdditive(o);break;case o2:default:for(let h=0,d=l.length;h!==d;++h)l[h].evaluate(r),c[h].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const s=this._weightInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,s=this.loop;let i=this.time+e,a=this._loopCount;const r=s===q4;if(e===0)return a===-1?i:r&&(a&1)===1?t-i:i;if(s===j4){a===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(a===-1&&(e>=0?(a=0,this._setEndings(!0,this.repetitions===0,r)):this._setEndings(this.repetitions===0,!0,r)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,a+=Math.abs(o);const l=this.repetitions-a;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,r)}else this._setEndings(!1,!1,r);this._loopCount=a,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(r&&(a&1)===1)return t-i}return i}_setEndings(e,t,s){const i=this._interpolantSettings;s?(i.endingStart=Um,i.endingEnd=Um):(e?i.endingStart=this.zeroSlopeAtStart?Um:Fm:i.endingStart=W1,t?i.endingEnd=this.zeroSlopeAtEnd?Um:Fm:i.endingEnd=W1)}_scheduleFading(e,t,s){const i=this._mixer,a=i.time;let r=this._weightInterpolant;r===null&&(r=i._lendControlInterpolant(),this._weightInterpolant=r);const o=r.parameterPositions,l=r.sampleValues;return o[0]=a,l[0]=t,o[1]=a+e,l[1]=s,this}}const VJ=new Float32Array(1);class HJ extends ph{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const s=e._localRoot||this._root,i=e._clip.tracks,a=i.length,r=e._propertyBindings,o=e._interpolants,l=s.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let d=0;d!==a;++d){const p=i[d],g=p.name;let v=h[g];if(v!==void 0)++v.referenceCount,r[d]=v;else{if(v=r[d],v!==void 0){v._cacheIndex===null&&(++v.referenceCount,this._addInactiveBinding(v,l,g));continue}const _=t&&t._propertyBindings[d].binding.parsedPath;v=new nV(Ns.create(s,g,_),p.ValueTypeName,p.getValueSize()),++v.referenceCount,this._addInactiveBinding(v,l,g),r[d]=v}o[d].resultBuffer=v.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,i=e._clip.uuid,a=this._actionsByClip[i];this._bindAction(e,a&&a.knownActions[0]),this._addInactiveAction(e,i,s)}const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const a=t[s];a.useCount++===0&&(this._lendBinding(a),a.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const a=t[s];--a.useCount===0&&(a.restoreOriginalState(),this._takeBackBinding(a))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,s){const i=this._actions,a=this._actionsByClip;let r=a[t];if(r===void 0)r={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,a[t]=r;else{const o=r.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),r.actionByRoot[s]=e}_removeInactiveAction(e){const t=this._actions,s=t[t.length-1],i=e._cacheIndex;s._cacheIndex=i,t[i]=s,t.pop(),e._cacheIndex=null;const a=e._clip.uuid,r=this._actionsByClip,o=r[a],l=o.knownActions,c=l[l.length-1],h=e._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),e._byClipCacheIndex=null;const d=o.actionByRoot,p=(e._localRoot||this._root).uuid;delete d[p],l.length===0&&delete r[a],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const a=t[s];--a.referenceCount===0&&this._removeInactiveBinding(a)}}_lendAction(e){const t=this._actions,s=e._cacheIndex,i=this._nActiveActions++,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=s,t[s]=a}_takeBackAction(e){const t=this._actions,s=e._cacheIndex,i=--this._nActiveActions,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=s,t[s]=a}_addInactiveBinding(e,t,s){const i=this._bindingsByRootAndName,a=this._bindings;let r=i[t];r===void 0&&(r={},i[t]=r),r[s]=e,e._cacheIndex=a.length,a.push(e)}_removeInactiveBinding(e){const t=this._bindings,s=e.binding,i=s.rootNode.uuid,a=s.path,r=this._bindingsByRootAndName,o=r[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete o[a],Object.keys(o).length===0&&delete r[i]}_lendBinding(e){const t=this._bindings,s=e._cacheIndex,i=this._nActiveBindings++,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=s,t[s]=a}_takeBackBinding(e){const t=this._bindings,s=e._cacheIndex,i=--this._nActiveBindings,a=t[i];e._cacheIndex=i,t[i]=e,a._cacheIndex=s,t[s]=a}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let s=e[t];return s===void 0&&(s=new wO(new Float32Array(2),new Float32Array(2),1,VJ),s.__cacheIndex=t,e[t]=s),s}_takeBackControlInterpolant(e){const t=this._controlInterpolants,s=e.__cacheIndex,i=--this._nActiveControlInterpolants,a=t[i];e.__cacheIndex=i,t[i]=e,a.__cacheIndex=s,t[s]=a}clipAction(e,t,s){const i=t||this._root,a=i.uuid;let r=typeof e=="string"?Gx.findByName(i,e):e;const o=r!==null?r.uuid:e,l=this._actionsByClip[o];let c=null;if(s===void 0&&(r!==null?s=r.blendMode:s=o2),l!==void 0){const d=l.actionByRoot[a];if(d!==void 0&&d.blendMode===s)return d;c=l.knownActions[0],r===null&&(r=c._clip)}if(r===null)return null;const h=new sV(this,r,t,s);return this._bindAction(h,c),this._addInactiveAction(h,o,a),h}existingAction(e,t){const s=t||this._root,i=s.uuid,a=typeof e=="string"?Gx.findByName(s,e):e,r=a?a.uuid:e,o=this._actionsByClip[r];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let s=t-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const t=this._actions,s=this._nActiveActions,i=this.time+=e,a=Math.sign(e),r=this._accuIndex^=1;for(let c=0;c!==s;++c)t[c]._update(i,e,a,r);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(r);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,s=e.uuid,i=this._actionsByClip,a=i[s];if(a!==void 0){const r=a.knownActions;for(let o=0,l=r.length;o!==l;++o){const c=r[o];this._deactivateAction(c);const h=c._cacheIndex,d=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,d._cacheIndex=h,t[h]=d,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[s]}}uncacheRoot(e){const t=e.uuid,s=this._actionsByClip;for(const r in s){const o=s[r].actionByRoot,l=o[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,a=i[t];if(a!==void 0)for(const r in a){const o=a[r];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const s=this.existingAction(e,t);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}class WJ extends aO{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isRenderTarget3D=!0,this.depth=s,this.texture=new c2(null,e,t,s),this._setTextureOptions(i),this.texture.isRenderTargetTexture=!0}}class Pr{constructor(e){this.value=e}clone(){return new Pr(this.value.clone===void 0?this.value:this.value.clone())}}let jJ=0;class XJ extends ph{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:jJ++}),this.name="",this.usage=X1,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let s=0,i=t.length;s<i;s++){const a=Array.isArray(t[s])?t[s]:[t[s]];for(let r=0;r<a.length;r++)this.uniforms.push(a[r].clone())}return this}clone(){return new this.constructor().copy(this)}}class qJ extends IS{constructor(e,t,s=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class KJ{constructor(e,t,s,i,a,r=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=s,this.elementSize=i,this.count=a,this.normalized=r,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const QU=new _n;class kO{constructor(e,t,s=0,i=1/0){this.ray=new Ag(e,t),this.near=s,this.far=i,this.camera=null,this.layers=new Px,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):On("Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return QU.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(QU),this}intersectObject(e,t=!0,s=[]){return k3(e,this,s,t),s.sort(eP),s}intersectObjects(e,t=!0,s=[]){for(let i=0,a=e.length;i<a;i++)k3(e[i],this,s,t);return s.sort(eP),s}}function eP(n,e){return n.distance-e.distance}function k3(n,e,t,s){let i=!0;if(n.layers.test(e.layers)&&n.raycast(e,t)===!1&&(i=!1),i===!0&&s===!0){const a=n.children;for(let r=0,o=a.length;r<o;r++)k3(a[r],e,t,!0)}}class YJ{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(e){this._document=e,e.hidden!==void 0&&(this._pageVisibilityHandler=JJ.bind(this),e.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){this._pageVisibilityHandler!==null&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(e){return this._timescale=e,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(e){return this._pageVisibilityHandler!==null&&this._document.hidden===!0?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(e!==void 0?e:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}}function JJ(){this._document.hidden===!1&&this.reset()}class L3{constructor(e=1,t=0,s=0){this.radius=e,this.phi=t,this.theta=s}set(e,t,s){return this.radius=e,this.phi=t,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Rn(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+t*t+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(Rn(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class ZJ{constructor(e=1,t=0,s=0){this.radius=e,this.theta=t,this.y=s}set(e,t,s){return this.radius=e,this.theta=t,this.y=s,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+s*s),this.theta=Math.atan2(e,s),this.y=t,this}clone(){return new this.constructor().copy(this)}}class LO{constructor(e,t,s,i){LO.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,t,s,i)}identity(){return this.set(1,0,0,1),this}fromArray(e,t=0){for(let s=0;s<4;s++)this.elements[s]=e[s+t];return this}set(e,t,s,i){const a=this.elements;return a[0]=e,a[2]=t,a[1]=s,a[3]=i,this}}const tP=new rt;class QJ{constructor(e=new rt(1/0,1/0),t=new rt(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=tP.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,tP).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const nP=new ue,RC=new ue,ux=new ue,hx=new ue,SI=new ue,eZ=new ue,tZ=new ue;class nZ{constructor(e=new ue,t=new ue){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){nP.subVectors(e,this.start),RC.subVectors(this.end,this.start);const s=RC.dot(RC);let a=RC.dot(nP)/s;return t&&(a=Rn(a,0,1)),a}closestPointToPoint(e,t,s){const i=this.closestPointToPointParameter(e,t);return this.delta(s).multiplyScalar(i).add(this.start)}distanceSqToLine3(e,t=eZ,s=tZ){const i=10000000000000001e-32;let a,r;const o=this.start,l=e.start,c=this.end,h=e.end;ux.subVectors(c,o),hx.subVectors(h,l),SI.subVectors(o,l);const d=ux.dot(ux),p=hx.dot(hx),g=hx.dot(SI);if(d<=i&&p<=i)return t.copy(o),s.copy(l),t.sub(s),t.dot(t);if(d<=i)a=0,r=g/p,r=Rn(r,0,1);else{const v=ux.dot(SI);if(p<=i)r=0,a=Rn(-v/d,0,1);else{const _=ux.dot(hx),S=d*p-_*_;S!==0?a=Rn((_*g-v*p)/S,0,1):a=0,r=(_*a+g)/p,r<0?(r=0,a=Rn(-v/d,0,1)):r>1&&(r=1,a=Rn((_-v)/d,0,1))}}return t.copy(o).add(ux.multiplyScalar(a)),s.copy(l).add(hx.multiplyScalar(r)),t.sub(s),t.dot(t)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const sP=new ue;class sZ extends Ts{constructor(e,t){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const s=new Ln,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,o=1,l=32;r<l;r++,o++){const c=r/l*Math.PI*2,h=o/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}s.setAttribute("position",new on(i,3));const a=new qr({fog:!1,toneMapped:!1});this.cone=new iu(s,a),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),sP.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(sP),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _f=new ue,IC=new _n,_I=new _n;class iZ extends iu{constructor(e){const t=iV(e),s=new Ln,i=[],a=[];for(let c=0;c<t.length;c++){const h=t[c];h.parent&&h.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),a.push(0,0,0),a.push(0,0,0))}s.setAttribute("position",new on(i,3)),s.setAttribute("color",new on(a,3));const r=new qr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,r),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1;const o=new $t(255),l=new $t(65280);this.setColors(o,l)}updateMatrixWorld(e){const t=this.bones,s=this.geometry,i=s.getAttribute("position");_I.copy(this.root.matrixWorld).invert();for(let a=0,r=0;a<t.length;a++){const o=t[a];o.parent&&o.parent.isBone&&(IC.multiplyMatrices(_I,o.matrixWorld),_f.setFromMatrixPosition(IC),i.setXYZ(r,_f.x,_f.y,_f.z),IC.multiplyMatrices(_I,o.parent.matrixWorld),_f.setFromMatrixPosition(IC),i.setXYZ(r+1,_f.x,_f.y,_f.z),r+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}setColors(e,t){const i=this.geometry.getAttribute("color");for(let a=0;a<i.count;a+=2)i.setXYZ(a,e.r,e.g,e.b),i.setXYZ(a+1,t.r,t.g,t.b);return i.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}function iV(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push(...iV(n.children[t]));return e}class aZ extends Ti{constructor(e,t,s){const i=new US(t,4,2),a=new Yo({wireframe:!0,fog:!1,toneMapped:!1});super(i,a),this.light=e,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const rZ=new ue,iP=new $t,aP=new $t;class oZ extends Ts{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="HemisphereLightHelper";const i=new FS(t);i.rotateY(Math.PI*.5),this.material=new Yo({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const a=i.getAttribute("position"),r=new Float32Array(a.count*3);i.setAttribute("color",new Es(r,3)),this.add(new Ti(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");iP.copy(this.light.color),aP.copy(this.light.groundColor);for(let s=0,i=t.count;s<i;s++){const a=s<i/2?iP:aP;t.setXYZ(s,a.r,a.g,a.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(rZ.setFromMatrixPosition(this.light.matrixWorld).negate())}}let lZ=class extends iu{constructor(e=10,t=10,s=4473924,i=8947848){s=new $t(s),i=new $t(i);const a=t/2,r=e/t,o=e/2,l=[],c=[];for(let p=0,g=0,v=-o;p<=t;p++,v+=r){l.push(-o,0,v,o,0,v),l.push(v,0,-o,v,0,o);const _=p===a?s:i;_.toArray(c,g),g+=3,_.toArray(c,g),g+=3,_.toArray(c,g),g+=3,_.toArray(c,g),g+=3}const h=new Ln;h.setAttribute("position",new on(l,3)),h.setAttribute("color",new on(c,3));const d=new qr({vertexColors:!0,toneMapped:!1});super(h,d),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}};class cZ extends iu{constructor(e=10,t=16,s=8,i=64,a=4473924,r=8947848){a=new $t(a),r=new $t(r);const o=[],l=[];if(t>1)for(let d=0;d<t;d++){const p=d/t*(Math.PI*2),g=Math.sin(p)*e,v=Math.cos(p)*e;o.push(0,0,0),o.push(g,0,v);const _=d&1?a:r;l.push(_.r,_.g,_.b),l.push(_.r,_.g,_.b)}for(let d=0;d<s;d++){const p=d&1?a:r,g=e-e/s*d;for(let v=0;v<i;v++){let _=v/i*(Math.PI*2),S=Math.sin(_)*g,b=Math.cos(_)*g;o.push(S,0,b),l.push(p.r,p.g,p.b),_=(v+1)/i*(Math.PI*2),S=Math.sin(_)*g,b=Math.cos(_)*g,o.push(S,0,b),l.push(p.r,p.g,p.b)}}const c=new Ln;c.setAttribute("position",new on(o,3)),c.setAttribute("color",new on(l,3));const h=new qr({vertexColors:!0,toneMapped:!1});super(c,h),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const rP=new ue,DC=new ue,oP=new ue;class uZ extends Ts{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new Ln;i.setAttribute("position",new on([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const a=new qr({fog:!1,toneMapped:!1});this.lightPlane=new pd(i,a),this.add(this.lightPlane),i=new Ln,i.setAttribute("position",new on([0,0,0,0,0,1],3)),this.targetLine=new pd(i,a),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),rP.setFromMatrixPosition(this.light.matrixWorld),DC.setFromMatrixPosition(this.light.target.matrixWorld),oP.subVectors(DC,rP),this.lightPlane.lookAt(DC),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(DC),this.targetLine.scale.z=oP.length()}}const OC=new ue,Hi=new NS;class hZ extends iu{constructor(e){const t=new Ln,s=new qr({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],a=[],r={};o("n1","n2"),o("n2","n4"),o("n4","n3"),o("n3","n1"),o("f1","f2"),o("f2","f4"),o("f4","f3"),o("f3","f1"),o("n1","f1"),o("n2","f2"),o("n3","f3"),o("n4","f4"),o("p","n1"),o("p","n2"),o("p","n3"),o("p","n4"),o("u1","u2"),o("u2","u3"),o("u3","u1"),o("c","t"),o("p","c"),o("cn1","cn2"),o("cn3","cn4"),o("cf1","cf2"),o("cf3","cf4");function o(v,_){l(v),l(_)}function l(v){i.push(0,0,0),a.push(0,0,0),r[v]===void 0&&(r[v]=[]),r[v].push(i.length/3-1)}t.setAttribute("position",new on(i,3)),t.setAttribute("color",new on(a,3)),super(t,s),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=r,this.update();const c=new $t(16755200),h=new $t(16711680),d=new $t(43775),p=new $t(16777215),g=new $t(3355443);this.setColors(c,h,d,p,g)}setColors(e,t,s,i,a){const o=this.geometry.getAttribute("color");return o.setXYZ(0,e.r,e.g,e.b),o.setXYZ(1,e.r,e.g,e.b),o.setXYZ(2,e.r,e.g,e.b),o.setXYZ(3,e.r,e.g,e.b),o.setXYZ(4,e.r,e.g,e.b),o.setXYZ(5,e.r,e.g,e.b),o.setXYZ(6,e.r,e.g,e.b),o.setXYZ(7,e.r,e.g,e.b),o.setXYZ(8,e.r,e.g,e.b),o.setXYZ(9,e.r,e.g,e.b),o.setXYZ(10,e.r,e.g,e.b),o.setXYZ(11,e.r,e.g,e.b),o.setXYZ(12,e.r,e.g,e.b),o.setXYZ(13,e.r,e.g,e.b),o.setXYZ(14,e.r,e.g,e.b),o.setXYZ(15,e.r,e.g,e.b),o.setXYZ(16,e.r,e.g,e.b),o.setXYZ(17,e.r,e.g,e.b),o.setXYZ(18,e.r,e.g,e.b),o.setXYZ(19,e.r,e.g,e.b),o.setXYZ(20,e.r,e.g,e.b),o.setXYZ(21,e.r,e.g,e.b),o.setXYZ(22,e.r,e.g,e.b),o.setXYZ(23,e.r,e.g,e.b),o.setXYZ(24,t.r,t.g,t.b),o.setXYZ(25,t.r,t.g,t.b),o.setXYZ(26,t.r,t.g,t.b),o.setXYZ(27,t.r,t.g,t.b),o.setXYZ(28,t.r,t.g,t.b),o.setXYZ(29,t.r,t.g,t.b),o.setXYZ(30,t.r,t.g,t.b),o.setXYZ(31,t.r,t.g,t.b),o.setXYZ(32,s.r,s.g,s.b),o.setXYZ(33,s.r,s.g,s.b),o.setXYZ(34,s.r,s.g,s.b),o.setXYZ(35,s.r,s.g,s.b),o.setXYZ(36,s.r,s.g,s.b),o.setXYZ(37,s.r,s.g,s.b),o.setXYZ(38,i.r,i.g,i.b),o.setXYZ(39,i.r,i.g,i.b),o.setXYZ(40,a.r,a.g,a.b),o.setXYZ(41,a.r,a.g,a.b),o.setXYZ(42,a.r,a.g,a.b),o.setXYZ(43,a.r,a.g,a.b),o.setXYZ(44,a.r,a.g,a.b),o.setXYZ(45,a.r,a.g,a.b),o.setXYZ(46,a.r,a.g,a.b),o.setXYZ(47,a.r,a.g,a.b),o.setXYZ(48,a.r,a.g,a.b),o.setXYZ(49,a.r,a.g,a.b),o.needsUpdate=!0,this}update(){const e=this.geometry,t=this.pointMap,s=1,i=1;let a,r;if(Hi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),this.camera.reversedDepth===!0)a=1,r=0;else if(this.camera.coordinateSystem===yl)a=-1,r=1;else if(this.camera.coordinateSystem===Lx)a=0,r=1;else throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: "+this.camera.coordinateSystem);na("c",t,e,Hi,0,0,a),na("t",t,e,Hi,0,0,r),na("n1",t,e,Hi,-s,-i,a),na("n2",t,e,Hi,s,-i,a),na("n3",t,e,Hi,-s,i,a),na("n4",t,e,Hi,s,i,a),na("f1",t,e,Hi,-s,-i,r),na("f2",t,e,Hi,s,-i,r),na("f3",t,e,Hi,-s,i,r),na("f4",t,e,Hi,s,i,r),na("u1",t,e,Hi,s*.7,i*1.1,a),na("u2",t,e,Hi,-s*.7,i*1.1,a),na("u3",t,e,Hi,0,i*2,a),na("cf1",t,e,Hi,-s,0,r),na("cf2",t,e,Hi,s,0,r),na("cf3",t,e,Hi,0,-i,r),na("cf4",t,e,Hi,0,i,r),na("cn1",t,e,Hi,-s,0,a),na("cn2",t,e,Hi,s,0,a),na("cn3",t,e,Hi,0,-i,a),na("cn4",t,e,Hi,0,i,a),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function na(n,e,t,s,i,a,r){OC.set(i,a,r).unproject(s);const o=e[n];if(o!==void 0){const l=t.getAttribute("position");for(let c=0,h=o.length;c<h;c++)l.setXYZ(o[c],OC.x,OC.y,OC.z)}}const BC=new yr;class dZ extends iu{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),a=new Ln;a.setIndex(new Es(s,1)),a.setAttribute("position",new Es(i,3)),super(a,new qr({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&BC.setFromObject(this.object),BC.isEmpty())return;const e=BC.min,t=BC.max,s=this.geometry.attributes.position,i=s.array;i[0]=t.x,i[1]=t.y,i[2]=t.z,i[3]=e.x,i[4]=t.y,i[5]=t.z,i[6]=e.x,i[7]=e.y,i[8]=t.z,i[9]=t.x,i[10]=e.y,i[11]=t.z,i[12]=t.x,i[13]=t.y,i[14]=e.z,i[15]=e.x,i[16]=t.y,i[17]=e.z,i[18]=e.x,i[19]=e.y,i[20]=e.z,i[21]=t.x,i[22]=e.y,i[23]=e.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class fZ extends iu{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],a=new Ln;a.setIndex(new Es(s,1)),a.setAttribute("position",new on(i,3)),super(a,new qr({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class pZ extends pd{constructor(e,t=1,s=16776960){const i=s,a=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],r=new Ln;r.setAttribute("position",new on(a,3)),r.computeBoundingSphere(),super(r,new qr({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const o=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new Ln;l.setAttribute("position",new on(o,3)),l.computeBoundingSphere(),this.add(new Ti(l,new Yo({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const lP=new ue;let kC,AI;class mZ extends Ts{constructor(e=new ue(0,0,1),t=new ue(0,0,0),s=1,i=16776960,a=s*.2,r=a*.2){super(),this.type="ArrowHelper",kC===void 0&&(kC=new Ln,kC.setAttribute("position",new on([0,0,0,0,1,0],3)),AI=new kS(.5,1,5,1),AI.translate(0,-.5,0)),this.position.copy(t),this.line=new pd(kC,new qr({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Ti(AI,new Yo({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(s,a,r)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{lP.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(lP,t)}}setLength(e,t=e*.2,s=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(s,t,s),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class gZ extends iu{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Ln;i.setAttribute("position",new on(t,3)),i.setAttribute("color",new on(s,3));const a=new qr({vertexColors:!0,toneMapped:!1});super(i,a),this.type="AxesHelper"}setColors(e,t,s){const i=new $t,a=this.geometry.attributes.color.array;return i.set(e),i.toArray(a,0),i.toArray(a,3),i.set(t),i.toArray(a,6),i.toArray(a,9),i.set(s),i.toArray(a,12),i.toArray(a,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class xZ{constructor(){this.type="ShapePath",this.color=new $t,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new dE,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,s,i){return this.currentPath.quadraticCurveTo(e,t,s,i),this}bezierCurveTo(e,t,s,i,a,r){return this.currentPath.bezierCurveTo(e,t,s,i,a,r),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(b){const w=[];for(let T=0,E=b.length;T<E;T++){const R=b[T],D=new Xm;D.curves=R.curves,w.push(D)}return w}function s(b,w){const T=w.length;let E=!1;for(let R=T-1,D=0;D<T;R=D++){let F=w[R],U=w[D],O=U.x-F.x,B=U.y-F.y;if(Math.abs(B)>Number.EPSILON){if(B<0&&(F=w[D],O=-O,U=w[R],B=-B),b.y<F.y||b.y>U.y)continue;if(b.y===F.y){if(b.x===F.x)return!0}else{const L=B*(b.x-F.x)-O*(b.y-F.y);if(L===0)return!0;if(L<0)continue;E=!E}}else{if(b.y!==F.y)continue;if(U.x<=b.x&&b.x<=F.x||F.x<=b.x&&b.x<=U.x)return!0}}return E}const i=Xc.isClockWise,a=this.subPaths;if(a.length===0)return[];let r,o,l;const c=[];if(a.length===1)return o=a[0],l=new Xm,l.curves=o.curves,c.push(l),c;let h=!i(a[0].getPoints());h=e?!h:h;const d=[],p=[];let g=[],v=0,_;p[v]=void 0,g[v]=[];for(let b=0,w=a.length;b<w;b++)o=a[b],_=o.getPoints(),r=i(_),r=e?!r:r,r?(!h&&p[v]&&v++,p[v]={s:new Xm,p:_},p[v].s.curves=o.curves,h&&v++,g[v]=[]):g[v].push({h:o,p:_[0]});if(!p[0])return t(a);if(p.length>1){let b=!1,w=0;for(let T=0,E=p.length;T<E;T++)d[T]=[];for(let T=0,E=p.length;T<E;T++){const R=g[T];for(let D=0;D<R.length;D++){const F=R[D];let U=!0;for(let O=0;O<p.length;O++)s(F.p,p[O].p)&&(T!==O&&w++,U?(U=!1,d[O].push(F)):b=!0);U&&d[T].push(F)}}w>0&&b===!1&&(g=d)}let S;for(let b=0,w=p.length;b<w;b++){l=p[b].s,c.push(l),S=g[b];for(let T=0,E=S.length;T<E;T++)l.holes.push(S[T].h)}return c}}class yZ extends ph{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){if(e===void 0){Wt("Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=e}disconnect(){}dispose(){}update(){}}function vZ(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2):(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0),n}function bZ(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0):(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2),n}function SZ(n){return n.repeat.x=1,n.repeat.y=1,n.offset.x=0,n.offset.y=0,n}function F3(n,e,t,s){const i=_Z(s);switch(t){case QD:return n*e;case ES:return n*e/i.components*i.byteLength;case MS:return n*e/i.components*i.byteLength;case i2:return n*e*2/i.components*i.byteLength;case a2:return n*e*2/i.components*i.byteLength;case eO:return n*e*3/i.components*i.byteLength;case ra:return n*e*4/i.components*i.byteLength;case r2:return n*e*4/i.components*i.byteLength;case O1:case B1:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case k1:case L1:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case kT:case FT:return Math.max(n,16)*Math.max(e,8)/4;case BT:case LT:return Math.max(n,8)*Math.max(e,8)/2;case UT:case PT:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case zT:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case $T:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case GT:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case VT:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case HT:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case WT:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case jT:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case XT:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case qT:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case KT:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case YT:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case JT:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case ZT:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case QT:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case eE:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case tE:case nE:case sE:return Math.ceil(n/4)*Math.ceil(e/4)*16;case iE:case aE:return Math.ceil(n/4)*Math.ceil(e/4)*8;case rE:case oE:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function _Z(n){switch(n){case Co:case e2:return{byteLength:1,components:1};case eg:case t2:case Wi:return{byteLength:2,components:1};case n2:case s2:return{byteLength:2,components:4};case rh:case TS:case wi:return{byteLength:4,components:1};case JD:case ZD:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}class AZ{static contain(e,t){return vZ(e,t)}static cover(e,t){return bZ(e,t)}static fill(e){return SZ(e)}static getByteLength(e,t,s,i){return F3(e,t,s,i)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:uy}}));typeof window<"u"&&(window.__THREE__?Wt("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=uy);function aV(){let n=null,e=!1,t=null,s=null;function i(a,r){t(a,r),s=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(a){t=a},setContext:function(a){n=a}}}function wZ(n){const e=new WeakMap;function t(o,l){const c=o.array,h=o.usage,d=c.byteLength,p=n.createBuffer();n.bindBuffer(l,p),n.bufferData(l,c,h),o.onUploadCallback();let g;if(c instanceof Float32Array)g=n.FLOAT;else if(typeof Float16Array<"u"&&c instanceof Float16Array)g=n.HALF_FLOAT;else if(c instanceof Uint16Array)o.isFloat16BufferAttribute?g=n.HALF_FLOAT:g=n.UNSIGNED_SHORT;else if(c instanceof Int16Array)g=n.SHORT;else if(c instanceof Uint32Array)g=n.UNSIGNED_INT;else if(c instanceof Int32Array)g=n.INT;else if(c instanceof Int8Array)g=n.BYTE;else if(c instanceof Uint8Array)g=n.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)g=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:p,type:g,bytesPerElement:c.BYTES_PER_ELEMENT,version:o.version,size:d}}function s(o,l,c){const h=l.array,d=l.updateRanges;if(n.bindBuffer(c,o),d.length===0)n.bufferSubData(c,0,h);else{d.sort((g,v)=>g.start-v.start);let p=0;for(let g=1;g<d.length;g++){const v=d[p],_=d[g];_.start<=v.start+v.count+1?v.count=Math.max(v.count,_.start+_.count-v.start):(++p,d[p]=_)}d.length=p+1;for(let g=0,v=d.length;g<v;g++){const _=d[g];n.bufferSubData(c,_.start*h.BYTES_PER_ELEMENT,h,_.start,_.count)}l.clearUpdateRanges()}l.onUploadCallback()}function i(o){return o.isInterleavedBufferAttribute&&(o=o.data),e.get(o)}function a(o){o.isInterleavedBufferAttribute&&(o=o.data);const l=e.get(o);l&&(n.deleteBuffer(l.buffer),e.delete(o))}function r(o,l){if(o.isInterleavedBufferAttribute&&(o=o.data),o.isGLBufferAttribute){const h=e.get(o);(!h||h.version<o.version)&&e.set(o,{buffer:o.buffer,type:o.type,bytesPerElement:o.elementSize,version:o.version});return}const c=e.get(o);if(c===void 0)e.set(o,t(o,l));else if(c.version<o.version){if(c.size!==o.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(c.buffer,o,l),c.version=o.version}}return{get:i,remove:a,update:r}}var CZ=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,TZ=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,EZ=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,MZ=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,NZ=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,RZ=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,IZ=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,DZ=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,OZ=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,BZ=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,kZ=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,LZ=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,FZ=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,UZ=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,PZ=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,zZ=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,$Z=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,GZ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,VZ=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,HZ=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,WZ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,jZ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,XZ=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,qZ=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,KZ=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,YZ=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,JZ=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,ZZ=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,QZ=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,eQ=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,tQ="gl_FragColor = linearToOutputTexel( gl_FragColor );",nQ=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,sQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,iQ=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,aQ=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,rQ=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,oQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,lQ=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,cQ=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,uQ=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,hQ=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,dQ=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,fQ=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,pQ=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,mQ=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,gQ=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,xQ=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,yQ=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,vQ=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,bQ=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,SQ=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,_Q=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,AQ=`uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 uv = vec2( roughness, dotNV );
	return texture2D( dfgLUT, uv ).rg;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );
	vec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );
	vec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,wQ=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,CQ=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,TQ=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,EQ=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,MQ=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,NQ=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,RQ=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,IQ=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,DQ=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,OQ=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,BQ=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,kQ=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,LQ=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,FQ=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,UQ=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,PQ=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,zQ=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,$Q=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,GQ=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,VQ=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,HQ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,WQ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,jQ=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,XQ=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,qQ=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,KQ=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,YQ=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,JQ=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,ZQ=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,QQ=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,eee=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,tee=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,nee=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,see=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,iee=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,aee=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,ree=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow( sampler2D shadow, vec2 uv, float compare ) {
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSED_DEPTH_BUFFER
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare, distribution.x );
		#endif
		if ( hard_shadow != 1.0 ) {
			float distance = compare - distribution.x;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,oee=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,lee=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,cee=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,uee=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,hee=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,dee=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,fee=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,pee=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,mee=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,gee=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,xee=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,yee=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,vee=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,bee=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,See=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,_ee=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,Aee=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const wee=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Cee=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Tee=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Eee=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Mee=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Nee=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Ree=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Iee=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,Dee=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Oee=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Bee=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,kee=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Lee=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Fee=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Uee=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Pee=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,zee=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,$ee=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Gee=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Vee=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Hee=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Wee=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,jee=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Xee=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,qee=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Kee=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Yee=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Jee=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Zee=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Qee=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,ete=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,tte=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,nte=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,ste=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Jn={alphahash_fragment:CZ,alphahash_pars_fragment:TZ,alphamap_fragment:EZ,alphamap_pars_fragment:MZ,alphatest_fragment:NZ,alphatest_pars_fragment:RZ,aomap_fragment:IZ,aomap_pars_fragment:DZ,batching_pars_vertex:OZ,batching_vertex:BZ,begin_vertex:kZ,beginnormal_vertex:LZ,bsdfs:FZ,iridescence_fragment:UZ,bumpmap_pars_fragment:PZ,clipping_planes_fragment:zZ,clipping_planes_pars_fragment:$Z,clipping_planes_pars_vertex:GZ,clipping_planes_vertex:VZ,color_fragment:HZ,color_pars_fragment:WZ,color_pars_vertex:jZ,color_vertex:XZ,common:qZ,cube_uv_reflection_fragment:KZ,defaultnormal_vertex:YZ,displacementmap_pars_vertex:JZ,displacementmap_vertex:ZZ,emissivemap_fragment:QZ,emissivemap_pars_fragment:eQ,colorspace_fragment:tQ,colorspace_pars_fragment:nQ,envmap_fragment:sQ,envmap_common_pars_fragment:iQ,envmap_pars_fragment:aQ,envmap_pars_vertex:rQ,envmap_physical_pars_fragment:xQ,envmap_vertex:oQ,fog_vertex:lQ,fog_pars_vertex:cQ,fog_fragment:uQ,fog_pars_fragment:hQ,gradientmap_pars_fragment:dQ,lightmap_pars_fragment:fQ,lights_lambert_fragment:pQ,lights_lambert_pars_fragment:mQ,lights_pars_begin:gQ,lights_toon_fragment:yQ,lights_toon_pars_fragment:vQ,lights_phong_fragment:bQ,lights_phong_pars_fragment:SQ,lights_physical_fragment:_Q,lights_physical_pars_fragment:AQ,lights_fragment_begin:wQ,lights_fragment_maps:CQ,lights_fragment_end:TQ,logdepthbuf_fragment:EQ,logdepthbuf_pars_fragment:MQ,logdepthbuf_pars_vertex:NQ,logdepthbuf_vertex:RQ,map_fragment:IQ,map_pars_fragment:DQ,map_particle_fragment:OQ,map_particle_pars_fragment:BQ,metalnessmap_fragment:kQ,metalnessmap_pars_fragment:LQ,morphinstance_vertex:FQ,morphcolor_vertex:UQ,morphnormal_vertex:PQ,morphtarget_pars_vertex:zQ,morphtarget_vertex:$Q,normal_fragment_begin:GQ,normal_fragment_maps:VQ,normal_pars_fragment:HQ,normal_pars_vertex:WQ,normal_vertex:jQ,normalmap_pars_fragment:XQ,clearcoat_normal_fragment_begin:qQ,clearcoat_normal_fragment_maps:KQ,clearcoat_pars_fragment:YQ,iridescence_pars_fragment:JQ,opaque_fragment:ZQ,packing:QQ,premultiplied_alpha_fragment:eee,project_vertex:tee,dithering_fragment:nee,dithering_pars_fragment:see,roughnessmap_fragment:iee,roughnessmap_pars_fragment:aee,shadowmap_pars_fragment:ree,shadowmap_pars_vertex:oee,shadowmap_vertex:lee,shadowmask_pars_fragment:cee,skinbase_vertex:uee,skinning_pars_vertex:hee,skinning_vertex:dee,skinnormal_vertex:fee,specularmap_fragment:pee,specularmap_pars_fragment:mee,tonemapping_fragment:gee,tonemapping_pars_fragment:xee,transmission_fragment:yee,transmission_pars_fragment:vee,uv_pars_fragment:bee,uv_pars_vertex:See,uv_vertex:_ee,worldpos_vertex:Aee,background_vert:wee,background_frag:Cee,backgroundCube_vert:Tee,backgroundCube_frag:Eee,cube_vert:Mee,cube_frag:Nee,depth_vert:Ree,depth_frag:Iee,distanceRGBA_vert:Dee,distanceRGBA_frag:Oee,equirect_vert:Bee,equirect_frag:kee,linedashed_vert:Lee,linedashed_frag:Fee,meshbasic_vert:Uee,meshbasic_frag:Pee,meshlambert_vert:zee,meshlambert_frag:$ee,meshmatcap_vert:Gee,meshmatcap_frag:Vee,meshnormal_vert:Hee,meshnormal_frag:Wee,meshphong_vert:jee,meshphong_frag:Xee,meshphysical_vert:qee,meshphysical_frag:Kee,meshtoon_vert:Yee,meshtoon_frag:Jee,points_vert:Zee,points_frag:Qee,shadow_vert:ete,shadow_frag:tte,sprite_vert:nte,sprite_frag:ste},Ht={common:{diffuse:{value:new $t(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Vn},alphaMap:{value:null},alphaMapTransform:{value:new Vn},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Vn}},envmap:{envMap:{value:null},envMapRotation:{value:new Vn},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Vn}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Vn}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Vn},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Vn},normalScale:{value:new rt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Vn},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Vn}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Vn}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Vn}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new $t(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new $t(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Vn},alphaTest:{value:0},uvTransform:{value:new Vn}},sprite:{diffuse:{value:new $t(16777215)},opacity:{value:1},center:{value:new rt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Vn},alphaMap:{value:null},alphaMapTransform:{value:new Vn},alphaTest:{value:0}}},Hc={basic:{uniforms:xo([Ht.common,Ht.specularmap,Ht.envmap,Ht.aomap,Ht.lightmap,Ht.fog]),vertexShader:Jn.meshbasic_vert,fragmentShader:Jn.meshbasic_frag},lambert:{uniforms:xo([Ht.common,Ht.specularmap,Ht.envmap,Ht.aomap,Ht.lightmap,Ht.emissivemap,Ht.bumpmap,Ht.normalmap,Ht.displacementmap,Ht.fog,Ht.lights,{emissive:{value:new $t(0)}}]),vertexShader:Jn.meshlambert_vert,fragmentShader:Jn.meshlambert_frag},phong:{uniforms:xo([Ht.common,Ht.specularmap,Ht.envmap,Ht.aomap,Ht.lightmap,Ht.emissivemap,Ht.bumpmap,Ht.normalmap,Ht.displacementmap,Ht.fog,Ht.lights,{emissive:{value:new $t(0)},specular:{value:new $t(1118481)},shininess:{value:30}}]),vertexShader:Jn.meshphong_vert,fragmentShader:Jn.meshphong_frag},standard:{uniforms:xo([Ht.common,Ht.envmap,Ht.aomap,Ht.lightmap,Ht.emissivemap,Ht.bumpmap,Ht.normalmap,Ht.displacementmap,Ht.roughnessmap,Ht.metalnessmap,Ht.fog,Ht.lights,{emissive:{value:new $t(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag},toon:{uniforms:xo([Ht.common,Ht.aomap,Ht.lightmap,Ht.emissivemap,Ht.bumpmap,Ht.normalmap,Ht.displacementmap,Ht.gradientmap,Ht.fog,Ht.lights,{emissive:{value:new $t(0)}}]),vertexShader:Jn.meshtoon_vert,fragmentShader:Jn.meshtoon_frag},matcap:{uniforms:xo([Ht.common,Ht.bumpmap,Ht.normalmap,Ht.displacementmap,Ht.fog,{matcap:{value:null}}]),vertexShader:Jn.meshmatcap_vert,fragmentShader:Jn.meshmatcap_frag},points:{uniforms:xo([Ht.points,Ht.fog]),vertexShader:Jn.points_vert,fragmentShader:Jn.points_frag},dashed:{uniforms:xo([Ht.common,Ht.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Jn.linedashed_vert,fragmentShader:Jn.linedashed_frag},depth:{uniforms:xo([Ht.common,Ht.displacementmap]),vertexShader:Jn.depth_vert,fragmentShader:Jn.depth_frag},normal:{uniforms:xo([Ht.common,Ht.bumpmap,Ht.normalmap,Ht.displacementmap,{opacity:{value:1}}]),vertexShader:Jn.meshnormal_vert,fragmentShader:Jn.meshnormal_frag},sprite:{uniforms:xo([Ht.sprite,Ht.fog]),vertexShader:Jn.sprite_vert,fragmentShader:Jn.sprite_frag},background:{uniforms:{uvTransform:{value:new Vn},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Jn.background_vert,fragmentShader:Jn.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Vn}},vertexShader:Jn.backgroundCube_vert,fragmentShader:Jn.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Jn.cube_vert,fragmentShader:Jn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Jn.equirect_vert,fragmentShader:Jn.equirect_frag},distanceRGBA:{uniforms:xo([Ht.common,Ht.displacementmap,{referencePosition:{value:new ue},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Jn.distanceRGBA_vert,fragmentShader:Jn.distanceRGBA_frag},shadow:{uniforms:xo([Ht.lights,Ht.fog,{color:{value:new $t(0)},opacity:{value:1}}]),vertexShader:Jn.shadow_vert,fragmentShader:Jn.shadow_frag}};Hc.physical={uniforms:xo([Hc.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Vn},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Vn},clearcoatNormalScale:{value:new rt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Vn},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Vn},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Vn},sheen:{value:0},sheenColor:{value:new $t(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Vn},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Vn},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Vn},transmissionSamplerSize:{value:new rt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Vn},attenuationDistance:{value:0},attenuationColor:{value:new $t(0)},specularColor:{value:new $t(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Vn},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Vn},anisotropyVector:{value:new rt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Vn}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag};const LC={r:0,b:0,g:0},vm=new wl,ite=new _n;function ate(n,e,t,s,i,a,r){const o=new $t(0);let l=a===!0?0:1,c,h,d=null,p=0,g=null;function v(T){let E=T.isScene===!0?T.background:null;return E&&E.isTexture&&(E=(T.backgroundBlurriness>0?t:e).get(E)),E}function _(T){let E=!1;const R=v(T);R===null?b(o,l):R&&R.isColor&&(b(R,1),E=!0);const D=n.xr.getEnvironmentBlendMode();D==="additive"?s.buffers.color.setClear(0,0,0,1,r):D==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,r),(n.autoClear||E)&&(s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function S(T,E){const R=v(E);R&&(R.isCubeTexture||R.mapping===hy)?(h===void 0&&(h=new Ti(new wg(1,1,1),new jr({name:"BackgroundCubeMaterial",uniforms:zx(Hc.backgroundCube.uniforms),vertexShader:Hc.backgroundCube.vertexShader,fragmentShader:Hc.backgroundCube.fragmentShader,side:Ao,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(D,F,U){this.matrixWorld.copyPosition(U.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(h)),vm.copy(E.backgroundRotation),vm.x*=-1,vm.y*=-1,vm.z*=-1,R.isCubeTexture&&R.isRenderTargetTexture===!1&&(vm.y*=-1,vm.z*=-1),h.material.uniforms.envMap.value=R,h.material.uniforms.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=E.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=E.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(ite.makeRotationFromEuler(vm)),h.material.toneMapped=ws.getTransfer(R.colorSpace)!==js,(d!==R||p!==R.version||g!==n.toneMapping)&&(h.material.needsUpdate=!0,d=R,p=R.version,g=n.toneMapping),h.layers.enableAll(),T.unshift(h,h.geometry,h.material,0,0,null)):R&&R.isTexture&&(c===void 0&&(c=new Ti(new sp(2,2),new jr({name:"BackgroundMaterial",uniforms:zx(Hc.background.uniforms),vertexShader:Hc.background.vertexShader,fragmentShader:Hc.background.fragmentShader,side:ih,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=R,c.material.uniforms.backgroundIntensity.value=E.backgroundIntensity,c.material.toneMapped=ws.getTransfer(R.colorSpace)!==js,R.matrixAutoUpdate===!0&&R.updateMatrix(),c.material.uniforms.uvTransform.value.copy(R.matrix),(d!==R||p!==R.version||g!==n.toneMapping)&&(c.material.needsUpdate=!0,d=R,p=R.version,g=n.toneMapping),c.layers.enableAll(),T.unshift(c,c.geometry,c.material,0,0,null))}function b(T,E){T.getRGB(LC,hG(n)),s.buffers.color.setClear(LC.r,LC.g,LC.b,E,r)}function w(){h!==void 0&&(h.geometry.dispose(),h.material.dispose(),h=void 0),c!==void 0&&(c.geometry.dispose(),c.material.dispose(),c=void 0)}return{getClearColor:function(){return o},setClearColor:function(T,E=1){o.set(T),l=E,b(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(T){l=T,b(o,l)},render:_,addToRenderList:S,dispose:w}}function rte(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),s={},i=p(null);let a=i,r=!1;function o(B,L,H,K,Z){let Q=!1;const P=d(K,H,L);a!==P&&(a=P,c(a.object)),Q=g(B,K,H,Z),Q&&v(B,K,H,Z),Z!==null&&e.update(Z,n.ELEMENT_ARRAY_BUFFER),(Q||r)&&(r=!1,E(B,L,H,K),Z!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(Z).buffer))}function l(){return n.createVertexArray()}function c(B){return n.bindVertexArray(B)}function h(B){return n.deleteVertexArray(B)}function d(B,L,H){const K=H.wireframe===!0;let Z=s[B.id];Z===void 0&&(Z={},s[B.id]=Z);let Q=Z[L.id];Q===void 0&&(Q={},Z[L.id]=Q);let P=Q[K];return P===void 0&&(P=p(l()),Q[K]=P),P}function p(B){const L=[],H=[],K=[];for(let Z=0;Z<t;Z++)L[Z]=0,H[Z]=0,K[Z]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:L,enabledAttributes:H,attributeDivisors:K,object:B,attributes:{},index:null}}function g(B,L,H,K){const Z=a.attributes,Q=L.attributes;let P=0;const W=H.getAttributes();for(const q in W)if(W[q].location>=0){const le=Z[q];let Y=Q[q];if(Y===void 0&&(q==="instanceMatrix"&&B.instanceMatrix&&(Y=B.instanceMatrix),q==="instanceColor"&&B.instanceColor&&(Y=B.instanceColor)),le===void 0||le.attribute!==Y||Y&&le.data!==Y.data)return!0;P++}return a.attributesNum!==P||a.index!==K}function v(B,L,H,K){const Z={},Q=L.attributes;let P=0;const W=H.getAttributes();for(const q in W)if(W[q].location>=0){let le=Q[q];le===void 0&&(q==="instanceMatrix"&&B.instanceMatrix&&(le=B.instanceMatrix),q==="instanceColor"&&B.instanceColor&&(le=B.instanceColor));const Y={};Y.attribute=le,le&&le.data&&(Y.data=le.data),Z[q]=Y,P++}a.attributes=Z,a.attributesNum=P,a.index=K}function _(){const B=a.newAttributes;for(let L=0,H=B.length;L<H;L++)B[L]=0}function S(B){b(B,0)}function b(B,L){const H=a.newAttributes,K=a.enabledAttributes,Z=a.attributeDivisors;H[B]=1,K[B]===0&&(n.enableVertexAttribArray(B),K[B]=1),Z[B]!==L&&(n.vertexAttribDivisor(B,L),Z[B]=L)}function w(){const B=a.newAttributes,L=a.enabledAttributes;for(let H=0,K=L.length;H<K;H++)L[H]!==B[H]&&(n.disableVertexAttribArray(H),L[H]=0)}function T(B,L,H,K,Z,Q,P){P===!0?n.vertexAttribIPointer(B,L,H,Z,Q):n.vertexAttribPointer(B,L,H,K,Z,Q)}function E(B,L,H,K){_();const Z=K.attributes,Q=H.getAttributes(),P=L.defaultAttributeValues;for(const W in Q){const q=Q[W];if(q.location>=0){let se=Z[W];if(se===void 0&&(W==="instanceMatrix"&&B.instanceMatrix&&(se=B.instanceMatrix),W==="instanceColor"&&B.instanceColor&&(se=B.instanceColor)),se!==void 0){const le=se.normalized,Y=se.itemSize,re=e.get(se);if(re===void 0)continue;const he=re.buffer,me=re.type,Ne=re.bytesPerElement,fe=me===n.INT||me===n.UNSIGNED_INT||se.gpuType===TS;if(se.isInterleavedBufferAttribute){const Te=se.data,Ge=Te.stride,nt=se.offset;if(Te.isInstancedInterleavedBuffer){for(let yt=0;yt<q.locationSize;yt++)b(q.location+yt,Te.meshPerAttribute);B.isInstancedMesh!==!0&&K._maxInstanceCount===void 0&&(K._maxInstanceCount=Te.meshPerAttribute*Te.count)}else for(let yt=0;yt<q.locationSize;yt++)S(q.location+yt);n.bindBuffer(n.ARRAY_BUFFER,he);for(let yt=0;yt<q.locationSize;yt++)T(q.location+yt,Y/q.locationSize,me,le,Ge*Ne,(nt+Y/q.locationSize*yt)*Ne,fe)}else{if(se.isInstancedBufferAttribute){for(let Te=0;Te<q.locationSize;Te++)b(q.location+Te,se.meshPerAttribute);B.isInstancedMesh!==!0&&K._maxInstanceCount===void 0&&(K._maxInstanceCount=se.meshPerAttribute*se.count)}else for(let Te=0;Te<q.locationSize;Te++)S(q.location+Te);n.bindBuffer(n.ARRAY_BUFFER,he);for(let Te=0;Te<q.locationSize;Te++)T(q.location+Te,Y/q.locationSize,me,le,Y*Ne,Y/q.locationSize*Te*Ne,fe)}}else if(P!==void 0){const le=P[W];if(le!==void 0)switch(le.length){case 2:n.vertexAttrib2fv(q.location,le);break;case 3:n.vertexAttrib3fv(q.location,le);break;case 4:n.vertexAttrib4fv(q.location,le);break;default:n.vertexAttrib1fv(q.location,le)}}}}w()}function R(){U();for(const B in s){const L=s[B];for(const H in L){const K=L[H];for(const Z in K)h(K[Z].object),delete K[Z];delete L[H]}delete s[B]}}function D(B){if(s[B.id]===void 0)return;const L=s[B.id];for(const H in L){const K=L[H];for(const Z in K)h(K[Z].object),delete K[Z];delete L[H]}delete s[B.id]}function F(B){for(const L in s){const H=s[L];if(H[B.id]===void 0)continue;const K=H[B.id];for(const Z in K)h(K[Z].object),delete K[Z];delete H[B.id]}}function U(){O(),r=!0,a!==i&&(a=i,c(a.object))}function O(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:o,reset:U,resetDefaultState:O,dispose:R,releaseStatesOfGeometry:D,releaseStatesOfProgram:F,initAttributes:_,enableAttribute:S,disableUnusedAttributes:w}}function ote(n,e,t){let s;function i(c){s=c}function a(c,h){n.drawArrays(s,c,h),t.update(h,s,1)}function r(c,h,d){d!==0&&(n.drawArraysInstanced(s,c,h,d),t.update(h,s,d))}function o(c,h,d){if(d===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(s,c,0,h,0,d);let g=0;for(let v=0;v<d;v++)g+=h[v];t.update(g,s,1)}function l(c,h,d,p){if(d===0)return;const g=e.get("WEBGL_multi_draw");if(g===null)for(let v=0;v<c.length;v++)r(c[v],h[v],p[v]);else{g.multiDrawArraysInstancedWEBGL(s,c,0,h,0,p,0,d);let v=0;for(let _=0;_<d;_++)v+=h[_]*p[_];t.update(v,s,1)}}this.setMode=i,this.render=a,this.renderInstances=r,this.renderMultiDraw=o,this.renderMultiDrawInstances=l}function lte(n,e,t,s){let i;function a(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const F=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function r(F){return!(F!==ra&&s.convert(F)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function o(F){const U=F===Wi&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(F!==Co&&s.convert(F)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&F!==wi&&!U)}function l(F){if(F==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";F="mediump"}return F==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=t.precision!==void 0?t.precision:"highp";const h=l(c);h!==c&&(Wt("WebGLRenderer:",c,"not supported, using",h,"instead."),c=h);const d=t.logarithmicDepthBuffer===!0,p=t.reversedDepthBuffer===!0&&e.has("EXT_clip_control"),g=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),v=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),_=n.getParameter(n.MAX_TEXTURE_SIZE),S=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),b=n.getParameter(n.MAX_VERTEX_ATTRIBS),w=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),T=n.getParameter(n.MAX_VARYING_VECTORS),E=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),R=v>0,D=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:a,getMaxPrecision:l,textureFormatReadable:r,textureTypeReadable:o,precision:c,logarithmicDepthBuffer:d,reversedDepthBuffer:p,maxTextures:g,maxVertexTextures:v,maxTextureSize:_,maxCubemapSize:S,maxAttributes:b,maxVertexUniforms:w,maxVaryings:T,maxFragmentUniforms:E,vertexTextures:R,maxSamples:D}}function cte(n){const e=this;let t=null,s=0,i=!1,a=!1;const r=new Vu,o=new Vn,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(d,p){const g=d.length!==0||p||s!==0||i;return i=p,s=d.length,g},this.beginShadows=function(){a=!0,h(null)},this.endShadows=function(){a=!1},this.setGlobalState=function(d,p){t=h(d,p,0)},this.setState=function(d,p,g){const v=d.clippingPlanes,_=d.clipIntersection,S=d.clipShadows,b=n.get(d);if(!i||v===null||v.length===0||a&&!S)a?h(null):c();else{const w=a?0:s,T=w*4;let E=b.clippingState||null;l.value=E,E=h(v,p,T,g);for(let R=0;R!==T;++R)E[R]=t[R];b.clippingState=E,this.numIntersection=_?this.numPlanes:0,this.numPlanes+=w}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function h(d,p,g,v){const _=d!==null?d.length:0;let S=null;if(_!==0){if(S=l.value,v!==!0||S===null){const b=g+_*4,w=p.matrixWorldInverse;o.getNormalMatrix(w),(S===null||S.length<b)&&(S=new Float32Array(b));for(let T=0,E=g;T!==_;++T,E+=4)r.copy(d[T]).applyMatrix4(w,o),r.normal.toArray(S,E),S[E+3]=r.constant}l.value=S,l.needsUpdate=!0}return e.numPlanes=_,e.numIntersection=0,S}}function ute(n){let e=new WeakMap;function t(r,o){return o===Rx?r.mapping=ah:o===H1&&(r.mapping=Uf),r}function s(r){if(r&&r.isTexture){const o=r.mapping;if(o===Rx||o===H1)if(e.has(r)){const l=e.get(r).texture;return t(l,r.mapping)}else{const l=r.image;if(l&&l.height>0){const c=new lO(l.height);return c.fromEquirectangularTexture(n,r),e.set(r,c),r.addEventListener("dispose",i),t(c.texture,r.mapping)}else return null}}return r}function i(r){const o=r.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function a(){e=new WeakMap}return{get:s,dispose:a}}const Mf=4,cP=[.125,.215,.35,.446,.526,.582],Rm=20,hte=256,p1=new Zu,uP=new $t;let wI=null,CI=0,TI=0,EI=!1;const dte=new ue;class U3{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(e,t=0,s=.1,i=100,a={}){const{size:r=256,position:o=dte}=a;wI=this._renderer.getRenderTarget(),CI=this._renderer.getActiveCubeFace(),TI=this._renderer.getActiveMipmapLevel(),EI=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(r);const l=this._allocateTargets();return l.depthBuffer=!0,this._sceneToCubeUV(e,s,i,l,o),t>0&&this._blur(l,0,0,t),this._applyPMREM(l),this._cleanup(l),l}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=fP(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=dP(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose(),this._backgroundBox!==null&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._ggxMaterial!==null&&this._ggxMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodMeshes.length;e++)this._lodMeshes[e].geometry.dispose()}_cleanup(e){this._renderer.setRenderTarget(wI,CI,TI),this._renderer.xr.enabled=EI,e.scissorTest=!1,dx(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===ah||e.mapping===Uf?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),wI=this._renderer.getRenderTarget(),CI=this._renderer.getActiveCubeFace(),TI=this._renderer.getActiveMipmapLevel(),EI=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:is,minFilter:is,generateMipmaps:!1,type:Wi,format:ra,colorSpace:Qc,depthBuffer:!1},i=hP(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=hP(e,t,s);const{_lodMax:a}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=fte(a)),this._blurMaterial=mte(a,e,t),this._ggxMaterial=pte(a,e,t)}return i}_compileMaterial(e){const t=new Ti(new Ln,e);this._renderer.compile(t,p1)}_sceneToCubeUV(e,t,s,i,a){const l=new ki(90,1,t,s),c=[1,-1,1,1,1,1],h=[1,1,1,-1,-1,-1],d=this._renderer,p=d.autoClear,g=d.toneMapping;d.getClearColor(uP),d.toneMapping=Ju,d.autoClear=!1,d.state.buffers.depth.getReversed()&&(d.setRenderTarget(i),d.clearDepth(),d.setRenderTarget(null)),this._backgroundBox===null&&(this._backgroundBox=new Ti(new wg,new Yo({name:"PMREM.Background",side:Ao,depthWrite:!1,depthTest:!1})));const _=this._backgroundBox,S=_.material;let b=!1;const w=e.background;w?w.isColor&&(S.color.copy(w),e.background=null,b=!0):(S.color.copy(uP),b=!0);for(let T=0;T<6;T++){const E=T%3;E===0?(l.up.set(0,c[T],0),l.position.set(a.x,a.y,a.z),l.lookAt(a.x+h[T],a.y,a.z)):E===1?(l.up.set(0,0,c[T]),l.position.set(a.x,a.y,a.z),l.lookAt(a.x,a.y+h[T],a.z)):(l.up.set(0,c[T],0),l.position.set(a.x,a.y,a.z),l.lookAt(a.x,a.y,a.z+h[T]));const R=this._cubeSize;dx(i,E*R,T>2?R:0,R,R),d.setRenderTarget(i),b&&d.render(_,l),d.render(e,l)}d.toneMapping=g,d.autoClear=p,e.background=w}_textureToCubeUV(e,t){const s=this._renderer,i=e.mapping===ah||e.mapping===Uf;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=fP()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=dP());const a=i?this._cubemapMaterial:this._equirectMaterial,r=this._lodMeshes[0];r.material=a;const o=a.uniforms;o.envMap.value=e;const l=this._cubeSize;dx(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(r,p1)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;const i=this._lodMeshes.length;for(let a=1;a<i;a++)this._applyGGXFilter(e,a-1,a);t.autoClear=s}_applyGGXFilter(e,t,s){const i=this._renderer,a=this._pingPongRenderTarget,r=this._ggxMaterial,o=this._lodMeshes[s];o.material=r;const l=r.uniforms,c=s/(this._lodMeshes.length-1),h=t/(this._lodMeshes.length-1),d=Math.sqrt(c*c-h*h),p=.05+c*.95,g=d*p,{_lodMax:v}=this,_=this._sizeLods[s],S=3*_*(s>v-Mf?s-v+Mf:0),b=4*(this._cubeSize-_);l.envMap.value=e.texture,l.roughness.value=g,l.mipInt.value=v-t,dx(a,S,b,3*_,2*_),i.setRenderTarget(a),i.render(o,p1),l.envMap.value=a.texture,l.roughness.value=0,l.mipInt.value=v-s,dx(e,S,b,3*_,2*_),i.setRenderTarget(e),i.render(o,p1)}_blur(e,t,s,i,a){const r=this._pingPongRenderTarget;this._halfBlur(e,r,t,s,i,"latitudinal",a),this._halfBlur(r,e,s,s,i,"longitudinal",a)}_halfBlur(e,t,s,i,a,r,o){const l=this._renderer,c=this._blurMaterial;r!=="latitudinal"&&r!=="longitudinal"&&On("blur direction must be either latitudinal or longitudinal!");const h=3,d=this._lodMeshes[i];d.material=c;const p=c.uniforms,g=this._sizeLods[s]-1,v=isFinite(a)?Math.PI/(2*g):2*Math.PI/(2*Rm-1),_=a/v,S=isFinite(a)?1+Math.floor(h*_):Rm;S>Rm&&Wt(`sigmaRadians, ${a}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${Rm}`);const b=[];let w=0;for(let F=0;F<Rm;++F){const U=F/_,O=Math.exp(-U*U/2);b.push(O),F===0?w+=O:F<S&&(w+=2*O)}for(let F=0;F<b.length;F++)b[F]=b[F]/w;p.envMap.value=e.texture,p.samples.value=S,p.weights.value=b,p.latitudinal.value=r==="latitudinal",o&&(p.poleAxis.value=o);const{_lodMax:T}=this;p.dTheta.value=v,p.mipInt.value=T-s;const E=this._sizeLods[i],R=3*E*(i>T-Mf?i-T+Mf:0),D=4*(this._cubeSize-E);dx(t,R,D,3*E,2*E),l.setRenderTarget(t),l.render(d,p1)}}function fte(n){const e=[],t=[],s=[];let i=n;const a=n-Mf+1+cP.length;for(let r=0;r<a;r++){const o=Math.pow(2,i);e.push(o);let l=1/o;r>n-Mf?l=cP[r-n+Mf-1]:r===0&&(l=0),t.push(l);const c=1/(o-2),h=-c,d=1+c,p=[h,h,d,h,d,d,h,h,d,d,h,d],g=6,v=6,_=3,S=2,b=1,w=new Float32Array(_*v*g),T=new Float32Array(S*v*g),E=new Float32Array(b*v*g);for(let D=0;D<g;D++){const F=D%3*2/3-1,U=D>2?0:-1,O=[F,U,0,F+2/3,U,0,F+2/3,U+1,0,F,U,0,F+2/3,U+1,0,F,U+1,0];w.set(O,_*v*D),T.set(p,S*v*D);const B=[D,D,D,D,D,D];E.set(B,b*v*D)}const R=new Ln;R.setAttribute("position",new Es(w,_)),R.setAttribute("uv",new Es(T,S)),R.setAttribute("faceIndex",new Es(E,b)),s.push(new Ti(R,null)),i>Mf&&i--}return{lodMeshes:s,sizeLods:e,sigmas:t}}function hP(n,e,t){const s=new Wr(n,e,t);return s.texture.mapping=hy,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function dx(n,e,t,s,i){n.viewport.set(e,t,s,i),n.scissor.set(e,t,s,i)}function pte(n,e,t){return new jr({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES:hte,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:R2(),fragmentShader:`

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,blending:ic,depthTest:!1,depthWrite:!1})}function mte(n,e,t){const s=new Float32Array(Rm),i=new ue(0,1,0);return new jr({name:"SphericalGaussianBlur",defines:{n:Rm,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:R2(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ic,depthTest:!1,depthWrite:!1})}function dP(){return new jr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:R2(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ic,depthTest:!1,depthWrite:!1})}function fP(){return new jr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:R2(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ic,depthTest:!1,depthWrite:!1})}function R2(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function gte(n){let e=new WeakMap,t=null;function s(o){if(o&&o.isTexture){const l=o.mapping,c=l===Rx||l===H1,h=l===ah||l===Uf;if(c||h){let d=e.get(o);const p=d!==void 0?d.texture.pmremVersion:0;if(o.isRenderTargetTexture&&o.pmremVersion!==p)return t===null&&(t=new U3(n)),d=c?t.fromEquirectangular(o,d):t.fromCubemap(o,d),d.texture.pmremVersion=o.pmremVersion,e.set(o,d),d.texture;if(d!==void 0)return d.texture;{const g=o.image;return c&&g&&g.height>0||h&&g&&i(g)?(t===null&&(t=new U3(n)),d=c?t.fromEquirectangular(o):t.fromCubemap(o),d.texture.pmremVersion=o.pmremVersion,e.set(o,d),o.addEventListener("dispose",a),d.texture):null}}}return o}function i(o){let l=0;const c=6;for(let h=0;h<c;h++)o[h]!==void 0&&l++;return l===c}function a(o){const l=o.target;l.removeEventListener("dispose",a);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function r(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:r}}function xte(n){const e={};function t(s){if(e[s]!==void 0)return e[s];const i=n.getExtension(s);return e[s]=i,i}return{has:function(s){return t(s)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(s){const i=t(s);return i===null&&Fx("WebGLRenderer: "+s+" extension not supported."),i}}}function yte(n,e,t,s){const i={},a=new WeakMap;function r(d){const p=d.target;p.index!==null&&e.remove(p.index);for(const v in p.attributes)e.remove(p.attributes[v]);p.removeEventListener("dispose",r),delete i[p.id];const g=a.get(p);g&&(e.remove(g),a.delete(p)),s.releaseStatesOfGeometry(p),p.isInstancedBufferGeometry===!0&&delete p._maxInstanceCount,t.memory.geometries--}function o(d,p){return i[p.id]===!0||(p.addEventListener("dispose",r),i[p.id]=!0,t.memory.geometries++),p}function l(d){const p=d.attributes;for(const g in p)e.update(p[g],n.ARRAY_BUFFER)}function c(d){const p=[],g=d.index,v=d.attributes.position;let _=0;if(g!==null){const w=g.array;_=g.version;for(let T=0,E=w.length;T<E;T+=3){const R=w[T+0],D=w[T+1],F=w[T+2];p.push(R,D,D,F,F,R)}}else if(v!==void 0){const w=v.array;_=v.version;for(let T=0,E=w.length/3-1;T<E;T+=3){const R=T+0,D=T+1,F=T+2;p.push(R,D,D,F,F,R)}}else return;const S=new(rG(p)?oO:rO)(p,1);S.version=_;const b=a.get(d);b&&e.remove(b),a.set(d,S)}function h(d){const p=a.get(d);if(p){const g=d.index;g!==null&&p.version<g.version&&c(d)}else c(d);return a.get(d)}return{get:o,update:l,getWireframeAttribute:h}}function vte(n,e,t){let s;function i(p){s=p}let a,r;function o(p){a=p.type,r=p.bytesPerElement}function l(p,g){n.drawElements(s,g,a,p*r),t.update(g,s,1)}function c(p,g,v){v!==0&&(n.drawElementsInstanced(s,g,a,p*r,v),t.update(g,s,v))}function h(p,g,v){if(v===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(s,g,0,a,p,0,v);let S=0;for(let b=0;b<v;b++)S+=g[b];t.update(S,s,1)}function d(p,g,v,_){if(v===0)return;const S=e.get("WEBGL_multi_draw");if(S===null)for(let b=0;b<p.length;b++)c(p[b]/r,g[b],_[b]);else{S.multiDrawElementsInstancedWEBGL(s,g,0,a,p,0,_,0,v);let b=0;for(let w=0;w<v;w++)b+=g[w]*_[w];t.update(b,s,1)}}this.setMode=i,this.setIndex=o,this.render=l,this.renderInstances=c,this.renderMultiDraw=h,this.renderMultiDrawInstances=d}function bte(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(a,r,o){switch(t.calls++,r){case n.TRIANGLES:t.triangles+=o*(a/3);break;case n.LINES:t.lines+=o*(a/2);break;case n.LINE_STRIP:t.lines+=o*(a-1);break;case n.LINE_LOOP:t.lines+=o*a;break;case n.POINTS:t.points+=o*a;break;default:On("WebGLInfo: Unknown draw mode:",r);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:s}}function Ste(n,e,t){const s=new WeakMap,i=new Cs;function a(r,o,l){const c=r.morphTargetInfluences,h=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,d=h!==void 0?h.length:0;let p=s.get(o);if(p===void 0||p.count!==d){let B=function(){U.dispose(),s.delete(o),o.removeEventListener("dispose",B)};var g=B;p!==void 0&&p.texture.dispose();const v=o.morphAttributes.position!==void 0,_=o.morphAttributes.normal!==void 0,S=o.morphAttributes.color!==void 0,b=o.morphAttributes.position||[],w=o.morphAttributes.normal||[],T=o.morphAttributes.color||[];let E=0;v===!0&&(E=1),_===!0&&(E=2),S===!0&&(E=3);let R=o.attributes.position.count*E,D=1;R>e.maxTextureSize&&(D=Math.ceil(R/e.maxTextureSize),R=e.maxTextureSize);const F=new Float32Array(R*D*4*d),U=new l2(F,R,D,d);U.type=wi,U.needsUpdate=!0;const O=E*4;for(let L=0;L<d;L++){const H=b[L],K=w[L],Z=T[L],Q=R*D*4*L;for(let P=0;P<H.count;P++){const W=P*O;v===!0&&(i.fromBufferAttribute(H,P),F[Q+W+0]=i.x,F[Q+W+1]=i.y,F[Q+W+2]=i.z,F[Q+W+3]=0),_===!0&&(i.fromBufferAttribute(K,P),F[Q+W+4]=i.x,F[Q+W+5]=i.y,F[Q+W+6]=i.z,F[Q+W+7]=0),S===!0&&(i.fromBufferAttribute(Z,P),F[Q+W+8]=i.x,F[Q+W+9]=i.y,F[Q+W+10]=i.z,F[Q+W+11]=Z.itemSize===4?i.w:1)}}p={count:d,texture:U,size:new rt(R,D)},s.set(o,p),o.addEventListener("dispose",B)}if(r.isInstancedMesh===!0&&r.morphTexture!==null)l.getUniforms().setValue(n,"morphTexture",r.morphTexture,t);else{let v=0;for(let S=0;S<c.length;S++)v+=c[S];const _=o.morphTargetsRelative?1:1-v;l.getUniforms().setValue(n,"morphTargetBaseInfluence",_),l.getUniforms().setValue(n,"morphTargetInfluences",c)}l.getUniforms().setValue(n,"morphTargetsTexture",p.texture,t),l.getUniforms().setValue(n,"morphTargetsTextureSize",p.size)}return{update:a}}function _te(n,e,t,s){let i=new WeakMap;function a(l){const c=s.render.frame,h=l.geometry,d=e.get(l,h);if(i.get(d)!==c&&(e.update(d),i.set(d,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),i.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const p=l.skeleton;i.get(p)!==c&&(p.update(),i.set(p,c))}return d}function r(){i=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:a,dispose:r}}const rV=new Vs,pP=new OS(1,1),oV=new l2,lV=new c2,cV=new RS,mP=[],gP=[],xP=new Float32Array(16),yP=new Float32Array(9),vP=new Float32Array(4);function gy(n,e,t){const s=n[0];if(s<=0||s>0)return n;const i=e*t;let a=mP[i];if(a===void 0&&(a=new Float32Array(i),mP[i]=a),e!==0){s.toArray(a,0);for(let r=1,o=0;r!==e;++r)o+=t,n[r].toArray(a,o)}return a}function Oa(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function Ba(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function I2(n,e){let t=gP[e];t===void 0&&(t=new Int32Array(e),gP[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function Ate(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function wte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Oa(t,e))return;n.uniform2fv(this.addr,e),Ba(t,e)}}function Cte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Oa(t,e))return;n.uniform3fv(this.addr,e),Ba(t,e)}}function Tte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Oa(t,e))return;n.uniform4fv(this.addr,e),Ba(t,e)}}function Ete(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Oa(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ba(t,e)}else{if(Oa(t,s))return;vP.set(s),n.uniformMatrix2fv(this.addr,!1,vP),Ba(t,s)}}function Mte(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Oa(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ba(t,e)}else{if(Oa(t,s))return;yP.set(s),n.uniformMatrix3fv(this.addr,!1,yP),Ba(t,s)}}function Nte(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Oa(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ba(t,e)}else{if(Oa(t,s))return;xP.set(s),n.uniformMatrix4fv(this.addr,!1,xP),Ba(t,s)}}function Rte(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function Ite(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Oa(t,e))return;n.uniform2iv(this.addr,e),Ba(t,e)}}function Dte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Oa(t,e))return;n.uniform3iv(this.addr,e),Ba(t,e)}}function Ote(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Oa(t,e))return;n.uniform4iv(this.addr,e),Ba(t,e)}}function Bte(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function kte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Oa(t,e))return;n.uniform2uiv(this.addr,e),Ba(t,e)}}function Lte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Oa(t,e))return;n.uniform3uiv(this.addr,e),Ba(t,e)}}function Fte(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Oa(t,e))return;n.uniform4uiv(this.addr,e),Ba(t,e)}}function Ute(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i);let a;this.type===n.SAMPLER_2D_SHADOW?(pP.compareFunction=sO,a=pP):a=rV,t.setTexture2D(e||a,i)}function Pte(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture3D(e||lV,i)}function zte(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTextureCube(e||cV,i)}function $te(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2DArray(e||oV,i)}function Gte(n){switch(n){case 5126:return Ate;case 35664:return wte;case 35665:return Cte;case 35666:return Tte;case 35674:return Ete;case 35675:return Mte;case 35676:return Nte;case 5124:case 35670:return Rte;case 35667:case 35671:return Ite;case 35668:case 35672:return Dte;case 35669:case 35673:return Ote;case 5125:return Bte;case 36294:return kte;case 36295:return Lte;case 36296:return Fte;case 35678:case 36198:case 36298:case 36306:case 35682:return Ute;case 35679:case 36299:case 36307:return Pte;case 35680:case 36300:case 36308:case 36293:return zte;case 36289:case 36303:case 36311:case 36292:return $te}}function Vte(n,e){n.uniform1fv(this.addr,e)}function Hte(n,e){const t=gy(e,this.size,2);n.uniform2fv(this.addr,t)}function Wte(n,e){const t=gy(e,this.size,3);n.uniform3fv(this.addr,t)}function jte(n,e){const t=gy(e,this.size,4);n.uniform4fv(this.addr,t)}function Xte(n,e){const t=gy(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function qte(n,e){const t=gy(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Kte(n,e){const t=gy(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function Yte(n,e){n.uniform1iv(this.addr,e)}function Jte(n,e){n.uniform2iv(this.addr,e)}function Zte(n,e){n.uniform3iv(this.addr,e)}function Qte(n,e){n.uniform4iv(this.addr,e)}function ene(n,e){n.uniform1uiv(this.addr,e)}function tne(n,e){n.uniform2uiv(this.addr,e)}function nne(n,e){n.uniform3uiv(this.addr,e)}function sne(n,e){n.uniform4uiv(this.addr,e)}function ine(n,e,t){const s=this.cache,i=e.length,a=I2(t,i);Oa(s,a)||(n.uniform1iv(this.addr,a),Ba(s,a));for(let r=0;r!==i;++r)t.setTexture2D(e[r]||rV,a[r])}function ane(n,e,t){const s=this.cache,i=e.length,a=I2(t,i);Oa(s,a)||(n.uniform1iv(this.addr,a),Ba(s,a));for(let r=0;r!==i;++r)t.setTexture3D(e[r]||lV,a[r])}function rne(n,e,t){const s=this.cache,i=e.length,a=I2(t,i);Oa(s,a)||(n.uniform1iv(this.addr,a),Ba(s,a));for(let r=0;r!==i;++r)t.setTextureCube(e[r]||cV,a[r])}function one(n,e,t){const s=this.cache,i=e.length,a=I2(t,i);Oa(s,a)||(n.uniform1iv(this.addr,a),Ba(s,a));for(let r=0;r!==i;++r)t.setTexture2DArray(e[r]||oV,a[r])}function lne(n){switch(n){case 5126:return Vte;case 35664:return Hte;case 35665:return Wte;case 35666:return jte;case 35674:return Xte;case 35675:return qte;case 35676:return Kte;case 5124:case 35670:return Yte;case 35667:case 35671:return Jte;case 35668:case 35672:return Zte;case 35669:case 35673:return Qte;case 5125:return ene;case 36294:return tne;case 36295:return nne;case 36296:return sne;case 35678:case 36198:case 36298:case 36306:case 35682:return ine;case 35679:case 36299:case 36307:return ane;case 35680:case 36300:case 36308:case 36293:return rne;case 36289:case 36303:case 36311:case 36292:return one}}class cne{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.setValue=Gte(t.type)}}class une{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=lne(t.type)}}class hne{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const i=this.seq;for(let a=0,r=i.length;a!==r;++a){const o=i[a];o.setValue(e,t[o.id],s)}}}const MI=/(\w+)(\])?(\[|\.)?/g;function bP(n,e){n.seq.push(e),n.map[e.id]=e}function dne(n,e,t){const s=n.name,i=s.length;for(MI.lastIndex=0;;){const a=MI.exec(s),r=MI.lastIndex;let o=a[1];const l=a[2]==="]",c=a[3];if(l&&(o=o|0),c===void 0||c==="["&&r+2===i){bP(t,c===void 0?new cne(o,n,e):new une(o,n,e));break}else{let d=t.map[o];d===void 0&&(d=new hne(o),bP(t,d)),t=d}}}class hT{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<s;++i){const a=e.getActiveUniform(t,i),r=e.getUniformLocation(t,a.name);dne(a,r,this)}}setValue(e,t,s,i){const a=this.map[t];a!==void 0&&a.setValue(e,s,i)}setOptional(e,t,s){const i=t[s];i!==void 0&&this.setValue(e,s,i)}static upload(e,t,s,i){for(let a=0,r=t.length;a!==r;++a){const o=t[a],l=s[o.id];l.needsUpdate!==!1&&o.setValue(e,l.value,i)}}static seqWithValue(e,t){const s=[];for(let i=0,a=e.length;i!==a;++i){const r=e[i];r.id in t&&s.push(r)}return s}}function SP(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}const fne=37297;let pne=0;function mne(n,e){const t=n.split(`
`),s=[],i=Math.max(e-6,0),a=Math.min(e+6,t.length);for(let r=i;r<a;r++){const o=r+1;s.push(`${o===e?">":" "} ${o}: ${t[r]}`)}return s.join(`
`)}const _P=new Vn;function gne(n){ws._getMatrix(_P,ws.workingColorSpace,n);const e=`mat3( ${_P.elements.map(t=>t.toFixed(4))} )`;switch(ws.getTransfer(n)){case j1:return[e,"LinearTransferOETF"];case js:return[e,"sRGBTransferOETF"];default:return Wt("WebGLProgram: Unsupported color space: ",n),[e,"LinearTransferOETF"]}}function AP(n,e,t){const s=n.getShaderParameter(e,n.COMPILE_STATUS),a=(n.getShaderInfoLog(e)||"").trim();if(s&&a==="")return"";const r=/ERROR: 0:(\d+)/.exec(a);if(r){const o=parseInt(r[1]);return t.toUpperCase()+`

`+a+`

`+mne(n.getShaderSource(e),o)}else return a}function xne(n,e){const t=gne(e);return[`vec4 ${n}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function yne(n,e){let t;switch(e){case P4:t="Linear";break;case z4:t="Reinhard";break;case $4:t="Cineon";break;case YD:t="ACESFilmic";break;case V4:t="AgX";break;case H4:t="Neutral";break;case G4:t="Custom";break;default:Wt("WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const FC=new ue;function vne(){ws.getLuminanceCoefficients(FC);const n=FC.x.toFixed(4),e=FC.y.toFixed(4),t=FC.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function bne(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(w1).join(`
`)}function Sne(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function _ne(n,e){const t={},s=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let i=0;i<s;i++){const a=n.getActiveAttrib(e,i),r=a.name;let o=1;a.type===n.FLOAT_MAT2&&(o=2),a.type===n.FLOAT_MAT3&&(o=3),a.type===n.FLOAT_MAT4&&(o=4),t[r]={type:a.type,location:n.getAttribLocation(e,r),locationSize:o}}return t}function w1(n){return n!==""}function wP(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function CP(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Ane=/^[ \t]*#include +<([\w\d./]+)>/gm;function P3(n){return n.replace(Ane,Cne)}const wne=new Map;function Cne(n,e){let t=Jn[e];if(t===void 0){const s=wne.get(e);if(s!==void 0)t=Jn[s],Wt('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return P3(t)}const Tne=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function TP(n){return n.replace(Tne,Ene)}function Ene(n,e,t,s){let i="";for(let a=parseInt(e);a<parseInt(t);a++)i+=s.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return i}function EP(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Mne(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===ZE?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===D1?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Gc&&(e="SHADOWMAP_TYPE_VSM"),e}function Nne(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case ah:case Uf:e="ENVMAP_TYPE_CUBE";break;case hy:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Rne(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Uf:e="ENVMAP_MODE_REFRACTION";break}return e}function Ine(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case CS:e="ENVMAP_BLENDING_MULTIPLY";break;case F4:e="ENVMAP_BLENDING_MIX";break;case U4:e="ENVMAP_BLENDING_ADD";break}return e}function Dne(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:s,maxMip:t}}function One(n,e,t,s){const i=n.getContext(),a=t.defines;let r=t.vertexShader,o=t.fragmentShader;const l=Mne(t),c=Nne(t),h=Rne(t),d=Ine(t),p=Dne(t),g=bne(t),v=Sne(a),_=i.createProgram();let S,b,w=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(S=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,v].filter(w1).join(`
`),S.length>0&&(S+=`
`),b=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,v].filter(w1).join(`
`),b.length>0&&(b+=`
`)):(S=[EP(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,v,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",t.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(w1).join(`
`),b=[EP(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,v,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+d:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",t.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ju?"#define TONE_MAPPING":"",t.toneMapping!==Ju?Jn.tonemapping_pars_fragment:"",t.toneMapping!==Ju?yne("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Jn.colorspace_pars_fragment,xne("linearToOutputTexel",t.outputColorSpace),vne(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(w1).join(`
`)),r=P3(r),r=wP(r,t),r=CP(r,t),o=P3(o),o=wP(o,t),o=CP(o,t),r=TP(r),o=TP(o),t.isRawShaderMaterial!==!0&&(w=`#version 300 es
`,S=[g,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+S,b=["#define varying in",t.glslVersion===R3?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===R3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+b);const T=w+S+r,E=w+b+o,R=SP(i,i.VERTEX_SHADER,T),D=SP(i,i.FRAGMENT_SHADER,E);i.attachShader(_,R),i.attachShader(_,D),t.index0AttributeName!==void 0?i.bindAttribLocation(_,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(_,0,"position"),i.linkProgram(_);function F(L){if(n.debug.checkShaderErrors){const H=i.getProgramInfoLog(_)||"",K=i.getShaderInfoLog(R)||"",Z=i.getShaderInfoLog(D)||"",Q=H.trim(),P=K.trim(),W=Z.trim();let q=!0,se=!0;if(i.getProgramParameter(_,i.LINK_STATUS)===!1)if(q=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,_,R,D);else{const le=AP(i,R,"vertex"),Y=AP(i,D,"fragment");On("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(_,i.VALIDATE_STATUS)+`

Material Name: `+L.name+`
Material Type: `+L.type+`

Program Info Log: `+Q+`
`+le+`
`+Y)}else Q!==""?Wt("WebGLProgram: Program Info Log:",Q):(P===""||W==="")&&(se=!1);se&&(L.diagnostics={runnable:q,programLog:Q,vertexShader:{log:P,prefix:S},fragmentShader:{log:W,prefix:b}})}i.deleteShader(R),i.deleteShader(D),U=new hT(i,_),O=_ne(i,_)}let U;this.getUniforms=function(){return U===void 0&&F(this),U};let O;this.getAttributes=function(){return O===void 0&&F(this),O};let B=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return B===!1&&(B=i.getProgramParameter(_,fne)),B},this.destroy=function(){s.releaseStatesOfProgram(this),i.deleteProgram(_),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=pne++,this.cacheKey=e,this.usedTimes=1,this.program=_,this.vertexShader=R,this.fragmentShader=D,this}let Bne=0;class kne{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,i=this._getShaderStage(t),a=this._getShaderStage(s),r=this._getShaderCacheForMaterial(e);return r.has(i)===!1&&(r.add(i),i.usedTimes++),r.has(a)===!1&&(r.add(a),a.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new Lne(e),t.set(e,s)),s}}class Lne{constructor(e){this.id=Bne++,this.code=e,this.usedTimes=0}}function Fne(n,e,t,s,i,a,r){const o=new Px,l=new kne,c=new Set,h=[],d=i.logarithmicDepthBuffer,p=i.vertexTextures;let g=i.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function _(O){return c.add(O),O===0?"uv":`uv${O}`}function S(O,B,L,H,K){const Z=H.fog,Q=K.geometry,P=O.isMeshStandardMaterial?H.environment:null,W=(O.isMeshStandardMaterial?t:e).get(O.envMap||P),q=W&&W.mapping===hy?W.image.height:null,se=v[O.type];O.precision!==null&&(g=i.getMaxPrecision(O.precision),g!==O.precision&&Wt("WebGLProgram.getParameters:",O.precision,"not supported, using",g,"instead."));const le=Q.morphAttributes.position||Q.morphAttributes.normal||Q.morphAttributes.color,Y=le!==void 0?le.length:0;let re=0;Q.morphAttributes.position!==void 0&&(re=1),Q.morphAttributes.normal!==void 0&&(re=2),Q.morphAttributes.color!==void 0&&(re=3);let he,me,Ne,fe;if(se){const Fn=Hc[se];he=Fn.vertexShader,me=Fn.fragmentShader}else he=O.vertexShader,me=O.fragmentShader,l.update(O),Ne=l.getVertexShaderID(O),fe=l.getFragmentShaderID(O);const Te=n.getRenderTarget(),Ge=n.state.buffers.depth.getReversed(),nt=K.isInstancedMesh===!0,yt=K.isBatchedMesh===!0,Dt=!!O.map,qt=!!O.matcap,Bt=!!W,Je=!!O.aoMap,oe=!!O.lightMap,Ze=!!O.bumpMap,it=!!O.normalMap,ft=!!O.displacementMap,gt=!!O.emissiveMap,Tt=!!O.metalnessMap,Et=!!O.roughnessMap,kt=O.anisotropy>0,ce=O.clearcoat>0,J=O.dispersion>0,Ie=O.iridescence>0,Ye=O.sheen>0,lt=O.transmission>0,Ve=kt&&!!O.anisotropyMap,Gt=ce&&!!O.clearcoatMap,Lt=ce&&!!O.clearcoatNormalMap,tn=ce&&!!O.clearcoatRoughnessMap,Jt=Ie&&!!O.iridescenceMap,at=Ie&&!!O.iridescenceThicknessMap,ut=Ye&&!!O.sheenColorMap,Zt=Ye&&!!O.sheenRoughnessMap,xe=!!O.specularMap,Fe=!!O.specularColorMap,mt=!!O.specularIntensityMap,ge=lt&&!!O.transmissionMap,Ue=lt&&!!O.thicknessMap,At=!!O.gradientMap,Rt=!!O.alphaMap,St=O.alphaTest>0,dt=!!O.alphaHash,Ut=!!O.extensions;let cn=Ju;O.toneMapped&&(Te===null||Te.isXRRenderTarget===!0)&&(cn=n.toneMapping);const Wn={shaderID:se,shaderType:O.type,shaderName:O.name,vertexShader:he,fragmentShader:me,defines:O.defines,customVertexShaderID:Ne,customFragmentShaderID:fe,isRawShaderMaterial:O.isRawShaderMaterial===!0,glslVersion:O.glslVersion,precision:g,batching:yt,batchingColor:yt&&K._colorsTexture!==null,instancing:nt,instancingColor:nt&&K.instanceColor!==null,instancingMorph:nt&&K.morphTexture!==null,supportsVertexTextures:p,outputColorSpace:Te===null?n.outputColorSpace:Te.isXRRenderTarget===!0?Te.texture.colorSpace:Qc,alphaToCoverage:!!O.alphaToCoverage,map:Dt,matcap:qt,envMap:Bt,envMapMode:Bt&&W.mapping,envMapCubeUVHeight:q,aoMap:Je,lightMap:oe,bumpMap:Ze,normalMap:it,displacementMap:p&&ft,emissiveMap:gt,normalMapObjectSpace:it&&O.normalMapType===Z4,normalMapTangentSpace:it&&O.normalMapType===tp,metalnessMap:Tt,roughnessMap:Et,anisotropy:kt,anisotropyMap:Ve,clearcoat:ce,clearcoatMap:Gt,clearcoatNormalMap:Lt,clearcoatRoughnessMap:tn,dispersion:J,iridescence:Ie,iridescenceMap:Jt,iridescenceThicknessMap:at,sheen:Ye,sheenColorMap:ut,sheenRoughnessMap:Zt,specularMap:xe,specularColorMap:Fe,specularIntensityMap:mt,transmission:lt,transmissionMap:ge,thicknessMap:Ue,gradientMap:At,opaque:O.transparent===!1&&O.blending===Wm&&O.alphaToCoverage===!1,alphaMap:Rt,alphaTest:St,alphaHash:dt,combine:O.combine,mapUv:Dt&&_(O.map.channel),aoMapUv:Je&&_(O.aoMap.channel),lightMapUv:oe&&_(O.lightMap.channel),bumpMapUv:Ze&&_(O.bumpMap.channel),normalMapUv:it&&_(O.normalMap.channel),displacementMapUv:ft&&_(O.displacementMap.channel),emissiveMapUv:gt&&_(O.emissiveMap.channel),metalnessMapUv:Tt&&_(O.metalnessMap.channel),roughnessMapUv:Et&&_(O.roughnessMap.channel),anisotropyMapUv:Ve&&_(O.anisotropyMap.channel),clearcoatMapUv:Gt&&_(O.clearcoatMap.channel),clearcoatNormalMapUv:Lt&&_(O.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:tn&&_(O.clearcoatRoughnessMap.channel),iridescenceMapUv:Jt&&_(O.iridescenceMap.channel),iridescenceThicknessMapUv:at&&_(O.iridescenceThicknessMap.channel),sheenColorMapUv:ut&&_(O.sheenColorMap.channel),sheenRoughnessMapUv:Zt&&_(O.sheenRoughnessMap.channel),specularMapUv:xe&&_(O.specularMap.channel),specularColorMapUv:Fe&&_(O.specularColorMap.channel),specularIntensityMapUv:mt&&_(O.specularIntensityMap.channel),transmissionMapUv:ge&&_(O.transmissionMap.channel),thicknessMapUv:Ue&&_(O.thicknessMap.channel),alphaMapUv:Rt&&_(O.alphaMap.channel),vertexTangents:!!Q.attributes.tangent&&(it||kt),vertexColors:O.vertexColors,vertexAlphas:O.vertexColors===!0&&!!Q.attributes.color&&Q.attributes.color.itemSize===4,pointsUvs:K.isPoints===!0&&!!Q.attributes.uv&&(Dt||Rt),fog:!!Z,useFog:O.fog===!0,fogExp2:!!Z&&Z.isFogExp2,flatShading:O.flatShading===!0&&O.wireframe===!1,sizeAttenuation:O.sizeAttenuation===!0,logarithmicDepthBuffer:d,reversedDepthBuffer:Ge,skinning:K.isSkinnedMesh===!0,morphTargets:Q.morphAttributes.position!==void 0,morphNormals:Q.morphAttributes.normal!==void 0,morphColors:Q.morphAttributes.color!==void 0,morphTargetsCount:Y,morphTextureStride:re,numDirLights:B.directional.length,numPointLights:B.point.length,numSpotLights:B.spot.length,numSpotLightMaps:B.spotLightMap.length,numRectAreaLights:B.rectArea.length,numHemiLights:B.hemi.length,numDirLightShadows:B.directionalShadowMap.length,numPointLightShadows:B.pointShadowMap.length,numSpotLightShadows:B.spotShadowMap.length,numSpotLightShadowsWithMaps:B.numSpotLightShadowsWithMaps,numLightProbes:B.numLightProbes,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:O.dithering,shadowMapEnabled:n.shadowMap.enabled&&L.length>0,shadowMapType:n.shadowMap.type,toneMapping:cn,decodeVideoTexture:Dt&&O.map.isVideoTexture===!0&&ws.getTransfer(O.map.colorSpace)===js,decodeVideoTextureEmissive:gt&&O.emissiveMap.isVideoTexture===!0&&ws.getTransfer(O.emissiveMap.colorSpace)===js,premultipliedAlpha:O.premultipliedAlpha,doubleSided:O.side===Ql,flipSided:O.side===Ao,useDepthPacking:O.depthPacking>=0,depthPacking:O.depthPacking||0,index0AttributeName:O.index0AttributeName,extensionClipCullDistance:Ut&&O.extensions.clipCullDistance===!0&&s.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Ut&&O.extensions.multiDraw===!0||yt)&&s.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:O.customProgramCacheKey()};return Wn.vertexUv1s=c.has(1),Wn.vertexUv2s=c.has(2),Wn.vertexUv3s=c.has(3),c.clear(),Wn}function b(O){const B=[];if(O.shaderID?B.push(O.shaderID):(B.push(O.customVertexShaderID),B.push(O.customFragmentShaderID)),O.defines!==void 0)for(const L in O.defines)B.push(L),B.push(O.defines[L]);return O.isRawShaderMaterial===!1&&(w(B,O),T(B,O),B.push(n.outputColorSpace)),B.push(O.customProgramCacheKey),B.join()}function w(O,B){O.push(B.precision),O.push(B.outputColorSpace),O.push(B.envMapMode),O.push(B.envMapCubeUVHeight),O.push(B.mapUv),O.push(B.alphaMapUv),O.push(B.lightMapUv),O.push(B.aoMapUv),O.push(B.bumpMapUv),O.push(B.normalMapUv),O.push(B.displacementMapUv),O.push(B.emissiveMapUv),O.push(B.metalnessMapUv),O.push(B.roughnessMapUv),O.push(B.anisotropyMapUv),O.push(B.clearcoatMapUv),O.push(B.clearcoatNormalMapUv),O.push(B.clearcoatRoughnessMapUv),O.push(B.iridescenceMapUv),O.push(B.iridescenceThicknessMapUv),O.push(B.sheenColorMapUv),O.push(B.sheenRoughnessMapUv),O.push(B.specularMapUv),O.push(B.specularColorMapUv),O.push(B.specularIntensityMapUv),O.push(B.transmissionMapUv),O.push(B.thicknessMapUv),O.push(B.combine),O.push(B.fogExp2),O.push(B.sizeAttenuation),O.push(B.morphTargetsCount),O.push(B.morphAttributeCount),O.push(B.numDirLights),O.push(B.numPointLights),O.push(B.numSpotLights),O.push(B.numSpotLightMaps),O.push(B.numHemiLights),O.push(B.numRectAreaLights),O.push(B.numDirLightShadows),O.push(B.numPointLightShadows),O.push(B.numSpotLightShadows),O.push(B.numSpotLightShadowsWithMaps),O.push(B.numLightProbes),O.push(B.shadowMapType),O.push(B.toneMapping),O.push(B.numClippingPlanes),O.push(B.numClipIntersection),O.push(B.depthPacking)}function T(O,B){o.disableAll(),B.supportsVertexTextures&&o.enable(0),B.instancing&&o.enable(1),B.instancingColor&&o.enable(2),B.instancingMorph&&o.enable(3),B.matcap&&o.enable(4),B.envMap&&o.enable(5),B.normalMapObjectSpace&&o.enable(6),B.normalMapTangentSpace&&o.enable(7),B.clearcoat&&o.enable(8),B.iridescence&&o.enable(9),B.alphaTest&&o.enable(10),B.vertexColors&&o.enable(11),B.vertexAlphas&&o.enable(12),B.vertexUv1s&&o.enable(13),B.vertexUv2s&&o.enable(14),B.vertexUv3s&&o.enable(15),B.vertexTangents&&o.enable(16),B.anisotropy&&o.enable(17),B.alphaHash&&o.enable(18),B.batching&&o.enable(19),B.dispersion&&o.enable(20),B.batchingColor&&o.enable(21),B.gradientMap&&o.enable(22),O.push(o.mask),o.disableAll(),B.fog&&o.enable(0),B.useFog&&o.enable(1),B.flatShading&&o.enable(2),B.logarithmicDepthBuffer&&o.enable(3),B.reversedDepthBuffer&&o.enable(4),B.skinning&&o.enable(5),B.morphTargets&&o.enable(6),B.morphNormals&&o.enable(7),B.morphColors&&o.enable(8),B.premultipliedAlpha&&o.enable(9),B.shadowMapEnabled&&o.enable(10),B.doubleSided&&o.enable(11),B.flipSided&&o.enable(12),B.useDepthPacking&&o.enable(13),B.dithering&&o.enable(14),B.transmission&&o.enable(15),B.sheen&&o.enable(16),B.opaque&&o.enable(17),B.pointsUvs&&o.enable(18),B.decodeVideoTexture&&o.enable(19),B.decodeVideoTextureEmissive&&o.enable(20),B.alphaToCoverage&&o.enable(21),O.push(o.mask)}function E(O){const B=v[O.type];let L;if(B){const H=Hc[B];L=dG.clone(H.uniforms)}else L=O.uniforms;return L}function R(O,B){let L;for(let H=0,K=h.length;H<K;H++){const Z=h[H];if(Z.cacheKey===B){L=Z,++L.usedTimes;break}}return L===void 0&&(L=new One(n,B,O,a),h.push(L)),L}function D(O){if(--O.usedTimes===0){const B=h.indexOf(O);h[B]=h[h.length-1],h.pop(),O.destroy()}}function F(O){l.remove(O)}function U(){l.dispose()}return{getParameters:S,getProgramCacheKey:b,getUniforms:E,acquireProgram:R,releaseProgram:D,releaseShaderCache:F,programs:h,dispose:U}}function Une(){let n=new WeakMap;function e(r){return n.has(r)}function t(r){let o=n.get(r);return o===void 0&&(o={},n.set(r,o)),o}function s(r){n.delete(r)}function i(r,o,l){n.get(r)[o]=l}function a(){n=new WeakMap}return{has:e,get:t,remove:s,update:i,dispose:a}}function Pne(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function MP(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function NP(){const n=[];let e=0;const t=[],s=[],i=[];function a(){e=0,t.length=0,s.length=0,i.length=0}function r(d,p,g,v,_,S){let b=n[e];return b===void 0?(b={id:d.id,object:d,geometry:p,material:g,groupOrder:v,renderOrder:d.renderOrder,z:_,group:S},n[e]=b):(b.id=d.id,b.object=d,b.geometry=p,b.material=g,b.groupOrder=v,b.renderOrder=d.renderOrder,b.z=_,b.group=S),e++,b}function o(d,p,g,v,_,S){const b=r(d,p,g,v,_,S);g.transmission>0?s.push(b):g.transparent===!0?i.push(b):t.push(b)}function l(d,p,g,v,_,S){const b=r(d,p,g,v,_,S);g.transmission>0?s.unshift(b):g.transparent===!0?i.unshift(b):t.unshift(b)}function c(d,p){t.length>1&&t.sort(d||Pne),s.length>1&&s.sort(p||MP),i.length>1&&i.sort(p||MP)}function h(){for(let d=e,p=n.length;d<p;d++){const g=n[d];if(g.id===null)break;g.id=null,g.object=null,g.geometry=null,g.material=null,g.group=null}}return{opaque:t,transmissive:s,transparent:i,init:a,push:o,unshift:l,finish:h,sort:c}}function zne(){let n=new WeakMap;function e(s,i){const a=n.get(s);let r;return a===void 0?(r=new NP,n.set(s,[r])):i>=a.length?(r=new NP,a.push(r)):r=a[i],r}function t(){n=new WeakMap}return{get:e,dispose:t}}function $ne(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new ue,color:new $t};break;case"SpotLight":t={position:new ue,direction:new ue,color:new $t,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new ue,color:new $t,distance:0,decay:0};break;case"HemisphereLight":t={direction:new ue,skyColor:new $t,groundColor:new $t};break;case"RectAreaLight":t={color:new $t,position:new ue,halfWidth:new ue,halfHeight:new ue};break}return n[e.id]=t,t}}}function Gne(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let Vne=0;function Hne(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function Wne(n){const e=new $ne,t=Gne(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)s.probe.push(new ue);const i=new ue,a=new _n,r=new _n;function o(c){let h=0,d=0,p=0;for(let O=0;O<9;O++)s.probe[O].set(0,0,0);let g=0,v=0,_=0,S=0,b=0,w=0,T=0,E=0,R=0,D=0,F=0;c.sort(Hne);for(let O=0,B=c.length;O<B;O++){const L=c[O],H=L.color,K=L.intensity,Z=L.distance,Q=L.shadow&&L.shadow.map?L.shadow.map.texture:null;if(L.isAmbientLight)h+=H.r*K,d+=H.g*K,p+=H.b*K;else if(L.isLightProbe){for(let P=0;P<9;P++)s.probe[P].addScaledVector(L.sh.coefficients[P],K);F++}else if(L.isDirectionalLight){const P=e.get(L);if(P.color.copy(L.color).multiplyScalar(L.intensity),L.castShadow){const W=L.shadow,q=t.get(L);q.shadowIntensity=W.intensity,q.shadowBias=W.bias,q.shadowNormalBias=W.normalBias,q.shadowRadius=W.radius,q.shadowMapSize=W.mapSize,s.directionalShadow[g]=q,s.directionalShadowMap[g]=Q,s.directionalShadowMatrix[g]=L.shadow.matrix,w++}s.directional[g]=P,g++}else if(L.isSpotLight){const P=e.get(L);P.position.setFromMatrixPosition(L.matrixWorld),P.color.copy(H).multiplyScalar(K),P.distance=Z,P.coneCos=Math.cos(L.angle),P.penumbraCos=Math.cos(L.angle*(1-L.penumbra)),P.decay=L.decay,s.spot[_]=P;const W=L.shadow;if(L.map&&(s.spotLightMap[R]=L.map,R++,W.updateMatrices(L),L.castShadow&&D++),s.spotLightMatrix[_]=W.matrix,L.castShadow){const q=t.get(L);q.shadowIntensity=W.intensity,q.shadowBias=W.bias,q.shadowNormalBias=W.normalBias,q.shadowRadius=W.radius,q.shadowMapSize=W.mapSize,s.spotShadow[_]=q,s.spotShadowMap[_]=Q,E++}_++}else if(L.isRectAreaLight){const P=e.get(L);P.color.copy(H).multiplyScalar(K),P.halfWidth.set(L.width*.5,0,0),P.halfHeight.set(0,L.height*.5,0),s.rectArea[S]=P,S++}else if(L.isPointLight){const P=e.get(L);if(P.color.copy(L.color).multiplyScalar(L.intensity),P.distance=L.distance,P.decay=L.decay,L.castShadow){const W=L.shadow,q=t.get(L);q.shadowIntensity=W.intensity,q.shadowBias=W.bias,q.shadowNormalBias=W.normalBias,q.shadowRadius=W.radius,q.shadowMapSize=W.mapSize,q.shadowCameraNear=W.camera.near,q.shadowCameraFar=W.camera.far,s.pointShadow[v]=q,s.pointShadowMap[v]=Q,s.pointShadowMatrix[v]=L.shadow.matrix,T++}s.point[v]=P,v++}else if(L.isHemisphereLight){const P=e.get(L);P.skyColor.copy(L.color).multiplyScalar(K),P.groundColor.copy(L.groundColor).multiplyScalar(K),s.hemi[b]=P,b++}}S>0&&(n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Ht.LTC_FLOAT_1,s.rectAreaLTC2=Ht.LTC_FLOAT_2):(s.rectAreaLTC1=Ht.LTC_HALF_1,s.rectAreaLTC2=Ht.LTC_HALF_2)),s.ambient[0]=h,s.ambient[1]=d,s.ambient[2]=p;const U=s.hash;(U.directionalLength!==g||U.pointLength!==v||U.spotLength!==_||U.rectAreaLength!==S||U.hemiLength!==b||U.numDirectionalShadows!==w||U.numPointShadows!==T||U.numSpotShadows!==E||U.numSpotMaps!==R||U.numLightProbes!==F)&&(s.directional.length=g,s.spot.length=_,s.rectArea.length=S,s.point.length=v,s.hemi.length=b,s.directionalShadow.length=w,s.directionalShadowMap.length=w,s.pointShadow.length=T,s.pointShadowMap.length=T,s.spotShadow.length=E,s.spotShadowMap.length=E,s.directionalShadowMatrix.length=w,s.pointShadowMatrix.length=T,s.spotLightMatrix.length=E+R-D,s.spotLightMap.length=R,s.numSpotLightShadowsWithMaps=D,s.numLightProbes=F,U.directionalLength=g,U.pointLength=v,U.spotLength=_,U.rectAreaLength=S,U.hemiLength=b,U.numDirectionalShadows=w,U.numPointShadows=T,U.numSpotShadows=E,U.numSpotMaps=R,U.numLightProbes=F,s.version=Vne++)}function l(c,h){let d=0,p=0,g=0,v=0,_=0;const S=h.matrixWorldInverse;for(let b=0,w=c.length;b<w;b++){const T=c[b];if(T.isDirectionalLight){const E=s.directional[d];E.direction.setFromMatrixPosition(T.matrixWorld),i.setFromMatrixPosition(T.target.matrixWorld),E.direction.sub(i),E.direction.transformDirection(S),d++}else if(T.isSpotLight){const E=s.spot[g];E.position.setFromMatrixPosition(T.matrixWorld),E.position.applyMatrix4(S),E.direction.setFromMatrixPosition(T.matrixWorld),i.setFromMatrixPosition(T.target.matrixWorld),E.direction.sub(i),E.direction.transformDirection(S),g++}else if(T.isRectAreaLight){const E=s.rectArea[v];E.position.setFromMatrixPosition(T.matrixWorld),E.position.applyMatrix4(S),r.identity(),a.copy(T.matrixWorld),a.premultiply(S),r.extractRotation(a),E.halfWidth.set(T.width*.5,0,0),E.halfHeight.set(0,T.height*.5,0),E.halfWidth.applyMatrix4(r),E.halfHeight.applyMatrix4(r),v++}else if(T.isPointLight){const E=s.point[p];E.position.setFromMatrixPosition(T.matrixWorld),E.position.applyMatrix4(S),p++}else if(T.isHemisphereLight){const E=s.hemi[_];E.direction.setFromMatrixPosition(T.matrixWorld),E.direction.transformDirection(S),_++}}}return{setup:o,setupView:l,state:s}}function RP(n){const e=new Wne(n),t=[],s=[];function i(h){c.camera=h,t.length=0,s.length=0}function a(h){t.push(h)}function r(h){s.push(h)}function o(){e.setup(t)}function l(h){e.setupView(t,h)}const c={lightsArray:t,shadowsArray:s,camera:null,lights:e,transmissionRenderTarget:{}};return{init:i,state:c,setupLights:o,setupLightsView:l,pushLight:a,pushShadow:r}}function jne(n){let e=new WeakMap;function t(i,a=0){const r=e.get(i);let o;return r===void 0?(o=new RP(n),e.set(i,[o])):a>=r.length?(o=new RP(n),r.push(o)):o=r[a],o}function s(){e=new WeakMap}return{get:t,dispose:s}}const Xne=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,qne=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Kne(n,e,t){let s=new fy;const i=new rt,a=new rt,r=new Cs,o=new SO({depthPacking:J4}),l=new _O,c={},h=t.maxTextureSize,d={[ih]:Ao,[Ao]:ih,[Ql]:Ql},p=new jr({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new rt},radius:{value:4}},vertexShader:Xne,fragmentShader:qne}),g=p.clone();g.defines.HORIZONTAL_PASS=1;const v=new Ln;v.setAttribute("position",new Es(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const _=new Ti(v,p),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ZE;let b=this.type;this.render=function(D,F,U){if(S.enabled===!1||S.autoUpdate===!1&&S.needsUpdate===!1||D.length===0)return;const O=n.getRenderTarget(),B=n.getActiveCubeFace(),L=n.getActiveMipmapLevel(),H=n.state;H.setBlending(ic),H.buffers.depth.getReversed()===!0?H.buffers.color.setClear(0,0,0,0):H.buffers.color.setClear(1,1,1,1),H.buffers.depth.setTest(!0),H.setScissorTest(!1);const K=b!==Gc&&this.type===Gc,Z=b===Gc&&this.type!==Gc;for(let Q=0,P=D.length;Q<P;Q++){const W=D[Q],q=W.shadow;if(q===void 0){Wt("WebGLShadowMap:",W,"has no shadow.");continue}if(q.autoUpdate===!1&&q.needsUpdate===!1)continue;i.copy(q.mapSize);const se=q.getFrameExtents();if(i.multiply(se),a.copy(q.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(a.x=Math.floor(h/se.x),i.x=a.x*se.x,q.mapSize.x=a.x),i.y>h&&(a.y=Math.floor(h/se.y),i.y=a.y*se.y,q.mapSize.y=a.y)),q.map===null||K===!0||Z===!0){const Y=this.type!==Gc?{minFilter:Ja,magFilter:Ja}:{};q.map!==null&&q.map.dispose(),q.map=new Wr(i.x,i.y,Y),q.map.texture.name=W.name+".shadowMap",q.camera.updateProjectionMatrix()}n.setRenderTarget(q.map),n.clear();const le=q.getViewportCount();for(let Y=0;Y<le;Y++){const re=q.getViewport(Y);r.set(a.x*re.x,a.y*re.y,a.x*re.z,a.y*re.w),H.viewport(r),q.updateMatrices(W,Y),s=q.getFrustum(),E(F,U,q.camera,W,this.type)}q.isPointLightShadow!==!0&&this.type===Gc&&w(q,U),q.needsUpdate=!1}b=this.type,S.needsUpdate=!1,n.setRenderTarget(O,B,L)};function w(D,F){const U=e.update(_);p.defines.VSM_SAMPLES!==D.blurSamples&&(p.defines.VSM_SAMPLES=D.blurSamples,g.defines.VSM_SAMPLES=D.blurSamples,p.needsUpdate=!0,g.needsUpdate=!0),D.mapPass===null&&(D.mapPass=new Wr(i.x,i.y)),p.uniforms.shadow_pass.value=D.map.texture,p.uniforms.resolution.value=D.mapSize,p.uniforms.radius.value=D.radius,n.setRenderTarget(D.mapPass),n.clear(),n.renderBufferDirect(F,null,U,p,_,null),g.uniforms.shadow_pass.value=D.mapPass.texture,g.uniforms.resolution.value=D.mapSize,g.uniforms.radius.value=D.radius,n.setRenderTarget(D.map),n.clear(),n.renderBufferDirect(F,null,U,g,_,null)}function T(D,F,U,O){let B=null;const L=U.isPointLight===!0?D.customDistanceMaterial:D.customDepthMaterial;if(L!==void 0)B=L;else if(B=U.isPointLight===!0?l:o,n.localClippingEnabled&&F.clipShadows===!0&&Array.isArray(F.clippingPlanes)&&F.clippingPlanes.length!==0||F.displacementMap&&F.displacementScale!==0||F.alphaMap&&F.alphaTest>0||F.map&&F.alphaTest>0||F.alphaToCoverage===!0){const H=B.uuid,K=F.uuid;let Z=c[H];Z===void 0&&(Z={},c[H]=Z);let Q=Z[K];Q===void 0&&(Q=B.clone(),Z[K]=Q,F.addEventListener("dispose",R)),B=Q}if(B.visible=F.visible,B.wireframe=F.wireframe,O===Gc?B.side=F.shadowSide!==null?F.shadowSide:F.side:B.side=F.shadowSide!==null?F.shadowSide:d[F.side],B.alphaMap=F.alphaMap,B.alphaTest=F.alphaToCoverage===!0?.5:F.alphaTest,B.map=F.map,B.clipShadows=F.clipShadows,B.clippingPlanes=F.clippingPlanes,B.clipIntersection=F.clipIntersection,B.displacementMap=F.displacementMap,B.displacementScale=F.displacementScale,B.displacementBias=F.displacementBias,B.wireframeLinewidth=F.wireframeLinewidth,B.linewidth=F.linewidth,U.isPointLight===!0&&B.isMeshDistanceMaterial===!0){const H=n.properties.get(B);H.light=U}return B}function E(D,F,U,O,B){if(D.visible===!1)return;if(D.layers.test(F.layers)&&(D.isMesh||D.isLine||D.isPoints)&&(D.castShadow||D.receiveShadow&&B===Gc)&&(!D.frustumCulled||s.intersectsObject(D))){D.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse,D.matrixWorld);const K=e.update(D),Z=D.material;if(Array.isArray(Z)){const Q=K.groups;for(let P=0,W=Q.length;P<W;P++){const q=Q[P],se=Z[q.materialIndex];if(se&&se.visible){const le=T(D,se,O,B);D.onBeforeShadow(n,D,F,U,K,le,q),n.renderBufferDirect(U,null,K,le,D,q),D.onAfterShadow(n,D,F,U,K,le,q)}}}else if(Z.visible){const Q=T(D,Z,O,B);D.onBeforeShadow(n,D,F,U,K,Q,null),n.renderBufferDirect(U,null,K,Q,D,null),D.onAfterShadow(n,D,F,U,K,Q,null)}}const H=D.children;for(let K=0,Z=H.length;K<Z;K++)E(H[K],F,U,O,B)}function R(D){D.target.removeEventListener("dispose",R);for(const U in c){const O=c[U],B=D.target.uuid;B in O&&(O[B].dispose(),delete O[B])}}}const Yne={[ET]:MT,[NT]:DT,[RT]:OT,[Qm]:IT,[MT]:ET,[DT]:NT,[OT]:RT,[IT]:Qm};function Jne(n,e){function t(){let ge=!1;const Ue=new Cs;let At=null;const Rt=new Cs(0,0,0,0);return{setMask:function(St){At!==St&&!ge&&(n.colorMask(St,St,St,St),At=St)},setLocked:function(St){ge=St},setClear:function(St,dt,Ut,cn,Wn){Wn===!0&&(St*=cn,dt*=cn,Ut*=cn),Ue.set(St,dt,Ut,cn),Rt.equals(Ue)===!1&&(n.clearColor(St,dt,Ut,cn),Rt.copy(Ue))},reset:function(){ge=!1,At=null,Rt.set(-1,0,0,0)}}}function s(){let ge=!1,Ue=!1,At=null,Rt=null,St=null;return{setReversed:function(dt){if(Ue!==dt){const Ut=e.get("EXT_clip_control");dt?Ut.clipControlEXT(Ut.LOWER_LEFT_EXT,Ut.ZERO_TO_ONE_EXT):Ut.clipControlEXT(Ut.LOWER_LEFT_EXT,Ut.NEGATIVE_ONE_TO_ONE_EXT),Ue=dt;const cn=St;St=null,this.setClear(cn)}},getReversed:function(){return Ue},setTest:function(dt){dt?Te(n.DEPTH_TEST):Ge(n.DEPTH_TEST)},setMask:function(dt){At!==dt&&!ge&&(n.depthMask(dt),At=dt)},setFunc:function(dt){if(Ue&&(dt=Yne[dt]),Rt!==dt){switch(dt){case ET:n.depthFunc(n.NEVER);break;case MT:n.depthFunc(n.ALWAYS);break;case NT:n.depthFunc(n.LESS);break;case Qm:n.depthFunc(n.LEQUAL);break;case RT:n.depthFunc(n.EQUAL);break;case IT:n.depthFunc(n.GEQUAL);break;case DT:n.depthFunc(n.GREATER);break;case OT:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}Rt=dt}},setLocked:function(dt){ge=dt},setClear:function(dt){St!==dt&&(Ue&&(dt=1-dt),n.clearDepth(dt),St=dt)},reset:function(){ge=!1,At=null,Rt=null,St=null,Ue=!1}}}function i(){let ge=!1,Ue=null,At=null,Rt=null,St=null,dt=null,Ut=null,cn=null,Wn=null;return{setTest:function(Fn){ge||(Fn?Te(n.STENCIL_TEST):Ge(n.STENCIL_TEST))},setMask:function(Fn){Ue!==Fn&&!ge&&(n.stencilMask(Fn),Ue=Fn)},setFunc:function(Fn,ei,Ni){(At!==Fn||Rt!==ei||St!==Ni)&&(n.stencilFunc(Fn,ei,Ni),At=Fn,Rt=ei,St=Ni)},setOp:function(Fn,ei,Ni){(dt!==Fn||Ut!==ei||cn!==Ni)&&(n.stencilOp(Fn,ei,Ni),dt=Fn,Ut=ei,cn=Ni)},setLocked:function(Fn){ge=Fn},setClear:function(Fn){Wn!==Fn&&(n.clearStencil(Fn),Wn=Fn)},reset:function(){ge=!1,Ue=null,At=null,Rt=null,St=null,dt=null,Ut=null,cn=null,Wn=null}}}const a=new t,r=new s,o=new i,l=new WeakMap,c=new WeakMap;let h={},d={},p=new WeakMap,g=[],v=null,_=!1,S=null,b=null,w=null,T=null,E=null,R=null,D=null,F=new $t(0,0,0),U=0,O=!1,B=null,L=null,H=null,K=null,Z=null;const Q=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let P=!1,W=0;const q=n.getParameter(n.VERSION);q.indexOf("WebGL")!==-1?(W=parseFloat(/^WebGL (\d)/.exec(q)[1]),P=W>=1):q.indexOf("OpenGL ES")!==-1&&(W=parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),P=W>=2);let se=null,le={};const Y=n.getParameter(n.SCISSOR_BOX),re=n.getParameter(n.VIEWPORT),he=new Cs().fromArray(Y),me=new Cs().fromArray(re);function Ne(ge,Ue,At,Rt){const St=new Uint8Array(4),dt=n.createTexture();n.bindTexture(ge,dt),n.texParameteri(ge,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(ge,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let Ut=0;Ut<At;Ut++)ge===n.TEXTURE_3D||ge===n.TEXTURE_2D_ARRAY?n.texImage3D(Ue,0,n.RGBA,1,1,Rt,0,n.RGBA,n.UNSIGNED_BYTE,St):n.texImage2D(Ue+Ut,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,St);return dt}const fe={};fe[n.TEXTURE_2D]=Ne(n.TEXTURE_2D,n.TEXTURE_2D,1),fe[n.TEXTURE_CUBE_MAP]=Ne(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),fe[n.TEXTURE_2D_ARRAY]=Ne(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),fe[n.TEXTURE_3D]=Ne(n.TEXTURE_3D,n.TEXTURE_3D,1,1),a.setClear(0,0,0,1),r.setClear(1),o.setClear(0),Te(n.DEPTH_TEST),r.setFunc(Qm),Ze(!1),it(A3),Te(n.CULL_FACE),Je(ic);function Te(ge){h[ge]!==!0&&(n.enable(ge),h[ge]=!0)}function Ge(ge){h[ge]!==!1&&(n.disable(ge),h[ge]=!1)}function nt(ge,Ue){return d[ge]!==Ue?(n.bindFramebuffer(ge,Ue),d[ge]=Ue,ge===n.DRAW_FRAMEBUFFER&&(d[n.FRAMEBUFFER]=Ue),ge===n.FRAMEBUFFER&&(d[n.DRAW_FRAMEBUFFER]=Ue),!0):!1}function yt(ge,Ue){let At=g,Rt=!1;if(ge){At=p.get(Ue),At===void 0&&(At=[],p.set(Ue,At));const St=ge.textures;if(At.length!==St.length||At[0]!==n.COLOR_ATTACHMENT0){for(let dt=0,Ut=St.length;dt<Ut;dt++)At[dt]=n.COLOR_ATTACHMENT0+dt;At.length=St.length,Rt=!0}}else At[0]!==n.BACK&&(At[0]=n.BACK,Rt=!0);Rt&&n.drawBuffers(At)}function Dt(ge){return v!==ge?(n.useProgram(ge),v=ge,!0):!1}const qt={[Tf]:n.FUNC_ADD,[b4]:n.FUNC_SUBTRACT,[S4]:n.FUNC_REVERSE_SUBTRACT};qt[_4]=n.MIN,qt[A4]=n.MAX;const Bt={[w4]:n.ZERO,[C4]:n.ONE,[T4]:n.SRC_COLOR,[CT]:n.SRC_ALPHA,[D4]:n.SRC_ALPHA_SATURATE,[R4]:n.DST_COLOR,[M4]:n.DST_ALPHA,[E4]:n.ONE_MINUS_SRC_COLOR,[TT]:n.ONE_MINUS_SRC_ALPHA,[I4]:n.ONE_MINUS_DST_COLOR,[N4]:n.ONE_MINUS_DST_ALPHA,[O4]:n.CONSTANT_COLOR,[B4]:n.ONE_MINUS_CONSTANT_COLOR,[k4]:n.CONSTANT_ALPHA,[L4]:n.ONE_MINUS_CONSTANT_ALPHA};function Je(ge,Ue,At,Rt,St,dt,Ut,cn,Wn,Fn){if(ge===ic){_===!0&&(Ge(n.BLEND),_=!1);return}if(_===!1&&(Te(n.BLEND),_=!0),ge!==v4){if(ge!==S||Fn!==O){if((b!==Tf||E!==Tf)&&(n.blendEquation(n.FUNC_ADD),b=Tf,E=Tf),Fn)switch(ge){case Wm:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case w3:n.blendFunc(n.ONE,n.ONE);break;case C3:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case T3:n.blendFuncSeparate(n.DST_COLOR,n.ONE_MINUS_SRC_ALPHA,n.ZERO,n.ONE);break;default:On("WebGLState: Invalid blending: ",ge);break}else switch(ge){case Wm:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case w3:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE,n.ONE,n.ONE);break;case C3:On("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case T3:On("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:On("WebGLState: Invalid blending: ",ge);break}w=null,T=null,R=null,D=null,F.set(0,0,0),U=0,S=ge,O=Fn}return}St=St||Ue,dt=dt||At,Ut=Ut||Rt,(Ue!==b||St!==E)&&(n.blendEquationSeparate(qt[Ue],qt[St]),b=Ue,E=St),(At!==w||Rt!==T||dt!==R||Ut!==D)&&(n.blendFuncSeparate(Bt[At],Bt[Rt],Bt[dt],Bt[Ut]),w=At,T=Rt,R=dt,D=Ut),(cn.equals(F)===!1||Wn!==U)&&(n.blendColor(cn.r,cn.g,cn.b,Wn),F.copy(cn),U=Wn),S=ge,O=!1}function oe(ge,Ue){ge.side===Ql?Ge(n.CULL_FACE):Te(n.CULL_FACE);let At=ge.side===Ao;Ue&&(At=!At),Ze(At),ge.blending===Wm&&ge.transparent===!1?Je(ic):Je(ge.blending,ge.blendEquation,ge.blendSrc,ge.blendDst,ge.blendEquationAlpha,ge.blendSrcAlpha,ge.blendDstAlpha,ge.blendColor,ge.blendAlpha,ge.premultipliedAlpha),r.setFunc(ge.depthFunc),r.setTest(ge.depthTest),r.setMask(ge.depthWrite),a.setMask(ge.colorWrite);const Rt=ge.stencilWrite;o.setTest(Rt),Rt&&(o.setMask(ge.stencilWriteMask),o.setFunc(ge.stencilFunc,ge.stencilRef,ge.stencilFuncMask),o.setOp(ge.stencilFail,ge.stencilZFail,ge.stencilZPass)),gt(ge.polygonOffset,ge.polygonOffsetFactor,ge.polygonOffsetUnits),ge.alphaToCoverage===!0?Te(n.SAMPLE_ALPHA_TO_COVERAGE):Ge(n.SAMPLE_ALPHA_TO_COVERAGE)}function Ze(ge){B!==ge&&(ge?n.frontFace(n.CW):n.frontFace(n.CCW),B=ge)}function it(ge){ge!==g4?(Te(n.CULL_FACE),ge!==L&&(ge===A3?n.cullFace(n.BACK):ge===x4?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):Ge(n.CULL_FACE),L=ge}function ft(ge){ge!==H&&(P&&n.lineWidth(ge),H=ge)}function gt(ge,Ue,At){ge?(Te(n.POLYGON_OFFSET_FILL),(K!==Ue||Z!==At)&&(n.polygonOffset(Ue,At),K=Ue,Z=At)):Ge(n.POLYGON_OFFSET_FILL)}function Tt(ge){ge?Te(n.SCISSOR_TEST):Ge(n.SCISSOR_TEST)}function Et(ge){ge===void 0&&(ge=n.TEXTURE0+Q-1),se!==ge&&(n.activeTexture(ge),se=ge)}function kt(ge,Ue,At){At===void 0&&(se===null?At=n.TEXTURE0+Q-1:At=se);let Rt=le[At];Rt===void 0&&(Rt={type:void 0,texture:void 0},le[At]=Rt),(Rt.type!==ge||Rt.texture!==Ue)&&(se!==At&&(n.activeTexture(At),se=At),n.bindTexture(ge,Ue||fe[ge]),Rt.type=ge,Rt.texture=Ue)}function ce(){const ge=le[se];ge!==void 0&&ge.type!==void 0&&(n.bindTexture(ge.type,null),ge.type=void 0,ge.texture=void 0)}function J(){try{n.compressedTexImage2D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function Ie(){try{n.compressedTexImage3D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function Ye(){try{n.texSubImage2D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function lt(){try{n.texSubImage3D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function Ve(){try{n.compressedTexSubImage2D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function Gt(){try{n.compressedTexSubImage3D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function Lt(){try{n.texStorage2D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function tn(){try{n.texStorage3D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function Jt(){try{n.texImage2D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function at(){try{n.texImage3D(...arguments)}catch(ge){ge("WebGLState:",ge)}}function ut(ge){he.equals(ge)===!1&&(n.scissor(ge.x,ge.y,ge.z,ge.w),he.copy(ge))}function Zt(ge){me.equals(ge)===!1&&(n.viewport(ge.x,ge.y,ge.z,ge.w),me.copy(ge))}function xe(ge,Ue){let At=c.get(Ue);At===void 0&&(At=new WeakMap,c.set(Ue,At));let Rt=At.get(ge);Rt===void 0&&(Rt=n.getUniformBlockIndex(Ue,ge.name),At.set(ge,Rt))}function Fe(ge,Ue){const Rt=c.get(Ue).get(ge);l.get(Ue)!==Rt&&(n.uniformBlockBinding(Ue,Rt,ge.__bindingPointIndex),l.set(Ue,Rt))}function mt(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),r.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},se=null,le={},d={},p=new WeakMap,g=[],v=null,_=!1,S=null,b=null,w=null,T=null,E=null,R=null,D=null,F=new $t(0,0,0),U=0,O=!1,B=null,L=null,H=null,K=null,Z=null,he.set(0,0,n.canvas.width,n.canvas.height),me.set(0,0,n.canvas.width,n.canvas.height),a.reset(),r.reset(),o.reset()}return{buffers:{color:a,depth:r,stencil:o},enable:Te,disable:Ge,bindFramebuffer:nt,drawBuffers:yt,useProgram:Dt,setBlending:Je,setMaterial:oe,setFlipSided:Ze,setCullFace:it,setLineWidth:ft,setPolygonOffset:gt,setScissorTest:Tt,activeTexture:Et,bindTexture:kt,unbindTexture:ce,compressedTexImage2D:J,compressedTexImage3D:Ie,texImage2D:Jt,texImage3D:at,updateUBOMapping:xe,uniformBlockBinding:Fe,texStorage2D:Lt,texStorage3D:tn,texSubImage2D:Ye,texSubImage3D:lt,compressedTexSubImage2D:Ve,compressedTexSubImage3D:Gt,scissor:ut,viewport:Zt,reset:mt}}function Zne(n,e,t,s,i,a,r){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new rt,h=new WeakMap;let d;const p=new WeakMap;let g=!1;try{g=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(ce,J){return g?new OffscreenCanvas(ce,J):q1("canvas")}function _(ce,J,Ie){let Ye=1;const lt=kt(ce);if((lt.width>Ie||lt.height>Ie)&&(Ye=Ie/Math.max(lt.width,lt.height)),Ye<1)if(typeof HTMLImageElement<"u"&&ce instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ce instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ce instanceof ImageBitmap||typeof VideoFrame<"u"&&ce instanceof VideoFrame){const Ve=Math.floor(Ye*lt.width),Gt=Math.floor(Ye*lt.height);d===void 0&&(d=v(Ve,Gt));const Lt=J?v(Ve,Gt):d;return Lt.width=Ve,Lt.height=Gt,Lt.getContext("2d").drawImage(ce,0,0,Ve,Gt),Wt("WebGLRenderer: Texture has been resized from ("+lt.width+"x"+lt.height+") to ("+Ve+"x"+Gt+")."),Lt}else return"data"in ce&&Wt("WebGLRenderer: Image in DataTexture is too big ("+lt.width+"x"+lt.height+")."),ce;return ce}function S(ce){return ce.generateMipmaps}function b(ce){n.generateMipmap(ce)}function w(ce){return ce.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:ce.isWebGL3DRenderTarget?n.TEXTURE_3D:ce.isWebGLArrayRenderTarget||ce.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function T(ce,J,Ie,Ye,lt=!1){if(ce!==null){if(n[ce]!==void 0)return n[ce];Wt("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ce+"'")}let Ve=J;if(J===n.RED&&(Ie===n.FLOAT&&(Ve=n.R32F),Ie===n.HALF_FLOAT&&(Ve=n.R16F),Ie===n.UNSIGNED_BYTE&&(Ve=n.R8)),J===n.RED_INTEGER&&(Ie===n.UNSIGNED_BYTE&&(Ve=n.R8UI),Ie===n.UNSIGNED_SHORT&&(Ve=n.R16UI),Ie===n.UNSIGNED_INT&&(Ve=n.R32UI),Ie===n.BYTE&&(Ve=n.R8I),Ie===n.SHORT&&(Ve=n.R16I),Ie===n.INT&&(Ve=n.R32I)),J===n.RG&&(Ie===n.FLOAT&&(Ve=n.RG32F),Ie===n.HALF_FLOAT&&(Ve=n.RG16F),Ie===n.UNSIGNED_BYTE&&(Ve=n.RG8)),J===n.RG_INTEGER&&(Ie===n.UNSIGNED_BYTE&&(Ve=n.RG8UI),Ie===n.UNSIGNED_SHORT&&(Ve=n.RG16UI),Ie===n.UNSIGNED_INT&&(Ve=n.RG32UI),Ie===n.BYTE&&(Ve=n.RG8I),Ie===n.SHORT&&(Ve=n.RG16I),Ie===n.INT&&(Ve=n.RG32I)),J===n.RGB_INTEGER&&(Ie===n.UNSIGNED_BYTE&&(Ve=n.RGB8UI),Ie===n.UNSIGNED_SHORT&&(Ve=n.RGB16UI),Ie===n.UNSIGNED_INT&&(Ve=n.RGB32UI),Ie===n.BYTE&&(Ve=n.RGB8I),Ie===n.SHORT&&(Ve=n.RGB16I),Ie===n.INT&&(Ve=n.RGB32I)),J===n.RGBA_INTEGER&&(Ie===n.UNSIGNED_BYTE&&(Ve=n.RGBA8UI),Ie===n.UNSIGNED_SHORT&&(Ve=n.RGBA16UI),Ie===n.UNSIGNED_INT&&(Ve=n.RGBA32UI),Ie===n.BYTE&&(Ve=n.RGBA8I),Ie===n.SHORT&&(Ve=n.RGBA16I),Ie===n.INT&&(Ve=n.RGBA32I)),J===n.RGB&&(Ie===n.UNSIGNED_INT_5_9_9_9_REV&&(Ve=n.RGB9_E5),Ie===n.UNSIGNED_INT_10F_11F_11F_REV&&(Ve=n.R11F_G11F_B10F)),J===n.RGBA){const Gt=lt?j1:ws.getTransfer(Ye);Ie===n.FLOAT&&(Ve=n.RGBA32F),Ie===n.HALF_FLOAT&&(Ve=n.RGBA16F),Ie===n.UNSIGNED_BYTE&&(Ve=Gt===js?n.SRGB8_ALPHA8:n.RGBA8),Ie===n.UNSIGNED_SHORT_4_4_4_4&&(Ve=n.RGBA4),Ie===n.UNSIGNED_SHORT_5_5_5_1&&(Ve=n.RGB5_A1)}return(Ve===n.R16F||Ve===n.R32F||Ve===n.RG16F||Ve===n.RG32F||Ve===n.RGBA16F||Ve===n.RGBA32F)&&e.get("EXT_color_buffer_float"),Ve}function E(ce,J){let Ie;return ce?J===null||J===rh||J===Dx?Ie=n.DEPTH24_STENCIL8:J===wi?Ie=n.DEPTH32F_STENCIL8:J===eg&&(Ie=n.DEPTH24_STENCIL8,Wt("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):J===null||J===rh||J===Dx?Ie=n.DEPTH_COMPONENT24:J===wi?Ie=n.DEPTH_COMPONENT32F:J===eg&&(Ie=n.DEPTH_COMPONENT16),Ie}function R(ce,J){return S(ce)===!0||ce.isFramebufferTexture&&ce.minFilter!==Ja&&ce.minFilter!==is?Math.log2(Math.max(J.width,J.height))+1:ce.mipmaps!==void 0&&ce.mipmaps.length>0?ce.mipmaps.length:ce.isCompressedTexture&&Array.isArray(ce.image)?J.mipmaps.length:1}function D(ce){const J=ce.target;J.removeEventListener("dispose",D),U(J),J.isVideoTexture&&h.delete(J)}function F(ce){const J=ce.target;J.removeEventListener("dispose",F),B(J)}function U(ce){const J=s.get(ce);if(J.__webglInit===void 0)return;const Ie=ce.source,Ye=p.get(Ie);if(Ye){const lt=Ye[J.__cacheKey];lt.usedTimes--,lt.usedTimes===0&&O(ce),Object.keys(Ye).length===0&&p.delete(Ie)}s.remove(ce)}function O(ce){const J=s.get(ce);n.deleteTexture(J.__webglTexture);const Ie=ce.source,Ye=p.get(Ie);delete Ye[J.__cacheKey],r.memory.textures--}function B(ce){const J=s.get(ce);if(ce.depthTexture&&(ce.depthTexture.dispose(),s.remove(ce.depthTexture)),ce.isWebGLCubeRenderTarget)for(let Ye=0;Ye<6;Ye++){if(Array.isArray(J.__webglFramebuffer[Ye]))for(let lt=0;lt<J.__webglFramebuffer[Ye].length;lt++)n.deleteFramebuffer(J.__webglFramebuffer[Ye][lt]);else n.deleteFramebuffer(J.__webglFramebuffer[Ye]);J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer[Ye])}else{if(Array.isArray(J.__webglFramebuffer))for(let Ye=0;Ye<J.__webglFramebuffer.length;Ye++)n.deleteFramebuffer(J.__webglFramebuffer[Ye]);else n.deleteFramebuffer(J.__webglFramebuffer);if(J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&n.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer)for(let Ye=0;Ye<J.__webglColorRenderbuffer.length;Ye++)J.__webglColorRenderbuffer[Ye]&&n.deleteRenderbuffer(J.__webglColorRenderbuffer[Ye]);J.__webglDepthRenderbuffer&&n.deleteRenderbuffer(J.__webglDepthRenderbuffer)}const Ie=ce.textures;for(let Ye=0,lt=Ie.length;Ye<lt;Ye++){const Ve=s.get(Ie[Ye]);Ve.__webglTexture&&(n.deleteTexture(Ve.__webglTexture),r.memory.textures--),s.remove(Ie[Ye])}s.remove(ce)}let L=0;function H(){L=0}function K(){const ce=L;return ce>=i.maxTextures&&Wt("WebGLTextures: Trying to use "+ce+" texture units while this GPU supports only "+i.maxTextures),L+=1,ce}function Z(ce){const J=[];return J.push(ce.wrapS),J.push(ce.wrapT),J.push(ce.wrapR||0),J.push(ce.magFilter),J.push(ce.minFilter),J.push(ce.anisotropy),J.push(ce.internalFormat),J.push(ce.format),J.push(ce.type),J.push(ce.generateMipmaps),J.push(ce.premultiplyAlpha),J.push(ce.flipY),J.push(ce.unpackAlignment),J.push(ce.colorSpace),J.join()}function Q(ce,J){const Ie=s.get(ce);if(ce.isVideoTexture&&Tt(ce),ce.isRenderTargetTexture===!1&&ce.isExternalTexture!==!0&&ce.version>0&&Ie.__version!==ce.version){const Ye=ce.image;if(Ye===null)Wt("WebGLRenderer: Texture marked for update but no image data found.");else if(Ye.complete===!1)Wt("WebGLRenderer: Texture marked for update but image is incomplete");else{fe(Ie,ce,J);return}}else ce.isExternalTexture&&(Ie.__webglTexture=ce.sourceTexture?ce.sourceTexture:null);t.bindTexture(n.TEXTURE_2D,Ie.__webglTexture,n.TEXTURE0+J)}function P(ce,J){const Ie=s.get(ce);if(ce.isRenderTargetTexture===!1&&ce.version>0&&Ie.__version!==ce.version){fe(Ie,ce,J);return}else ce.isExternalTexture&&(Ie.__webglTexture=ce.sourceTexture?ce.sourceTexture:null);t.bindTexture(n.TEXTURE_2D_ARRAY,Ie.__webglTexture,n.TEXTURE0+J)}function W(ce,J){const Ie=s.get(ce);if(ce.isRenderTargetTexture===!1&&ce.version>0&&Ie.__version!==ce.version){fe(Ie,ce,J);return}t.bindTexture(n.TEXTURE_3D,Ie.__webglTexture,n.TEXTURE0+J)}function q(ce,J){const Ie=s.get(ce);if(ce.version>0&&Ie.__version!==ce.version){Te(Ie,ce,J);return}t.bindTexture(n.TEXTURE_CUBE_MAP,Ie.__webglTexture,n.TEXTURE0+J)}const se={[Pf]:n.REPEAT,[Fi]:n.CLAMP_TO_EDGE,[Ix]:n.MIRRORED_REPEAT},le={[Ja]:n.NEAREST,[QE]:n.NEAREST_MIPMAP_NEAREST,[Lm]:n.NEAREST_MIPMAP_LINEAR,[is]:n.LINEAR,[Sx]:n.LINEAR_MIPMAP_NEAREST,[tc]:n.LINEAR_MIPMAP_LINEAR},Y={[Q4]:n.NEVER,[aG]:n.ALWAYS,[eG]:n.LESS,[sO]:n.LEQUAL,[tG]:n.EQUAL,[iG]:n.GEQUAL,[nG]:n.GREATER,[sG]:n.NOTEQUAL};function re(ce,J){if(J.type===wi&&e.has("OES_texture_float_linear")===!1&&(J.magFilter===is||J.magFilter===Sx||J.magFilter===Lm||J.magFilter===tc||J.minFilter===is||J.minFilter===Sx||J.minFilter===Lm||J.minFilter===tc)&&Wt("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(ce,n.TEXTURE_WRAP_S,se[J.wrapS]),n.texParameteri(ce,n.TEXTURE_WRAP_T,se[J.wrapT]),(ce===n.TEXTURE_3D||ce===n.TEXTURE_2D_ARRAY)&&n.texParameteri(ce,n.TEXTURE_WRAP_R,se[J.wrapR]),n.texParameteri(ce,n.TEXTURE_MAG_FILTER,le[J.magFilter]),n.texParameteri(ce,n.TEXTURE_MIN_FILTER,le[J.minFilter]),J.compareFunction&&(n.texParameteri(ce,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(ce,n.TEXTURE_COMPARE_FUNC,Y[J.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(J.magFilter===Ja||J.minFilter!==Lm&&J.minFilter!==tc||J.type===wi&&e.has("OES_texture_float_linear")===!1)return;if(J.anisotropy>1||s.get(J).__currentAnisotropy){const Ie=e.get("EXT_texture_filter_anisotropic");n.texParameterf(ce,Ie.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(J.anisotropy,i.getMaxAnisotropy())),s.get(J).__currentAnisotropy=J.anisotropy}}}function he(ce,J){let Ie=!1;ce.__webglInit===void 0&&(ce.__webglInit=!0,J.addEventListener("dispose",D));const Ye=J.source;let lt=p.get(Ye);lt===void 0&&(lt={},p.set(Ye,lt));const Ve=Z(J);if(Ve!==ce.__cacheKey){lt[Ve]===void 0&&(lt[Ve]={texture:n.createTexture(),usedTimes:0},r.memory.textures++,Ie=!0),lt[Ve].usedTimes++;const Gt=lt[ce.__cacheKey];Gt!==void 0&&(lt[ce.__cacheKey].usedTimes--,Gt.usedTimes===0&&O(J)),ce.__cacheKey=Ve,ce.__webglTexture=lt[Ve].texture}return Ie}function me(ce,J,Ie){return Math.floor(Math.floor(ce/Ie)/J)}function Ne(ce,J,Ie,Ye){const Ve=ce.updateRanges;if(Ve.length===0)t.texSubImage2D(n.TEXTURE_2D,0,0,0,J.width,J.height,Ie,Ye,J.data);else{Ve.sort((at,ut)=>at.start-ut.start);let Gt=0;for(let at=1;at<Ve.length;at++){const ut=Ve[Gt],Zt=Ve[at],xe=ut.start+ut.count,Fe=me(Zt.start,J.width,4),mt=me(ut.start,J.width,4);Zt.start<=xe+1&&Fe===mt&&me(Zt.start+Zt.count-1,J.width,4)===Fe?ut.count=Math.max(ut.count,Zt.start+Zt.count-ut.start):(++Gt,Ve[Gt]=Zt)}Ve.length=Gt+1;const Lt=n.getParameter(n.UNPACK_ROW_LENGTH),tn=n.getParameter(n.UNPACK_SKIP_PIXELS),Jt=n.getParameter(n.UNPACK_SKIP_ROWS);n.pixelStorei(n.UNPACK_ROW_LENGTH,J.width);for(let at=0,ut=Ve.length;at<ut;at++){const Zt=Ve[at],xe=Math.floor(Zt.start/4),Fe=Math.ceil(Zt.count/4),mt=xe%J.width,ge=Math.floor(xe/J.width),Ue=Fe,At=1;n.pixelStorei(n.UNPACK_SKIP_PIXELS,mt),n.pixelStorei(n.UNPACK_SKIP_ROWS,ge),t.texSubImage2D(n.TEXTURE_2D,0,mt,ge,Ue,At,Ie,Ye,J.data)}ce.clearUpdateRanges(),n.pixelStorei(n.UNPACK_ROW_LENGTH,Lt),n.pixelStorei(n.UNPACK_SKIP_PIXELS,tn),n.pixelStorei(n.UNPACK_SKIP_ROWS,Jt)}}function fe(ce,J,Ie){let Ye=n.TEXTURE_2D;(J.isDataArrayTexture||J.isCompressedArrayTexture)&&(Ye=n.TEXTURE_2D_ARRAY),J.isData3DTexture&&(Ye=n.TEXTURE_3D);const lt=he(ce,J),Ve=J.source;t.bindTexture(Ye,ce.__webglTexture,n.TEXTURE0+Ie);const Gt=s.get(Ve);if(Ve.version!==Gt.__version||lt===!0){t.activeTexture(n.TEXTURE0+Ie);const Lt=ws.getPrimaries(ws.workingColorSpace),tn=J.colorSpace===id?null:ws.getPrimaries(J.colorSpace),Jt=J.colorSpace===id||Lt===tn?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,J.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,J.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,J.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Jt);let at=_(J.image,!1,i.maxTextureSize);at=Et(J,at);const ut=a.convert(J.format,J.colorSpace),Zt=a.convert(J.type);let xe=T(J.internalFormat,ut,Zt,J.colorSpace,J.isVideoTexture);re(Ye,J);let Fe;const mt=J.mipmaps,ge=J.isVideoTexture!==!0,Ue=Gt.__version===void 0||lt===!0,At=Ve.dataReady,Rt=R(J,at);if(J.isDepthTexture)xe=E(J.format===Ox,J.type),Ue&&(ge?t.texStorage2D(n.TEXTURE_2D,1,xe,at.width,at.height):t.texImage2D(n.TEXTURE_2D,0,xe,at.width,at.height,0,ut,Zt,null));else if(J.isDataTexture)if(mt.length>0){ge&&Ue&&t.texStorage2D(n.TEXTURE_2D,Rt,xe,mt[0].width,mt[0].height);for(let St=0,dt=mt.length;St<dt;St++)Fe=mt[St],ge?At&&t.texSubImage2D(n.TEXTURE_2D,St,0,0,Fe.width,Fe.height,ut,Zt,Fe.data):t.texImage2D(n.TEXTURE_2D,St,xe,Fe.width,Fe.height,0,ut,Zt,Fe.data);J.generateMipmaps=!1}else ge?(Ue&&t.texStorage2D(n.TEXTURE_2D,Rt,xe,at.width,at.height),At&&Ne(J,at,ut,Zt)):t.texImage2D(n.TEXTURE_2D,0,xe,at.width,at.height,0,ut,Zt,at.data);else if(J.isCompressedTexture)if(J.isCompressedArrayTexture){ge&&Ue&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Rt,xe,mt[0].width,mt[0].height,at.depth);for(let St=0,dt=mt.length;St<dt;St++)if(Fe=mt[St],J.format!==ra)if(ut!==null)if(ge){if(At)if(J.layerUpdates.size>0){const Ut=F3(Fe.width,Fe.height,J.format,J.type);for(const cn of J.layerUpdates){const Wn=Fe.data.subarray(cn*Ut/Fe.data.BYTES_PER_ELEMENT,(cn+1)*Ut/Fe.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,St,0,0,cn,Fe.width,Fe.height,1,ut,Wn)}J.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,St,0,0,0,Fe.width,Fe.height,at.depth,ut,Fe.data)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,St,xe,Fe.width,Fe.height,at.depth,0,Fe.data,0,0);else Wt("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else ge?At&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,St,0,0,0,Fe.width,Fe.height,at.depth,ut,Zt,Fe.data):t.texImage3D(n.TEXTURE_2D_ARRAY,St,xe,Fe.width,Fe.height,at.depth,0,ut,Zt,Fe.data)}else{ge&&Ue&&t.texStorage2D(n.TEXTURE_2D,Rt,xe,mt[0].width,mt[0].height);for(let St=0,dt=mt.length;St<dt;St++)Fe=mt[St],J.format!==ra?ut!==null?ge?At&&t.compressedTexSubImage2D(n.TEXTURE_2D,St,0,0,Fe.width,Fe.height,ut,Fe.data):t.compressedTexImage2D(n.TEXTURE_2D,St,xe,Fe.width,Fe.height,0,Fe.data):Wt("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):ge?At&&t.texSubImage2D(n.TEXTURE_2D,St,0,0,Fe.width,Fe.height,ut,Zt,Fe.data):t.texImage2D(n.TEXTURE_2D,St,xe,Fe.width,Fe.height,0,ut,Zt,Fe.data)}else if(J.isDataArrayTexture)if(ge){if(Ue&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Rt,xe,at.width,at.height,at.depth),At)if(J.layerUpdates.size>0){const St=F3(at.width,at.height,J.format,J.type);for(const dt of J.layerUpdates){const Ut=at.data.subarray(dt*St/at.data.BYTES_PER_ELEMENT,(dt+1)*St/at.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,dt,at.width,at.height,1,ut,Zt,Ut)}J.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,at.width,at.height,at.depth,ut,Zt,at.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,xe,at.width,at.height,at.depth,0,ut,Zt,at.data);else if(J.isData3DTexture)ge?(Ue&&t.texStorage3D(n.TEXTURE_3D,Rt,xe,at.width,at.height,at.depth),At&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,at.width,at.height,at.depth,ut,Zt,at.data)):t.texImage3D(n.TEXTURE_3D,0,xe,at.width,at.height,at.depth,0,ut,Zt,at.data);else if(J.isFramebufferTexture){if(Ue)if(ge)t.texStorage2D(n.TEXTURE_2D,Rt,xe,at.width,at.height);else{let St=at.width,dt=at.height;for(let Ut=0;Ut<Rt;Ut++)t.texImage2D(n.TEXTURE_2D,Ut,xe,St,dt,0,ut,Zt,null),St>>=1,dt>>=1}}else if(mt.length>0){if(ge&&Ue){const St=kt(mt[0]);t.texStorage2D(n.TEXTURE_2D,Rt,xe,St.width,St.height)}for(let St=0,dt=mt.length;St<dt;St++)Fe=mt[St],ge?At&&t.texSubImage2D(n.TEXTURE_2D,St,0,0,ut,Zt,Fe):t.texImage2D(n.TEXTURE_2D,St,xe,ut,Zt,Fe);J.generateMipmaps=!1}else if(ge){if(Ue){const St=kt(at);t.texStorage2D(n.TEXTURE_2D,Rt,xe,St.width,St.height)}At&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,ut,Zt,at)}else t.texImage2D(n.TEXTURE_2D,0,xe,ut,Zt,at);S(J)&&b(Ye),Gt.__version=Ve.version,J.onUpdate&&J.onUpdate(J)}ce.__version=J.version}function Te(ce,J,Ie){if(J.image.length!==6)return;const Ye=he(ce,J),lt=J.source;t.bindTexture(n.TEXTURE_CUBE_MAP,ce.__webglTexture,n.TEXTURE0+Ie);const Ve=s.get(lt);if(lt.version!==Ve.__version||Ye===!0){t.activeTexture(n.TEXTURE0+Ie);const Gt=ws.getPrimaries(ws.workingColorSpace),Lt=J.colorSpace===id?null:ws.getPrimaries(J.colorSpace),tn=J.colorSpace===id||Gt===Lt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,J.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,J.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,J.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,tn);const Jt=J.isCompressedTexture||J.image[0].isCompressedTexture,at=J.image[0]&&J.image[0].isDataTexture,ut=[];for(let dt=0;dt<6;dt++)!Jt&&!at?ut[dt]=_(J.image[dt],!0,i.maxCubemapSize):ut[dt]=at?J.image[dt].image:J.image[dt],ut[dt]=Et(J,ut[dt]);const Zt=ut[0],xe=a.convert(J.format,J.colorSpace),Fe=a.convert(J.type),mt=T(J.internalFormat,xe,Fe,J.colorSpace),ge=J.isVideoTexture!==!0,Ue=Ve.__version===void 0||Ye===!0,At=lt.dataReady;let Rt=R(J,Zt);re(n.TEXTURE_CUBE_MAP,J);let St;if(Jt){ge&&Ue&&t.texStorage2D(n.TEXTURE_CUBE_MAP,Rt,mt,Zt.width,Zt.height);for(let dt=0;dt<6;dt++){St=ut[dt].mipmaps;for(let Ut=0;Ut<St.length;Ut++){const cn=St[Ut];J.format!==ra?xe!==null?ge?At&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut,0,0,cn.width,cn.height,xe,cn.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut,mt,cn.width,cn.height,0,cn.data):Wt("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):ge?At&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut,0,0,cn.width,cn.height,xe,Fe,cn.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut,mt,cn.width,cn.height,0,xe,Fe,cn.data)}}}else{if(St=J.mipmaps,ge&&Ue){St.length>0&&Rt++;const dt=kt(ut[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,Rt,mt,dt.width,dt.height)}for(let dt=0;dt<6;dt++)if(at){ge?At&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,0,0,0,ut[dt].width,ut[dt].height,xe,Fe,ut[dt].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,0,mt,ut[dt].width,ut[dt].height,0,xe,Fe,ut[dt].data);for(let Ut=0;Ut<St.length;Ut++){const Wn=St[Ut].image[dt].image;ge?At&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut+1,0,0,Wn.width,Wn.height,xe,Fe,Wn.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut+1,mt,Wn.width,Wn.height,0,xe,Fe,Wn.data)}}else{ge?At&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,0,0,0,xe,Fe,ut[dt]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,0,mt,xe,Fe,ut[dt]);for(let Ut=0;Ut<St.length;Ut++){const cn=St[Ut];ge?At&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut+1,0,0,xe,Fe,cn.image[dt]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+dt,Ut+1,mt,xe,Fe,cn.image[dt])}}}S(J)&&b(n.TEXTURE_CUBE_MAP),Ve.__version=lt.version,J.onUpdate&&J.onUpdate(J)}ce.__version=J.version}function Ge(ce,J,Ie,Ye,lt,Ve){const Gt=a.convert(Ie.format,Ie.colorSpace),Lt=a.convert(Ie.type),tn=T(Ie.internalFormat,Gt,Lt,Ie.colorSpace),Jt=s.get(J),at=s.get(Ie);if(at.__renderTarget=J,!Jt.__hasExternalTextures){const ut=Math.max(1,J.width>>Ve),Zt=Math.max(1,J.height>>Ve);lt===n.TEXTURE_3D||lt===n.TEXTURE_2D_ARRAY?t.texImage3D(lt,Ve,tn,ut,Zt,J.depth,0,Gt,Lt,null):t.texImage2D(lt,Ve,tn,ut,Zt,0,Gt,Lt,null)}t.bindFramebuffer(n.FRAMEBUFFER,ce),gt(J)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,Ye,lt,at.__webglTexture,0,ft(J)):(lt===n.TEXTURE_2D||lt>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&lt<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,Ye,lt,at.__webglTexture,Ve),t.bindFramebuffer(n.FRAMEBUFFER,null)}function nt(ce,J,Ie){if(n.bindRenderbuffer(n.RENDERBUFFER,ce),J.depthBuffer){const Ye=J.depthTexture,lt=Ye&&Ye.isDepthTexture?Ye.type:null,Ve=E(J.stencilBuffer,lt),Gt=J.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Lt=ft(J);gt(J)?o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Lt,Ve,J.width,J.height):Ie?n.renderbufferStorageMultisample(n.RENDERBUFFER,Lt,Ve,J.width,J.height):n.renderbufferStorage(n.RENDERBUFFER,Ve,J.width,J.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,Gt,n.RENDERBUFFER,ce)}else{const Ye=J.textures;for(let lt=0;lt<Ye.length;lt++){const Ve=Ye[lt],Gt=a.convert(Ve.format,Ve.colorSpace),Lt=a.convert(Ve.type),tn=T(Ve.internalFormat,Gt,Lt,Ve.colorSpace),Jt=ft(J);Ie&&gt(J)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Jt,tn,J.width,J.height):gt(J)?o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Jt,tn,J.width,J.height):n.renderbufferStorage(n.RENDERBUFFER,tn,J.width,J.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function yt(ce,J){if(J&&J.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,ce),!(J.depthTexture&&J.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const Ye=s.get(J.depthTexture);Ye.__renderTarget=J,(!Ye.__webglTexture||J.depthTexture.image.width!==J.width||J.depthTexture.image.height!==J.height)&&(J.depthTexture.image.width=J.width,J.depthTexture.image.height=J.height,J.depthTexture.needsUpdate=!0),Q(J.depthTexture,0);const lt=Ye.__webglTexture,Ve=ft(J);if(J.depthTexture.format===tg)gt(J)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,lt,0,Ve):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,lt,0);else if(J.depthTexture.format===Ox)gt(J)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,lt,0,Ve):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,lt,0);else throw new Error("Unknown depthTexture format")}function Dt(ce){const J=s.get(ce),Ie=ce.isWebGLCubeRenderTarget===!0;if(J.__boundDepthTexture!==ce.depthTexture){const Ye=ce.depthTexture;if(J.__depthDisposeCallback&&J.__depthDisposeCallback(),Ye){const lt=()=>{delete J.__boundDepthTexture,delete J.__depthDisposeCallback,Ye.removeEventListener("dispose",lt)};Ye.addEventListener("dispose",lt),J.__depthDisposeCallback=lt}J.__boundDepthTexture=Ye}if(ce.depthTexture&&!J.__autoAllocateDepthBuffer){if(Ie)throw new Error("target.depthTexture not supported in Cube render targets");const Ye=ce.texture.mipmaps;Ye&&Ye.length>0?yt(J.__webglFramebuffer[0],ce):yt(J.__webglFramebuffer,ce)}else if(Ie){J.__webglDepthbuffer=[];for(let Ye=0;Ye<6;Ye++)if(t.bindFramebuffer(n.FRAMEBUFFER,J.__webglFramebuffer[Ye]),J.__webglDepthbuffer[Ye]===void 0)J.__webglDepthbuffer[Ye]=n.createRenderbuffer(),nt(J.__webglDepthbuffer[Ye],ce,!1);else{const lt=ce.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Ve=J.__webglDepthbuffer[Ye];n.bindRenderbuffer(n.RENDERBUFFER,Ve),n.framebufferRenderbuffer(n.FRAMEBUFFER,lt,n.RENDERBUFFER,Ve)}}else{const Ye=ce.texture.mipmaps;if(Ye&&Ye.length>0?t.bindFramebuffer(n.FRAMEBUFFER,J.__webglFramebuffer[0]):t.bindFramebuffer(n.FRAMEBUFFER,J.__webglFramebuffer),J.__webglDepthbuffer===void 0)J.__webglDepthbuffer=n.createRenderbuffer(),nt(J.__webglDepthbuffer,ce,!1);else{const lt=ce.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Ve=J.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,Ve),n.framebufferRenderbuffer(n.FRAMEBUFFER,lt,n.RENDERBUFFER,Ve)}}t.bindFramebuffer(n.FRAMEBUFFER,null)}function qt(ce,J,Ie){const Ye=s.get(ce);J!==void 0&&Ge(Ye.__webglFramebuffer,ce,ce.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),Ie!==void 0&&Dt(ce)}function Bt(ce){const J=ce.texture,Ie=s.get(ce),Ye=s.get(J);ce.addEventListener("dispose",F);const lt=ce.textures,Ve=ce.isWebGLCubeRenderTarget===!0,Gt=lt.length>1;if(Gt||(Ye.__webglTexture===void 0&&(Ye.__webglTexture=n.createTexture()),Ye.__version=J.version,r.memory.textures++),Ve){Ie.__webglFramebuffer=[];for(let Lt=0;Lt<6;Lt++)if(J.mipmaps&&J.mipmaps.length>0){Ie.__webglFramebuffer[Lt]=[];for(let tn=0;tn<J.mipmaps.length;tn++)Ie.__webglFramebuffer[Lt][tn]=n.createFramebuffer()}else Ie.__webglFramebuffer[Lt]=n.createFramebuffer()}else{if(J.mipmaps&&J.mipmaps.length>0){Ie.__webglFramebuffer=[];for(let Lt=0;Lt<J.mipmaps.length;Lt++)Ie.__webglFramebuffer[Lt]=n.createFramebuffer()}else Ie.__webglFramebuffer=n.createFramebuffer();if(Gt)for(let Lt=0,tn=lt.length;Lt<tn;Lt++){const Jt=s.get(lt[Lt]);Jt.__webglTexture===void 0&&(Jt.__webglTexture=n.createTexture(),r.memory.textures++)}if(ce.samples>0&&gt(ce)===!1){Ie.__webglMultisampledFramebuffer=n.createFramebuffer(),Ie.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,Ie.__webglMultisampledFramebuffer);for(let Lt=0;Lt<lt.length;Lt++){const tn=lt[Lt];Ie.__webglColorRenderbuffer[Lt]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,Ie.__webglColorRenderbuffer[Lt]);const Jt=a.convert(tn.format,tn.colorSpace),at=a.convert(tn.type),ut=T(tn.internalFormat,Jt,at,tn.colorSpace,ce.isXRRenderTarget===!0),Zt=ft(ce);n.renderbufferStorageMultisample(n.RENDERBUFFER,Zt,ut,ce.width,ce.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Lt,n.RENDERBUFFER,Ie.__webglColorRenderbuffer[Lt])}n.bindRenderbuffer(n.RENDERBUFFER,null),ce.depthBuffer&&(Ie.__webglDepthRenderbuffer=n.createRenderbuffer(),nt(Ie.__webglDepthRenderbuffer,ce,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(Ve){t.bindTexture(n.TEXTURE_CUBE_MAP,Ye.__webglTexture),re(n.TEXTURE_CUBE_MAP,J);for(let Lt=0;Lt<6;Lt++)if(J.mipmaps&&J.mipmaps.length>0)for(let tn=0;tn<J.mipmaps.length;tn++)Ge(Ie.__webglFramebuffer[Lt][tn],ce,J,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,tn);else Ge(Ie.__webglFramebuffer[Lt],ce,J,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+Lt,0);S(J)&&b(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Gt){for(let Lt=0,tn=lt.length;Lt<tn;Lt++){const Jt=lt[Lt],at=s.get(Jt);let ut=n.TEXTURE_2D;(ce.isWebGL3DRenderTarget||ce.isWebGLArrayRenderTarget)&&(ut=ce.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(ut,at.__webglTexture),re(ut,Jt),Ge(Ie.__webglFramebuffer,ce,Jt,n.COLOR_ATTACHMENT0+Lt,ut,0),S(Jt)&&b(ut)}t.unbindTexture()}else{let Lt=n.TEXTURE_2D;if((ce.isWebGL3DRenderTarget||ce.isWebGLArrayRenderTarget)&&(Lt=ce.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(Lt,Ye.__webglTexture),re(Lt,J),J.mipmaps&&J.mipmaps.length>0)for(let tn=0;tn<J.mipmaps.length;tn++)Ge(Ie.__webglFramebuffer[tn],ce,J,n.COLOR_ATTACHMENT0,Lt,tn);else Ge(Ie.__webglFramebuffer,ce,J,n.COLOR_ATTACHMENT0,Lt,0);S(J)&&b(Lt),t.unbindTexture()}ce.depthBuffer&&Dt(ce)}function Je(ce){const J=ce.textures;for(let Ie=0,Ye=J.length;Ie<Ye;Ie++){const lt=J[Ie];if(S(lt)){const Ve=w(ce),Gt=s.get(lt).__webglTexture;t.bindTexture(Ve,Gt),b(Ve),t.unbindTexture()}}}const oe=[],Ze=[];function it(ce){if(ce.samples>0){if(gt(ce)===!1){const J=ce.textures,Ie=ce.width,Ye=ce.height;let lt=n.COLOR_BUFFER_BIT;const Ve=ce.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Gt=s.get(ce),Lt=J.length>1;if(Lt)for(let Jt=0;Jt<J.length;Jt++)t.bindFramebuffer(n.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Jt,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,Gt.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Jt,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer);const tn=ce.texture.mipmaps;tn&&tn.length>0?t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Gt.__webglFramebuffer[0]):t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Gt.__webglFramebuffer);for(let Jt=0;Jt<J.length;Jt++){if(ce.resolveDepthBuffer&&(ce.depthBuffer&&(lt|=n.DEPTH_BUFFER_BIT),ce.stencilBuffer&&ce.resolveStencilBuffer&&(lt|=n.STENCIL_BUFFER_BIT)),Lt){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,Gt.__webglColorRenderbuffer[Jt]);const at=s.get(J[Jt]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,at,0)}n.blitFramebuffer(0,0,Ie,Ye,0,0,Ie,Ye,lt,n.NEAREST),l===!0&&(oe.length=0,Ze.length=0,oe.push(n.COLOR_ATTACHMENT0+Jt),ce.depthBuffer&&ce.resolveDepthBuffer===!1&&(oe.push(Ve),Ze.push(Ve),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,Ze)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,oe))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),Lt)for(let Jt=0;Jt<J.length;Jt++){t.bindFramebuffer(n.FRAMEBUFFER,Gt.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Jt,n.RENDERBUFFER,Gt.__webglColorRenderbuffer[Jt]);const at=s.get(J[Jt]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,Gt.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Jt,n.TEXTURE_2D,at,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Gt.__webglMultisampledFramebuffer)}else if(ce.depthBuffer&&ce.resolveDepthBuffer===!1&&l){const J=ce.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[J])}}}function ft(ce){return Math.min(i.maxSamples,ce.samples)}function gt(ce){const J=s.get(ce);return ce.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&J.__useRenderToTexture!==!1}function Tt(ce){const J=r.render.frame;h.get(ce)!==J&&(h.set(ce,J),ce.update())}function Et(ce,J){const Ie=ce.colorSpace,Ye=ce.format,lt=ce.type;return ce.isCompressedTexture===!0||ce.isVideoTexture===!0||Ie!==Qc&&Ie!==id&&(ws.getTransfer(Ie)===js?(Ye!==ra||lt!==Co)&&Wt("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):On("WebGLTextures: Unsupported texture color space:",Ie)),J}function kt(ce){return typeof HTMLImageElement<"u"&&ce instanceof HTMLImageElement?(c.width=ce.naturalWidth||ce.width,c.height=ce.naturalHeight||ce.height):typeof VideoFrame<"u"&&ce instanceof VideoFrame?(c.width=ce.displayWidth,c.height=ce.displayHeight):(c.width=ce.width,c.height=ce.height),c}this.allocateTextureUnit=K,this.resetTextureUnits=H,this.setTexture2D=Q,this.setTexture2DArray=P,this.setTexture3D=W,this.setTextureCube=q,this.rebindTextures=qt,this.setupRenderTarget=Bt,this.updateRenderTargetMipmap=Je,this.updateMultisampleRenderTarget=it,this.setupDepthRenderbuffer=Dt,this.setupFrameBufferTexture=Ge,this.useMultisampledRTT=gt}function uV(n,e){function t(s,i=id){let a;const r=ws.getTransfer(i);if(s===Co)return n.UNSIGNED_BYTE;if(s===n2)return n.UNSIGNED_SHORT_4_4_4_4;if(s===s2)return n.UNSIGNED_SHORT_5_5_5_1;if(s===JD)return n.UNSIGNED_INT_5_9_9_9_REV;if(s===ZD)return n.UNSIGNED_INT_10F_11F_11F_REV;if(s===e2)return n.BYTE;if(s===t2)return n.SHORT;if(s===eg)return n.UNSIGNED_SHORT;if(s===TS)return n.INT;if(s===rh)return n.UNSIGNED_INT;if(s===wi)return n.FLOAT;if(s===Wi)return n.HALF_FLOAT;if(s===QD)return n.ALPHA;if(s===eO)return n.RGB;if(s===ra)return n.RGBA;if(s===tg)return n.DEPTH_COMPONENT;if(s===Ox)return n.DEPTH_STENCIL;if(s===ES)return n.RED;if(s===MS)return n.RED_INTEGER;if(s===i2)return n.RG;if(s===a2)return n.RG_INTEGER;if(s===r2)return n.RGBA_INTEGER;if(s===O1||s===B1||s===k1||s===L1)if(r===js)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===O1)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===B1)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===k1)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===L1)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===O1)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===B1)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===k1)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===L1)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===BT||s===kT||s===LT||s===FT)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===BT)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===kT)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===LT)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===FT)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===UT||s===PT||s===zT)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===UT||s===PT)return r===js?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===zT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===$T||s===GT||s===VT||s===HT||s===WT||s===jT||s===XT||s===qT||s===KT||s===YT||s===JT||s===ZT||s===QT||s===eE)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===$T)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===GT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===VT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===HT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===WT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===jT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===XT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===qT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===KT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===YT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===JT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===ZT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===QT)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===eE)return r===js?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===tE||s===nE||s===sE)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===tE)return r===js?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===nE)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===sE)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===iE||s===aE||s===rE||s===oE)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(s===iE)return a.COMPRESSED_RED_RGTC1_EXT;if(s===aE)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===rE)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===oE)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===Dx?n.UNSIGNED_INT_24_8:n[s]!==void 0?n[s]:null}return{convert:t}}const Qne=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,ese=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class tse{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t){if(this.texture===null){const s=new pO(e.texture);(e.depthNear!==t.depthNear||e.depthFar!==t.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=s}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,s=new jr({vertexShader:Qne,fragmentShader:ese,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new Ti(new sp(20,20),s)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class nse extends ph{constructor(e,t){super();const s=this;let i=null,a=1,r=null,o="local-floor",l=1,c=null,h=null,d=null,p=null,g=null,v=null;const _=typeof XRWebGLBinding<"u",S=new tse,b={},w=t.getContextAttributes();let T=null,E=null;const R=[],D=[],F=new rt;let U=null;const O=new ki;O.viewport=new Cs;const B=new ki;B.viewport=new Cs;const L=[O,B],H=new eV;let K=null,Z=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(fe){let Te=R[fe];return Te===void 0&&(Te=new uT,R[fe]=Te),Te.getTargetRaySpace()},this.getControllerGrip=function(fe){let Te=R[fe];return Te===void 0&&(Te=new uT,R[fe]=Te),Te.getGripSpace()},this.getHand=function(fe){let Te=R[fe];return Te===void 0&&(Te=new uT,R[fe]=Te),Te.getHandSpace()};function Q(fe){const Te=D.indexOf(fe.inputSource);if(Te===-1)return;const Ge=R[Te];Ge!==void 0&&(Ge.update(fe.inputSource,fe.frame,c||r),Ge.dispatchEvent({type:fe.type,data:fe.inputSource}))}function P(){i.removeEventListener("select",Q),i.removeEventListener("selectstart",Q),i.removeEventListener("selectend",Q),i.removeEventListener("squeeze",Q),i.removeEventListener("squeezestart",Q),i.removeEventListener("squeezeend",Q),i.removeEventListener("end",P),i.removeEventListener("inputsourceschange",W);for(let fe=0;fe<R.length;fe++){const Te=D[fe];Te!==null&&(D[fe]=null,R[fe].disconnect(Te))}K=null,Z=null,S.reset();for(const fe in b)delete b[fe];e.setRenderTarget(T),g=null,p=null,d=null,i=null,E=null,Ne.stop(),s.isPresenting=!1,e.setPixelRatio(U),e.setSize(F.width,F.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(fe){a=fe,s.isPresenting===!0&&Wt("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(fe){o=fe,s.isPresenting===!0&&Wt("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||r},this.setReferenceSpace=function(fe){c=fe},this.getBaseLayer=function(){return p!==null?p:g},this.getBinding=function(){return d===null&&_&&(d=new XRWebGLBinding(i,t)),d},this.getFrame=function(){return v},this.getSession=function(){return i},this.setSession=async function(fe){if(i=fe,i!==null){if(T=e.getRenderTarget(),i.addEventListener("select",Q),i.addEventListener("selectstart",Q),i.addEventListener("selectend",Q),i.addEventListener("squeeze",Q),i.addEventListener("squeezestart",Q),i.addEventListener("squeezeend",Q),i.addEventListener("end",P),i.addEventListener("inputsourceschange",W),w.xrCompatible!==!0&&await t.makeXRCompatible(),U=e.getPixelRatio(),e.getSize(F),_&&"createProjectionLayer"in XRWebGLBinding.prototype){let Ge=null,nt=null,yt=null;w.depth&&(yt=w.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Ge=w.stencil?Ox:tg,nt=w.stencil?Dx:rh);const Dt={colorFormat:t.RGBA8,depthFormat:yt,scaleFactor:a};d=this.getBinding(),p=d.createProjectionLayer(Dt),i.updateRenderState({layers:[p]}),e.setPixelRatio(1),e.setSize(p.textureWidth,p.textureHeight,!1),E=new Wr(p.textureWidth,p.textureHeight,{format:ra,type:Co,depthTexture:new OS(p.textureWidth,p.textureHeight,nt,void 0,void 0,void 0,void 0,void 0,void 0,Ge),stencilBuffer:w.stencil,colorSpace:e.outputColorSpace,samples:w.antialias?4:0,resolveDepthBuffer:p.ignoreDepthValues===!1,resolveStencilBuffer:p.ignoreDepthValues===!1})}else{const Ge={antialias:w.antialias,alpha:!0,depth:w.depth,stencil:w.stencil,framebufferScaleFactor:a};g=new XRWebGLLayer(i,t,Ge),i.updateRenderState({baseLayer:g}),e.setPixelRatio(1),e.setSize(g.framebufferWidth,g.framebufferHeight,!1),E=new Wr(g.framebufferWidth,g.framebufferHeight,{format:ra,type:Co,colorSpace:e.outputColorSpace,stencilBuffer:w.stencil,resolveDepthBuffer:g.ignoreDepthValues===!1,resolveStencilBuffer:g.ignoreDepthValues===!1})}E.isXRRenderTarget=!0,this.setFoveation(l),c=null,r=await i.requestReferenceSpace(o),Ne.setContext(i),Ne.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return S.getDepthTexture()};function W(fe){for(let Te=0;Te<fe.removed.length;Te++){const Ge=fe.removed[Te],nt=D.indexOf(Ge);nt>=0&&(D[nt]=null,R[nt].disconnect(Ge))}for(let Te=0;Te<fe.added.length;Te++){const Ge=fe.added[Te];let nt=D.indexOf(Ge);if(nt===-1){for(let Dt=0;Dt<R.length;Dt++)if(Dt>=D.length){D.push(Ge),nt=Dt;break}else if(D[Dt]===null){D[Dt]=Ge,nt=Dt;break}if(nt===-1)break}const yt=R[nt];yt&&yt.connect(Ge)}}const q=new ue,se=new ue;function le(fe,Te,Ge){q.setFromMatrixPosition(Te.matrixWorld),se.setFromMatrixPosition(Ge.matrixWorld);const nt=q.distanceTo(se),yt=Te.projectionMatrix.elements,Dt=Ge.projectionMatrix.elements,qt=yt[14]/(yt[10]-1),Bt=yt[14]/(yt[10]+1),Je=(yt[9]+1)/yt[5],oe=(yt[9]-1)/yt[5],Ze=(yt[8]-1)/yt[0],it=(Dt[8]+1)/Dt[0],ft=qt*Ze,gt=qt*it,Tt=nt/(-Ze+it),Et=Tt*-Ze;if(Te.matrixWorld.decompose(fe.position,fe.quaternion,fe.scale),fe.translateX(Et),fe.translateZ(Tt),fe.matrixWorld.compose(fe.position,fe.quaternion,fe.scale),fe.matrixWorldInverse.copy(fe.matrixWorld).invert(),yt[10]===-1)fe.projectionMatrix.copy(Te.projectionMatrix),fe.projectionMatrixInverse.copy(Te.projectionMatrixInverse);else{const kt=qt+Tt,ce=Bt+Tt,J=ft-Et,Ie=gt+(nt-Et),Ye=Je*Bt/ce*kt,lt=oe*Bt/ce*kt;fe.projectionMatrix.makePerspective(J,Ie,Ye,lt,kt,ce),fe.projectionMatrixInverse.copy(fe.projectionMatrix).invert()}}function Y(fe,Te){Te===null?fe.matrixWorld.copy(fe.matrix):fe.matrixWorld.multiplyMatrices(Te.matrixWorld,fe.matrix),fe.matrixWorldInverse.copy(fe.matrixWorld).invert()}this.updateCamera=function(fe){if(i===null)return;let Te=fe.near,Ge=fe.far;S.texture!==null&&(S.depthNear>0&&(Te=S.depthNear),S.depthFar>0&&(Ge=S.depthFar)),H.near=B.near=O.near=Te,H.far=B.far=O.far=Ge,(K!==H.near||Z!==H.far)&&(i.updateRenderState({depthNear:H.near,depthFar:H.far}),K=H.near,Z=H.far),H.layers.mask=fe.layers.mask|6,O.layers.mask=H.layers.mask&3,B.layers.mask=H.layers.mask&5;const nt=fe.parent,yt=H.cameras;Y(H,nt);for(let Dt=0;Dt<yt.length;Dt++)Y(yt[Dt],nt);yt.length===2?le(H,O,B):H.projectionMatrix.copy(O.projectionMatrix),re(fe,H,nt)};function re(fe,Te,Ge){Ge===null?fe.matrix.copy(Te.matrixWorld):(fe.matrix.copy(Ge.matrixWorld),fe.matrix.invert(),fe.matrix.multiply(Te.matrixWorld)),fe.matrix.decompose(fe.position,fe.quaternion,fe.scale),fe.updateMatrixWorld(!0),fe.projectionMatrix.copy(Te.projectionMatrix),fe.projectionMatrixInverse.copy(Te.projectionMatrixInverse),fe.isPerspectiveCamera&&(fe.fov=Ux*2*Math.atan(1/fe.projectionMatrix.elements[5]),fe.zoom=1)}this.getCamera=function(){return H},this.getFoveation=function(){if(!(p===null&&g===null))return l},this.setFoveation=function(fe){l=fe,p!==null&&(p.fixedFoveation=fe),g!==null&&g.fixedFoveation!==void 0&&(g.fixedFoveation=fe)},this.hasDepthSensing=function(){return S.texture!==null},this.getDepthSensingMesh=function(){return S.getMesh(H)},this.getCameraTexture=function(fe){return b[fe]};let he=null;function me(fe,Te){if(h=Te.getViewerPose(c||r),v=Te,h!==null){const Ge=h.views;g!==null&&(e.setRenderTargetFramebuffer(E,g.framebuffer),e.setRenderTarget(E));let nt=!1;Ge.length!==H.cameras.length&&(H.cameras.length=0,nt=!0);for(let Bt=0;Bt<Ge.length;Bt++){const Je=Ge[Bt];let oe=null;if(g!==null)oe=g.getViewport(Je);else{const it=d.getViewSubImage(p,Je);oe=it.viewport,Bt===0&&(e.setRenderTargetTextures(E,it.colorTexture,it.depthStencilTexture),e.setRenderTarget(E))}let Ze=L[Bt];Ze===void 0&&(Ze=new ki,Ze.layers.enable(Bt),Ze.viewport=new Cs,L[Bt]=Ze),Ze.matrix.fromArray(Je.transform.matrix),Ze.matrix.decompose(Ze.position,Ze.quaternion,Ze.scale),Ze.projectionMatrix.fromArray(Je.projectionMatrix),Ze.projectionMatrixInverse.copy(Ze.projectionMatrix).invert(),Ze.viewport.set(oe.x,oe.y,oe.width,oe.height),Bt===0&&(H.matrix.copy(Ze.matrix),H.matrix.decompose(H.position,H.quaternion,H.scale)),nt===!0&&H.cameras.push(Ze)}const yt=i.enabledFeatures;if(yt&&yt.includes("depth-sensing")&&i.depthUsage=="gpu-optimized"&&_){d=s.getBinding();const Bt=d.getDepthInformation(Ge[0]);Bt&&Bt.isValid&&Bt.texture&&S.init(Bt,i.renderState)}if(yt&&yt.includes("camera-access")&&_){e.state.unbindTexture(),d=s.getBinding();for(let Bt=0;Bt<Ge.length;Bt++){const Je=Ge[Bt].camera;if(Je){let oe=b[Je];oe||(oe=new pO,b[Je]=oe);const Ze=d.getCameraImage(Je);oe.sourceTexture=Ze}}}}for(let Ge=0;Ge<R.length;Ge++){const nt=D[Ge],yt=R[Ge];nt!==null&&yt!==void 0&&yt.update(nt,Te,c||r)}he&&he(fe,Te),Te.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:Te}),v=null}const Ne=new aV;Ne.setAnimationLoop(me),this.setAnimationLoop=function(fe){he=fe},this.dispose=function(){}}}const bm=new wl,sse=new _n;function ise(n,e){function t(S,b){S.matrixAutoUpdate===!0&&S.updateMatrix(),b.value.copy(S.matrix)}function s(S,b){b.color.getRGB(S.fogColor.value,hG(n)),b.isFog?(S.fogNear.value=b.near,S.fogFar.value=b.far):b.isFogExp2&&(S.fogDensity.value=b.density)}function i(S,b,w,T,E){b.isMeshBasicMaterial||b.isMeshLambertMaterial?a(S,b):b.isMeshToonMaterial?(a(S,b),d(S,b)):b.isMeshPhongMaterial?(a(S,b),h(S,b)):b.isMeshStandardMaterial?(a(S,b),p(S,b),b.isMeshPhysicalMaterial&&g(S,b,E)):b.isMeshMatcapMaterial?(a(S,b),v(S,b)):b.isMeshDepthMaterial?a(S,b):b.isMeshDistanceMaterial?(a(S,b),_(S,b)):b.isMeshNormalMaterial?a(S,b):b.isLineBasicMaterial?(r(S,b),b.isLineDashedMaterial&&o(S,b)):b.isPointsMaterial?l(S,b,w,T):b.isSpriteMaterial?c(S,b):b.isShadowMaterial?(S.color.value.copy(b.color),S.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function a(S,b){S.opacity.value=b.opacity,b.color&&S.diffuse.value.copy(b.color),b.emissive&&S.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(S.map.value=b.map,t(b.map,S.mapTransform)),b.alphaMap&&(S.alphaMap.value=b.alphaMap,t(b.alphaMap,S.alphaMapTransform)),b.bumpMap&&(S.bumpMap.value=b.bumpMap,t(b.bumpMap,S.bumpMapTransform),S.bumpScale.value=b.bumpScale,b.side===Ao&&(S.bumpScale.value*=-1)),b.normalMap&&(S.normalMap.value=b.normalMap,t(b.normalMap,S.normalMapTransform),S.normalScale.value.copy(b.normalScale),b.side===Ao&&S.normalScale.value.negate()),b.displacementMap&&(S.displacementMap.value=b.displacementMap,t(b.displacementMap,S.displacementMapTransform),S.displacementScale.value=b.displacementScale,S.displacementBias.value=b.displacementBias),b.emissiveMap&&(S.emissiveMap.value=b.emissiveMap,t(b.emissiveMap,S.emissiveMapTransform)),b.specularMap&&(S.specularMap.value=b.specularMap,t(b.specularMap,S.specularMapTransform)),b.alphaTest>0&&(S.alphaTest.value=b.alphaTest);const w=e.get(b),T=w.envMap,E=w.envMapRotation;T&&(S.envMap.value=T,bm.copy(E),bm.x*=-1,bm.y*=-1,bm.z*=-1,T.isCubeTexture&&T.isRenderTargetTexture===!1&&(bm.y*=-1,bm.z*=-1),S.envMapRotation.value.setFromMatrix4(sse.makeRotationFromEuler(bm)),S.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,S.reflectivity.value=b.reflectivity,S.ior.value=b.ior,S.refractionRatio.value=b.refractionRatio),b.lightMap&&(S.lightMap.value=b.lightMap,S.lightMapIntensity.value=b.lightMapIntensity,t(b.lightMap,S.lightMapTransform)),b.aoMap&&(S.aoMap.value=b.aoMap,S.aoMapIntensity.value=b.aoMapIntensity,t(b.aoMap,S.aoMapTransform))}function r(S,b){S.diffuse.value.copy(b.color),S.opacity.value=b.opacity,b.map&&(S.map.value=b.map,t(b.map,S.mapTransform))}function o(S,b){S.dashSize.value=b.dashSize,S.totalSize.value=b.dashSize+b.gapSize,S.scale.value=b.scale}function l(S,b,w,T){S.diffuse.value.copy(b.color),S.opacity.value=b.opacity,S.size.value=b.size*w,S.scale.value=T*.5,b.map&&(S.map.value=b.map,t(b.map,S.uvTransform)),b.alphaMap&&(S.alphaMap.value=b.alphaMap,t(b.alphaMap,S.alphaMapTransform)),b.alphaTest>0&&(S.alphaTest.value=b.alphaTest)}function c(S,b){S.diffuse.value.copy(b.color),S.opacity.value=b.opacity,S.rotation.value=b.rotation,b.map&&(S.map.value=b.map,t(b.map,S.mapTransform)),b.alphaMap&&(S.alphaMap.value=b.alphaMap,t(b.alphaMap,S.alphaMapTransform)),b.alphaTest>0&&(S.alphaTest.value=b.alphaTest)}function h(S,b){S.specular.value.copy(b.specular),S.shininess.value=Math.max(b.shininess,1e-4)}function d(S,b){b.gradientMap&&(S.gradientMap.value=b.gradientMap)}function p(S,b){S.metalness.value=b.metalness,b.metalnessMap&&(S.metalnessMap.value=b.metalnessMap,t(b.metalnessMap,S.metalnessMapTransform)),S.roughness.value=b.roughness,b.roughnessMap&&(S.roughnessMap.value=b.roughnessMap,t(b.roughnessMap,S.roughnessMapTransform)),b.envMap&&(S.envMapIntensity.value=b.envMapIntensity)}function g(S,b,w){S.ior.value=b.ior,b.sheen>0&&(S.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),S.sheenRoughness.value=b.sheenRoughness,b.sheenColorMap&&(S.sheenColorMap.value=b.sheenColorMap,t(b.sheenColorMap,S.sheenColorMapTransform)),b.sheenRoughnessMap&&(S.sheenRoughnessMap.value=b.sheenRoughnessMap,t(b.sheenRoughnessMap,S.sheenRoughnessMapTransform))),b.clearcoat>0&&(S.clearcoat.value=b.clearcoat,S.clearcoatRoughness.value=b.clearcoatRoughness,b.clearcoatMap&&(S.clearcoatMap.value=b.clearcoatMap,t(b.clearcoatMap,S.clearcoatMapTransform)),b.clearcoatRoughnessMap&&(S.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap,t(b.clearcoatRoughnessMap,S.clearcoatRoughnessMapTransform)),b.clearcoatNormalMap&&(S.clearcoatNormalMap.value=b.clearcoatNormalMap,t(b.clearcoatNormalMap,S.clearcoatNormalMapTransform),S.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),b.side===Ao&&S.clearcoatNormalScale.value.negate())),b.dispersion>0&&(S.dispersion.value=b.dispersion),b.iridescence>0&&(S.iridescence.value=b.iridescence,S.iridescenceIOR.value=b.iridescenceIOR,S.iridescenceThicknessMinimum.value=b.iridescenceThicknessRange[0],S.iridescenceThicknessMaximum.value=b.iridescenceThicknessRange[1],b.iridescenceMap&&(S.iridescenceMap.value=b.iridescenceMap,t(b.iridescenceMap,S.iridescenceMapTransform)),b.iridescenceThicknessMap&&(S.iridescenceThicknessMap.value=b.iridescenceThicknessMap,t(b.iridescenceThicknessMap,S.iridescenceThicknessMapTransform))),b.transmission>0&&(S.transmission.value=b.transmission,S.transmissionSamplerMap.value=w.texture,S.transmissionSamplerSize.value.set(w.width,w.height),b.transmissionMap&&(S.transmissionMap.value=b.transmissionMap,t(b.transmissionMap,S.transmissionMapTransform)),S.thickness.value=b.thickness,b.thicknessMap&&(S.thicknessMap.value=b.thicknessMap,t(b.thicknessMap,S.thicknessMapTransform)),S.attenuationDistance.value=b.attenuationDistance,S.attenuationColor.value.copy(b.attenuationColor)),b.anisotropy>0&&(S.anisotropyVector.value.set(b.anisotropy*Math.cos(b.anisotropyRotation),b.anisotropy*Math.sin(b.anisotropyRotation)),b.anisotropyMap&&(S.anisotropyMap.value=b.anisotropyMap,t(b.anisotropyMap,S.anisotropyMapTransform))),S.specularIntensity.value=b.specularIntensity,S.specularColor.value.copy(b.specularColor),b.specularColorMap&&(S.specularColorMap.value=b.specularColorMap,t(b.specularColorMap,S.specularColorMapTransform)),b.specularIntensityMap&&(S.specularIntensityMap.value=b.specularIntensityMap,t(b.specularIntensityMap,S.specularIntensityMapTransform))}function v(S,b){b.matcap&&(S.matcap.value=b.matcap)}function _(S,b){const w=e.get(b).light;S.referencePosition.value.setFromMatrixPosition(w.matrixWorld),S.nearDistance.value=w.shadow.camera.near,S.farDistance.value=w.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:i}}function ase(n,e,t,s){let i={},a={},r=[];const o=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function l(w,T){const E=T.program;s.uniformBlockBinding(w,E)}function c(w,T){let E=i[w.id];E===void 0&&(v(w),E=h(w),i[w.id]=E,w.addEventListener("dispose",S));const R=T.program;s.updateUBOMapping(w,R);const D=e.render.frame;a[w.id]!==D&&(p(w),a[w.id]=D)}function h(w){const T=d();w.__bindingPointIndex=T;const E=n.createBuffer(),R=w.__size,D=w.usage;return n.bindBuffer(n.UNIFORM_BUFFER,E),n.bufferData(n.UNIFORM_BUFFER,R,D),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,T,E),E}function d(){for(let w=0;w<o;w++)if(r.indexOf(w)===-1)return r.push(w),w;return On("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function p(w){const T=i[w.id],E=w.uniforms,R=w.__cache;n.bindBuffer(n.UNIFORM_BUFFER,T);for(let D=0,F=E.length;D<F;D++){const U=Array.isArray(E[D])?E[D]:[E[D]];for(let O=0,B=U.length;O<B;O++){const L=U[O];if(g(L,D,O,R)===!0){const H=L.__offset,K=Array.isArray(L.value)?L.value:[L.value];let Z=0;for(let Q=0;Q<K.length;Q++){const P=K[Q],W=_(P);typeof P=="number"||typeof P=="boolean"?(L.__data[0]=P,n.bufferSubData(n.UNIFORM_BUFFER,H+Z,L.__data)):P.isMatrix3?(L.__data[0]=P.elements[0],L.__data[1]=P.elements[1],L.__data[2]=P.elements[2],L.__data[3]=0,L.__data[4]=P.elements[3],L.__data[5]=P.elements[4],L.__data[6]=P.elements[5],L.__data[7]=0,L.__data[8]=P.elements[6],L.__data[9]=P.elements[7],L.__data[10]=P.elements[8],L.__data[11]=0):(P.toArray(L.__data,Z),Z+=W.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,H,L.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function g(w,T,E,R){const D=w.value,F=T+"_"+E;if(R[F]===void 0)return typeof D=="number"||typeof D=="boolean"?R[F]=D:R[F]=D.clone(),!0;{const U=R[F];if(typeof D=="number"||typeof D=="boolean"){if(U!==D)return R[F]=D,!0}else if(U.equals(D)===!1)return U.copy(D),!0}return!1}function v(w){const T=w.uniforms;let E=0;const R=16;for(let F=0,U=T.length;F<U;F++){const O=Array.isArray(T[F])?T[F]:[T[F]];for(let B=0,L=O.length;B<L;B++){const H=O[B],K=Array.isArray(H.value)?H.value:[H.value];for(let Z=0,Q=K.length;Z<Q;Z++){const P=K[Z],W=_(P),q=E%R,se=q%W.boundary,le=q+se;E+=se,le!==0&&R-le<W.storage&&(E+=R-le),H.__data=new Float32Array(W.storage/Float32Array.BYTES_PER_ELEMENT),H.__offset=E,E+=W.storage}}}const D=E%R;return D>0&&(E+=R-D),w.__size=E,w.__cache={},this}function _(w){const T={boundary:0,storage:0};return typeof w=="number"||typeof w=="boolean"?(T.boundary=4,T.storage=4):w.isVector2?(T.boundary=8,T.storage=8):w.isVector3||w.isColor?(T.boundary=16,T.storage=12):w.isVector4?(T.boundary=16,T.storage=16):w.isMatrix3?(T.boundary=48,T.storage=48):w.isMatrix4?(T.boundary=64,T.storage=64):w.isTexture?Wt("WebGLRenderer: Texture samplers can not be part of an uniforms group."):Wt("WebGLRenderer: Unsupported uniform value type.",w),T}function S(w){const T=w.target;T.removeEventListener("dispose",S);const E=r.indexOf(T.__bindingPointIndex);r.splice(E,1),n.deleteBuffer(i[T.id]),delete i[T.id],delete a[T.id]}function b(){for(const w in i)n.deleteBuffer(i[w]);r=[],i={},a={}}return{bind:l,update:c,dispose:b}}const rse=new Uint16Array([11481,15204,11534,15171,11808,15015,12385,14843,12894,14716,13396,14600,13693,14483,13976,14366,14237,14171,14405,13961,14511,13770,14605,13598,14687,13444,14760,13305,14822,13066,14876,12857,14923,12675,14963,12517,14997,12379,15025,12230,15049,12023,15070,11843,15086,11687,15100,11551,15111,11433,15120,11330,15127,11217,15132,11060,15135,10922,15138,10801,15139,10695,15139,10600,13012,14923,13020,14917,13064,14886,13176,14800,13349,14666,13513,14526,13724,14398,13960,14230,14200,14020,14383,13827,14488,13651,14583,13491,14667,13348,14740,13132,14803,12908,14856,12713,14901,12542,14938,12394,14968,12241,14992,12017,15010,11822,15024,11654,15034,11507,15041,11380,15044,11269,15044,11081,15042,10913,15037,10764,15031,10635,15023,10520,15014,10419,15003,10330,13657,14676,13658,14673,13670,14660,13698,14622,13750,14547,13834,14442,13956,14317,14112,14093,14291,13889,14407,13704,14499,13538,14586,13389,14664,13201,14733,12966,14792,12758,14842,12577,14882,12418,14915,12272,14940,12033,14959,11826,14972,11646,14980,11490,14983,11355,14983,11212,14979,11008,14971,10830,14961,10675,14950,10540,14936,10420,14923,10315,14909,10204,14894,10041,14089,14460,14090,14459,14096,14452,14112,14431,14141,14388,14186,14305,14252,14130,14341,13941,14399,13756,14467,13585,14539,13430,14610,13272,14677,13026,14737,12808,14790,12617,14833,12449,14869,12303,14896,12065,14916,11845,14929,11655,14937,11490,14939,11347,14936,11184,14930,10970,14921,10783,14912,10621,14900,10480,14885,10356,14867,10247,14848,10062,14827,9894,14805,9745,14400,14208,14400,14206,14402,14198,14406,14174,14415,14122,14427,14035,14444,13913,14469,13767,14504,13613,14548,13463,14598,13324,14651,13082,14704,12858,14752,12658,14795,12483,14831,12330,14860,12106,14881,11875,14895,11675,14903,11501,14905,11351,14903,11178,14900,10953,14892,10757,14880,10589,14865,10442,14847,10313,14827,10162,14805,9965,14782,9792,14757,9642,14731,9507,14562,13883,14562,13883,14563,13877,14566,13862,14570,13830,14576,13773,14584,13689,14595,13582,14613,13461,14637,13336,14668,13120,14704,12897,14741,12695,14776,12516,14808,12358,14835,12150,14856,11910,14870,11701,14878,11519,14882,11361,14884,11187,14880,10951,14871,10748,14858,10572,14842,10418,14823,10286,14801,10099,14777,9897,14751,9722,14725,9567,14696,9430,14666,9309,14702,13604,14702,13604,14702,13600,14703,13591,14705,13570,14707,13533,14709,13477,14712,13400,14718,13305,14727,13106,14743,12907,14762,12716,14784,12539,14807,12380,14827,12190,14844,11943,14855,11727,14863,11539,14870,11376,14871,11204,14868,10960,14858,10748,14845,10565,14829,10406,14809,10269,14786,10058,14761,9852,14734,9671,14705,9512,14674,9374,14641,9253,14608,9076,14821,13366,14821,13365,14821,13364,14821,13358,14821,13344,14821,13320,14819,13252,14817,13145,14815,13011,14814,12858,14817,12698,14823,12539,14832,12389,14841,12214,14850,11968,14856,11750,14861,11558,14866,11390,14867,11226,14862,10972,14853,10754,14840,10565,14823,10401,14803,10259,14780,10032,14754,9820,14725,9635,14694,9473,14661,9333,14627,9203,14593,8988,14557,8798,14923,13014,14922,13014,14922,13012,14922,13004,14920,12987,14919,12957,14915,12907,14909,12834,14902,12738,14894,12623,14888,12498,14883,12370,14880,12203,14878,11970,14875,11759,14873,11569,14874,11401,14872,11243,14865,10986,14855,10762,14842,10568,14825,10401,14804,10255,14781,10017,14754,9799,14725,9611,14692,9445,14658,9301,14623,9139,14587,8920,14548,8729,14509,8562,15008,12672,15008,12672,15008,12671,15007,12667,15005,12656,15001,12637,14997,12605,14989,12556,14978,12490,14966,12407,14953,12313,14940,12136,14927,11934,14914,11742,14903,11563,14896,11401,14889,11247,14879,10992,14866,10767,14851,10570,14833,10400,14812,10252,14789,10007,14761,9784,14731,9592,14698,9424,14663,9279,14627,9088,14588,8868,14548,8676,14508,8508,14467,8360,15080,12386,15080,12386,15079,12385,15078,12383,15076,12378,15072,12367,15066,12347,15057,12315,15045,12253,15030,12138,15012,11998,14993,11845,14972,11685,14951,11530,14935,11383,14920,11228,14904,10981,14887,10762,14870,10567,14850,10397,14827,10248,14803,9997,14774,9771,14743,9578,14710,9407,14674,9259,14637,9048,14596,8826,14555,8632,14514,8464,14471,8317,14427,8182,15139,12008,15139,12008,15138,12008,15137,12007,15135,12003,15130,11990,15124,11969,15115,11929,15102,11872,15086,11794,15064,11693,15041,11581,15013,11459,14987,11336,14966,11170,14944,10944,14921,10738,14898,10552,14875,10387,14850,10239,14824,9983,14794,9758,14762,9563,14728,9392,14692,9244,14653,9014,14611,8791,14569,8597,14526,8427,14481,8281,14436,8110,14391,7885,15188,11617,15188,11617,15187,11617,15186,11618,15183,11617,15179,11612,15173,11601,15163,11581,15150,11546,15133,11495,15110,11427,15083,11346,15051,11246,15024,11057,14996,10868,14967,10687,14938,10517,14911,10362,14882,10206,14853,9956,14821,9737,14787,9543,14752,9375,14715,9228,14675,8980,14632,8760,14589,8565,14544,8395,14498,8248,14451,8049,14404,7824,14357,7630,15228,11298,15228,11298,15227,11299,15226,11301,15223,11303,15219,11302,15213,11299,15204,11290,15191,11271,15174,11217,15150,11129,15119,11015,15087,10886,15057,10744,15024,10599,14990,10455,14957,10318,14924,10143,14891,9911,14856,9701,14820,9516,14782,9352,14744,9200,14703,8946,14659,8725,14615,8533,14568,8366,14521,8220,14472,7992,14423,7770,14374,7578,14315,7408,15260,10819,15260,10819,15259,10822,15258,10826,15256,10832,15251,10836,15246,10841,15237,10838,15225,10821,15207,10788,15183,10734,15151,10660,15120,10571,15087,10469,15049,10359,15012,10249,14974,10041,14937,9837,14900,9647,14860,9475,14820,9320,14779,9147,14736,8902,14691,8688,14646,8499,14598,8335,14549,8189,14499,7940,14448,7720,14397,7529,14347,7363,14256,7218,15285,10410,15285,10411,15285,10413,15284,10418,15282,10425,15278,10434,15272,10442,15264,10449,15252,10445,15235,10433,15210,10403,15179,10358,15149,10301,15113,10218,15073,10059,15033,9894,14991,9726,14951,9565,14909,9413,14865,9273,14822,9073,14777,8845,14730,8641,14682,8459,14633,8300,14583,8129,14531,7883,14479,7670,14426,7482,14373,7321,14305,7176,14201,6939,15305,9939,15305,9940,15305,9945,15304,9955,15302,9967,15298,9989,15293,10010,15286,10033,15274,10044,15258,10045,15233,10022,15205,9975,15174,9903,15136,9808,15095,9697,15053,9578,15009,9451,14965,9327,14918,9198,14871,8973,14825,8766,14775,8579,14725,8408,14675,8259,14622,8058,14569,7821,14515,7615,14460,7435,14405,7276,14350,7108,14256,6866,14149,6653,15321,9444,15321,9445,15321,9448,15320,9458,15317,9470,15314,9490,15310,9515,15302,9540,15292,9562,15276,9579,15251,9577,15226,9559,15195,9519,15156,9463,15116,9389,15071,9304,15025,9208,14978,9023,14927,8838,14878,8661,14827,8496,14774,8344,14722,8206,14667,7973,14612,7749,14556,7555,14499,7382,14443,7229,14385,7025,14322,6791,14210,6588,14100,6409,15333,8920,15333,8921,15332,8927,15332,8943,15329,8965,15326,9002,15322,9048,15316,9106,15307,9162,15291,9204,15267,9221,15244,9221,15212,9196,15175,9134,15133,9043,15088,8930,15040,8801,14990,8665,14938,8526,14886,8391,14830,8261,14775,8087,14719,7866,14661,7664,14603,7482,14544,7322,14485,7178,14426,6936,14367,6713,14281,6517,14166,6348,14054,6198,15341,8360,15341,8361,15341,8366,15341,8379,15339,8399,15336,8431,15332,8473,15326,8527,15318,8585,15302,8632,15281,8670,15258,8690,15227,8690,15191,8664,15149,8612,15104,8543,15055,8456,15001,8360,14948,8259,14892,8122,14834,7923,14776,7734,14716,7558,14656,7397,14595,7250,14534,7070,14472,6835,14410,6628,14350,6443,14243,6283,14125,6135,14010,5889,15348,7715,15348,7717,15348,7725,15347,7745,15345,7780,15343,7836,15339,7905,15334,8e3,15326,8103,15310,8193,15293,8239,15270,8270,15240,8287,15204,8283,15163,8260,15118,8223,15067,8143,15014,8014,14958,7873,14899,7723,14839,7573,14778,7430,14715,7293,14652,7164,14588,6931,14524,6720,14460,6531,14396,6362,14330,6210,14207,6015,14086,5781,13969,5576,15352,7114,15352,7116,15352,7128,15352,7159,15350,7195,15348,7237,15345,7299,15340,7374,15332,7457,15317,7544,15301,7633,15280,7703,15251,7754,15216,7775,15176,7767,15131,7733,15079,7670,15026,7588,14967,7492,14906,7387,14844,7278,14779,7171,14714,6965,14648,6770,14581,6587,14515,6420,14448,6269,14382,6123,14299,5881,14172,5665,14049,5477,13929,5310,15355,6329,15355,6330,15355,6339,15355,6362,15353,6410,15351,6472,15349,6572,15344,6688,15337,6835,15323,6985,15309,7142,15287,7220,15260,7277,15226,7310,15188,7326,15142,7318,15090,7285,15036,7239,14976,7177,14914,7045,14849,6892,14782,6736,14714,6581,14645,6433,14576,6293,14506,6164,14438,5946,14369,5733,14270,5540,14140,5369,14014,5216,13892,5043,15357,5483,15357,5484,15357,5496,15357,5528,15356,5597,15354,5692,15351,5835,15347,6011,15339,6195,15328,6317,15314,6446,15293,6566,15268,6668,15235,6746,15197,6796,15152,6811,15101,6790,15046,6748,14985,6673,14921,6583,14854,6479,14785,6371,14714,6259,14643,6149,14571,5946,14499,5750,14428,5567,14358,5401,14242,5250,14109,5111,13980,4870,13856,4657,15359,4555,15359,4557,15358,4573,15358,4633,15357,4715,15355,4841,15353,5061,15349,5216,15342,5391,15331,5577,15318,5770,15299,5967,15274,6150,15243,6223,15206,6280,15161,6310,15111,6317,15055,6300,14994,6262,14928,6208,14860,6141,14788,5994,14715,5838,14641,5684,14566,5529,14492,5384,14418,5247,14346,5121,14216,4892,14079,4682,13948,4496,13822,4330,15359,3498,15359,3501,15359,3520,15359,3598,15358,3719,15356,3860,15355,4137,15351,4305,15344,4563,15334,4809,15321,5116,15303,5273,15280,5418,15250,5547,15214,5653,15170,5722,15120,5761,15064,5763,15002,5733,14935,5673,14865,5597,14792,5504,14716,5400,14640,5294,14563,5185,14486,5041,14410,4841,14335,4655,14191,4482,14051,4325,13918,4183,13790,4012,15360,2282,15360,2285,15360,2306,15360,2401,15359,2547,15357,2748,15355,3103,15352,3349,15345,3675,15336,4020,15324,4272,15307,4496,15285,4716,15255,4908,15220,5086,15178,5170,15128,5214,15072,5234,15010,5231,14943,5206,14871,5166,14796,5102,14718,4971,14639,4833,14559,4687,14480,4541,14402,4401,14315,4268,14167,4142,14025,3958,13888,3747,13759,3556,15360,923,15360,925,15360,946,15360,1052,15359,1214,15357,1494,15356,1892,15352,2274,15346,2663,15338,3099,15326,3393,15309,3679,15288,3980,15260,4183,15226,4325,15185,4437,15136,4517,15080,4570,15018,4591,14950,4581,14877,4545,14800,4485,14720,4411,14638,4325,14556,4231,14475,4136,14395,3988,14297,3803,14145,3628,13999,3465,13861,3314,13729,3177,15360,263,15360,264,15360,272,15360,325,15359,407,15358,548,15356,780,15352,1144,15347,1580,15339,2099,15328,2425,15312,2795,15292,3133,15264,3329,15232,3517,15191,3689,15143,3819,15088,3923,15025,3978,14956,3999,14882,3979,14804,3931,14722,3855,14639,3756,14554,3645,14470,3529,14388,3409,14279,3289,14124,3173,13975,3055,13834,2848,13701,2658,15360,49,15360,49,15360,52,15360,75,15359,111,15358,201,15356,283,15353,519,15348,726,15340,1045,15329,1415,15314,1795,15295,2173,15269,2410,15237,2649,15197,2866,15150,3054,15095,3140,15032,3196,14963,3228,14888,3236,14808,3224,14725,3191,14639,3146,14553,3088,14466,2976,14382,2836,14262,2692,14103,2549,13952,2409,13808,2278,13674,2154,15360,4,15360,4,15360,4,15360,13,15359,33,15358,59,15357,112,15353,199,15348,302,15341,456,15331,628,15316,827,15297,1082,15272,1332,15241,1601,15202,1851,15156,2069,15101,2172,15039,2256,14970,2314,14894,2348,14813,2358,14728,2344,14640,2311,14551,2263,14463,2203,14376,2133,14247,2059,14084,1915,13930,1761,13784,1609,13648,1464,15360,0,15360,0,15360,0,15360,3,15359,18,15358,26,15357,53,15354,80,15348,97,15341,165,15332,238,15318,326,15299,427,15275,529,15245,654,15207,771,15161,885,15108,994,15046,1089,14976,1170,14900,1229,14817,1266,14731,1284,14641,1282,14550,1260,14460,1223,14370,1174,14232,1116,14066,1050,13909,981,13761,910,13623,839]);let Qh=null;function ose(){return Qh===null&&(Qh=new ac(rse,32,32,i2,Wi),Qh.minFilter=is,Qh.magFilter=is,Qh.wrapS=Fi,Qh.wrapT=Fi,Qh.generateMipmaps=!1,Qh.needsUpdate=!0),Qh}class FO{constructor(e={}){const{canvas:t=oG(),context:s=null,depth:i=!0,stencil:a=!1,alpha:r=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:d=!1,reversedDepthBuffer:p=!1}=e;this.isWebGLRenderer=!0;let g;if(s!==null){if(typeof WebGLRenderingContext<"u"&&s instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");g=s.getContextAttributes().alpha}else g=r;const v=new Set([r2,a2,MS]),_=new Set([Co,rh,eg,Dx,n2,s2]),S=new Uint32Array(4),b=new Int32Array(4);let w=null,T=null;const E=[],R=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=Ju,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const D=this;let F=!1;this._outputColorSpace=mr;let U=0,O=0,B=null,L=-1,H=null;const K=new Cs,Z=new Cs;let Q=null;const P=new $t(0);let W=0,q=t.width,se=t.height,le=1,Y=null,re=null;const he=new Cs(0,0,q,se),me=new Cs(0,0,q,se);let Ne=!1;const fe=new fy;let Te=!1,Ge=!1;const nt=new _n,yt=new ue,Dt=new Cs,qt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Bt=!1;function Je(){return B===null?le:1}let oe=s;function Ze(X,de){return t.getContext(X,de)}try{const X={alpha:!0,depth:i,stencil:a,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:d};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${uy}`),t.addEventListener("webglcontextlost",St,!1),t.addEventListener("webglcontextrestored",dt,!1),t.addEventListener("webglcontextcreationerror",Ut,!1),oe===null){const de="webgl2";if(oe=Ze(de,X),oe===null)throw Ze(de)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(X){throw X("WebGLRenderer: "+X.message),X}let it,ft,gt,Tt,Et,kt,ce,J,Ie,Ye,lt,Ve,Gt,Lt,tn,Jt,at,ut,Zt,xe,Fe,mt,ge,Ue;function At(){it=new xte(oe),it.init(),mt=new uV(oe,it),ft=new lte(oe,it,e,mt),gt=new Jne(oe,it),ft.reversedDepthBuffer&&p&&gt.buffers.depth.setReversed(!0),Tt=new bte(oe),Et=new Une,kt=new Zne(oe,it,gt,Et,ft,mt,Tt),ce=new ute(D),J=new gte(D),Ie=new wZ(oe),ge=new rte(oe,Ie),Ye=new yte(oe,Ie,Tt,ge),lt=new _te(oe,Ye,Ie,Tt),Zt=new Ste(oe,ft,kt),Jt=new cte(Et),Ve=new Fne(D,ce,J,it,ft,ge,Jt),Gt=new ise(D,Et),Lt=new zne,tn=new jne(it),ut=new ate(D,ce,J,gt,lt,g,l),at=new Kne(D,lt,ft),Ue=new ase(oe,Tt,ft,gt),xe=new ote(oe,it,Tt),Fe=new vte(oe,it,Tt),Tt.programs=Ve.programs,D.capabilities=ft,D.extensions=it,D.properties=Et,D.renderLists=Lt,D.shadowMap=at,D.state=gt,D.info=Tt}At();const Rt=new nse(D,oe);this.xr=Rt,this.getContext=function(){return oe},this.getContextAttributes=function(){return oe.getContextAttributes()},this.forceContextLoss=function(){const X=it.get("WEBGL_lose_context");X&&X.loseContext()},this.forceContextRestore=function(){const X=it.get("WEBGL_lose_context");X&&X.restoreContext()},this.getPixelRatio=function(){return le},this.setPixelRatio=function(X){X!==void 0&&(le=X,this.setSize(q,se,!1))},this.getSize=function(X){return X.set(q,se)},this.setSize=function(X,de,Se=!0){if(Rt.isPresenting){Wt("WebGLRenderer: Can't change size while VR device is presenting.");return}q=X,se=de,t.width=Math.floor(X*le),t.height=Math.floor(de*le),Se===!0&&(t.style.width=X+"px",t.style.height=de+"px"),this.setViewport(0,0,X,de)},this.getDrawingBufferSize=function(X){return X.set(q*le,se*le).floor()},this.setDrawingBufferSize=function(X,de,Se){q=X,se=de,le=Se,t.width=Math.floor(X*Se),t.height=Math.floor(de*Se),this.setViewport(0,0,X,de)},this.getCurrentViewport=function(X){return X.copy(K)},this.getViewport=function(X){return X.copy(he)},this.setViewport=function(X,de,Se,De){X.isVector4?he.set(X.x,X.y,X.z,X.w):he.set(X,de,Se,De),gt.viewport(K.copy(he).multiplyScalar(le).round())},this.getScissor=function(X){return X.copy(me)},this.setScissor=function(X,de,Se,De){X.isVector4?me.set(X.x,X.y,X.z,X.w):me.set(X,de,Se,De),gt.scissor(Z.copy(me).multiplyScalar(le).round())},this.getScissorTest=function(){return Ne},this.setScissorTest=function(X){gt.setScissorTest(Ne=X)},this.setOpaqueSort=function(X){Y=X},this.setTransparentSort=function(X){re=X},this.getClearColor=function(X){return X.copy(ut.getClearColor())},this.setClearColor=function(){ut.setClearColor(...arguments)},this.getClearAlpha=function(){return ut.getClearAlpha()},this.setClearAlpha=function(){ut.setClearAlpha(...arguments)},this.clear=function(X=!0,de=!0,Se=!0){let De=0;if(X){let ye=!1;if(B!==null){const Ke=B.texture.format;ye=v.has(Ke)}if(ye){const Ke=B.texture.type,ct=_.has(Ke),vt=ut.getClearColor(),It=ut.getClearAlpha(),Pt=vt.r,Kt=vt.g,jt=vt.b;ct?(S[0]=Pt,S[1]=Kt,S[2]=jt,S[3]=It,oe.clearBufferuiv(oe.COLOR,0,S)):(b[0]=Pt,b[1]=Kt,b[2]=jt,b[3]=It,oe.clearBufferiv(oe.COLOR,0,b))}else De|=oe.COLOR_BUFFER_BIT}de&&(De|=oe.DEPTH_BUFFER_BIT),Se&&(De|=oe.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),oe.clear(De)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",St,!1),t.removeEventListener("webglcontextrestored",dt,!1),t.removeEventListener("webglcontextcreationerror",Ut,!1),ut.dispose(),Lt.dispose(),tn.dispose(),Et.dispose(),ce.dispose(),J.dispose(),lt.dispose(),ge.dispose(),Ue.dispose(),Ve.dispose(),Rt.dispose(),Rt.removeEventListener("sessionstart",fc),Rt.removeEventListener("sessionend",Oo),zi.stop()};function St(X){X.preventDefault(),K1("WebGLRenderer: Context Lost."),F=!0}function dt(){K1("WebGLRenderer: Context Restored."),F=!1;const X=Tt.autoReset,de=at.enabled,Se=at.autoUpdate,De=at.needsUpdate,ye=at.type;At(),Tt.autoReset=X,at.enabled=de,at.autoUpdate=Se,at.needsUpdate=De,at.type=ye}function Ut(X){On("WebGLRenderer: A WebGL context could not be created. Reason: ",X.statusMessage)}function cn(X){const de=X.target;de.removeEventListener("dispose",cn),Wn(de)}function Wn(X){Fn(X),Et.remove(X)}function Fn(X){const de=Et.get(X).programs;de!==void 0&&(de.forEach(function(Se){Ve.releaseProgram(Se)}),X.isShaderMaterial&&Ve.releaseShaderCache(X))}this.renderBufferDirect=function(X,de,Se,De,ye,Ke){de===null&&(de=qt);const ct=ye.isMesh&&ye.matrixWorld.determinant()<0,vt=We(X,de,Se,De,ye);gt.setMaterial(De,ct);let It=Se.index,Pt=1;if(De.wireframe===!0){if(It=Ye.getWireframeAttribute(Se),It===void 0)return;Pt=2}const Kt=Se.drawRange,jt=Se.attributes.position;let Qt=Kt.start*Pt,In=(Kt.start+Kt.count)*Pt;Ke!==null&&(Qt=Math.max(Qt,Ke.start*Pt),In=Math.min(In,(Ke.start+Ke.count)*Pt)),It!==null?(Qt=Math.max(Qt,0),In=Math.min(In,It.count)):jt!=null&&(Qt=Math.max(Qt,0),In=Math.min(In,jt.count));const hn=In-Qt;if(hn<0||hn===1/0)return;ge.setup(ye,De,vt,Se,It);let bn,jn=xe;if(It!==null&&(bn=Ie.get(It),jn=Fe,jn.setIndex(bn)),ye.isMesh)De.wireframe===!0?(gt.setLineWidth(De.wireframeLinewidth*Je()),jn.setMode(oe.LINES)):jn.setMode(oe.TRIANGLES);else if(ye.isLine){let dn=De.linewidth;dn===void 0&&(dn=1),gt.setLineWidth(dn*Je()),ye.isLineSegments?jn.setMode(oe.LINES):ye.isLineLoop?jn.setMode(oe.LINE_LOOP):jn.setMode(oe.LINE_STRIP)}else ye.isPoints?jn.setMode(oe.POINTS):ye.isSprite&&jn.setMode(oe.TRIANGLES);if(ye.isBatchedMesh)if(ye._multiDrawInstances!==null)Fx("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),jn.renderMultiDrawInstances(ye._multiDrawStarts,ye._multiDrawCounts,ye._multiDrawCount,ye._multiDrawInstances);else if(it.get("WEBGL_multi_draw"))jn.renderMultiDraw(ye._multiDrawStarts,ye._multiDrawCounts,ye._multiDrawCount);else{const dn=ye._multiDrawStarts,zn=ye._multiDrawCounts,nn=ye._multiDrawCount,ss=It?Ie.get(It).bytesPerElement:1,ms=Et.get(De).currentProgram.getUniforms();for(let mn=0;mn<nn;mn++)ms.setValue(oe,"_gl_DrawID",mn),jn.render(dn[mn]/ss,zn[mn])}else if(ye.isInstancedMesh)jn.renderInstances(Qt,hn,ye.count);else if(Se.isInstancedBufferGeometry){const dn=Se._maxInstanceCount!==void 0?Se._maxInstanceCount:1/0,zn=Math.min(Se.instanceCount,dn);jn.renderInstances(Qt,hn,zn)}else jn.render(Qt,hn)};function ei(X,de,Se){X.transparent===!0&&X.side===Ql&&X.forceSinglePass===!1?(X.side=Ao,X.needsUpdate=!0,j(X,de,Se),X.side=ih,X.needsUpdate=!0,j(X,de,Se),X.side=Ql):j(X,de,Se)}this.compile=function(X,de,Se=null){Se===null&&(Se=X),T=tn.get(Se),T.init(de),R.push(T),Se.traverseVisible(function(ye){ye.isLight&&ye.layers.test(de.layers)&&(T.pushLight(ye),ye.castShadow&&T.pushShadow(ye))}),X!==Se&&X.traverseVisible(function(ye){ye.isLight&&ye.layers.test(de.layers)&&(T.pushLight(ye),ye.castShadow&&T.pushShadow(ye))}),T.setupLights();const De=new Set;return X.traverse(function(ye){if(!(ye.isMesh||ye.isPoints||ye.isLine||ye.isSprite))return;const Ke=ye.material;if(Ke)if(Array.isArray(Ke))for(let ct=0;ct<Ke.length;ct++){const vt=Ke[ct];ei(vt,Se,ye),De.add(vt)}else ei(Ke,Se,ye),De.add(Ke)}),T=R.pop(),De},this.compileAsync=function(X,de,Se=null){const De=this.compile(X,de,Se);return new Promise(ye=>{function Ke(){if(De.forEach(function(ct){Et.get(ct).currentProgram.isReady()&&De.delete(ct)}),De.size===0){ye(X);return}setTimeout(Ke,10)}it.get("KHR_parallel_shader_compile")!==null?Ke():setTimeout(Ke,10)})};let Ni=null;function xh(X){Ni&&Ni(X)}function fc(){zi.stop()}function Oo(){zi.start()}const zi=new aV;zi.setAnimationLoop(xh),typeof self<"u"&&zi.setContext(self),this.setAnimationLoop=function(X){Ni=X,Rt.setAnimationLoop(X),X===null?zi.stop():zi.start()},Rt.addEventListener("sessionstart",fc),Rt.addEventListener("sessionend",Oo),this.render=function(X,de){if(de!==void 0&&de.isCamera!==!0){On("WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(F===!0)return;if(X.matrixWorldAutoUpdate===!0&&X.updateMatrixWorld(),de.parent===null&&de.matrixWorldAutoUpdate===!0&&de.updateMatrixWorld(),Rt.enabled===!0&&Rt.isPresenting===!0&&(Rt.cameraAutoUpdate===!0&&Rt.updateCamera(de),de=Rt.getCamera()),X.isScene===!0&&X.onBeforeRender(D,X,de,B),T=tn.get(X,R.length),T.init(de),R.push(T),nt.multiplyMatrices(de.projectionMatrix,de.matrixWorldInverse),fe.setFromProjectionMatrix(nt,yl,de.reversedDepth),Ge=this.localClippingEnabled,Te=Jt.init(this.clippingPlanes,Ge),w=Lt.get(X,E.length),w.init(),E.push(w),Rt.enabled===!0&&Rt.isPresenting===!0){const Ke=D.xr.getDepthSensingMesh();Ke!==null&&Ar(Ke,de,-1/0,D.sortObjects)}Ar(X,de,0,D.sortObjects),w.finish(),D.sortObjects===!0&&w.sort(Y,re),Bt=Rt.enabled===!1||Rt.isPresenting===!1||Rt.hasDepthSensing()===!1,Bt&&ut.addToRenderList(w,X),this.info.render.frame++,Te===!0&&Jt.beginShadows();const Se=T.state.shadowsArray;at.render(Se,X,de),Te===!0&&Jt.endShadows(),this.info.autoReset===!0&&this.info.reset();const De=w.opaque,ye=w.transmissive;if(T.setupLights(),de.isArrayCamera){const Ke=de.cameras;if(ye.length>0)for(let ct=0,vt=Ke.length;ct<vt;ct++){const It=Ke[ct];Cn(De,ye,X,It)}Bt&&ut.render(X);for(let ct=0,vt=Ke.length;ct<vt;ct++){const It=Ke[ct];ca(w,X,It,It.viewport)}}else ye.length>0&&Cn(De,ye,X,de),Bt&&ut.render(X),ca(w,X,de);B!==null&&O===0&&(kt.updateMultisampleRenderTarget(B),kt.updateRenderTargetMipmap(B)),X.isScene===!0&&X.onAfterRender(D,X,de),ge.resetDefaultState(),L=-1,H=null,R.pop(),R.length>0?(T=R[R.length-1],Te===!0&&Jt.setGlobalState(D.clippingPlanes,T.state.camera)):T=null,E.pop(),E.length>0?w=E[E.length-1]:w=null};function Ar(X,de,Se,De){if(X.visible===!1)return;if(X.layers.test(de.layers)){if(X.isGroup)Se=X.renderOrder;else if(X.isLOD)X.autoUpdate===!0&&X.update(de);else if(X.isLight)T.pushLight(X),X.castShadow&&T.pushShadow(X);else if(X.isSprite){if(!X.frustumCulled||fe.intersectsSprite(X)){De&&Dt.setFromMatrixPosition(X.matrixWorld).applyMatrix4(nt);const ct=lt.update(X),vt=X.material;vt.visible&&w.push(X,ct,vt,Se,Dt.z,null)}}else if((X.isMesh||X.isLine||X.isPoints)&&(!X.frustumCulled||fe.intersectsObject(X))){const ct=lt.update(X),vt=X.material;if(De&&(X.boundingSphere!==void 0?(X.boundingSphere===null&&X.computeBoundingSphere(),Dt.copy(X.boundingSphere.center)):(ct.boundingSphere===null&&ct.computeBoundingSphere(),Dt.copy(ct.boundingSphere.center)),Dt.applyMatrix4(X.matrixWorld).applyMatrix4(nt)),Array.isArray(vt)){const It=ct.groups;for(let Pt=0,Kt=It.length;Pt<Kt;Pt++){const jt=It[Pt],Qt=vt[jt.materialIndex];Qt&&Qt.visible&&w.push(X,ct,Qt,Se,Dt.z,jt)}}else vt.visible&&w.push(X,ct,vt,Se,Dt.z,null)}}const Ke=X.children;for(let ct=0,vt=Ke.length;ct<vt;ct++)Ar(Ke[ct],de,Se,De)}function ca(X,de,Se,De){const{opaque:ye,transmissive:Ke,transparent:ct}=X;T.setupLightsView(Se),Te===!0&&Jt.setGlobalState(D.clippingPlanes,Se),De&&gt.viewport(K.copy(De)),ye.length>0&&Ji(ye,de,Se),Ke.length>0&&Ji(Ke,de,Se),ct.length>0&&Ji(ct,de,Se),gt.buffers.depth.setTest(!0),gt.buffers.depth.setMask(!0),gt.buffers.color.setMask(!0),gt.setPolygonOffset(!1)}function Cn(X,de,Se,De){if((Se.isScene===!0?Se.overrideMaterial:null)!==null)return;T.state.transmissionRenderTarget[De.id]===void 0&&(T.state.transmissionRenderTarget[De.id]=new Wr(1,1,{generateMipmaps:!0,type:it.has("EXT_color_buffer_half_float")||it.has("EXT_color_buffer_float")?Wi:Co,minFilter:tc,samples:4,stencilBuffer:a,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ws.workingColorSpace}));const Ke=T.state.transmissionRenderTarget[De.id],ct=De.viewport||K;Ke.setSize(ct.z*D.transmissionResolutionScale,ct.w*D.transmissionResolutionScale);const vt=D.getRenderTarget(),It=D.getActiveCubeFace(),Pt=D.getActiveMipmapLevel();D.setRenderTarget(Ke),D.getClearColor(P),W=D.getClearAlpha(),W<1&&D.setClearColor(16777215,.5),D.clear(),Bt&&ut.render(Se);const Kt=D.toneMapping;D.toneMapping=Ju;const jt=De.viewport;if(De.viewport!==void 0&&(De.viewport=void 0),T.setupLightsView(De),Te===!0&&Jt.setGlobalState(D.clippingPlanes,De),Ji(X,Se,De),kt.updateMultisampleRenderTarget(Ke),kt.updateRenderTargetMipmap(Ke),it.has("WEBGL_multisampled_render_to_texture")===!1){let Qt=!1;for(let In=0,hn=de.length;In<hn;In++){const bn=de[In],{object:jn,geometry:dn,material:zn,group:nn}=bn;if(zn.side===Ql&&jn.layers.test(De.layers)){const ss=zn.side;zn.side=Ao,zn.needsUpdate=!0,Un(jn,Se,De,dn,zn,nn),zn.side=ss,zn.needsUpdate=!0,Qt=!0}}Qt===!0&&(kt.updateMultisampleRenderTarget(Ke),kt.updateRenderTargetMipmap(Ke))}D.setRenderTarget(vt,It,Pt),D.setClearColor(P,W),jt!==void 0&&(De.viewport=jt),D.toneMapping=Kt}function Ji(X,de,Se){const De=de.isScene===!0?de.overrideMaterial:null;for(let ye=0,Ke=X.length;ye<Ke;ye++){const ct=X[ye],{object:vt,geometry:It,group:Pt}=ct;let Kt=ct.material;Kt.allowOverride===!0&&De!==null&&(Kt=De),vt.layers.test(Se.layers)&&Un(vt,de,Se,It,Kt,Pt)}}function Un(X,de,Se,De,ye,Ke){X.onBeforeRender(D,de,Se,De,ye,Ke),X.modelViewMatrix.multiplyMatrices(Se.matrixWorldInverse,X.matrixWorld),X.normalMatrix.getNormalMatrix(X.modelViewMatrix),ye.onBeforeRender(D,de,Se,De,X,Ke),ye.transparent===!0&&ye.side===Ql&&ye.forceSinglePass===!1?(ye.side=Ao,ye.needsUpdate=!0,D.renderBufferDirect(Se,de,De,ye,X,Ke),ye.side=ih,ye.needsUpdate=!0,D.renderBufferDirect(Se,de,De,ye,X,Ke),ye.side=Ql):D.renderBufferDirect(Se,de,De,ye,X,Ke),X.onAfterRender(D,de,Se,De,ye,Ke)}function j(X,de,Se){de.isScene!==!0&&(de=qt);const De=Et.get(X),ye=T.state.lights,Ke=T.state.shadowsArray,ct=ye.state.version,vt=Ve.getParameters(X,ye.state,Ke,de,Se),It=Ve.getProgramCacheKey(vt);let Pt=De.programs;De.environment=X.isMeshStandardMaterial?de.environment:null,De.fog=de.fog,De.envMap=(X.isMeshStandardMaterial?J:ce).get(X.envMap||De.environment),De.envMapRotation=De.environment!==null&&X.envMap===null?de.environmentRotation:X.envMapRotation,Pt===void 0&&(X.addEventListener("dispose",cn),Pt=new Map,De.programs=Pt);let Kt=Pt.get(It);if(Kt!==void 0){if(De.currentProgram===Kt&&De.lightsStateVersion===ct)return Ce(X,vt),Kt}else vt.uniforms=Ve.getUniforms(X),X.onBeforeCompile(vt,D),Kt=Ve.acquireProgram(vt,It),Pt.set(It,Kt),De.uniforms=vt.uniforms;const jt=De.uniforms;return(!X.isShaderMaterial&&!X.isRawShaderMaterial||X.clipping===!0)&&(jt.clippingPlanes=Jt.uniform),Ce(X,vt),De.needsLights=tt(X),De.lightsStateVersion=ct,De.needsLights&&(jt.ambientLightColor.value=ye.state.ambient,jt.lightProbe.value=ye.state.probe,jt.directionalLights.value=ye.state.directional,jt.directionalLightShadows.value=ye.state.directionalShadow,jt.spotLights.value=ye.state.spot,jt.spotLightShadows.value=ye.state.spotShadow,jt.rectAreaLights.value=ye.state.rectArea,jt.ltc_1.value=ye.state.rectAreaLTC1,jt.ltc_2.value=ye.state.rectAreaLTC2,jt.pointLights.value=ye.state.point,jt.pointLightShadows.value=ye.state.pointShadow,jt.hemisphereLights.value=ye.state.hemi,jt.directionalShadowMap.value=ye.state.directionalShadowMap,jt.directionalShadowMatrix.value=ye.state.directionalShadowMatrix,jt.spotShadowMap.value=ye.state.spotShadowMap,jt.spotLightMatrix.value=ye.state.spotLightMatrix,jt.spotLightMap.value=ye.state.spotLightMap,jt.pointShadowMap.value=ye.state.pointShadowMap,jt.pointShadowMatrix.value=ye.state.pointShadowMatrix),De.currentProgram=Kt,De.uniformsList=null,Kt}function ae(X){if(X.uniformsList===null){const de=X.currentProgram.getUniforms();X.uniformsList=hT.seqWithValue(de.seq,X.uniforms)}return X.uniformsList}function Ce(X,de){const Se=Et.get(X);Se.outputColorSpace=de.outputColorSpace,Se.batching=de.batching,Se.batchingColor=de.batchingColor,Se.instancing=de.instancing,Se.instancingColor=de.instancingColor,Se.instancingMorph=de.instancingMorph,Se.skinning=de.skinning,Se.morphTargets=de.morphTargets,Se.morphNormals=de.morphNormals,Se.morphColors=de.morphColors,Se.morphTargetsCount=de.morphTargetsCount,Se.numClippingPlanes=de.numClippingPlanes,Se.numIntersection=de.numClipIntersection,Se.vertexAlphas=de.vertexAlphas,Se.vertexTangents=de.vertexTangents,Se.toneMapping=de.toneMapping}function We(X,de,Se,De,ye){de.isScene!==!0&&(de=qt),kt.resetTextureUnits();const Ke=de.fog,ct=De.isMeshStandardMaterial?de.environment:null,vt=B===null?D.outputColorSpace:B.isXRRenderTarget===!0?B.texture.colorSpace:Qc,It=(De.isMeshStandardMaterial?J:ce).get(De.envMap||ct),Pt=De.vertexColors===!0&&!!Se.attributes.color&&Se.attributes.color.itemSize===4,Kt=!!Se.attributes.tangent&&(!!De.normalMap||De.anisotropy>0),jt=!!Se.morphAttributes.position,Qt=!!Se.morphAttributes.normal,In=!!Se.morphAttributes.color;let hn=Ju;De.toneMapped&&(B===null||B.isXRRenderTarget===!0)&&(hn=D.toneMapping);const bn=Se.morphAttributes.position||Se.morphAttributes.normal||Se.morphAttributes.color,jn=bn!==void 0?bn.length:0,dn=Et.get(De),zn=T.state.lights;if(Te===!0&&(Ge===!0||X!==H)){const Zi=X===H&&De.id===L;Jt.setState(De,X,Zi)}let nn=!1;De.version===dn.__version?(dn.needsLights&&dn.lightsStateVersion!==zn.state.version||dn.outputColorSpace!==vt||ye.isBatchedMesh&&dn.batching===!1||!ye.isBatchedMesh&&dn.batching===!0||ye.isBatchedMesh&&dn.batchingColor===!0&&ye.colorTexture===null||ye.isBatchedMesh&&dn.batchingColor===!1&&ye.colorTexture!==null||ye.isInstancedMesh&&dn.instancing===!1||!ye.isInstancedMesh&&dn.instancing===!0||ye.isSkinnedMesh&&dn.skinning===!1||!ye.isSkinnedMesh&&dn.skinning===!0||ye.isInstancedMesh&&dn.instancingColor===!0&&ye.instanceColor===null||ye.isInstancedMesh&&dn.instancingColor===!1&&ye.instanceColor!==null||ye.isInstancedMesh&&dn.instancingMorph===!0&&ye.morphTexture===null||ye.isInstancedMesh&&dn.instancingMorph===!1&&ye.morphTexture!==null||dn.envMap!==It||De.fog===!0&&dn.fog!==Ke||dn.numClippingPlanes!==void 0&&(dn.numClippingPlanes!==Jt.numPlanes||dn.numIntersection!==Jt.numIntersection)||dn.vertexAlphas!==Pt||dn.vertexTangents!==Kt||dn.morphTargets!==jt||dn.morphNormals!==Qt||dn.morphColors!==In||dn.toneMapping!==hn||dn.morphTargetsCount!==jn)&&(nn=!0):(nn=!0,dn.__version=De.version);let ss=dn.currentProgram;nn===!0&&(ss=j(De,de,ye));let ms=!1,mn=!1,li=!1;const cs=ss.getUniforms(),vs=dn.uniforms;if(gt.useProgram(ss.program)&&(ms=!0,mn=!0,li=!0),De.id!==L&&(L=De.id,mn=!0),ms||H!==X){gt.buffers.depth.getReversed()&&X.reversedDepth!==!0&&(X._reversedDepth=!0,X.updateProjectionMatrix()),cs.setValue(oe,"projectionMatrix",X.projectionMatrix),cs.setValue(oe,"viewMatrix",X.matrixWorldInverse);const pi=cs.map.cameraPosition;pi!==void 0&&pi.setValue(oe,yt.setFromMatrixPosition(X.matrixWorld)),ft.logarithmicDepthBuffer&&cs.setValue(oe,"logDepthBufFC",2/(Math.log(X.far+1)/Math.LN2)),(De.isMeshPhongMaterial||De.isMeshToonMaterial||De.isMeshLambertMaterial||De.isMeshBasicMaterial||De.isMeshStandardMaterial||De.isShaderMaterial)&&cs.setValue(oe,"isOrthographic",X.isOrthographicCamera===!0),H!==X&&(H=X,mn=!0,li=!0)}if(ye.isSkinnedMesh){cs.setOptional(oe,ye,"bindMatrix"),cs.setOptional(oe,ye,"bindMatrixInverse");const Zi=ye.skeleton;Zi&&(Zi.boneTexture===null&&Zi.computeBoneTexture(),cs.setValue(oe,"boneTexture",Zi.boneTexture,kt))}ye.isBatchedMesh&&(cs.setOptional(oe,ye,"batchingTexture"),cs.setValue(oe,"batchingTexture",ye._matricesTexture,kt),cs.setOptional(oe,ye,"batchingIdTexture"),cs.setValue(oe,"batchingIdTexture",ye._indirectTexture,kt),cs.setOptional(oe,ye,"batchingColorTexture"),ye._colorsTexture!==null&&cs.setValue(oe,"batchingColorTexture",ye._colorsTexture,kt));const Ps=Se.morphAttributes;if((Ps.position!==void 0||Ps.normal!==void 0||Ps.color!==void 0)&&Zt.update(ye,Se,ss),(mn||dn.receiveShadow!==ye.receiveShadow)&&(dn.receiveShadow=ye.receiveShadow,cs.setValue(oe,"receiveShadow",ye.receiveShadow)),De.isMeshGouraudMaterial&&De.envMap!==null&&(vs.envMap.value=It,vs.flipEnvMap.value=It.isCubeTexture&&It.isRenderTargetTexture===!1?-1:1),De.isMeshStandardMaterial&&De.envMap===null&&de.environment!==null&&(vs.envMapIntensity.value=de.environmentIntensity),vs.dfgLUT!==void 0&&(vs.dfgLUT.value=ose()),mn&&(cs.setValue(oe,"toneMappingExposure",D.toneMappingExposure),dn.needsLights&&st(vs,li),Ke&&De.fog===!0&&Gt.refreshFogUniforms(vs,Ke),Gt.refreshMaterialUniforms(vs,De,le,se,T.state.transmissionRenderTarget[X.id]),hT.upload(oe,ae(dn),vs,kt)),De.isShaderMaterial&&De.uniformsNeedUpdate===!0&&(hT.upload(oe,ae(dn),vs,kt),De.uniformsNeedUpdate=!1),De.isSpriteMaterial&&cs.setValue(oe,"center",ye.center),cs.setValue(oe,"modelViewMatrix",ye.modelViewMatrix),cs.setValue(oe,"normalMatrix",ye.normalMatrix),cs.setValue(oe,"modelMatrix",ye.matrixWorld),De.isShaderMaterial||De.isRawShaderMaterial){const Zi=De.uniformsGroups;for(let pi=0,nl=Zi.length;pi<nl;pi++){const Bo=Zi[pi];Ue.update(Bo,ss),Ue.bind(Bo,ss)}}return ss}function st(X,de){X.ambientLightColor.needsUpdate=de,X.lightProbe.needsUpdate=de,X.directionalLights.needsUpdate=de,X.directionalLightShadows.needsUpdate=de,X.pointLights.needsUpdate=de,X.pointLightShadows.needsUpdate=de,X.spotLights.needsUpdate=de,X.spotLightShadows.needsUpdate=de,X.rectAreaLights.needsUpdate=de,X.hemisphereLights.needsUpdate=de}function tt(X){return X.isMeshLambertMaterial||X.isMeshToonMaterial||X.isMeshPhongMaterial||X.isMeshStandardMaterial||X.isShadowMaterial||X.isShaderMaterial&&X.lights===!0}this.getActiveCubeFace=function(){return U},this.getActiveMipmapLevel=function(){return O},this.getRenderTarget=function(){return B},this.setRenderTargetTextures=function(X,de,Se){const De=Et.get(X);De.__autoAllocateDepthBuffer=X.resolveDepthBuffer===!1,De.__autoAllocateDepthBuffer===!1&&(De.__useRenderToTexture=!1),Et.get(X.texture).__webglTexture=de,Et.get(X.depthTexture).__webglTexture=De.__autoAllocateDepthBuffer?void 0:Se,De.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(X,de){const Se=Et.get(X);Se.__webglFramebuffer=de,Se.__useDefaultFramebuffer=de===void 0};const Mt=oe.createFramebuffer();this.setRenderTarget=function(X,de=0,Se=0){B=X,U=de,O=Se;let De=!0,ye=null,Ke=!1,ct=!1;if(X){const It=Et.get(X);if(It.__useDefaultFramebuffer!==void 0)gt.bindFramebuffer(oe.FRAMEBUFFER,null),De=!1;else if(It.__webglFramebuffer===void 0)kt.setupRenderTarget(X);else if(It.__hasExternalTextures)kt.rebindTextures(X,Et.get(X.texture).__webglTexture,Et.get(X.depthTexture).__webglTexture);else if(X.depthBuffer){const jt=X.depthTexture;if(It.__boundDepthTexture!==jt){if(jt!==null&&Et.has(jt)&&(X.width!==jt.image.width||X.height!==jt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");kt.setupDepthRenderbuffer(X)}}const Pt=X.texture;(Pt.isData3DTexture||Pt.isDataArrayTexture||Pt.isCompressedArrayTexture)&&(ct=!0);const Kt=Et.get(X).__webglFramebuffer;X.isWebGLCubeRenderTarget?(Array.isArray(Kt[de])?ye=Kt[de][Se]:ye=Kt[de],Ke=!0):X.samples>0&&kt.useMultisampledRTT(X)===!1?ye=Et.get(X).__webglMultisampledFramebuffer:Array.isArray(Kt)?ye=Kt[Se]:ye=Kt,K.copy(X.viewport),Z.copy(X.scissor),Q=X.scissorTest}else K.copy(he).multiplyScalar(le).floor(),Z.copy(me).multiplyScalar(le).floor(),Q=Ne;if(Se!==0&&(ye=Mt),gt.bindFramebuffer(oe.FRAMEBUFFER,ye)&&De&&gt.drawBuffers(X,ye),gt.viewport(K),gt.scissor(Z),gt.setScissorTest(Q),Ke){const It=Et.get(X.texture);oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_CUBE_MAP_POSITIVE_X+de,It.__webglTexture,Se)}else if(ct){const It=de;for(let Pt=0;Pt<X.textures.length;Pt++){const Kt=Et.get(X.textures[Pt]);oe.framebufferTextureLayer(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0+Pt,Kt.__webglTexture,Se,It)}}else if(X!==null&&Se!==0){const It=Et.get(X.texture);oe.framebufferTexture2D(oe.FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_2D,It.__webglTexture,Se)}L=-1},this.readRenderTargetPixels=function(X,de,Se,De,ye,Ke,ct,vt=0){if(!(X&&X.isWebGLRenderTarget)){On("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let It=Et.get(X).__webglFramebuffer;if(X.isWebGLCubeRenderTarget&&ct!==void 0&&(It=It[ct]),It){gt.bindFramebuffer(oe.FRAMEBUFFER,It);try{const Pt=X.textures[vt],Kt=Pt.format,jt=Pt.type;if(!ft.textureFormatReadable(Kt)){On("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!ft.textureTypeReadable(jt)){On("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}de>=0&&de<=X.width-De&&Se>=0&&Se<=X.height-ye&&(X.textures.length>1&&oe.readBuffer(oe.COLOR_ATTACHMENT0+vt),oe.readPixels(de,Se,De,ye,mt.convert(Kt),mt.convert(jt),Ke))}finally{const Pt=B!==null?Et.get(B).__webglFramebuffer:null;gt.bindFramebuffer(oe.FRAMEBUFFER,Pt)}}},this.readRenderTargetPixelsAsync=async function(X,de,Se,De,ye,Ke,ct,vt=0){if(!(X&&X.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let It=Et.get(X).__webglFramebuffer;if(X.isWebGLCubeRenderTarget&&ct!==void 0&&(It=It[ct]),It)if(de>=0&&de<=X.width-De&&Se>=0&&Se<=X.height-ye){gt.bindFramebuffer(oe.FRAMEBUFFER,It);const Pt=X.textures[vt],Kt=Pt.format,jt=Pt.type;if(!ft.textureFormatReadable(Kt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!ft.textureTypeReadable(jt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const Qt=oe.createBuffer();oe.bindBuffer(oe.PIXEL_PACK_BUFFER,Qt),oe.bufferData(oe.PIXEL_PACK_BUFFER,Ke.byteLength,oe.STREAM_READ),X.textures.length>1&&oe.readBuffer(oe.COLOR_ATTACHMENT0+vt),oe.readPixels(de,Se,De,ye,mt.convert(Kt),mt.convert(jt),0);const In=B!==null?Et.get(B).__webglFramebuffer:null;gt.bindFramebuffer(oe.FRAMEBUFFER,In);const hn=oe.fenceSync(oe.SYNC_GPU_COMMANDS_COMPLETE,0);return oe.flush(),await IK(oe,hn,4),oe.bindBuffer(oe.PIXEL_PACK_BUFFER,Qt),oe.getBufferSubData(oe.PIXEL_PACK_BUFFER,0,Ke),oe.deleteBuffer(Qt),oe.deleteSync(hn),Ke}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(X,de=null,Se=0){const De=Math.pow(2,-Se),ye=Math.floor(X.image.width*De),Ke=Math.floor(X.image.height*De),ct=de!==null?de.x:0,vt=de!==null?de.y:0;kt.setTexture2D(X,0),oe.copyTexSubImage2D(oe.TEXTURE_2D,Se,0,0,ct,vt,ye,Ke),gt.unbindTexture()};const wt=oe.createFramebuffer(),Ct=oe.createFramebuffer();this.copyTextureToTexture=function(X,de,Se=null,De=null,ye=0,Ke=null){Ke===null&&(ye!==0?(Fx("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Ke=ye,ye=0):Ke=0);let ct,vt,It,Pt,Kt,jt,Qt,In,hn;const bn=X.isCompressedTexture?X.mipmaps[Ke]:X.image;if(Se!==null)ct=Se.max.x-Se.min.x,vt=Se.max.y-Se.min.y,It=Se.isBox3?Se.max.z-Se.min.z:1,Pt=Se.min.x,Kt=Se.min.y,jt=Se.isBox3?Se.min.z:0;else{const Ps=Math.pow(2,-ye);ct=Math.floor(bn.width*Ps),vt=Math.floor(bn.height*Ps),X.isDataArrayTexture?It=bn.depth:X.isData3DTexture?It=Math.floor(bn.depth*Ps):It=1,Pt=0,Kt=0,jt=0}De!==null?(Qt=De.x,In=De.y,hn=De.z):(Qt=0,In=0,hn=0);const jn=mt.convert(de.format),dn=mt.convert(de.type);let zn;de.isData3DTexture?(kt.setTexture3D(de,0),zn=oe.TEXTURE_3D):de.isDataArrayTexture||de.isCompressedArrayTexture?(kt.setTexture2DArray(de,0),zn=oe.TEXTURE_2D_ARRAY):(kt.setTexture2D(de,0),zn=oe.TEXTURE_2D),oe.pixelStorei(oe.UNPACK_FLIP_Y_WEBGL,de.flipY),oe.pixelStorei(oe.UNPACK_PREMULTIPLY_ALPHA_WEBGL,de.premultiplyAlpha),oe.pixelStorei(oe.UNPACK_ALIGNMENT,de.unpackAlignment);const nn=oe.getParameter(oe.UNPACK_ROW_LENGTH),ss=oe.getParameter(oe.UNPACK_IMAGE_HEIGHT),ms=oe.getParameter(oe.UNPACK_SKIP_PIXELS),mn=oe.getParameter(oe.UNPACK_SKIP_ROWS),li=oe.getParameter(oe.UNPACK_SKIP_IMAGES);oe.pixelStorei(oe.UNPACK_ROW_LENGTH,bn.width),oe.pixelStorei(oe.UNPACK_IMAGE_HEIGHT,bn.height),oe.pixelStorei(oe.UNPACK_SKIP_PIXELS,Pt),oe.pixelStorei(oe.UNPACK_SKIP_ROWS,Kt),oe.pixelStorei(oe.UNPACK_SKIP_IMAGES,jt);const cs=X.isDataArrayTexture||X.isData3DTexture,vs=de.isDataArrayTexture||de.isData3DTexture;if(X.isDepthTexture){const Ps=Et.get(X),Zi=Et.get(de),pi=Et.get(Ps.__renderTarget),nl=Et.get(Zi.__renderTarget);gt.bindFramebuffer(oe.READ_FRAMEBUFFER,pi.__webglFramebuffer),gt.bindFramebuffer(oe.DRAW_FRAMEBUFFER,nl.__webglFramebuffer);for(let Bo=0;Bo<It;Bo++)cs&&(oe.framebufferTextureLayer(oe.READ_FRAMEBUFFER,oe.COLOR_ATTACHMENT0,Et.get(X).__webglTexture,ye,jt+Bo),oe.framebufferTextureLayer(oe.DRAW_FRAMEBUFFER,oe.COLOR_ATTACHMENT0,Et.get(de).__webglTexture,Ke,hn+Bo)),oe.blitFramebuffer(Pt,Kt,ct,vt,Qt,In,ct,vt,oe.DEPTH_BUFFER_BIT,oe.NEAREST);gt.bindFramebuffer(oe.READ_FRAMEBUFFER,null),gt.bindFramebuffer(oe.DRAW_FRAMEBUFFER,null)}else if(ye!==0||X.isRenderTargetTexture||Et.has(X)){const Ps=Et.get(X),Zi=Et.get(de);gt.bindFramebuffer(oe.READ_FRAMEBUFFER,wt),gt.bindFramebuffer(oe.DRAW_FRAMEBUFFER,Ct);for(let pi=0;pi<It;pi++)cs?oe.framebufferTextureLayer(oe.READ_FRAMEBUFFER,oe.COLOR_ATTACHMENT0,Ps.__webglTexture,ye,jt+pi):oe.framebufferTexture2D(oe.READ_FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_2D,Ps.__webglTexture,ye),vs?oe.framebufferTextureLayer(oe.DRAW_FRAMEBUFFER,oe.COLOR_ATTACHMENT0,Zi.__webglTexture,Ke,hn+pi):oe.framebufferTexture2D(oe.DRAW_FRAMEBUFFER,oe.COLOR_ATTACHMENT0,oe.TEXTURE_2D,Zi.__webglTexture,Ke),ye!==0?oe.blitFramebuffer(Pt,Kt,ct,vt,Qt,In,ct,vt,oe.COLOR_BUFFER_BIT,oe.NEAREST):vs?oe.copyTexSubImage3D(zn,Ke,Qt,In,hn+pi,Pt,Kt,ct,vt):oe.copyTexSubImage2D(zn,Ke,Qt,In,Pt,Kt,ct,vt);gt.bindFramebuffer(oe.READ_FRAMEBUFFER,null),gt.bindFramebuffer(oe.DRAW_FRAMEBUFFER,null)}else vs?X.isDataTexture||X.isData3DTexture?oe.texSubImage3D(zn,Ke,Qt,In,hn,ct,vt,It,jn,dn,bn.data):de.isCompressedArrayTexture?oe.compressedTexSubImage3D(zn,Ke,Qt,In,hn,ct,vt,It,jn,bn.data):oe.texSubImage3D(zn,Ke,Qt,In,hn,ct,vt,It,jn,dn,bn):X.isDataTexture?oe.texSubImage2D(oe.TEXTURE_2D,Ke,Qt,In,ct,vt,jn,dn,bn.data):X.isCompressedTexture?oe.compressedTexSubImage2D(oe.TEXTURE_2D,Ke,Qt,In,bn.width,bn.height,jn,bn.data):oe.texSubImage2D(oe.TEXTURE_2D,Ke,Qt,In,ct,vt,jn,dn,bn);oe.pixelStorei(oe.UNPACK_ROW_LENGTH,nn),oe.pixelStorei(oe.UNPACK_IMAGE_HEIGHT,ss),oe.pixelStorei(oe.UNPACK_SKIP_PIXELS,ms),oe.pixelStorei(oe.UNPACK_SKIP_ROWS,mn),oe.pixelStorei(oe.UNPACK_SKIP_IMAGES,li),Ke===0&&de.generateMipmaps&&oe.generateMipmap(zn),gt.unbindTexture()},this.initRenderTarget=function(X){Et.get(X).__webglFramebuffer===void 0&&kt.setupRenderTarget(X)},this.initTexture=function(X){X.isCubeTexture?kt.setTextureCube(X,0):X.isData3DTexture?kt.setTexture3D(X,0):X.isDataArrayTexture||X.isCompressedArrayTexture?kt.setTexture2DArray(X,0):kt.setTexture2D(X,0),gt.unbindTexture()},this.resetState=function(){U=0,O=0,B=null,gt.reset(),ge.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return yl}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=ws._getDrawingBufferColorSpace(e),t.unpackColorSpace=ws._getUnpackColorSpace()}}const lse=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:YD,AddEquation:Tf,AddOperation:U4,AdditiveAnimationBlendMode:tO,AdditiveBlending:w3,AgXToneMapping:V4,AlphaFormat:QD,AlwaysCompare:aG,AlwaysDepth:MT,AlwaysStencilFunc:N3,AmbientLight:XG,AnimationAction:sV,AnimationClip:Gx,AnimationLoader:vJ,AnimationMixer:HJ,AnimationObjectGroup:GJ,AnimationUtils:mJ,ArcCurve:bG,ArrayCamera:eV,ArrowHelper:mZ,AttachedBindMode:E3,Audio:tV,AudioAnalyser:DJ,AudioContext:IO,AudioListener:NJ,AudioLoader:TJ,AxesHelper:gZ,BackSide:Ao,BasicDepthPacking:Y4,BasicShadowMap:y4,BatchedMesh:xG,Bone:d2,BooleanKeyframeTrack:Cg,Box2:QJ,Box3:yr,Box3Helper:fZ,BoxGeometry:wg,BoxHelper:dZ,BufferAttribute:Es,BufferGeometry:Ln,BufferGeometryLoader:ZG,ByteType:e2,Cache:qu,Camera:NS,CameraHelper:hZ,CanvasTexture:UY,CapsuleGeometry:g2,CatmullRomCurve3:SG,CineonToneMapping:$4,CircleGeometry:x2,ClampToEdgeWrapping:Fi,Clock:DO,Color:$t,ColorKeyframeTrack:CO,ColorManagement:ws,CompressedArrayTexture:LY,CompressedCubeTexture:FY,CompressedTexture:m2,CompressedTextureLoader:bJ,ConeGeometry:kS,ConstantAlphaFactor:k4,ConstantColorFactor:O4,Controls:yZ,CubeCamera:fG,CubeReflectionMapping:ah,CubeRefractionMapping:Uf,CubeTexture:RS,CubeTextureLoader:HG,CubeUVReflectionMapping:hy,CubicBezierCurve:gO,CubicBezierCurve3:_G,CubicInterpolant:zG,CullFaceBack:A3,CullFaceFront:x4,CullFaceFrontBack:Kq,CullFaceNone:g4,Curve:au,CurvePath:wG,CustomBlending:v4,CustomToneMapping:G4,CylinderGeometry:BS,Cylindrical:ZJ,Data3DTexture:c2,DataArrayTexture:l2,DataTexture:ac,DataTextureLoader:TO,DataUtils:Pm,DecrementStencilOp:aK,DecrementWrapStencilOp:oK,DefaultLoadingManager:VG,DepthFormat:tg,DepthStencilFormat:Ox,DepthTexture:OS,DetachedBindMode:W4,DirectionalLight:RO,DirectionalLightHelper:uZ,DiscreteInterpolant:$G,DodecahedronGeometry:y2,DoubleSide:Ql,DstAlphaFactor:M4,DstColorFactor:R4,DynamicCopyUsage:_K,DynamicDrawUsage:gK,DynamicReadUsage:vK,EdgesGeometry:vG,EllipseCurve:v2,EqualCompare:tG,EqualDepth:RT,EqualStencilFunc:hK,EquirectangularReflectionMapping:Rx,EquirectangularRefractionMapping:H1,Euler:wl,EventDispatcher:ph,ExternalTexture:pO,ExtrudeGeometry:b2,FileLoader:vr,Float16BufferAttribute:pY,Float32BufferAttribute:on,FloatType:wi,Fog:h2,FogExp2:u2,FramebufferTexture:kY,FrontSide:ih,Frustum:fy,FrustumArray:f2,GLBufferAttribute:KJ,GLSL1:wK,GLSL3:R3,GreaterCompare:nG,GreaterDepth:DT,GreaterEqualCompare:iG,GreaterEqualDepth:IT,GreaterEqualStencilFunc:mK,GreaterStencilFunc:fK,GridHelper:lZ,Group:ld,HalfFloatType:Wi,HemisphereLight:jG,HemisphereLightHelper:oZ,IcosahedronGeometry:LS,ImageBitmapLoader:QG,ImageLoader:Q1,ImageUtils:cG,IncrementStencilOp:iK,IncrementWrapStencilOp:rK,InstancedBufferAttribute:ng,InstancedBufferGeometry:JG,InstancedInterleavedBuffer:qJ,InstancedMesh:hO,Int16BufferAttribute:dY,Int32BufferAttribute:fY,Int8BufferAttribute:cY,IntType:TS,InterleavedBuffer:IS,InterleavedBufferAttribute:$f,Interpolant:my,InterpolateDiscrete:Bx,InterpolateLinear:kx,InterpolateSmooth:cT,InterpolationSamplingMode:EK,InterpolationSamplingType:TK,InvertStencilOp:lK,KeepStencilOp:Em,KeyframeTrack:cc,LOD:gG,LatheGeometry:S2,Layers:Px,LessCompare:eG,LessDepth:NT,LessEqualCompare:sO,LessEqualDepth:Qm,LessEqualStencilFunc:dK,LessStencilFunc:uK,Light:ip,LightProbe:YG,Line:pd,Line3:nZ,LineBasicMaterial:qr,LineCurve:xO,LineCurve3:AG,LineDashedMaterial:FG,LineLoop:dO,LineSegments:iu,LinearFilter:is,LinearInterpolant:wO,LinearMipMapLinearFilter:M3,LinearMipMapNearestFilter:Zq,LinearMipmapLinearFilter:tc,LinearMipmapNearestFilter:Sx,LinearSRGBColorSpace:Qc,LinearToneMapping:P4,LinearTransfer:j1,Loader:br,LoaderUtils:Of,LoadingManager:M2,LoopOnce:j4,LoopPingPong:q4,LoopRepeat:X4,MOUSE:Cm,Material:Da,MaterialLoader:N2,MathUtils:lG,Matrix2:LO,Matrix3:Vn,Matrix4:_n,MaxEquation:A4,Mesh:Ti,MeshBasicMaterial:Yo,MeshDepthMaterial:SO,MeshDistanceMaterial:_O,MeshLambertMaterial:kG,MeshMatcapMaterial:LG,MeshNormalMaterial:BG,MeshPhongMaterial:DG,MeshPhysicalMaterial:lc,MeshStandardMaterial:py,MeshToonMaterial:OG,MinEquation:_4,MirroredRepeatWrapping:Ix,MixOperation:F4,MultiplyBlending:T3,MultiplyOperation:CS,NearestFilter:Ja,NearestMipMapLinearFilter:Jq,NearestMipMapNearestFilter:Yq,NearestMipmapLinearFilter:Lm,NearestMipmapNearestFilter:QE,NeutralToneMapping:H4,NeverCompare:Q4,NeverDepth:ET,NeverStencilFunc:cK,NoBlending:ic,NoColorSpace:id,NoToneMapping:Ju,NormalAnimationBlendMode:o2,NormalBlending:Wm,NotEqualCompare:sG,NotEqualDepth:OT,NotEqualStencilFunc:pK,NumberKeyframeTrack:ig,Object3D:Ts,ObjectLoader:wJ,ObjectSpaceNormalMap:Z4,OctahedronGeometry:FS,OneFactor:C4,OneMinusConstantAlphaFactor:L4,OneMinusConstantColorFactor:B4,OneMinusDstAlphaFactor:N4,OneMinusDstColorFactor:I4,OneMinusSrcAlphaFactor:TT,OneMinusSrcColorFactor:E4,OrthographicCamera:Zu,PCFShadowMap:ZE,PCFSoftShadowMap:D1,PMREMGenerator:U3,Path:dE,PerspectiveCamera:ki,Plane:Vu,PlaneGeometry:sp,PlaneHelper:pZ,PointLight:NO,PointLightHelper:aZ,Points:fO,PointsMaterial:p2,PolarGridHelper:cZ,PolyhedronGeometry:np,PositionalAudio:IJ,PropertyBinding:Ns,PropertyMixer:nV,QuadraticBezierCurve:yO,QuadraticBezierCurve3:vO,Quaternion:Za,QuaternionKeyframeTrack:ag,QuaternionLinearInterpolant:GG,RED_GREEN_RGTC2_Format:rE,RED_RGTC1_Format:iE,REVISION:uy,RGBADepthPacking:J4,RGBAFormat:ra,RGBAIntegerFormat:r2,RGBA_ASTC_10x10_Format:ZT,RGBA_ASTC_10x5_Format:KT,RGBA_ASTC_10x6_Format:YT,RGBA_ASTC_10x8_Format:JT,RGBA_ASTC_12x10_Format:QT,RGBA_ASTC_12x12_Format:eE,RGBA_ASTC_4x4_Format:$T,RGBA_ASTC_5x4_Format:GT,RGBA_ASTC_5x5_Format:VT,RGBA_ASTC_6x5_Format:HT,RGBA_ASTC_6x6_Format:WT,RGBA_ASTC_8x5_Format:jT,RGBA_ASTC_8x6_Format:XT,RGBA_ASTC_8x8_Format:qT,RGBA_BPTC_Format:tE,RGBA_ETC2_EAC_Format:zT,RGBA_PVRTC_2BPPV1_Format:FT,RGBA_PVRTC_4BPPV1_Format:LT,RGBA_S3TC_DXT1_Format:B1,RGBA_S3TC_DXT3_Format:k1,RGBA_S3TC_DXT5_Format:L1,RGBDepthPacking:eK,RGBFormat:eO,RGBIntegerFormat:Qq,RGB_BPTC_SIGNED_Format:nE,RGB_BPTC_UNSIGNED_Format:sE,RGB_ETC1_Format:UT,RGB_ETC2_Format:PT,RGB_PVRTC_2BPPV1_Format:kT,RGB_PVRTC_4BPPV1_Format:BT,RGB_S3TC_DXT1_Format:O1,RGDepthPacking:tK,RGFormat:i2,RGIntegerFormat:a2,RawShaderMaterial:IG,Ray:Ag,Raycaster:kO,RectAreaLight:qG,RedFormat:ES,RedIntegerFormat:MS,ReinhardToneMapping:z4,RenderTarget:aO,RenderTarget3D:WJ,RepeatWrapping:Pf,ReplaceStencilOp:sK,ReverseSubtractEquation:S4,RingGeometry:_2,SIGNED_RED_GREEN_RGTC2_Format:oE,SIGNED_RED_RGTC1_Format:aE,SRGBColorSpace:mr,SRGBTransfer:js,Scene:dy,ShaderChunk:Jn,ShaderLib:Hc,ShaderMaterial:jr,ShadowMaterial:RG,Shape:Xm,ShapeGeometry:A2,ShapePath:xZ,ShapeUtils:Xc,ShortType:t2,Skeleton:DS,SkeletonHelper:iZ,SkinnedMesh:uO,Source:Ef,Sphere:Qa,SphereGeometry:US,Spherical:L3,SphericalHarmonics3:KG,SplineCurve:bO,SpotLight:MO,SpotLightHelper:sZ,Sprite:mG,SpriteMaterial:cO,SrcAlphaFactor:CT,SrcAlphaSaturateFactor:D4,SrcColorFactor:T4,StaticCopyUsage:SK,StaticDrawUsage:X1,StaticReadUsage:yK,StereoCamera:EJ,StreamCopyUsage:AK,StreamDrawUsage:xK,StreamReadUsage:bK,StringKeyframeTrack:Tg,SubtractEquation:b4,SubtractiveBlending:C3,TOUCH:Tm,TangentSpaceNormalMap:tp,TetrahedronGeometry:w2,Texture:Vs,TextureLoader:WG,TextureUtils:AZ,Timer:YJ,TimestampQuery:CK,TorusGeometry:C2,TorusKnotGeometry:T2,Triangle:qo,TriangleFanDrawMode:lE,TriangleStripDrawMode:nO,TrianglesDrawMode:K4,TubeGeometry:E2,UVMapping:Ff,Uint16BufferAttribute:rO,Uint32BufferAttribute:oO,Uint8BufferAttribute:uY,Uint8ClampedBufferAttribute:hY,Uniform:Pr,UniformsGroup:XJ,UniformsLib:Ht,UniformsUtils:dG,UnsignedByteType:Co,UnsignedInt101111Type:ZD,UnsignedInt248Type:Dx,UnsignedInt5999Type:JD,UnsignedIntType:rh,UnsignedShort4444Type:n2,UnsignedShort5551Type:s2,UnsignedShortType:eg,VSMShadowMap:Gc,Vector2:rt,Vector3:ue,Vector4:Cs,VectorKeyframeTrack:rg,VideoFrameTexture:BY,VideoTexture:yG,WebGL3DRenderTarget:ZK,WebGLArrayRenderTarget:JK,WebGLCoordinateSystem:yl,WebGLCubeRenderTarget:lO,WebGLRenderTarget:Wr,WebGLRenderer:FO,WebGLUtils:uV,WebGPUCoordinateSystem:Lx,WebXRController:uT,WireframeGeometry:NG,WrapAroundEnding:W1,ZeroCurvatureEnding:Fm,ZeroFactor:w4,ZeroSlopeEnding:Um,ZeroStencilOp:nK,createCanvasElement:oG,error:On,getConsoleFunction:RK,log:K1,setConsoleFunction:NK,warn:Wt,warnOnce:Fx},Symbol.toStringTag,{value:"Module"}));var NI={exports:{}},RI={},II={exports:{}},DI={};var IP;function cse(){if(IP)return DI;IP=1;var n=ay();function e(d,p){return d===p&&(d!==0||1/d===1/p)||d!==d&&p!==p}var t=typeof Object.is=="function"?Object.is:e,s=n.useState,i=n.useEffect,a=n.useLayoutEffect,r=n.useDebugValue;function o(d,p){var g=p(),v=s({inst:{value:g,getSnapshot:p}}),_=v[0].inst,S=v[1];return a(function(){_.value=g,_.getSnapshot=p,l(_)&&S({inst:_})},[d,g,p]),i(function(){return l(_)&&S({inst:_}),d(function(){l(_)&&S({inst:_})})},[d]),r(g),g}function l(d){var p=d.getSnapshot;d=d.value;try{var g=p();return!t(d,g)}catch{return!0}}function c(d,p){return p()}var h=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?c:o;return DI.useSyncExternalStore=n.useSyncExternalStore!==void 0?n.useSyncExternalStore:h,DI}var DP;function use(){return DP||(DP=1,II.exports=cse()),II.exports}var OP;function hse(){if(OP)return RI;OP=1;var n=ay(),e=use();function t(c,h){return c===h&&(c!==0||1/c===1/h)||c!==c&&h!==h}var s=typeof Object.is=="function"?Object.is:t,i=e.useSyncExternalStore,a=n.useRef,r=n.useEffect,o=n.useMemo,l=n.useDebugValue;return RI.useSyncExternalStoreWithSelector=function(c,h,d,p,g){var v=a(null);if(v.current===null){var _={hasValue:!1,value:null};v.current=_}else _=v.current;v=o(function(){function b(D){if(!w){if(w=!0,T=D,D=p(D),g!==void 0&&_.hasValue){var F=_.value;if(g(F,D))return E=F}return E=D}if(F=E,s(T,D))return F;var U=p(D);return g!==void 0&&g(F,U)?(T=D,F):(T=D,E=U)}var w=!1,T,E,R=d===void 0?null:d;return[function(){return b(h())},R===null?void 0:function(){return b(R())}]},[h,d,p,g]);var S=i(c,v[0],v[1]);return r(function(){_.hasValue=!0,_.value=S},[S]),l(S),S},RI}var BP;function dse(){return BP||(BP=1,NI.exports=hse()),NI.exports}var fse=dse();const pse=KE(fse),kP=n=>{let e;const t=new Set,s=(c,h)=>{const d=typeof c=="function"?c(e):c;if(!Object.is(d,e)){const p=e;e=h??(typeof d!="object"||d===null)?d:Object.assign({},e,d),t.forEach(g=>g(e,p))}},i=()=>e,o={setState:s,getState:i,getInitialState:()=>l,subscribe:c=>(t.add(c),()=>t.delete(c))},l=e=n(s,i,o);return o},mse=(n=>n?kP(n):kP),{useSyncExternalStoreWithSelector:gse}=pse,xse=n=>n;function yse(n,e=xse,t){const s=gse(n.subscribe,n.getState,n.getInitialState,e,t);return H7.useDebugValue(s),s}const LP=(n,e)=>{const t=mse(n),s=(i,a=e)=>yse(t,i,a);return Object.assign(s,t),s},hV=((n,e)=>n?LP(n,e):LP),vse=n=>typeof n=="object"&&typeof n.then=="function",$m=[];function dV(n,e,t=(s,i)=>s===i){if(n===e)return!0;if(!n||!e)return!1;const s=n.length;if(e.length!==s)return!1;for(let i=0;i<s;i++)if(!t(n[i],e[i]))return!1;return!0}function fV(n,e=null,t=!1,s={}){e===null&&(e=[n]);for(const a of $m)if(dV(e,a.keys,a.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(a,"error"))throw a.error;if(Object.prototype.hasOwnProperty.call(a,"response"))return s.lifespan&&s.lifespan>0&&(a.timeout&&clearTimeout(a.timeout),a.timeout=setTimeout(a.remove,s.lifespan)),a.response;if(!t)throw a.promise}const i={keys:e,equal:s.equal,remove:()=>{const a=$m.indexOf(i);a!==-1&&$m.splice(a,1)},promise:(vse(n)?n:n(...e)).then(a=>{i.response=a,s.lifespan&&s.lifespan>0&&(i.timeout=setTimeout(i.remove,s.lifespan))}).catch(a=>i.error=a)};if($m.push(i),!t)throw i.promise}const bse=(n,e,t)=>fV(n,e,!1,t),Sse=(n,e,t)=>void fV(n,e,!0,t),_se=n=>{if(n===void 0||n.length===0)$m.splice(0,$m.length);else{const e=$m.find(t=>dV(n,t.keys,t.equal));e&&e.remove()}};var OI={exports:{}},BI={exports:{}},kI={exports:{}},LI={};var FP;function Ase(){return FP||(FP=1,(function(n){function e(P,W){var q=P.length;P.push(W);e:for(;0<q;){var se=q-1>>>1,le=P[se];if(0<i(le,W))P[se]=W,P[q]=le,q=se;else break e}}function t(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var W=P[0],q=P.pop();if(q!==W){P[0]=q;e:for(var se=0,le=P.length,Y=le>>>1;se<Y;){var re=2*(se+1)-1,he=P[re],me=re+1,Ne=P[me];if(0>i(he,q))me<le&&0>i(Ne,he)?(P[se]=Ne,P[me]=q,se=me):(P[se]=he,P[re]=q,se=re);else if(me<le&&0>i(Ne,q))P[se]=Ne,P[me]=q,se=me;else break e}}return W}function i(P,W){var q=P.sortIndex-W.sortIndex;return q!==0?q:P.id-W.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var a=performance;n.unstable_now=function(){return a.now()}}else{var r=Date,o=r.now();n.unstable_now=function(){return r.now()-o}}var l=[],c=[],h=1,d=null,p=3,g=!1,v=!1,_=!1,S=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,w=typeof setImmediate<"u"?setImmediate:null;function T(P){for(var W=t(c);W!==null;){if(W.callback===null)s(c);else if(W.startTime<=P)s(c),W.sortIndex=W.expirationTime,e(l,W);else break;W=t(c)}}function E(P){if(_=!1,T(P),!v)if(t(l)!==null)v=!0,Z();else{var W=t(c);W!==null&&Q(E,W.startTime-P)}}var R=!1,D=-1,F=5,U=-1;function O(){return!(n.unstable_now()-U<F)}function B(){if(R){var P=n.unstable_now();U=P;var W=!0;try{e:{v=!1,_&&(_=!1,b(D),D=-1),g=!0;var q=p;try{t:{for(T(P),d=t(l);d!==null&&!(d.expirationTime>P&&O());){var se=d.callback;if(typeof se=="function"){d.callback=null,p=d.priorityLevel;var le=se(d.expirationTime<=P);if(P=n.unstable_now(),typeof le=="function"){d.callback=le,T(P),W=!0;break t}d===t(l)&&s(l),T(P)}else s(l);d=t(l)}if(d!==null)W=!0;else{var Y=t(c);Y!==null&&Q(E,Y.startTime-P),W=!1}}break e}finally{d=null,p=q,g=!1}W=void 0}}finally{W?L():R=!1}}}var L;if(typeof w=="function")L=function(){w(B)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,K=H.port2;H.port1.onmessage=B,L=function(){K.postMessage(null)}}else L=function(){S(B,0)};function Z(){R||(R=!0,L())}function Q(P,W){D=S(function(){P(n.unstable_now())},W)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_continueExecution=function(){v||g||(v=!0,Z())},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):F=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(P){switch(p){case 1:case 2:case 3:var W=3;break;default:W=p}var q=p;p=W;try{return P()}finally{p=q}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(P,W){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var q=p;p=P;try{return W()}finally{p=q}},n.unstable_scheduleCallback=function(P,W,q){var se=n.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?se+q:se):q=se,P){case 1:var le=-1;break;case 2:le=250;break;case 5:le=1073741823;break;case 4:le=1e4;break;default:le=5e3}return le=q+le,P={id:h++,callback:W,priorityLevel:P,startTime:q,expirationTime:le,sortIndex:-1},q>se?(P.sortIndex=q,e(c,P),t(l)===null&&P===t(c)&&(_?(b(D),D=-1):_=!0,Q(E,q-se))):(P.sortIndex=le,e(l,P),v||g||(v=!0,Z())),P},n.unstable_shouldYield=O,n.unstable_wrapCallback=function(P){var W=p;return function(){var q=p;p=W;try{return P.apply(this,arguments)}finally{p=q}}}})(LI)),LI}var UP;function wse(){return UP||(UP=1,kI.exports=Ase()),kI.exports}var PP;function Cse(){return PP||(PP=1,(function(n){n.exports=function(e){function t(m,x,C,N){return new eb(m,x,C,N)}function s(){}function i(m){var x="https://react.dev/errors/"+m;if(1<arguments.length){x+="?args[]="+encodeURIComponent(arguments[1]);for(var C=2;C<arguments.length;C++)x+="&args[]="+encodeURIComponent(arguments[C])}return"Minified React error #"+m+"; visit "+x+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function a(m){return m===null||typeof m!="object"?null:(m=ob&&m[ob]||m["@@iterator"],typeof m=="function"?m:null)}function r(m){if(m==null)return null;if(typeof m=="function")return m.$$typeof===Ih?null:m.displayName||m.name||null;if(typeof m=="string")return m;switch(m){case jd:return"Fragment";case rl:return"Portal";case rb:return"Profiler";case ab:return"StrictMode";case d0:return"Suspense";case Eu:return"SuspenseList"}if(typeof m=="object")switch(m.$$typeof){case kl:return(m.displayName||"Context")+".Provider";case Tu:return(m._context.displayName||"Context")+".Consumer";case Xd:var x=m.render;return m=m.displayName,m||(m=x.displayName||x.name||"",m=m!==""?"ForwardRef("+m+")":"ForwardRef"),m;case Fp:return x=m.displayName||null,x!==null?x:r(m.type)||"Memo";case ol:x=m._payload,m=m._init;try{return r(m(x))}catch{}}return null}function o(m){if(f0===void 0)try{throw Error()}catch(C){var x=C.stack.trim().match(/\n( *(at )?)/);f0=x&&x[1]||"",lb=-1<C.stack.indexOf(`
    at`)?" (<anonymous>)":-1<C.stack.indexOf("@")?"@unknown:0:0":""}return`
`+f0+m+lb}function l(m,x){if(!m||Mu)return"";Mu=!0;var C=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var N={DetermineComponentFrameRoot:function(){try{if(x){var Vt=function(){throw Error()};if(Object.defineProperty(Vt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Vt,[])}catch(Dn){var Yt=Dn}Reflect.construct(m,[],Vt)}else{try{Vt.call()}catch(Dn){Yt=Dn}m.call(Vt.prototype)}}else{try{throw Error()}catch(Dn){Yt=Dn}(Vt=m())&&typeof Vt.catch=="function"&&Vt.catch(function(){})}}catch(Dn){if(Dn&&Yt&&typeof Dn.stack=="string")return[Dn.stack,Yt.stack]}return[null,null]}};N.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var k=Object.getOwnPropertyDescriptor(N.DetermineComponentFrameRoot,"name");k&&k.configurable&&Object.defineProperty(N.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var z=N.DetermineComponentFrameRoot(),ie=z[0],_e=z[1];if(ie&&_e){var ke=ie.split(`
`),ht=_e.split(`
`);for(k=N=0;N<ke.length&&!ke[N].includes("DetermineComponentFrameRoot");)N++;for(;k<ht.length&&!ht[k].includes("DetermineComponentFrameRoot");)k++;if(N===ke.length||k===ht.length)for(N=ke.length-1,k=ht.length-1;1<=N&&0<=k&&ke[N]!==ht[k];)k--;for(;1<=N&&0<=k;N--,k--)if(ke[N]!==ht[k]){if(N!==1||k!==1)do if(N--,k--,0>k||ke[N]!==ht[k]){var Ot=`
`+ke[N].replace(" at new "," at ");return m.displayName&&Ot.includes("<anonymous>")&&(Ot=Ot.replace("<anonymous>",m.displayName)),Ot}while(1<=N&&0<=k);break}}}finally{Mu=!1,Error.prepareStackTrace=C}return(C=m?m.displayName||m.name:"")?o(C):""}function c(m){switch(m.tag){case 26:case 27:case 5:return o(m.type);case 16:return o("Lazy");case 13:return o("Suspense");case 19:return o("SuspenseList");case 0:case 15:return m=l(m.type,!1),m;case 11:return m=l(m.type.render,!1),m;case 1:return m=l(m.type,!0),m;default:return""}}function h(m){try{var x="";do x+=c(m),m=m.return;while(m);return x}catch(C){return`
Error generating stack: `+C.message+`
`+C.stack}}function d(m){var x=m,C=m;if(m.alternate)for(;x.return;)x=x.return;else{m=x;do x=m,(x.flags&4098)!==0&&(C=x.return),m=x.return;while(m)}return x.tag===3?C:null}function p(m){if(d(m)!==m)throw Error(i(188))}function g(m){var x=m.alternate;if(!x){if(x=d(m),x===null)throw Error(i(188));return x!==m?null:m}for(var C=m,N=x;;){var k=C.return;if(k===null)break;var z=k.alternate;if(z===null){if(N=k.return,N!==null){C=N;continue}break}if(k.child===z.child){for(z=k.child;z;){if(z===C)return p(k),m;if(z===N)return p(k),x;z=z.sibling}throw Error(i(188))}if(C.return!==N.return)C=k,N=z;else{for(var ie=!1,_e=k.child;_e;){if(_e===C){ie=!0,C=k,N=z;break}if(_e===N){ie=!0,N=k,C=z;break}_e=_e.sibling}if(!ie){for(_e=z.child;_e;){if(_e===C){ie=!0,C=z,N=k;break}if(_e===N){ie=!0,N=z,C=k;break}_e=_e.sibling}if(!ie)throw Error(i(189))}}if(C.alternate!==N)throw Error(i(190))}if(C.tag!==3)throw Error(i(188));return C.stateNode.current===C?m:x}function v(m){var x=m.tag;if(x===5||x===26||x===27||x===6)return m;for(m=m.child;m!==null;){if(x=v(m),x!==null)return x;m=m.sibling}return null}function _(m){var x=m.tag;if(x===5||x===26||x===27||x===6)return m;for(m=m.child;m!==null;){if(m.tag!==4&&(x=_(m),x!==null))return x;m=m.sibling}return null}function S(m){return{current:m}}function b(m){0>Ec||(m.current=jp[Ec],jp[Ec]=null,Ec--)}function w(m,x){Ec++,jp[Ec]=m.current,m.current=x}function T(m){return m>>>=0,m===0?32:31-(Xp(m)/Sw|0)|0}function E(m){var x=m&42;if(x!==0)return x;switch(m&-m){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m&4194176;case 4194304:case 8388608:case 16777216:case 33554432:return m&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return m}}function R(m,x){var C=m.pendingLanes;if(C===0)return 0;var N=0,k=m.suspendedLanes,z=m.pingedLanes,ie=m.warmLanes;m=m.finishedLanes!==0;var _e=C&134217727;return _e!==0?(C=_e&~k,C!==0?N=E(C):(z&=_e,z!==0?N=E(z):m||(ie=_e&~ie,ie!==0&&(N=E(ie))))):(_e=C&~k,_e!==0?N=E(_e):z!==0?N=E(z):m||(ie=C&~ie,ie!==0&&(N=E(ie)))),N===0?0:x!==0&&x!==N&&(x&k)===0&&(k=N&-N,ie=x&-x,k>=ie||k===32&&(ie&4194176)!==0)?x:N}function D(m,x){return(m.pendingLanes&~(m.suspendedLanes&~m.pingedLanes)&x)===0}function F(m,x){switch(m){case 1:case 2:case 4:case 8:return x+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return x+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function U(){var m=Jd;return Jd<<=1,(Jd&4194176)===0&&(Jd=128),m}function O(){var m=qp;return qp<<=1,(qp&62914560)===0&&(qp=4194304),m}function B(m){for(var x=[],C=0;31>C;C++)x.push(m);return x}function L(m,x){m.pendingLanes|=x,x!==268435456&&(m.suspendedLanes=0,m.pingedLanes=0,m.warmLanes=0)}function H(m,x,C,N,k,z){var ie=m.pendingLanes;m.pendingLanes=C,m.suspendedLanes=0,m.pingedLanes=0,m.warmLanes=0,m.expiredLanes&=C,m.entangledLanes&=C,m.errorRecoveryDisabledLanes&=C,m.shellSuspendCounter=0;var _e=m.entanglements,ke=m.expirationTimes,ht=m.hiddenUpdates;for(C=ie&~C;0<C;){var Ot=31-Mr(C),Vt=1<<Ot;_e[Ot]=0,ke[Ot]=-1;var Yt=ht[Ot];if(Yt!==null)for(ht[Ot]=null,Ot=0;Ot<Yt.length;Ot++){var Dn=Yt[Ot];Dn!==null&&(Dn.lane&=-536870913)}C&=~Vt}N!==0&&K(m,N,0),z!==0&&k===0&&m.tag!==0&&(m.suspendedLanes|=z&~(ie&~x))}function K(m,x,C){m.pendingLanes|=x,m.suspendedLanes&=~x;var N=31-Mr(x);m.entangledLanes|=x,m.entanglements[N]=m.entanglements[N]|1073741824|C&4194218}function Z(m,x){var C=m.entangledLanes|=x;for(m=m.entanglements;C;){var N=31-Mr(C),k=1<<N;k&x|m[N]&x&&(m[N]|=x),C&=~k}}function Q(m){return m&=-m,2<m?8<m?(m&134217727)!==0?32:268435456:8:2}function P(m){if(Nr&&typeof Nr.onCommitFiberRoot=="function")try{Nr.onCommitFiberRoot(Qd,m,void 0,(m.current.flags&128)===128)}catch{}}function W(m){if(typeof Cw=="function"&&Pb(m),Nr&&typeof Nr.setStrictMode=="function")try{Nr.setStrictMode(Qd,m)}catch{}}function q(m,x){return m===x&&(m!==0||1/m===1/x)||m!==m&&x!==x}function se(m,x){if(typeof m=="object"&&m!==null){var C=R0.get(m);return C!==void 0?C:(x={value:m,source:x,stack:h(x)},R0.set(m,x),x)}return{value:m,source:x,stack:h(x)}}function le(m,x){si[xi++]=Jp,si[xi++]=Yp,Yp=m,Jp=x}function Y(m,x,C){io[ao++]=zl,io[ao++]=Fo,io[ao++]=ll,ll=m;var N=zl;m=Fo;var k=32-Mr(N)-1;N&=~(1<<k),C+=1;var z=32-Mr(x)+k;if(30<z){var ie=k-k%5;z=(N&(1<<ie)-1).toString(32),N>>=ie,k-=ie,zl=1<<32-Mr(x)+k|C<<k|N,Fo=z+m}else zl=1<<z|C<<k|N,Fo=m}function re(m){m.return!==null&&(le(m,1),Y(m,1,0))}function he(m){for(;m===Yp;)Yp=si[--xi],si[xi]=null,Jp=si[--xi],si[xi]=null;for(;m===ll;)ll=io[--ao],io[ao]=null,Fo=io[--ao],io[ao]=null,zl=io[--ao],io[ao]=null}function me(m,x){w(cl,x),w(Zp,m),w(pa,null),m=Dh(x),b(pa),w(pa,m)}function Ne(){b(pa),b(Zp),b(cl)}function fe(m){m.memoizedState!==null&&w(ef,m);var x=pa.current,C=ew(x,m.type);x!==C&&(w(Zp,m),w(pa,C))}function Te(m){Zp.current===m&&(b(pa),b(Zp)),ef.current===m&&(b(ef),Fl?En._currentValue=Er:En._currentValue2=Er)}function Ge(m){var x=Error(i(418,""));throw Bt(se(x,m)),Qp}function nt(m,x){if(!ur)throw Error(i(175));eR(m.stateNode,m.type,m.memoizedProps,x,m)||Ge(m)}function yt(m){for(Ha=m.return;Ha;)switch(Ha.tag){case 3:case 27:Uo=!0;return;case 5:case 13:Uo=!1;return;default:Ha=Ha.return}}function Dt(m){if(!ur||m!==Ha)return!1;if(!bs)return yt(m),bs=!0,!1;var x=!1;if(Ta?m.tag!==3&&m.tag!==27&&(m.tag!==5||gw(m.type)&&!Iu(m.type,m.memoizedProps))&&(x=!0):m.tag!==3&&(m.tag!==5||gw(m.type)&&!Iu(m.type,m.memoizedProps))&&(x=!0),x&&Ma&&Ge(m),yt(m),m.tag===13){if(!ur)throw Error(i(316));if(m=m.memoizedState,m=m!==null?m.dehydrated:null,!m)throw Error(i(317));Ma=pw(m)}else Ma=Ha?Tb(m.stateNode):null;return!0}function qt(){ur&&(Ma=Ha=null,bs=!1)}function Bt(m){ro===null?ro=[m]:ro.push(m)}function Je(){for(var m=Ou,x=tf=Ou=0;x<m;){var C=oo[x];oo[x++]=null;var N=oo[x];oo[x++]=null;var k=oo[x];oo[x++]=null;var z=oo[x];if(oo[x++]=null,N!==null&&k!==null){var ie=N.pending;ie===null?k.next=k:(k.next=ie.next,ie.next=k),N.pending=k}z!==0&&ft(C,k,z)}}function oe(m,x,C,N){oo[Ou++]=m,oo[Ou++]=x,oo[Ou++]=C,oo[Ou++]=N,tf|=N,m.lanes|=N,m=m.alternate,m!==null&&(m.lanes|=N)}function Ze(m,x,C,N){return oe(m,x,C,N),gt(m)}function it(m,x){return oe(m,null,null,x),gt(m)}function ft(m,x,C){m.lanes|=C;var N=m.alternate;N!==null&&(N.lanes|=C);for(var k=!1,z=m.return;z!==null;)z.childLanes|=C,N=z.alternate,N!==null&&(N.childLanes|=C),z.tag===22&&(m=z.stateNode,m===null||m._visibility&1||(k=!0)),m=z,z=z.return;k&&x!==null&&m.tag===3&&(z=m.stateNode,k=31-Mr(C),z=z.hiddenUpdates,m=z[k],m===null?z[k]=[x]:m.push(x),x.lane=C|536870912)}function gt(m){if(50<Vh)throw Vh=0,fr=null,Error(i(185));for(var x=m.return;x!==null;)m=x,x=m.return;return m.tag===3?m.stateNode:null}function Tt(m){m!==Lh&&m.next===null&&(Lh===null?nf=Lh=m:Lh=Lh.next=m),tm=!0,em||(em=!0,Ye(kt))}function Et(m,x){if(!ul&&tm){ul=!0;do for(var C=!1,N=nf;N!==null;){if(m!==0){var k=N.pendingLanes;if(k===0)var z=0;else{var ie=N.suspendedLanes,_e=N.pingedLanes;z=(1<<31-Mr(42|m)+1)-1,z&=k&~(ie&~_e),z=z&201326677?z&201326677|1:z?z|2:0}z!==0&&(C=!0,Ie(N,z))}else z=Kn,z=R(N,N===ts?z:0),(z&3)===0||D(N,z)||(C=!0,Ie(N,z));N=N.next}while(C);ul=!1}}function kt(){tm=em=!1;var m=0;Bu!==0&&(Du()&&(m=Bu),Bu=0);for(var x=Ea(),C=null,N=nf;N!==null;){var k=N.next,z=ce(N,x);z===0?(N.next=null,C===null?nf=k:C.next=k,k===null&&(Lh=C)):(C=N,(m!==0||(z&3)!==0)&&(tm=!0)),N=k}Et(m)}function ce(m,x){for(var C=m.suspendedLanes,N=m.pingedLanes,k=m.expirationTimes,z=m.pendingLanes&-62914561;0<z;){var ie=31-Mr(z),_e=1<<ie,ke=k[ie];ke===-1?((_e&C)===0||(_e&N)!==0)&&(k[ie]=F(_e,x)):ke<=x&&(m.expiredLanes|=_e),z&=~_e}if(x=ts,C=Kn,C=R(m,m===x?C:0),N=m.callbackNode,C===0||m===x&&$s===2||m.cancelPendingCommit!==null)return N!==null&&N!==null&&Kp(N),m.callbackNode=null,m.callbackPriority=0;if((C&3)===0||D(m,C)){if(x=C&-C,x===m.callbackPriority)return x;switch(N!==null&&Kp(N),Q(C)){case 2:case 8:C=ww;break;case 32:C=M0;break;case 268435456:C=N0;break;default:C=M0}return N=J.bind(null,m),C=Zd(C,N),m.callbackPriority=x,m.callbackNode=C,x}return N!==null&&N!==null&&Kp(N),m.callbackPriority=2,m.callbackNode=null,2}function J(m,x){var C=m.callbackNode;if(da()&&m.callbackNode!==C)return null;var N=Kn;return N=R(m,m===ts?N:0),N===0?null:(Dp(m,N,x),ce(m,Ea()),m.callbackNode!=null&&m.callbackNode===C?J.bind(null,m):null)}function Ie(m,x){if(da())return null;Dp(m,x,!0)}function Ye(m){$i?x0(function(){(yn&6)!==0?Zd(Ub,m):m()}):Zd(Ub,m)}function lt(){return Bu===0&&(Bu=U()),Bu}function Ve(m,x){if(nm===null){var C=nm=[];I0=0,Rr=lt(),ku={status:"pending",value:void 0,then:function(N){C.push(N)}}}return I0++,x.then(Gt,Gt),x}function Gt(){if(--I0===0&&nm!==null){ku!==null&&(ku.status="fulfilled");var m=nm;nm=null,Rr=0,ku=null;for(var x=0;x<m.length;x++)(0,m[x])()}}function Lt(m,x){var C=[],N={status:"pending",value:null,reason:null,then:function(k){C.push(k)}};return m.then(function(){N.status="fulfilled",N.value=x;for(var k=0;k<C.length;k++)(0,C[k])(x)},function(k){for(N.status="rejected",N.reason=k,k=0;k<C.length;k++)(0,C[k])(void 0)}),N}function tn(m){m.updateQueue={baseState:m.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Jt(m,x){m=m.updateQueue,x.updateQueue===m&&(x.updateQueue={baseState:m.baseState,firstBaseUpdate:m.firstBaseUpdate,lastBaseUpdate:m.lastBaseUpdate,shared:m.shared,callbacks:null})}function at(m){return{lane:m,tag:0,payload:null,callback:null,next:null}}function ut(m,x,C){var N=m.updateQueue;if(N===null)return null;if(N=N.shared,(yn&2)!==0){var k=N.pending;return k===null?x.next=x:(x.next=k.next,k.next=x),N.pending=x,x=gt(m),ft(m,null,C),x}return oe(m,N,x,C),gt(m)}function Zt(m,x,C){if(x=x.updateQueue,x!==null&&(x=x.shared,(C&4194176)!==0)){var N=x.lanes;N&=m.pendingLanes,C|=N,x.lanes=C,Z(m,C)}}function xe(m,x){var C=m.updateQueue,N=m.alternate;if(N!==null&&(N=N.updateQueue,C===N)){var k=null,z=null;if(C=C.firstBaseUpdate,C!==null){do{var ie={lane:C.lane,tag:C.tag,payload:C.payload,callback:null,next:null};z===null?k=z=ie:z=z.next=ie,C=C.next}while(C!==null);z===null?k=z=x:z=z.next=x}else k=z=x;C={baseState:N.baseState,firstBaseUpdate:k,lastBaseUpdate:z,shared:N.shared,callbacks:N.callbacks},m.updateQueue=C;return}m=C.lastBaseUpdate,m===null?C.firstBaseUpdate=x:m.next=x,C.lastBaseUpdate=x}function Fe(){if(sf){var m=ku;if(m!==null)throw m}}function mt(m,x,C,N){sf=!1;var k=m.updateQueue;Mc=!1;var z=k.firstBaseUpdate,ie=k.lastBaseUpdate,_e=k.shared.pending;if(_e!==null){k.shared.pending=null;var ke=_e,ht=ke.next;ke.next=null,ie===null?z=ht:ie.next=ht,ie=ke;var Ot=m.alternate;Ot!==null&&(Ot=Ot.updateQueue,_e=Ot.lastBaseUpdate,_e!==ie&&(_e===null?Ot.firstBaseUpdate=ht:_e.next=ht,Ot.lastBaseUpdate=ke))}if(z!==null){var Vt=k.baseState;ie=0,Ot=ht=ke=null,_e=z;do{var Yt=_e.lane&-536870913,Dn=Yt!==_e.lane;if(Dn?(Kn&Yt)===Yt:(N&Yt)===Yt){Yt!==0&&Yt===Rr&&(sf=!0),Ot!==null&&(Ot=Ot.next={lane:0,tag:_e.tag,payload:_e.payload,callback:null,next:null});e:{var Br=m,rm=_e;Yt=x;var Hh=C;switch(rm.tag){case 1:if(Br=rm.payload,typeof Br=="function"){Vt=Br.call(Hh,Vt,Yt);break e}Vt=Br;break e;case 3:Br.flags=Br.flags&-65537|128;case 0:if(Br=rm.payload,Yt=typeof Br=="function"?Br.call(Hh,Vt,Yt):Br,Yt==null)break e;Vt=Rh({},Vt,Yt);break e;case 2:Mc=!0}}Yt=_e.callback,Yt!==null&&(m.flags|=64,Dn&&(m.flags|=8192),Dn=k.callbacks,Dn===null?k.callbacks=[Yt]:Dn.push(Yt))}else Dn={lane:Yt,tag:_e.tag,payload:_e.payload,callback:_e.callback,next:null},Ot===null?(ht=Ot=Dn,ke=Vt):Ot=Ot.next=Dn,ie|=Yt;if(_e=_e.next,_e===null){if(_e=k.shared.pending,_e===null)break;Dn=_e,_e=Dn.next,Dn.next=null,k.lastBaseUpdate=Dn,k.shared.pending=null}}while(!0);Ot===null&&(ke=Vt),k.baseState=ke,k.firstBaseUpdate=ht,k.lastBaseUpdate=Ot,z===null&&(k.shared.lanes=0),ho|=ie,m.lanes=ie,m.memoizedState=Vt}}function ge(m,x){if(typeof m!="function")throw Error(i(191,m));m.call(x)}function Ue(m,x){var C=m.callbacks;if(C!==null)for(m.callbacks=null,m=0;m<C.length;m++)ge(C[m],x)}function At(m,x){if(so(m,x))return!0;if(typeof m!="object"||m===null||typeof x!="object"||x===null)return!1;var C=Object.keys(m),N=Object.keys(x);if(C.length!==N.length)return!1;for(N=0;N<C.length;N++){var k=C[N];if(!sm.call(x,k)||!so(m[k],x[k]))return!1}return!0}function Rt(m){return m=m.status,m==="fulfilled"||m==="rejected"}function St(){}function dt(m,x,C){switch(C=m[C],C===void 0?m.push(x):C!==x&&(x.then(St,St),x=C),x.status){case"fulfilled":return x.value;case"rejected":throw m=x.reason,m===Fs?Error(i(483)):m;default:if(typeof x.status=="string")x.then(St,St);else{if(m=ts,m!==null&&100<m.shellSuspendCounter)throw Error(i(482));m=x,m.status="pending",m.then(function(N){if(x.status==="pending"){var k=x;k.status="fulfilled",k.value=N}},function(N){if(x.status==="pending"){var k=x;k.status="rejected",k.reason=N}})}switch(x.status){case"fulfilled":return x.value;case"rejected":throw m=x.reason,m===Fs?Error(i(483)):m}throw Fh=x,Fs}}function Ut(){if(Fh===null)throw Error(i(459));var m=Fh;return Fh=null,m}function cn(m){var x=Po;return Po+=1,$l===null&&($l=[]),dt($l,m,x)}function Wn(m,x){x=x.props.ref,m.ref=x!==void 0?x:null}function Fn(m,x){throw x.$$typeof===ib?Error(i(525)):(m=Object.prototype.toString.call(x),Error(i(31,m==="[object Object]"?"object with keys {"+Object.keys(x).join(", ")+"}":m)))}function ei(m){var x=m._init;return x(m._payload)}function Ni(m){function x(He,Oe){if(m){var Xe=He.deletions;Xe===null?(He.deletions=[Oe],He.flags|=16):Xe.push(Oe)}}function C(He,Oe){if(!m)return null;for(;Oe!==null;)x(He,Oe),Oe=Oe.sibling;return null}function N(He){for(var Oe=new Map;He!==null;)He.key!==null?Oe.set(He.key,He):Oe.set(He.index,He),He=He.sibling;return Oe}function k(He,Oe){return He=Ga(He,Oe),He.index=0,He.sibling=null,He}function z(He,Oe,Xe){return He.index=Xe,m?(Xe=He.alternate,Xe!==null?(Xe=Xe.index,Xe<Oe?(He.flags|=33554434,Oe):Xe):(He.flags|=33554434,Oe)):(He.flags|=1048576,Oe)}function ie(He){return m&&He.alternate===null&&(He.flags|=33554434),He}function _e(He,Oe,Xe,Nt){return Oe===null||Oe.tag!==6?(Oe=Cu(Xe,He.mode,Nt),Oe.return=He,Oe):(Oe=k(Oe,Xe),Oe.return=He,Oe)}function ke(He,Oe,Xe,Nt){var pn=Xe.type;return pn===jd?Ot(He,Oe,Xe.props.children,Nt,Xe.key):Oe!==null&&(Oe.elementType===pn||typeof pn=="object"&&pn!==null&&pn.$$typeof===ol&&ei(pn)===Oe.type)?(Oe=k(Oe,Xe.props),Wn(Oe,Xe),Oe.return=He,Oe):(Oe=ko(Xe.type,Xe.key,Xe.props,null,He.mode,Nt),Wn(Oe,Xe),Oe.return=He,Oe)}function ht(He,Oe,Xe,Nt){return Oe===null||Oe.tag!==4||Oe.stateNode.containerInfo!==Xe.containerInfo||Oe.stateNode.implementation!==Xe.implementation?(Oe=Wd(Xe,He.mode,Nt),Oe.return=He,Oe):(Oe=k(Oe,Xe.children||[]),Oe.return=He,Oe)}function Ot(He,Oe,Xe,Nt,pn){return Oe===null||Oe.tag!==7?(Oe=_c(Xe,He.mode,Nt,pn),Oe.return=He,Oe):(Oe=k(Oe,Xe),Oe.return=He,Oe)}function Vt(He,Oe,Xe){if(typeof Oe=="string"&&Oe!==""||typeof Oe=="number"||typeof Oe=="bigint")return Oe=Cu(""+Oe,He.mode,Xe),Oe.return=He,Oe;if(typeof Oe=="object"&&Oe!==null){switch(Oe.$$typeof){case Ac:return Xe=ko(Oe.type,Oe.key,Oe.props,null,He.mode,Xe),Wn(Xe,Oe),Xe.return=He,Xe;case rl:return Oe=Wd(Oe,He.mode,Xe),Oe.return=He,Oe;case ol:var Nt=Oe._init;return Oe=Nt(Oe._payload),Vt(He,Oe,Xe)}if(Nu(Oe)||a(Oe))return Oe=_c(Oe,He.mode,Xe,null),Oe.return=He,Oe;if(typeof Oe.then=="function")return Vt(He,cn(Oe),Xe);if(Oe.$$typeof===kl)return Vt(He,Ep(He,Oe),Xe);Fn(He,Oe)}return null}function Yt(He,Oe,Xe,Nt){var pn=Oe!==null?Oe.key:null;if(typeof Xe=="string"&&Xe!==""||typeof Xe=="number"||typeof Xe=="bigint")return pn!==null?null:_e(He,Oe,""+Xe,Nt);if(typeof Xe=="object"&&Xe!==null){switch(Xe.$$typeof){case Ac:return Xe.key===pn?ke(He,Oe,Xe,Nt):null;case rl:return Xe.key===pn?ht(He,Oe,Xe,Nt):null;case ol:return pn=Xe._init,Xe=pn(Xe._payload),Yt(He,Oe,Xe,Nt)}if(Nu(Xe)||a(Xe))return pn!==null?null:Ot(He,Oe,Xe,Nt,null);if(typeof Xe.then=="function")return Yt(He,Oe,cn(Xe),Nt);if(Xe.$$typeof===kl)return Yt(He,Oe,Ep(He,Xe),Nt);Fn(He,Xe)}return null}function Dn(He,Oe,Xe,Nt,pn){if(typeof Nt=="string"&&Nt!==""||typeof Nt=="number"||typeof Nt=="bigint")return He=He.get(Xe)||null,_e(Oe,He,""+Nt,pn);if(typeof Nt=="object"&&Nt!==null){switch(Nt.$$typeof){case Ac:return He=He.get(Nt.key===null?Xe:Nt.key)||null,ke(Oe,He,Nt,pn);case rl:return He=He.get(Nt.key===null?Xe:Nt.key)||null,ht(Oe,He,Nt,pn);case ol:var Ys=Nt._init;return Nt=Ys(Nt._payload),Dn(He,Oe,Xe,Nt,pn)}if(Nu(Nt)||a(Nt))return He=He.get(Xe)||null,Ot(Oe,He,Nt,pn,null);if(typeof Nt.then=="function")return Dn(He,Oe,Xe,cn(Nt),pn);if(Nt.$$typeof===kl)return Dn(He,Oe,Xe,Ep(Oe,Nt),pn);Fn(Oe,Nt)}return null}function Br(He,Oe,Xe,Nt){for(var pn=null,Ys=null,Mn=Oe,_s=Oe=0,ta=null;Mn!==null&&_s<Xe.length;_s++){Mn.index>_s?(ta=Mn,Mn=null):ta=Mn.sibling;var As=Yt(He,Mn,Xe[_s],Nt);if(As===null){Mn===null&&(Mn=ta);break}m&&Mn&&As.alternate===null&&x(He,Mn),Oe=z(As,Oe,_s),Ys===null?pn=As:Ys.sibling=As,Ys=As,Mn=ta}if(_s===Xe.length)return C(He,Mn),bs&&le(He,_s),pn;if(Mn===null){for(;_s<Xe.length;_s++)Mn=Vt(He,Xe[_s],Nt),Mn!==null&&(Oe=z(Mn,Oe,_s),Ys===null?pn=Mn:Ys.sibling=Mn,Ys=Mn);return bs&&le(He,_s),pn}for(Mn=N(Mn);_s<Xe.length;_s++)ta=Dn(Mn,He,_s,Xe[_s],Nt),ta!==null&&(m&&ta.alternate!==null&&Mn.delete(ta.key===null?_s:ta.key),Oe=z(ta,Oe,_s),Ys===null?pn=ta:Ys.sibling=ta,Ys=ta);return m&&Mn.forEach(function(kc){return x(He,kc)}),bs&&le(He,_s),pn}function rm(He,Oe,Xe,Nt){if(Xe==null)throw Error(i(151));for(var pn=null,Ys=null,Mn=Oe,_s=Oe=0,ta=null,As=Xe.next();Mn!==null&&!As.done;_s++,As=Xe.next()){Mn.index>_s?(ta=Mn,Mn=null):ta=Mn.sibling;var kc=Yt(He,Mn,As.value,Nt);if(kc===null){Mn===null&&(Mn=ta);break}m&&Mn&&kc.alternate===null&&x(He,Mn),Oe=z(kc,Oe,_s),Ys===null?pn=kc:Ys.sibling=kc,Ys=kc,Mn=ta}if(As.done)return C(He,Mn),bs&&le(He,_s),pn;if(Mn===null){for(;!As.done;_s++,As=Xe.next())As=Vt(He,As.value,Nt),As!==null&&(Oe=z(As,Oe,_s),Ys===null?pn=As:Ys.sibling=As,Ys=As);return bs&&le(He,_s),pn}for(Mn=N(Mn);!As.done;_s++,As=Xe.next())As=Dn(Mn,He,_s,As.value,Nt),As!==null&&(m&&As.alternate!==null&&Mn.delete(As.key===null?_s:As.key),Oe=z(As,Oe,_s),Ys===null?pn=As:Ys.sibling=As,Ys=As);return m&&Mn.forEach(function(z0){return x(He,z0)}),bs&&le(He,_s),pn}function Hh(He,Oe,Xe,Nt){if(typeof Xe=="object"&&Xe!==null&&Xe.type===jd&&Xe.key===null&&(Xe=Xe.props.children),typeof Xe=="object"&&Xe!==null){switch(Xe.$$typeof){case Ac:e:{for(var pn=Xe.key;Oe!==null;){if(Oe.key===pn){if(pn=Xe.type,pn===jd){if(Oe.tag===7){C(He,Oe.sibling),Nt=k(Oe,Xe.props.children),Nt.return=He,He=Nt;break e}}else if(Oe.elementType===pn||typeof pn=="object"&&pn!==null&&pn.$$typeof===ol&&ei(pn)===Oe.type){C(He,Oe.sibling),Nt=k(Oe,Xe.props),Wn(Nt,Xe),Nt.return=He,He=Nt;break e}C(He,Oe);break}else x(He,Oe);Oe=Oe.sibling}Xe.type===jd?(Nt=_c(Xe.props.children,He.mode,Nt,Xe.key),Nt.return=He,He=Nt):(Nt=ko(Xe.type,Xe.key,Xe.props,null,He.mode,Nt),Wn(Nt,Xe),Nt.return=He,He=Nt)}return ie(He);case rl:e:{for(pn=Xe.key;Oe!==null;){if(Oe.key===pn)if(Oe.tag===4&&Oe.stateNode.containerInfo===Xe.containerInfo&&Oe.stateNode.implementation===Xe.implementation){C(He,Oe.sibling),Nt=k(Oe,Xe.children||[]),Nt.return=He,He=Nt;break e}else{C(He,Oe);break}else x(He,Oe);Oe=Oe.sibling}Nt=Wd(Xe,He.mode,Nt),Nt.return=He,He=Nt}return ie(He);case ol:return pn=Xe._init,Xe=pn(Xe._payload),Hh(He,Oe,Xe,Nt)}if(Nu(Xe))return Br(He,Oe,Xe,Nt);if(a(Xe)){if(pn=a(Xe),typeof pn!="function")throw Error(i(150));return Xe=pn.call(Xe),rm(He,Oe,Xe,Nt)}if(typeof Xe.then=="function")return Hh(He,Oe,cn(Xe),Nt);if(Xe.$$typeof===kl)return Hh(He,Oe,Ep(He,Xe),Nt);Fn(He,Xe)}return typeof Xe=="string"&&Xe!==""||typeof Xe=="number"||typeof Xe=="bigint"?(Xe=""+Xe,Oe!==null&&Oe.tag===6?(C(He,Oe.sibling),Nt=k(Oe,Xe),Nt.return=He,He=Nt):(C(He,Oe),Nt=Cu(Xe,He.mode,Nt),Nt.return=He,He=Nt),ie(He)):C(He,Oe)}return function(He,Oe,Xe,Nt){try{Po=0;var pn=Hh(He,Oe,Xe,Nt);return $l=null,pn}catch(Mn){if(Mn===Fs)throw Mn;var Ys=t(29,Mn,null,He.mode);return Ys.lanes=Nt,Ys.return=He,Ys}finally{}}}function xh(m,x){m=hl,w(lo,m),w(Gl,x),hl=m|x.baseLanes}function fc(){w(lo,hl),w(Gl,Gl.current)}function Oo(){hl=lo.current,b(Gl),b(lo)}function zi(m){var x=m.alternate;w(Gi,Gi.current&1),w(co,m),zo===null&&(x===null||Gl.current!==null||x.memoizedState!==null)&&(zo=m)}function Ar(m){if(m.tag===22){if(w(Gi,Gi.current),w(co,m),zo===null){var x=m.alternate;x!==null&&x.memoizedState!==null&&(zo=m)}}else ca()}function ca(){w(Gi,Gi.current),w(co,co.current)}function Cn(m){b(co),zo===m&&(zo=null),b(Gi)}function Ji(m){for(var x=m;x!==null;){if(x.tag===13){var C=x.memoizedState;if(C!==null&&(C=C.dehydrated,C===null||_0(C)||Wp(C)))return x}else if(x.tag===19&&x.memoizedProps.revealOrder!==void 0){if((x.flags&128)!==0)return x}else if(x.child!==null){x.child.return=x,x=x.child;continue}if(x===m)break;for(;x.sibling===null;){if(x.return===null||x.return===m)return null;x=x.return}x.sibling.return=x.return,x=x.sibling}return null}function Un(){throw Error(i(321))}function j(m,x){if(x===null)return!1;for(var C=0;C<x.length&&C<m.length;C++)if(!so(m[C],x[C]))return!1;return!0}function ae(m,x,C,N,k,z){return Vl=z,$n=x,x.memoizedState=null,x.updateQueue=null,x.lanes=0,An.H=m===null||m.memoizedState===null?Vi:Wa,Nc=!1,z=C(N,k),Nc=!1,ii&&(z=We(x,C,N,k)),Ce(m),z}function Ce(m){An.H=Ss;var x=Is!==null&&Is.next!==null;if(Vl=0,Ii=Is=$n=null,$o=!1,yi=0,af=null,x)throw Error(i(300));m===null||Di||(m=m.dependencies,m!==null&&pu(m)&&(Di=!0))}function We(m,x,C,N){$n=m;var k=0;do{if(ii&&(af=null),yi=0,ii=!1,25<=k)throw Error(i(301));if(k+=1,Ii=Is=null,m.updateQueue!=null){var z=m.updateQueue;z.lastEffect=null,z.events=null,z.stores=null,z.memoCache!=null&&(z.memoCache.index=0)}An.H=Fu,z=x(C,N)}while(ii);return z}function st(){var m=An.H,x=m.useState()[0];return x=typeof x.then=="function"?de(x):x,m=m.useState()[0],(Is!==null?Is.memoizedState:null)!==m&&($n.flags|=1024),x}function tt(){var m=im!==0;return im=0,m}function Mt(m,x,C){x.updateQueue=m.updateQueue,x.flags&=-2053,m.lanes&=~C}function wt(m){if($o){for(m=m.memoizedState;m!==null;){var x=m.queue;x!==null&&(x.pending=null),m=m.next}$o=!1}Vl=0,Ii=Is=$n=null,ii=!1,yi=im=0,af=null}function Ct(){var m={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ii===null?$n.memoizedState=Ii=m:Ii=Ii.next=m,Ii}function X(){if(Is===null){var m=$n.alternate;m=m!==null?m.memoizedState:null}else m=Is.next;var x=Ii===null?$n.memoizedState:Ii.next;if(x!==null)Ii=x,Is=m;else{if(m===null)throw $n.alternate===null?Error(i(467)):Error(i(310));Is=m,m={memoizedState:Is.memoizedState,baseState:Is.baseState,baseQueue:Is.baseQueue,queue:Is.queue,next:null},Ii===null?$n.memoizedState=Ii=m:Ii=Ii.next=m}return Ii}function de(m){var x=yi;return yi+=1,af===null&&(af=[]),m=dt(af,m,x),x=$n,(Ii===null?x.memoizedState:Ii.next)===null&&(x=x.alternate,An.H=x===null||x.memoizedState===null?Vi:Wa),m}function Se(m){if(m!==null&&typeof m=="object"){if(typeof m.then=="function")return de(m);if(m.$$typeof===kl)return Aa(m)}throw Error(i(438,String(m)))}function De(m){var x=null,C=$n.updateQueue;if(C!==null&&(x=C.memoCache),x==null){var N=$n.alternate;N!==null&&(N=N.updateQueue,N!==null&&(N=N.memoCache,N!=null&&(x={data:N.data.map(function(k){return k.slice()}),index:0})))}if(x==null&&(x={data:[],index:0}),C===null&&(C=O0(),$n.updateQueue=C),C.memoCache=x,C=x.data[x.index],C===void 0)for(C=x.data[x.index]=Array(m),N=0;N<m;N++)C[N]=QA;return x.index++,C}function ye(m,x){return typeof x=="function"?x(m):x}function Ke(m){var x=X();return ct(x,Is,m)}function ct(m,x,C){var N=m.queue;if(N===null)throw Error(i(311));N.lastRenderedReducer=C;var k=m.baseQueue,z=N.pending;if(z!==null){if(k!==null){var ie=k.next;k.next=z.next,z.next=ie}x.baseQueue=k=z,N.pending=null}if(z=m.baseState,k===null)m.memoizedState=z;else{x=k.next;var _e=ie=null,ke=null,ht=x,Ot=!1;do{var Vt=ht.lane&-536870913;if(Vt!==ht.lane?(Kn&Vt)===Vt:(Vl&Vt)===Vt){var Yt=ht.revertLane;if(Yt===0)ke!==null&&(ke=ke.next={lane:0,revertLane:0,action:ht.action,hasEagerState:ht.hasEagerState,eagerState:ht.eagerState,next:null}),Vt===Rr&&(Ot=!0);else if((Vl&Yt)===Yt){ht=ht.next,Yt===Rr&&(Ot=!0);continue}else Vt={lane:0,revertLane:ht.revertLane,action:ht.action,hasEagerState:ht.hasEagerState,eagerState:ht.eagerState,next:null},ke===null?(_e=ke=Vt,ie=z):ke=ke.next=Vt,$n.lanes|=Yt,ho|=Yt;Vt=ht.action,Nc&&C(z,Vt),z=ht.hasEagerState?ht.eagerState:C(z,Vt)}else Yt={lane:Vt,revertLane:ht.revertLane,action:ht.action,hasEagerState:ht.hasEagerState,eagerState:ht.eagerState,next:null},ke===null?(_e=ke=Yt,ie=z):ke=ke.next=Yt,$n.lanes|=Vt,ho|=Vt;ht=ht.next}while(ht!==null&&ht!==x);if(ke===null?ie=z:ke.next=_e,!so(z,m.memoizedState)&&(Di=!0,Ot&&(C=ku,C!==null)))throw C;m.memoizedState=z,m.baseState=ie,m.baseQueue=ke,N.lastRenderedState=z}return k===null&&(N.lanes=0),[m.memoizedState,N.dispatch]}function vt(m){var x=X(),C=x.queue;if(C===null)throw Error(i(311));C.lastRenderedReducer=m;var N=C.dispatch,k=C.pending,z=x.memoizedState;if(k!==null){C.pending=null;var ie=k=k.next;do z=m(z,ie.action),ie=ie.next;while(ie!==k);so(z,x.memoizedState)||(Di=!0),x.memoizedState=z,x.baseQueue===null&&(x.baseState=z),C.lastRenderedState=z}return[z,N]}function It(m,x,C){var N=$n,k=X(),z=bs;if(z){if(C===void 0)throw Error(i(407));C=C()}else C=x();var ie=!so((Is||k).memoizedState,C);if(ie&&(k.memoizedState=C,Di=!0),k=k.queue,xp(jt.bind(null,N,k,m),[m]),k.getSnapshot!==x||ie||Ii!==null&&Ii.memoizedState.tag&1){if(N.flags|=2048,pi(9,Kt.bind(null,N,k,C,x),{destroy:void 0},null),ts===null)throw Error(i(349));z||(Vl&60)!==0||Pt(N,x,C)}return C}function Pt(m,x,C){m.flags|=16384,m={getSnapshot:x,value:C},x=$n.updateQueue,x===null?(x=O0(),$n.updateQueue=x,x.stores=[m]):(C=x.stores,C===null?x.stores=[m]:C.push(m))}function Kt(m,x,C,N){x.value=C,x.getSnapshot=N,Qt(x)&&In(m)}function jt(m,x,C){return C(function(){Qt(x)&&In(m)})}function Qt(m){var x=m.getSnapshot;m=m.value;try{var C=x();return!so(m,C)}catch{return!0}}function In(m){var x=it(m,2);x!==null&&$a(x,m,2)}function hn(m){var x=Ct();if(typeof m=="function"){var C=m;if(m=C(),Nc){W(!0);try{C()}finally{W(!1)}}}return x.memoizedState=x.baseState=m,x.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ye,lastRenderedState:m},x}function bn(m,x,C,N){return m.baseState=C,ct(m,Is,typeof N=="function"?N:ye)}function jn(m,x,C,N,k){if(bh(m))throw Error(i(485));if(m=x.action,m!==null){var z={payload:k,action:m,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(ie){z.listeners.push(ie)}};An.T!==null?C(!0):z.isTransition=!1,N(z),C=x.pending,C===null?(z.next=x.pending=z,dn(x,z)):(z.next=C.next,x.pending=C.next=z)}}function dn(m,x){var C=x.action,N=x.payload,k=m.state;if(x.isTransition){var z=An.T,ie={};An.T=ie;try{var _e=C(k,N),ke=An.S;ke!==null&&ke(ie,_e),zn(m,x,_e)}catch(ht){ss(m,x,ht)}finally{An.T=z}}else try{z=C(k,N),zn(m,x,z)}catch(ht){ss(m,x,ht)}}function zn(m,x,C){C!==null&&typeof C=="object"&&typeof C.then=="function"?C.then(function(N){nn(m,x,N)},function(N){return ss(m,x,N)}):nn(m,x,C)}function nn(m,x,C){x.status="fulfilled",x.value=C,ms(x),m.state=C,x=m.pending,x!==null&&(C=x.next,C===x?m.pending=null:(C=C.next,x.next=C,dn(m,C)))}function ss(m,x,C){var N=m.pending;if(m.pending=null,N!==null){N=N.next;do x.status="rejected",x.reason=C,ms(x),x=x.next;while(x!==N)}m.action=null}function ms(m){m=m.listeners;for(var x=0;x<m.length;x++)(0,m[x])()}function mn(m,x){return x}function li(m,x){if(bs){var C=ts.formState;if(C!==null){e:{var N=$n;if(bs){if(Ma){var k=rw(Ma,Uo);if(k){Ma=Tb(k),N=ow(k);break e}}Ge(N)}N=!1}N&&(x=C[0])}}C=Ct(),C.memoizedState=C.baseState=x,N={pending:null,lanes:0,dispatch:null,lastRenderedReducer:mn,lastRenderedState:x},C.queue=N,C=Hg.bind(null,$n,N),N.dispatch=C,N=hn(!1);var z=Wg.bind(null,$n,!1,N.queue);return N=Ct(),k={state:x,dispatch:null,action:m,pending:null},N.queue=k,C=jn.bind(null,$n,k,z,C),k.dispatch=C,N.memoizedState=m,[x,C,!1]}function cs(m){var x=X();return vs(x,Is,m)}function vs(m,x,C){x=ct(m,x,mn)[0],m=Ke(ye)[0],x=typeof x=="object"&&x!==null&&typeof x.then=="function"?de(x):x;var N=X(),k=N.queue,z=k.dispatch;return C!==N.memoizedState&&($n.flags|=2048,pi(9,Ps.bind(null,k,C),{destroy:void 0},null)),[x,z,m]}function Ps(m,x){m.action=x}function Zi(m){var x=X(),C=Is;if(C!==null)return vs(x,C,m);X(),x=x.memoizedState,C=X();var N=C.queue.dispatch;return C.memoizedState=m,[x,N,!1]}function pi(m,x,C,N){return m={tag:m,create:x,inst:C,deps:N,next:null},x=$n.updateQueue,x===null&&(x=O0(),$n.updateQueue=x),C=x.lastEffect,C===null?x.lastEffect=m.next=m:(N=C.next,C.next=m,m.next=N,x.lastEffect=m),m}function nl(){return X().memoizedState}function Bo(m,x,C,N){var k=Ct();$n.flags|=m,k.memoizedState=pi(1|x,C,{destroy:void 0},N===void 0?null:N)}function gp(m,x,C,N){var k=X();N=N===void 0?null:N;var z=k.memoizedState.inst;Is!==null&&N!==null&&j(N,Is.memoizedState.deps)?k.memoizedState=pi(x,C,z,N):($n.flags|=m,k.memoizedState=pi(1|x,C,z,N))}function Nv(m,x){Bo(8390656,8,m,x)}function xp(m,x){gp(2048,8,m,x)}function MA(m,x){return gp(4,2,m,x)}function NA(m,x){return gp(4,4,m,x)}function yp(m,x){if(typeof x=="function"){m=m();var C=x(m);return function(){typeof C=="function"?C():x(null)}}if(x!=null)return m=m(),x.current=m,function(){x.current=null}}function Ml(m,x,C){C=C!=null?C.concat([m]):null,gp(4,4,yp.bind(null,x,m),C)}function vp(){}function $g(m,x){var C=X();x=x===void 0?null:x;var N=C.memoizedState;return x!==null&&j(x,N[1])?N[0]:(C.memoizedState=[m,x],m)}function yh(m,x){var C=X();x=x===void 0?null:x;var N=C.memoizedState;if(x!==null&&j(x,N[1]))return N[0];if(N=m(),Nc){W(!0);try{m()}finally{W(!1)}}return C.memoizedState=[N,x],N}function cu(m,x,C){return C===void 0||(Vl&1073741824)!==0?m.memoizedState=x:(m.memoizedState=C,m=Il(),$n.lanes|=m,ho|=m,C)}function Rv(m,x,C,N){return so(C,x)?C:Gl.current!==null?(m=cu(m,C,N),so(m,x)||(Di=!0),m):(Vl&42)===0?(Di=!0,m.memoizedState=C):(m=Il(),$n.lanes|=m,ho|=m,x)}function Gg(m,x,C,N,k){var z=Qi();Va(z!==0&&8>z?z:8);var ie=An.T,_e={};An.T=_e,Wg(m,!1,x,C);try{var ke=k(),ht=An.S;if(ht!==null&&ht(_e,ke),ke!==null&&typeof ke=="object"&&typeof ke.then=="function"){var Ot=Lt(ke,N);hu(m,x,Ot,cr(m))}else hu(m,x,N,cr(m))}catch(Vt){hu(m,x,{then:function(){},status:"rejected",reason:Vt},cr())}finally{Va(z),An.T=ie}}function Iv(m){var x=m.memoizedState;if(x!==null)return x;x={memoizedState:Er,baseState:Er,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ye,lastRenderedState:Er},next:null};var C={};return x.next={memoizedState:C,baseState:C,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ye,lastRenderedState:C},next:null},m.memoizedState=x,m=m.alternate,m!==null&&(m.memoizedState=x),x}function vh(){return Aa(En)}function Nl(){return X().memoizedState}function Vg(){return X().memoizedState}function bp(m){for(var x=m.return;x!==null;){switch(x.tag){case 24:case 3:var C=cr();m=at(C);var N=ut(x,m,C);N!==null&&($a(N,x,C),Zt(N,x,C)),x={cache:Yg()},m.payload=x;return}x=x.return}}function uu(m,x,C){var N=cr();C={lane:N,revertLane:0,action:C,hasEagerState:!1,eagerState:null,next:null},bh(m)?Sp(x,C):(C=Ze(m,x,C,N),C!==null&&($a(C,m,N),Dv(C,x,N)))}function Hg(m,x,C){var N=cr();hu(m,x,C,N)}function hu(m,x,C,N){var k={lane:N,revertLane:0,action:C,hasEagerState:!1,eagerState:null,next:null};if(bh(m))Sp(x,k);else{var z=m.alternate;if(m.lanes===0&&(z===null||z.lanes===0)&&(z=x.lastRenderedReducer,z!==null))try{var ie=x.lastRenderedState,_e=z(ie,C);if(k.hasEagerState=!0,k.eagerState=_e,so(_e,ie))return oe(m,x,k,0),ts===null&&Je(),!1}catch{}finally{}if(C=Ze(m,x,k,N),C!==null)return $a(C,m,N),Dv(C,x,N),!0}return!1}function Wg(m,x,C,N){if(N={lane:2,revertLane:lt(),action:N,hasEagerState:!1,eagerState:null,next:null},bh(m)){if(x)throw Error(i(479))}else x=Ze(m,C,N,2),x!==null&&$a(x,m,2)}function bh(m){var x=m.alternate;return m===$n||x!==null&&x===$n}function Sp(m,x){ii=$o=!0;var C=m.pending;C===null?x.next=x:(x.next=C.next,C.next=x),m.pending=x}function Dv(m,x,C){if((C&4194176)!==0){var N=x.lanes;N&=m.pendingLanes,C|=N,x.lanes=C,Z(m,C)}}function Pa(m,x,C,N){x=m.memoizedState,C=C(N,x),C=C==null?x:Rh({},x,C),m.memoizedState=C,m.lanes===0&&(m.updateQueue.baseState=C)}function du(m,x,C,N,k,z,ie){return m=m.stateNode,typeof m.shouldComponentUpdate=="function"?m.shouldComponentUpdate(N,z,ie):x.prototype&&x.prototype.isPureReactComponent?!At(C,N)||!At(k,z):!0}function _p(m,x,C,N){m=x.state,typeof x.componentWillReceiveProps=="function"&&x.componentWillReceiveProps(C,N),typeof x.UNSAFE_componentWillReceiveProps=="function"&&x.UNSAFE_componentWillReceiveProps(C,N),x.state!==m&&B0.enqueueReplaceState(x,x.state,null)}function sl(m,x){var C=x;if("ref"in x){C={};for(var N in x)N!=="ref"&&(C[N]=x[N])}if(m=m.defaultProps){C===x&&(C=Rh({},C));for(var k in m)C[k]===void 0&&(C[k]=m[k])}return C}function jg(m,x){try{var C=m.onUncaughtError;C(x.value,{componentStack:x.stack})}catch(N){setTimeout(function(){throw N})}}function Xg(m,x,C){try{var N=m.onCaughtError;N(C.value,{componentStack:C.stack,errorBoundary:x.tag===1?x.stateNode:null})}catch(k){setTimeout(function(){throw k})}}function Ap(m,x,C){return C=at(C),C.tag=3,C.payload={element:null},C.callback=function(){jg(m,x)},C}function Id(m){return m=at(m),m.tag=3,m}function wp(m,x,C,N){var k=C.type.getDerivedStateFromError;if(typeof k=="function"){var z=N.value;m.payload=function(){return k(z)},m.callback=function(){Xg(x,C,N)}}var ie=C.stateNode;ie!==null&&typeof ie.componentDidCatch=="function"&&(m.callback=function(){Xg(x,C,N),typeof k!="function"&&(po===null?po=new Set([this]):po.add(this));var _e=N.stack;this.componentDidCatch(N.value,{componentStack:_e!==null?_e:""})})}function RA(m,x,C,N,k){if(C.flags|=32768,N!==null&&typeof N=="object"&&typeof N.then=="function"){if(x=C.alternate,x!==null&&Sh(x,C,k,!0),C=co.current,C!==null){switch(C.tag){case 13:return zo===null?Tr():C.alternate===null&&xs===0&&(xs=3),C.flags&=-257,C.flags|=65536,C.lanes=k,N===D0?C.flags|=16384:(x=C.updateQueue,x===null?C.updateQueue=new Set([N]):x.add(N),u0(m,N,k)),!1;case 22:return C.flags|=65536,N===D0?C.flags|=16384:(x=C.updateQueue,x===null?(x={transitions:null,markerInstances:null,retryQueue:new Set([N])},C.updateQueue=x):(C=x.retryQueue,C===null?x.retryQueue=new Set([N]):C.add(N)),u0(m,N,k)),!1}throw Error(i(435,C.tag))}return u0(m,N,k),Tr(),!1}if(bs)return x=co.current,x!==null?((x.flags&65536)===0&&(x.flags|=256),x.flags|=65536,x.lanes=k,N!==Qp&&(m=Error(i(422),{cause:N}),Bt(se(m,C)))):(N!==Qp&&(x=Error(i(423),{cause:N}),Bt(se(x,C))),m=m.current.alternate,m.flags|=65536,k&=-k,m.lanes|=k,N=se(N,C),k=Ap(m.stateNode,N,k),xe(m,k),xs!==4&&(xs=2)),!1;var z=Error(i(520),{cause:N});if(z=se(z,C),of===null?of=[z]:of.push(z),xs!==4&&(xs=2),x===null)return!0;N=se(N,C),C=x;do{switch(C.tag){case 3:return C.flags|=65536,m=k&-k,C.lanes|=m,m=Ap(C.stateNode,N,m),xe(C,m),!1;case 1:if(x=C.type,z=C.stateNode,(C.flags&128)===0&&(typeof x.getDerivedStateFromError=="function"||z!==null&&typeof z.componentDidCatch=="function"&&(po===null||!po.has(z))))return C.flags|=65536,k&=-k,C.lanes|=k,k=Id(k),wp(k,m,C,N),xe(C,k),!1}C=C.return}while(C!==null);return!1}function _a(m,x,C,N){x.child=m===null?$b(x,null,C,N):Lu(x,m.child,C,N)}function IA(m,x,C,N,k){C=C.render;var z=x.ref;if("ref"in N){var ie={};for(var _e in N)_e!=="ref"&&(ie[_e]=N[_e])}else ie=N;return _h(x),N=ae(m,x,C,ie,z,k),_e=tt(),m!==null&&!Di?(Mt(m,x,k),pc(m,x,k)):(bs&&_e&&re(x),x.flags|=1,_a(m,x,N,k),x.child)}function DA(m,x,C,N,k){if(m===null){var z=C.type;return typeof z=="function"&&!bc(z)&&z.defaultProps===void 0&&C.compare===null?(x.tag=15,x.type=z,qg(m,x,z,N,k)):(m=ko(C.type,null,N,x,x.mode,k),m.ref=x.ref,m.return=x,x.child=m)}if(z=m.child,!Pv(m,k)){var ie=z.memoizedProps;if(C=C.compare,C=C!==null?C:At,C(ie,N)&&m.ref===x.ref)return pc(m,x,k)}return x.flags|=1,m=Ga(z,N),m.ref=x.ref,m.return=x,x.child=m}function qg(m,x,C,N,k){if(m!==null){var z=m.memoizedProps;if(At(z,N)&&m.ref===x.ref)if(Di=!1,x.pendingProps=N=z,Pv(m,k))(m.flags&131072)!==0&&(Di=!0);else return x.lanes=m.lanes,pc(m,x,k)}return Ov(m,x,C,N,k)}function OA(m,x,C){var N=x.pendingProps,k=N.children,z=(x.stateNode._pendingVisibility&2)!==0,ie=m!==null?m.memoizedState:null;if(Cp(m,x),N.mode==="hidden"||z){if((x.flags&128)!==0){if(N=ie!==null?ie.baseLanes|C:C,m!==null){for(k=x.child=m.child,z=0;k!==null;)z=z|k.lanes|k.childLanes,k=k.sibling;x.childLanes=z&~N}else x.childLanes=0,x.child=null;return BA(m,x,N,C)}if((C&536870912)!==0)x.memoizedState={baseLanes:0,cachePool:null},m!==null&&Jg(x,ie!==null?ie.cachePool:null),ie!==null?xh(x,ie):fc(),Ar(x);else return x.lanes=x.childLanes=536870912,BA(m,x,ie!==null?ie.baseLanes|C:C,C)}else ie!==null?(Jg(x,ie.cachePool),xh(x,ie),ca(),x.memoizedState=null):(m!==null&&Jg(x,null),fc(),ca());return _a(m,x,k,C),x.child}function BA(m,x,C,N){var k=mu();return k=k===null?null:{parent:Fl?Ds._currentValue:Ds._currentValue2,pool:k},x.memoizedState={baseLanes:C,cachePool:k},m!==null&&Jg(x,null),fc(),Ar(x),m!==null&&Sh(m,x,N,!0),null}function Cp(m,x){var C=x.ref;if(C===null)m!==null&&m.ref!==null&&(x.flags|=2097664);else{if(typeof C!="function"&&typeof C!="object")throw Error(i(284));(m===null||m.ref!==C)&&(x.flags|=2097664)}}function Ov(m,x,C,N,k){return _h(x),C=ae(m,x,C,N,void 0,k),N=tt(),m!==null&&!Di?(Mt(m,x,k),pc(m,x,k)):(bs&&N&&re(x),x.flags|=1,_a(m,x,C,k),x.child)}function kA(m,x,C,N,k,z){return _h(x),x.updateQueue=null,C=We(x,N,C,k),Ce(m),N=tt(),m!==null&&!Di?(Mt(m,x,z),pc(m,x,z)):(bs&&N&&re(x),x.flags|=1,_a(m,x,C,z),x.child)}function Bv(m,x,C,N,k){if(_h(x),x.stateNode===null){var z=kh,ie=C.contextType;typeof ie=="object"&&ie!==null&&(z=Aa(ie)),z=new C(N,z),x.memoizedState=z.state!==null&&z.state!==void 0?z.state:null,z.updater=B0,x.stateNode=z,z._reactInternals=x,z=x.stateNode,z.props=N,z.state=x.memoizedState,z.refs={},tn(x),ie=C.contextType,z.context=typeof ie=="object"&&ie!==null?Aa(ie):kh,z.state=x.memoizedState,ie=C.getDerivedStateFromProps,typeof ie=="function"&&(Pa(x,C,ie,N),z.state=x.memoizedState),typeof C.getDerivedStateFromProps=="function"||typeof z.getSnapshotBeforeUpdate=="function"||typeof z.UNSAFE_componentWillMount!="function"&&typeof z.componentWillMount!="function"||(ie=z.state,typeof z.componentWillMount=="function"&&z.componentWillMount(),typeof z.UNSAFE_componentWillMount=="function"&&z.UNSAFE_componentWillMount(),ie!==z.state&&B0.enqueueReplaceState(z,z.state,null),mt(x,N,z,k),Fe(),z.state=x.memoizedState),typeof z.componentDidMount=="function"&&(x.flags|=4194308),N=!0}else if(m===null){z=x.stateNode;var _e=x.memoizedProps,ke=sl(C,_e);z.props=ke;var ht=z.context,Ot=C.contextType;ie=kh,typeof Ot=="object"&&Ot!==null&&(ie=Aa(Ot));var Vt=C.getDerivedStateFromProps;Ot=typeof Vt=="function"||typeof z.getSnapshotBeforeUpdate=="function",_e=x.pendingProps!==_e,Ot||typeof z.UNSAFE_componentWillReceiveProps!="function"&&typeof z.componentWillReceiveProps!="function"||(_e||ht!==ie)&&_p(x,z,N,ie),Mc=!1;var Yt=x.memoizedState;z.state=Yt,mt(x,N,z,k),Fe(),ht=x.memoizedState,_e||Yt!==ht||Mc?(typeof Vt=="function"&&(Pa(x,C,Vt,N),ht=x.memoizedState),(ke=Mc||du(x,C,ke,N,Yt,ht,ie))?(Ot||typeof z.UNSAFE_componentWillMount!="function"&&typeof z.componentWillMount!="function"||(typeof z.componentWillMount=="function"&&z.componentWillMount(),typeof z.UNSAFE_componentWillMount=="function"&&z.UNSAFE_componentWillMount()),typeof z.componentDidMount=="function"&&(x.flags|=4194308)):(typeof z.componentDidMount=="function"&&(x.flags|=4194308),x.memoizedProps=N,x.memoizedState=ht),z.props=N,z.state=ht,z.context=ie,N=ke):(typeof z.componentDidMount=="function"&&(x.flags|=4194308),N=!1)}else{z=x.stateNode,Jt(m,x),ie=x.memoizedProps,Ot=sl(C,ie),z.props=Ot,Vt=x.pendingProps,Yt=z.context,ht=C.contextType,ke=kh,typeof ht=="object"&&ht!==null&&(ke=Aa(ht)),_e=C.getDerivedStateFromProps,(ht=typeof _e=="function"||typeof z.getSnapshotBeforeUpdate=="function")||typeof z.UNSAFE_componentWillReceiveProps!="function"&&typeof z.componentWillReceiveProps!="function"||(ie!==Vt||Yt!==ke)&&_p(x,z,N,ke),Mc=!1,Yt=x.memoizedState,z.state=Yt,mt(x,N,z,k),Fe();var Dn=x.memoizedState;ie!==Vt||Yt!==Dn||Mc||m!==null&&m.dependencies!==null&&pu(m.dependencies)?(typeof _e=="function"&&(Pa(x,C,_e,N),Dn=x.memoizedState),(Ot=Mc||du(x,C,Ot,N,Yt,Dn,ke)||m!==null&&m.dependencies!==null&&pu(m.dependencies))?(ht||typeof z.UNSAFE_componentWillUpdate!="function"&&typeof z.componentWillUpdate!="function"||(typeof z.componentWillUpdate=="function"&&z.componentWillUpdate(N,Dn,ke),typeof z.UNSAFE_componentWillUpdate=="function"&&z.UNSAFE_componentWillUpdate(N,Dn,ke)),typeof z.componentDidUpdate=="function"&&(x.flags|=4),typeof z.getSnapshotBeforeUpdate=="function"&&(x.flags|=1024)):(typeof z.componentDidUpdate!="function"||ie===m.memoizedProps&&Yt===m.memoizedState||(x.flags|=4),typeof z.getSnapshotBeforeUpdate!="function"||ie===m.memoizedProps&&Yt===m.memoizedState||(x.flags|=1024),x.memoizedProps=N,x.memoizedState=Dn),z.props=N,z.state=Dn,z.context=ke,N=Ot):(typeof z.componentDidUpdate!="function"||ie===m.memoizedProps&&Yt===m.memoizedState||(x.flags|=4),typeof z.getSnapshotBeforeUpdate!="function"||ie===m.memoizedProps&&Yt===m.memoizedState||(x.flags|=1024),N=!1)}return z=N,Cp(m,x),N=(x.flags&128)!==0,z||N?(z=x.stateNode,C=N&&typeof C.getDerivedStateFromError!="function"?null:z.render(),x.flags|=1,m!==null&&N?(x.child=Lu(x,m.child,null,k),x.child=Lu(x,null,C,k)):_a(m,x,C,k),x.memoizedState=z.state,m=x.child):m=pc(m,x,k),m}function LA(m,x,C,N){return qt(),x.flags|=256,_a(m,x,C,N),x.child}function kv(m){return{baseLanes:m,cachePool:$A()}}function Lv(m,x,C){return m=m!==null?m.childLanes&~C:0,x&&(m|=Or),m}function FA(m,x,C){var N=x.pendingProps,k=!1,z=(x.flags&128)!==0,ie;if((ie=z)||(ie=m!==null&&m.memoizedState===null?!1:(Gi.current&2)!==0),ie&&(k=!0,x.flags&=-129),ie=(x.flags&32)!==0,x.flags&=-33,m===null){if(bs){if(k?zi(x):ca(),bs){var _e=Ma,ke;(ke=_e)&&(_e=dw(_e,Uo),_e!==null?(x.memoizedState={dehydrated:_e,treeContext:ll!==null?{id:zl,overflow:Fo}:null,retryLane:536870912},ke=t(18,null,null,0),ke.stateNode=_e,ke.return=x,x.child=ke,Ha=x,Ma=null,ke=!0):ke=!1),ke||Ge(x)}if(_e=x.memoizedState,_e!==null&&(_e=_e.dehydrated,_e!==null))return Wp(_e)?x.lanes=16:x.lanes=536870912,null;Cn(x)}return _e=N.children,N=N.fallback,k?(ca(),k=x.mode,_e=Fv({mode:"hidden",children:_e},k),N=_c(N,k,C,null),_e.return=x,N.return=x,_e.sibling=N,x.child=_e,k=x.child,k.memoizedState=kv(C),k.childLanes=Lv(m,ie,C),x.memoizedState=ja,N):(zi(x),Tp(x,_e))}if(ke=m.memoizedState,ke!==null&&(_e=ke.dehydrated,_e!==null)){if(z)x.flags&256?(zi(x),x.flags&=-257,x=Uv(m,x,C)):x.memoizedState!==null?(ca(),x.child=m.child,x.flags|=128,x=null):(ca(),k=N.fallback,_e=x.mode,N=Fv({mode:"visible",children:N.children},_e),k=_c(k,_e,C,null),k.flags|=2,N.return=x,k.return=x,N.sibling=k,x.child=N,Lu(x,m.child,null,C),N=x.child,N.memoizedState=kv(C),N.childLanes=Lv(m,ie,C),x.memoizedState=ja,x=k);else if(zi(x),Wp(_e))ie=aw(_e).digest,N=Error(i(419)),N.stack="",N.digest=ie,Bt({value:N,source:null,stack:null}),x=Uv(m,x,C);else if(Di||Sh(m,x,C,!1),ie=(C&m.childLanes)!==0,Di||ie){if(ie=ts,ie!==null){if(N=C&-C,(N&42)!==0)N=1;else switch(N){case 2:N=1;break;case 8:N=4;break;case 32:N=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:N=64;break;case 268435456:N=134217728;break;default:N=0}if(N=(N&(ie.suspendedLanes|C))!==0?0:N,N!==0&&N!==ke.retryLane)throw ke.retryLane=N,it(m,N),$a(ie,m,N),Ew}_0(_e)||Tr(),x=Uv(m,x,C)}else _0(_e)?(x.flags|=128,x.child=m.child,x=Mh.bind(null,m),QN(_e,x),x=null):(m=ke.treeContext,ur&&(Ma=cw(_e),Ha=x,bs=!0,ro=null,Uo=!1,m!==null&&(io[ao++]=zl,io[ao++]=Fo,io[ao++]=ll,zl=m.id,Fo=m.overflow,ll=x)),x=Tp(x,N.children),x.flags|=4096);return x}return k?(ca(),k=N.fallback,_e=x.mode,ke=m.child,z=ke.sibling,N=Ga(ke,{mode:"hidden",children:N.children}),N.subtreeFlags=ke.subtreeFlags&31457280,z!==null?k=Ga(z,k):(k=_c(k,_e,C,null),k.flags|=2),k.return=x,N.return=x,N.sibling=k,x.child=N,N=k,k=x.child,_e=m.child.memoizedState,_e===null?_e=kv(C):(ke=_e.cachePool,ke!==null?(z=Fl?Ds._currentValue:Ds._currentValue2,ke=ke.parent!==z?{parent:z,pool:z}:ke):ke=$A(),_e={baseLanes:_e.baseLanes|C,cachePool:ke}),k.memoizedState=_e,k.childLanes=Lv(m,ie,C),x.memoizedState=ja,N):(zi(x),C=m.child,m=C.sibling,C=Ga(C,{mode:"visible",children:N.children}),C.return=x,C.sibling=null,m!==null&&(ie=x.deletions,ie===null?(x.deletions=[m],x.flags|=16):ie.push(m)),x.child=C,x.memoizedState=null,C)}function Tp(m,x){return x=Fv({mode:"visible",children:x},m.mode),x.return=m,m.child=x}function Fv(m,x){return h0(m,x,0,null)}function Uv(m,x,C){return Lu(x,m.child,null,C),m=Tp(x,x.pendingProps.children),m.flags|=2,x.memoizedState=null,m}function UA(m,x,C){m.lanes|=x;var N=m.alternate;N!==null&&(N.lanes|=x),zv(m.return,x,C)}function Kg(m,x,C,N,k){var z=m.memoizedState;z===null?m.memoizedState={isBackwards:x,rendering:null,renderingStartTime:0,last:N,tail:C,tailMode:k}:(z.isBackwards=x,z.rendering=null,z.renderingStartTime=0,z.last=N,z.tail=C,z.tailMode=k)}function PA(m,x,C){var N=x.pendingProps,k=N.revealOrder,z=N.tail;if(_a(m,x,N.children,C),N=Gi.current,(N&2)!==0)N=N&1|2,x.flags|=128;else{if(m!==null&&(m.flags&128)!==0)e:for(m=x.child;m!==null;){if(m.tag===13)m.memoizedState!==null&&UA(m,C,x);else if(m.tag===19)UA(m,C,x);else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===x)break e;for(;m.sibling===null;){if(m.return===null||m.return===x)break e;m=m.return}m.sibling.return=m.return,m=m.sibling}N&=1}switch(w(Gi,N),k){case"forwards":for(C=x.child,k=null;C!==null;)m=C.alternate,m!==null&&Ji(m)===null&&(k=C),C=C.sibling;C=k,C===null?(k=x.child,x.child=null):(k=C.sibling,C.sibling=null),Kg(x,!1,k,C,z);break;case"backwards":for(C=null,k=x.child,x.child=null;k!==null;){if(m=k.alternate,m!==null&&Ji(m)===null){x.child=k;break}m=k.sibling,k.sibling=C,C=k,k=m}Kg(x,!0,C,null,z);break;case"together":Kg(x,!1,null,null,void 0);break;default:x.memoizedState=null}return x.child}function pc(m,x,C){if(m!==null&&(x.dependencies=m.dependencies),ho|=x.lanes,(C&x.childLanes)===0)if(m!==null){if(Sh(m,x,C,!1),(C&x.childLanes)===0)return null}else return null;if(m!==null&&x.child!==m.child)throw Error(i(153));if(x.child!==null){for(m=x.child,C=Ga(m,m.pendingProps),x.child=C,C.return=x;m.sibling!==null;)m=m.sibling,C=C.sibling=Ga(m,m.pendingProps),C.return=x;C.sibling=null}return x.child}function Pv(m,x){return(m.lanes&x)!==0?!0:(m=m.dependencies,!!(m!==null&&pu(m)))}function YN(m,x,C){switch(x.tag){case 3:me(x,x.stateNode.containerInfo),fu(x,Ds,m.memoizedState.cache),qt();break;case 27:case 5:fe(x);break;case 4:me(x,x.stateNode.containerInfo);break;case 10:fu(x,x.type,x.memoizedProps.value);break;case 13:var N=x.memoizedState;if(N!==null)return N.dehydrated!==null?(zi(x),x.flags|=128,null):(C&x.child.childLanes)!==0?FA(m,x,C):(zi(x),m=pc(m,x,C),m!==null?m.sibling:null);zi(x);break;case 19:var k=(m.flags&128)!==0;if(N=(C&x.childLanes)!==0,N||(Sh(m,x,C,!1),N=(C&x.childLanes)!==0),k){if(N)return PA(m,x,C);x.flags|=128}if(k=x.memoizedState,k!==null&&(k.rendering=null,k.tail=null,k.lastEffect=null),w(Gi,Gi.current),N)break;return null;case 22:case 23:return x.lanes=0,OA(m,x,C);case 24:fu(x,Ds,m.memoizedState.cache)}return pc(m,x,C)}function zA(m,x,C){if(m!==null)if(m.memoizedProps!==x.pendingProps)Di=!0;else{if(!Pv(m,C)&&(x.flags&128)===0)return Di=!1,YN(m,x,C);Di=(m.flags&131072)!==0}else Di=!1,bs&&(x.flags&1048576)!==0&&Y(x,Jp,x.index);switch(x.lanes=0,x.tag){case 16:e:{m=x.pendingProps;var N=x.elementType,k=N._init;if(N=k(N._payload),x.type=N,typeof N=="function")bc(N)?(m=sl(N,m),x.tag=1,x=Bv(null,x,N,m,C)):(x.tag=0,x=Ov(null,x,N,m,C));else{if(N!=null){if(k=N.$$typeof,k===Xd){x.tag=11,x=IA(null,x,N,m,C);break e}else if(k===Fp){x.tag=14,x=DA(null,x,N,m,C);break e}}throw x=r(N)||N,Error(i(306,x,""))}}return x;case 0:return Ov(m,x,x.type,x.pendingProps,C);case 1:return N=x.type,k=sl(N,x.pendingProps),Bv(m,x,N,k,C);case 3:e:{if(me(x,x.stateNode.containerInfo),m===null)throw Error(i(387));var z=x.pendingProps;k=x.memoizedState,N=k.element,Jt(m,x),mt(x,z,null,C);var ie=x.memoizedState;if(z=ie.cache,fu(x,Ds,z),z!==k.cache&&$v(x,[Ds],C,!0),Fe(),z=ie.element,ur&&k.isDehydrated)if(k={element:z,isDehydrated:!1,cache:ie.cache},x.updateQueue.baseState=k,x.memoizedState=k,x.flags&256){x=LA(m,x,z,C);break e}else if(z!==N){N=se(Error(i(424)),x),Bt(N),x=LA(m,x,z,C);break e}else for(ur&&(Ma=lw(x.stateNode.containerInfo),Ha=x,bs=!0,ro=null,Uo=!0),C=$b(x,null,z,C),x.child=C;C;)C.flags=C.flags&-3|4096,C=C.sibling;else{if(qt(),z===N){x=pc(m,x,C);break e}_a(m,x,z,C)}x=x.child}return x;case 26:if(no)return Cp(m,x),m===null?(C=E0(x.type,null,x.pendingProps,null))?x.memoizedState=C:bs||(x.stateNode=tR(x.type,x.pendingProps,cl.current,x)):x.memoizedState=E0(x.type,m.memoizedProps,x.pendingProps,m.memoizedState),null;case 27:if(Ta)return fe(x),m===null&&Ta&&bs&&(N=x.stateNode=Fb(x.type,x.pendingProps,cl.current,pa.current,!1),Ha=x,Uo=!0,Ma=A0(N)),N=x.pendingProps.children,m!==null||bs?_a(m,x,N,C):x.child=Lu(x,null,N,C),Cp(m,x),x.child;case 5:return m===null&&bs&&(xw(x.type,x.pendingProps,pa.current),(k=N=Ma)&&(N=uw(N,x.type,x.pendingProps,Uo),N!==null?(x.stateNode=N,Ha=x,Ma=A0(N),Uo=!1,k=!0):k=!1),k||Ge(x)),fe(x),k=x.type,z=x.pendingProps,ie=m!==null?m.memoizedProps:null,N=z.children,Iu(k,z)?N=null:ie!==null&&Iu(k,ie)&&(x.flags|=32),x.memoizedState!==null&&(k=ae(m,x,st,null,null,C),Fl?En._currentValue=k:En._currentValue2=k),Cp(m,x),_a(m,x,N,C),x.child;case 6:return m===null&&bs&&(yw(x.pendingProps,pa.current),(m=C=Ma)&&(C=hw(C,x.pendingProps,Uo),C!==null?(x.stateNode=C,Ha=x,Ma=null,m=!0):m=!1),m||Ge(x)),null;case 13:return FA(m,x,C);case 4:return me(x,x.stateNode.containerInfo),N=x.pendingProps,m===null?x.child=Lu(x,null,N,C):_a(m,x,N,C),x.child;case 11:return IA(m,x,x.type,x.pendingProps,C);case 7:return _a(m,x,x.pendingProps,C),x.child;case 8:return _a(m,x,x.pendingProps.children,C),x.child;case 12:return _a(m,x,x.pendingProps.children,C),x.child;case 10:return N=x.pendingProps,fu(x,x.type,N.value),_a(m,x,N.children,C),x.child;case 9:return k=x.type._context,N=x.pendingProps.children,_h(x),k=Aa(k),N=N(k),x.flags|=1,_a(m,x,N,C),x.child;case 14:return DA(m,x,x.type,x.pendingProps,C);case 15:return qg(m,x,x.type,x.pendingProps,C);case 19:return PA(m,x,C);case 22:return OA(m,x,C);case 24:return _h(x),N=Aa(Ds),m===null?(k=mu(),k===null&&(k=ts,z=Yg(),k.pooledCache=z,z.refCount++,z!==null&&(k.pooledCacheLanes|=C),k=z),x.memoizedState={parent:N,cache:k},tn(x),fu(x,Ds,k)):((m.lanes&C)!==0&&(Jt(m,x),mt(x,null,null,C),Fe()),k=m.memoizedState,z=x.memoizedState,k.parent!==N?(k={parent:N,cache:N},x.memoizedState=k,x.lanes===0&&(x.memoizedState=x.updateQueue.baseState=k),fu(x,Ds,N)):(N=z.cache,fu(x,Ds,N),N!==k.cache&&$v(x,[Ds],C,!0))),_a(m,x,x.pendingProps.children,C),x.child;case 29:throw x.pendingProps}throw Error(i(156,x.tag))}function fu(m,x,C){Fl?(w(Ir,x._currentValue),x._currentValue=C):(w(Ir,x._currentValue2),x._currentValue2=C)}function mc(m){var x=Ir.current;Fl?m._currentValue=x:m._currentValue2=x,b(Ir)}function zv(m,x,C){for(;m!==null;){var N=m.alternate;if((m.childLanes&x)!==x?(m.childLanes|=x,N!==null&&(N.childLanes|=x)):N!==null&&(N.childLanes&x)!==x&&(N.childLanes|=x),m===C)break;m=m.return}}function $v(m,x,C,N){var k=m.child;for(k!==null&&(k.return=m);k!==null;){var z=k.dependencies;if(z!==null){var ie=k.child;z=z.firstContext;e:for(;z!==null;){var _e=z;z=k;for(var ke=0;ke<x.length;ke++)if(_e.context===x[ke]){z.lanes|=C,_e=z.alternate,_e!==null&&(_e.lanes|=C),zv(z.return,C,m),N||(ie=null);break e}z=_e.next}}else if(k.tag===18){if(ie=k.return,ie===null)throw Error(i(341));ie.lanes|=C,z=ie.alternate,z!==null&&(z.lanes|=C),zv(ie,C,m),ie=null}else ie=k.child;if(ie!==null)ie.return=k;else for(ie=k;ie!==null;){if(ie===m){ie=null;break}if(k=ie.sibling,k!==null){k.return=ie.return,ie=k;break}ie=ie.return}k=ie}}function Sh(m,x,C,N){m=null;for(var k=x,z=!1;k!==null;){if(!z){if((k.flags&524288)!==0)z=!0;else if((k.flags&262144)!==0)break}if(k.tag===10){var ie=k.alternate;if(ie===null)throw Error(i(387));if(ie=ie.memoizedProps,ie!==null){var _e=k.type;so(k.pendingProps.value,ie.value)||(m!==null?m.push(_e):m=[_e])}}else if(k===ef.current){if(ie=k.alternate,ie===null)throw Error(i(387));ie.memoizedState.memoizedState!==k.memoizedState.memoizedState&&(m!==null?m.push(En):m=[En])}k=k.return}m!==null&&$v(x,m,C,N),x.flags|=262144}function pu(m){for(m=m.firstContext;m!==null;){var x=m.context;if(!so(Fl?x._currentValue:x._currentValue2,m.memoizedValue))return!0;m=m.next}return!1}function _h(m){Uu=m,vi=null,m=m.dependencies,m!==null&&(m.firstContext=null)}function Aa(m){return Gv(Uu,m)}function Ep(m,x){return Uu===null&&_h(m),Gv(m,x)}function Gv(m,x){var C=Fl?x._currentValue:x._currentValue2;if(x={context:x,memoizedValue:C,next:null},vi===null){if(m===null)throw Error(i(308));vi=x,m.dependencies={lanes:0,firstContext:x},m.flags|=524288}else vi=vi.next=x;return C}function Yg(){return{controller:new Mw,data:new Map,refCount:0}}function Dd(m){m.refCount--,m.refCount===0&&Rc(Uh,function(){m.controller.abort()})}function mu(){var m=Ic.current;return m!==null?m:ts.pooledCache}function Jg(m,x){x===null?w(Ic,Ic.current):w(Ic,x.pool)}function $A(){var m=mu();return m===null?null:{parent:Fl?Ds._currentValue:Ds._currentValue2,pool:m}}function Jr(m){m.flags|=4}function Vv(m,x){if(m!==null&&m.child===x.child)return!1;if((x.flags&16)!==0)return!0;for(m=x.child;m!==null;){if((m.flags&13878)!==0||(m.subtreeFlags&13878)!==0)return!0;m=m.sibling}return!1}function Zg(m,x,C,N){if(Ca)for(C=x.child;C!==null;){if(C.tag===5||C.tag===6)Ll(m,C.stateNode);else if(!(C.tag===4||Ta&&C.tag===27)&&C.child!==null){C.child.return=C,C=C.child;continue}if(C===x)break;for(;C.sibling===null;){if(C.return===null||C.return===x)return;C=C.return}C.sibling.return=C.return,C=C.sibling}else if(eo)for(var k=x.child;k!==null;){if(k.tag===5){var z=k.stateNode;C&&N&&(z=wb(z,k.type,k.memoizedProps)),Ll(m,z)}else if(k.tag===6)z=k.stateNode,C&&N&&(z=Cb(z,k.memoizedProps)),Ll(m,z);else if(k.tag!==4){if(k.tag===22&&k.memoizedState!==null)z=k.child,z!==null&&(z.return=k),Zg(m,k,!0,!0);else if(k.child!==null){k.child.return=k,k=k.child;continue}}if(k===x)break;for(;k.sibling===null;){if(k.return===null||k.return===x)return;k=k.return}k.sibling.return=k.return,k=k.sibling}}function Od(m,x,C,N){if(eo)for(var k=x.child;k!==null;){if(k.tag===5){var z=k.stateNode;C&&N&&(z=wb(z,k.type,k.memoizedProps)),_b(m,z)}else if(k.tag===6)z=k.stateNode,C&&N&&(z=Cb(z,k.memoizedProps)),_b(m,z);else if(k.tag!==4){if(k.tag===22&&k.memoizedState!==null)z=k.child,z!==null&&(z.return=k),Od(m,k,!(k.memoizedProps!==null&&k.memoizedProps.mode==="manual"),!0);else if(k.child!==null){k.child.return=k,k=k.child;continue}}if(k===x)break;for(;k.sibling===null;){if(k.return===null||k.return===x)return;k=k.return}k.sibling.return=k.return,k=k.sibling}}function Bd(m,x){if(eo&&Vv(m,x)){m=x.stateNode;var C=m.containerInfo,N=S0();Od(N,x,!1,!1),m.pendingChildren=N,Jr(x),iw(C,N)}}function Hv(m,x,C,N){if(Ca)m.memoizedProps!==N&&Jr(x);else if(eo){var k=m.stateNode,z=m.memoizedProps;if((m=Vv(m,x))||z!==N){var ie=pa.current;z=Sb(k,C,z,N,!m,null),z===k?x.stateNode=k:(wc(z,C,N,ie)&&Jr(x),x.stateNode=z,m?Zg(z,x,!1,!1):Jr(x))}else x.stateNode=k}}function kd(m,x,C){if(tw(x,C)){if(m.flags|=16777216,!Cc(x,C))if(Op())m.flags|=8192;else throw Fh=D0,zb}else m.flags&=-16777217}function Wv(m,x){if(vw(x)){if(m.flags|=16777216,!kb(x))if(Op())m.flags|=8192;else throw Fh=D0,zb}else m.flags&=-16777217}function Mp(m,x){x!==null&&(m.flags|=4),m.flags&16384&&(x=m.tag!==22?O():536870912,m.lanes|=x,Oc|=x)}function Ah(m,x){if(!bs)switch(m.tailMode){case"hidden":x=m.tail;for(var C=null;x!==null;)x.alternate!==null&&(C=x),x=x.sibling;C===null?m.tail=null:C.sibling=null;break;case"collapsed":C=m.tail;for(var N=null;C!==null;)C.alternate!==null&&(N=C),C=C.sibling;N===null?x||m.tail===null?m.tail=null:m.tail.sibling=null:N.sibling=null}}function ti(m){var x=m.alternate!==null&&m.alternate.child===m.child,C=0,N=0;if(x)for(var k=m.child;k!==null;)C|=k.lanes|k.childLanes,N|=k.subtreeFlags&31457280,N|=k.flags&31457280,k.return=m,k=k.sibling;else for(k=m.child;k!==null;)C|=k.lanes|k.childLanes,N|=k.subtreeFlags,N|=k.flags,k.return=m,k=k.sibling;return m.subtreeFlags|=N,m.childLanes=C,x}function GA(m,x,C){var N=x.pendingProps;switch(he(x),x.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ti(x),null;case 1:return ti(x),null;case 3:return C=x.stateNode,N=null,m!==null&&(N=m.memoizedState.cache),x.memoizedState.cache!==N&&(x.flags|=2048),mc(Ds),Ne(),C.pendingContext&&(C.context=C.pendingContext,C.pendingContext=null),(m===null||m.child===null)&&(Dt(x)?Jr(x):m===null||m.memoizedState.isDehydrated&&(x.flags&256)===0||(x.flags|=1024,ro!==null&&(xc(ro),ro=null))),Bd(m,x),ti(x),null;case 26:if(no){C=x.type;var k=x.memoizedState;return m===null?(Jr(x),k!==null?(ti(x),Wv(x,k)):(ti(x),kd(x,C,N))):k?k!==m.memoizedState?(Jr(x),ti(x),Wv(x,k)):(ti(x),x.flags&=-16777217):(Ca?m.memoizedProps!==N&&Jr(x):Hv(m,x,C,N),ti(x),kd(x,C,N)),null}case 27:if(Ta){if(Te(x),C=cl.current,k=x.type,m!==null&&x.stateNode!=null)Ca?m.memoizedProps!==N&&Jr(x):Hv(m,x,k,N);else{if(!N){if(x.stateNode===null)throw Error(i(166));return ti(x),null}m=pa.current,Dt(x)?nt(x,m):(m=Fb(k,N,C,m,!0),x.stateNode=m,Jr(x))}return ti(x),null}case 5:if(Te(x),C=x.type,m!==null&&x.stateNode!=null)Hv(m,x,C,N);else{if(!N){if(x.stateNode===null)throw Error(i(166));return ti(x),null}m=pa.current,Dt(x)?nt(x,m):(k=ub(C,N,cl.current,m,x),Zg(k,x,!1,!1),x.stateNode=k,wc(k,C,N,m)&&Jr(x))}return ti(x),kd(x,x.type,x.pendingProps),null;case 6:if(m&&x.stateNode!=null)C=m.memoizedProps,Ca?C!==N&&Jr(x):eo&&(C!==N?(x.stateNode=m0(N,cl.current,pa.current,x),Jr(x)):x.stateNode=m.stateNode);else{if(typeof N!="string"&&x.stateNode===null)throw Error(i(166));if(m=cl.current,C=pa.current,Dt(x)){if(!ur)throw Error(i(176));if(m=x.stateNode,C=x.memoizedProps,N=null,k=Ha,k!==null)switch(k.tag){case 27:case 5:N=k.memoizedProps}fw(m,C,x,N)||Ge(x)}else x.stateNode=m0(N,m,C,x)}return ti(x),null;case 13:if(N=x.memoizedState,m===null||m.memoizedState!==null&&m.memoizedState.dehydrated!==null){if(k=Dt(x),N!==null&&N.dehydrated!==null){if(m===null){if(!k)throw Error(i(318));if(!ur)throw Error(i(344));if(k=x.memoizedState,k=k!==null?k.dehydrated:null,!k)throw Error(i(317));Kd(k,x)}else qt(),(x.flags&128)===0&&(x.memoizedState=null),x.flags|=4;ti(x),k=!1}else ro!==null&&(xc(ro),ro=null),k=!0;if(!k)return x.flags&256?(Cn(x),x):(Cn(x),null)}if(Cn(x),(x.flags&128)!==0)return x.lanes=C,x;if(C=N!==null,m=m!==null&&m.memoizedState!==null,C){N=x.child,k=null,N.alternate!==null&&N.alternate.memoizedState!==null&&N.alternate.memoizedState.cachePool!==null&&(k=N.alternate.memoizedState.cachePool.pool);var z=null;N.memoizedState!==null&&N.memoizedState.cachePool!==null&&(z=N.memoizedState.cachePool.pool),z!==k&&(N.flags|=2048)}return C!==m&&C&&(x.child.flags|=8192),Mp(x,x.updateQueue),ti(x),null;case 4:return Ne(),Bd(m,x),m===null&&fb(x.stateNode.containerInfo),ti(x),null;case 10:return mc(x.type),ti(x),null;case 19:if(b(Gi),k=x.memoizedState,k===null)return ti(x),null;if(N=(x.flags&128)!==0,z=k.rendering,z===null)if(N)Ah(k,!1);else{if(xs!==0||m!==null&&(m.flags&128)!==0)for(m=x.child;m!==null;){if(z=Ji(m),z!==null){for(x.flags|=128,Ah(k,!1),m=z.updateQueue,x.updateQueue=m,Mp(x,m),x.subtreeFlags=0,m=C,C=x.child;C!==null;)Sc(C,m),C=C.sibling;return w(Gi,Gi.current&1|2),x.child}m=m.sibling}k.tail!==null&&Ea()>ui&&(x.flags|=128,N=!0,Ah(k,!1),x.lanes=4194304)}else{if(!N)if(m=Ji(z),m!==null){if(x.flags|=128,N=!0,m=m.updateQueue,x.updateQueue=m,Mp(x,m),Ah(k,!0),k.tail===null&&k.tailMode==="hidden"&&!z.alternate&&!bs)return ti(x),null}else 2*Ea()-k.renderingStartTime>ui&&C!==536870912&&(x.flags|=128,N=!0,Ah(k,!1),x.lanes=4194304);k.isBackwards?(z.sibling=x.child,x.child=z):(m=k.last,m!==null?m.sibling=z:x.child=z,k.last=z)}return k.tail!==null?(x=k.tail,k.rendering=x,k.tail=x.sibling,k.renderingStartTime=Ea(),x.sibling=null,m=Gi.current,w(Gi,N?m&1|2:m&1),x):(ti(x),null);case 22:case 23:return Cn(x),Oo(),N=x.memoizedState!==null,m!==null?m.memoizedState!==null!==N&&(x.flags|=8192):N&&(x.flags|=8192),N?(C&536870912)!==0&&(x.flags&128)===0&&(ti(x),x.subtreeFlags&6&&(x.flags|=8192)):ti(x),C=x.updateQueue,C!==null&&Mp(x,C.retryQueue),C=null,m!==null&&m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(C=m.memoizedState.cachePool.pool),N=null,x.memoizedState!==null&&x.memoizedState.cachePool!==null&&(N=x.memoizedState.cachePool.pool),N!==C&&(x.flags|=2048),m!==null&&b(Ic),null;case 24:return C=null,m!==null&&(C=m.memoizedState.cache),x.memoizedState.cache!==C&&(x.flags|=2048),mc(Ds),ti(x),null;case 25:return null}throw Error(i(156,x.tag))}function VA(m,x){switch(he(x),x.tag){case 1:return m=x.flags,m&65536?(x.flags=m&-65537|128,x):null;case 3:return mc(Ds),Ne(),m=x.flags,(m&65536)!==0&&(m&128)===0?(x.flags=m&-65537|128,x):null;case 26:case 27:case 5:return Te(x),null;case 13:if(Cn(x),m=x.memoizedState,m!==null&&m.dehydrated!==null){if(x.alternate===null)throw Error(i(340));qt()}return m=x.flags,m&65536?(x.flags=m&-65537|128,x):null;case 19:return b(Gi),null;case 4:return Ne(),null;case 10:return mc(x.type),null;case 22:case 23:return Cn(x),Oo(),m!==null&&b(Ic),m=x.flags,m&65536?(x.flags=m&-65537|128,x):null;case 24:return mc(Ds),null;case 25:return null;default:return null}}function jv(m,x){switch(he(x),x.tag){case 3:mc(Ds),Ne();break;case 26:case 27:case 5:Te(x);break;case 4:Ne();break;case 13:Cn(x);break;case 19:b(Gi);break;case 10:mc(x.type);break;case 22:case 23:Cn(x),Oo(),m!==null&&b(Ic);break;case 24:mc(Ds)}}function Np(m,x){try{var C=x.updateQueue,N=C!==null?C.lastEffect:null;if(N!==null){var k=N.next;C=k;do{if((C.tag&m)===m){N=void 0;var z=C.create,ie=C.inst;N=z(),ie.destroy=N}C=C.next}while(C!==k)}}catch(_e){rs(x,x.return,_e)}}function gu(m,x,C){try{var N=x.updateQueue,k=N!==null?N.lastEffect:null;if(k!==null){var z=k.next;N=z;do{if((N.tag&m)===m){var ie=N.inst,_e=ie.destroy;if(_e!==void 0){ie.destroy=void 0,k=x;var ke=C;try{_e()}catch(ht){rs(k,ke,ht)}}}N=N.next}while(N!==z)}}catch(ht){rs(x,x.return,ht)}}function HA(m){var x=m.updateQueue;if(x!==null){var C=m.stateNode;try{Ue(x,C)}catch(N){rs(m,m.return,N)}}}function WA(m,x,C){C.props=sl(m.type,m.memoizedProps),C.state=m.memoizedState;try{C.componentWillUnmount()}catch(N){rs(m,x,N)}}function wh(m,x){try{var C=m.ref;if(C!==null){var N=m.stateNode;switch(m.tag){case 26:case 27:case 5:var k=qd(N);break;default:k=N}typeof C=="function"?m.refCleanup=C(k):C.current=k}}catch(z){rs(m,x,z)}}function ni(m,x){var C=m.ref,N=m.refCleanup;if(C!==null)if(typeof N=="function")try{N()}catch(k){rs(m,x,k)}finally{m.refCleanup=null,m=m.alternate,m!=null&&(m.refCleanup=null)}else if(typeof C=="function")try{C(null)}catch(k){rs(m,x,k)}else C.current=null}function Ld(m){var x=m.type,C=m.memoizedProps,N=m.stateNode;try{ZN(N,x,C,m)}catch(k){rs(m,m.return,k)}}function Xv(m,x,C){try{xb(m.stateNode,m.type,C,x,m)}catch(N){rs(m,m.return,N)}}function qv(m){return m.tag===5||m.tag===3||(no?m.tag===26:!1)||(Ta?m.tag===27:!1)||m.tag===4}function Qg(m){e:for(;;){for(;m.sibling===null;){if(m.return===null||qv(m.return))return null;m=m.return}for(m.sibling.return=m.return,m=m.sibling;m.tag!==5&&m.tag!==6&&(!Ta||m.tag!==27)&&m.tag!==18;){if(m.flags&2||m.child===null||m.tag===4)continue e;m.child.return=m,m=m.child}if(!(m.flags&2))return m.stateNode}}function e0(m,x,C){var N=m.tag;if(N===5||N===6)m=m.stateNode,x?vb(C,m,x):nw(C,m);else if(!(N===4||Ta&&N===27)&&(m=m.child,m!==null))for(e0(m,x,C),m=m.sibling;m!==null;)e0(m,x,C),m=m.sibling}function Fd(m,x,C){var N=m.tag;if(N===5||N===6)m=m.stateNode,x?yb(C,m,x):gb(C,m);else if(!(N===4||Ta&&N===27)&&(m=m.child,m!==null))for(Fd(m,x,C),m=m.sibling;m!==null;)Fd(m,x,C),m=m.sibling}function jA(m,x,C){m=m.containerInfo;try{Ab(m,C)}catch(N){rs(x,x.return,N)}}function Ud(m,x){for(Ru(m.containerInfo),bi=x;bi!==null;)if(m=bi,x=m.child,(m.subtreeFlags&1028)!==0&&x!==null)x.return=m,bi=x;else for(;bi!==null;){m=bi;var C=m.alternate;switch(x=m.flags,m.tag){case 0:break;case 11:case 15:break;case 1:if((x&1024)!==0&&C!==null){x=void 0;var N=m,k=C.memoizedProps;C=C.memoizedState;var z=N.stateNode;try{var ie=sl(N.type,k,N.elementType===N.type);x=z.getSnapshotBeforeUpdate(ie,C),z.__reactInternalSnapshotBeforeUpdate=x}catch(_e){rs(N,N.return,_e)}}break;case 3:(x&1024)!==0&&Ca&&b0(m.stateNode.containerInfo);break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((x&1024)!==0)throw Error(i(163))}if(x=m.sibling,x!==null){x.return=m.return,bi=x;break}bi=m.return}return ie=Ph,Ph=!1,ie}function t0(m,x,C){var N=C.flags;switch(C.tag){case 0:case 11:case 15:Rl(m,C),N&4&&Np(5,C);break;case 1:if(Rl(m,C),N&4)if(m=C.stateNode,x===null)try{m.componentDidMount()}catch(_e){rs(C,C.return,_e)}else{var k=sl(C.type,x.memoizedProps);x=x.memoizedState;try{m.componentDidUpdate(k,x,m.__reactInternalSnapshotBeforeUpdate)}catch(_e){rs(C,C.return,_e)}}N&64&&HA(C),N&512&&wh(C,C.return);break;case 3:if(Rl(m,C),N&64&&(N=C.updateQueue,N!==null)){if(m=null,C.child!==null)switch(C.child.tag){case 27:case 5:m=qd(C.child.stateNode);break;case 1:m=C.child.stateNode}try{Ue(N,m)}catch(_e){rs(C,C.return,_e)}}break;case 26:if(no){Rl(m,C),N&512&&wh(C,C.return);break}case 27:case 5:Rl(m,C),x===null&&N&4&&Ld(C),N&512&&wh(C,C.return);break;case 12:Rl(m,C);break;case 13:Rl(m,C),N&4&&xu(m,C);break;case 22:if(k=C.memoizedState!==null||ea,!k){x=x!==null&&x.memoizedState!==null||ci;var z=ea,ie=ci;ea=k,(ci=x)&&!ie?vu(m,C,(C.subtreeFlags&8772)!==0):Rl(m,C),ea=z,ci=ie}N&512&&(C.memoizedProps.mode==="manual"?wh(C,C.return):ni(C,C.return));break;default:Rl(m,C)}}function Pd(m){var x=m.alternate;x!==null&&(m.alternate=null,Pd(x)),m.child=null,m.deletions=null,m.sibling=null,m.tag===5&&(x=m.stateNode,x!==null&&pb(x)),m.stateNode=null,m.return=null,m.dependencies=null,m.memoizedProps=null,m.memoizedState=null,m.pendingProps=null,m.stateNode=null,m.updateQueue=null}function Zr(m,x,C){for(C=C.child;C!==null;)n0(m,x,C),C=C.sibling}function n0(m,x,C){if(Nr&&typeof Nr.onCommitFiberUnmount=="function")try{Nr.onCommitFiberUnmount(Qd,C)}catch{}switch(C.tag){case 26:if(no){ci||ni(C,x),Zr(m,x,C),C.memoizedState?Rb(C.memoizedState):C.stateNode&&Ob(C.stateNode);break}case 27:if(Ta){ci||ni(C,x);var N=Oi,k=Dr;Oi=C.stateNode,Zr(m,x,C),bw(C.stateNode),Oi=N,Dr=k;break}case 5:ci||ni(C,x);case 6:if(Ca){if(N=Oi,k=Dr,Oi=null,Zr(m,x,C),Oi=N,Dr=k,Oi!==null)if(Dr)try{Ri(Oi,C.stateNode)}catch(z){rs(C,x,z)}else try{hr(Oi,C.stateNode)}catch(z){rs(C,x,z)}}else Zr(m,x,C);break;case 18:Ca&&Oi!==null&&(Dr?Eb(Oi,C.stateNode):mw(Oi,C.stateNode));break;case 4:Ca?(N=Oi,k=Dr,Oi=C.stateNode.containerInfo,Dr=!0,Zr(m,x,C),Oi=N,Dr=k):(eo&&jA(C.stateNode,C,S0()),Zr(m,x,C));break;case 0:case 11:case 14:case 15:ci||gu(2,C,x),ci||gu(4,C,x),Zr(m,x,C);break;case 1:ci||(ni(C,x),N=C.stateNode,typeof N.componentWillUnmount=="function"&&WA(C,x,N)),Zr(m,x,C);break;case 21:Zr(m,x,C);break;case 22:ci||ni(C,x),ci=(N=ci)||C.memoizedState!==null,Zr(m,x,C),ci=N;break;default:Zr(m,x,C)}}function xu(m,x){if(ur&&x.memoizedState===null&&(m=x.alternate,m!==null&&(m=m.memoizedState,m!==null&&(m=m.dehydrated,m!==null))))try{C0(m)}catch(C){rs(x,x.return,C)}}function zd(m){switch(m.tag){case 13:case 19:var x=m.stateNode;return x===null&&(x=m.stateNode=new rf),x;case 22:return m=m.stateNode,x=m._retryCache,x===null&&(x=m._retryCache=new rf),x;default:throw Error(i(435,m.tag))}}function Rp(m,x){var C=zd(m);x.forEach(function(N){var k=Qv.bind(null,m,N);C.has(N)||(C.add(N),N.then(k,k))})}function or(m,x){var C=x.deletions;if(C!==null)for(var N=0;N<C.length;N++){var k=C[N],z=m,ie=x;if(Ca){var _e=ie;e:for(;_e!==null;){switch(_e.tag){case 27:case 5:Oi=_e.stateNode,Dr=!1;break e;case 3:Oi=_e.stateNode.containerInfo,Dr=!0;break e;case 4:Oi=_e.stateNode.containerInfo,Dr=!0;break e}_e=_e.return}if(Oi===null)throw Error(i(160));n0(z,ie,k),Oi=null,Dr=!1}else n0(z,ie,k);z=k.alternate,z!==null&&(z.return=null),k.return=null}if(x.subtreeFlags&13878)for(x=x.child;x!==null;)yu(x,m),x=x.sibling}function yu(m,x){var C=m.alternate,N=m.flags;switch(m.tag){case 0:case 11:case 14:case 15:or(x,m),wr(m),N&4&&(gu(3,m,m.return),Np(3,m),gu(5,m,m.return));break;case 1:or(x,m),wr(m),N&512&&(ci||C===null||ni(C,C.return)),N&64&&ea&&(m=m.updateQueue,m!==null&&(N=m.callbacks,N!==null&&(C=m.shared.hiddenCallbacks,m.shared.hiddenCallbacks=C===null?N:C.concat(N))));break;case 26:if(no){var k=dr;or(x,m),wr(m),N&512&&(ci||C===null||ni(C,C.return)),N&4&&(N=C!==null?C.memoizedState:null,x=m.memoizedState,C===null?x===null?m.stateNode===null?m.stateNode=Ib(k,m.type,m.memoizedProps,m):Db(k,m.type,m.stateNode):m.stateNode=Nb(k,x,m.memoizedProps):N!==x?(N===null?C.stateNode!==null&&Ob(C.stateNode):Rb(N),x===null?Db(k,m.type,m.stateNode):Nb(k,x,m.memoizedProps)):x===null&&m.stateNode!==null&&Xv(m,m.memoizedProps,C.memoizedProps));break}case 27:if(Ta&&N&4&&m.alternate===null){k=m.stateNode;var z=m.memoizedProps;try{nR(k),sR(m.type,z,k,m)}catch(Ot){rs(m,m.return,Ot)}}case 5:if(or(x,m),wr(m),N&512&&(ci||C===null||ni(C,C.return)),Ca){if(m.flags&32){x=m.stateNode;try{Vp(x)}catch(Ot){rs(m,m.return,Ot)}}N&4&&m.stateNode!=null&&(x=m.memoizedProps,Xv(m,x,C!==null?C.memoizedProps:x)),N&1024&&(Pu=!0)}break;case 6:if(or(x,m),wr(m),N&4&&Ca){if(m.stateNode===null)throw Error(i(162));N=m.memoizedProps,C=C!==null?C.memoizedProps:N,x=m.stateNode;try{sw(x,C,N)}catch(Ot){rs(m,m.return,Ot)}}break;case 3:if(no?(Bb(),k=dr,dr=T0(x.containerInfo),or(x,m),dr=k):or(x,m),wr(m),N&4){if(Ca&&ur&&C!==null&&C.memoizedState.isDehydrated)try{w0(x.containerInfo)}catch(Ot){rs(m,m.return,Ot)}if(eo){N=x.containerInfo,C=x.pendingChildren;try{Ab(N,C)}catch(Ot){rs(m,m.return,Ot)}}}Pu&&(Pu=!1,Kv(m));break;case 4:no?(C=dr,dr=T0(m.stateNode.containerInfo),or(x,m),wr(m),dr=C):(or(x,m),wr(m)),N&4&&eo&&jA(m.stateNode,m,m.stateNode.pendingChildren);break;case 12:or(x,m),wr(m);break;case 13:or(x,m),wr(m),m.child.flags&8192&&m.memoizedState!==null!=(C!==null&&C.memoizedState!==null)&&(Hl=Ea()),N&4&&(N=m.updateQueue,N!==null&&(m.updateQueue=null,Rp(m,N)));break;case 22:N&512&&(ci||C===null||ni(C,C.return)),k=m.memoizedState!==null;var ie=C!==null&&C.memoizedState!==null,_e=ea,ke=ci;if(ea=_e||k,ci=ke||ie,or(x,m),ci=ke,ea=_e,wr(m),x=m.stateNode,x._current=m,x._visibility&=-3,x._visibility|=x._pendingVisibility&2,N&8192&&(x._visibility=k?x._visibility&-2:x._visibility|1,k&&(x=ea||ci,C===null||ie||x||$d(m)),Ca&&(m.memoizedProps===null||m.memoizedProps.mode!=="manual"))){e:if(C=null,Ca)for(x=m;;){if(x.tag===5||no&&x.tag===26||Ta&&x.tag===27){if(C===null){ie=C=x;try{z=ie.stateNode,k?Hp(z):bb(ie.stateNode,ie.memoizedProps)}catch(Ot){rs(ie,ie.return,Ot)}}}else if(x.tag===6){if(C===null){ie=x;try{var ht=ie.stateNode;k?v0(ht):Tc(ht,ie.memoizedProps)}catch(Ot){rs(ie,ie.return,Ot)}}}else if((x.tag!==22&&x.tag!==23||x.memoizedState===null||x===m)&&x.child!==null){x.child.return=x,x=x.child;continue}if(x===m)break e;for(;x.sibling===null;){if(x.return===null||x.return===m)break e;C===x&&(C=null),x=x.return}C===x&&(C=null),x.sibling.return=x.return,x=x.sibling}}N&4&&(N=m.updateQueue,N!==null&&(C=N.retryQueue,C!==null&&(N.retryQueue=null,Rp(m,C))));break;case 19:or(x,m),wr(m),N&4&&(N=m.updateQueue,N!==null&&(m.updateQueue=null,Rp(m,N)));break;case 21:break;default:or(x,m),wr(m)}}function wr(m){var x=m.flags;if(x&2){try{if(Ca&&(!Ta||m.tag!==27)){e:{for(var C=m.return;C!==null;){if(qv(C)){var N=C;break e}C=C.return}throw Error(i(160))}switch(N.tag){case 27:if(Ta){var k=N.stateNode,z=Qg(m);Fd(m,z,k);break}case 5:var ie=N.stateNode;N.flags&32&&(Vp(ie),N.flags&=-33);var _e=Qg(m);Fd(m,_e,ie);break;case 3:case 4:var ke=N.stateNode.containerInfo,ht=Qg(m);e0(m,ht,ke);break;default:throw Error(i(161))}}}catch(Ot){rs(m,m.return,Ot)}m.flags&=-3}x&4096&&(m.flags&=-4097)}function Kv(m){if(m.subtreeFlags&1024)for(m=m.child;m!==null;){var x=m;Kv(x),x.tag===5&&x.flags&1024&&zs(x.stateNode),m=m.sibling}}function Rl(m,x){if(x.subtreeFlags&8772)for(x=x.child;x!==null;)t0(m,x.alternate,x),x=x.sibling}function $d(m){for(m=m.child;m!==null;){var x=m;switch(x.tag){case 0:case 11:case 14:case 15:gu(4,x,x.return),$d(x);break;case 1:ni(x,x.return);var C=x.stateNode;typeof C.componentWillUnmount=="function"&&WA(x,x.return,C),$d(x);break;case 26:case 27:case 5:ni(x,x.return),$d(x);break;case 22:ni(x,x.return),x.memoizedState===null&&$d(x);break;default:$d(x)}m=m.sibling}}function vu(m,x,C){for(C=C&&(x.subtreeFlags&8772)!==0,x=x.child;x!==null;){var N=x.alternate,k=m,z=x,ie=z.flags;switch(z.tag){case 0:case 11:case 15:vu(k,z,C),Np(4,z);break;case 1:if(vu(k,z,C),N=z,k=N.stateNode,typeof k.componentDidMount=="function")try{k.componentDidMount()}catch(ht){rs(N,N.return,ht)}if(N=z,k=N.updateQueue,k!==null){var _e=N.stateNode;try{var ke=k.shared.hiddenCallbacks;if(ke!==null)for(k.shared.hiddenCallbacks=null,k=0;k<ke.length;k++)ge(ke[k],_e)}catch(ht){rs(N,N.return,ht)}}C&&ie&64&&HA(z),wh(z,z.return);break;case 26:case 27:case 5:vu(k,z,C),C&&N===null&&ie&4&&Ld(z),wh(z,z.return);break;case 12:vu(k,z,C);break;case 13:vu(k,z,C),C&&ie&4&&xu(k,z);break;case 22:z.memoizedState===null&&vu(k,z,C),wh(z,z.return);break;default:vu(k,z,C)}x=x.sibling}}function Yv(m,x){var C=null;m!==null&&m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(C=m.memoizedState.cachePool.pool),m=null,x.memoizedState!==null&&x.memoizedState.cachePool!==null&&(m=x.memoizedState.cachePool.pool),m!==C&&(m!=null&&m.refCount++,C!=null&&Dd(C))}function s0(m,x){m=null,x.alternate!==null&&(m=x.alternate.memoizedState.cache),x=x.memoizedState.cache,x!==m&&(x.refCount++,m!=null&&Dd(m))}function gc(m,x,C,N){if(x.subtreeFlags&10256)for(x=x.child;x!==null;)i0(m,x,C,N),x=x.sibling}function i0(m,x,C,N){var k=x.flags;switch(x.tag){case 0:case 11:case 15:gc(m,x,C,N),k&2048&&Np(9,x);break;case 3:gc(m,x,C,N),k&2048&&(m=null,x.alternate!==null&&(m=x.alternate.memoizedState.cache),x=x.memoizedState.cache,x!==m&&(x.refCount++,m!=null&&Dd(m)));break;case 12:if(k&2048){gc(m,x,C,N),m=x.stateNode;try{var z=x.memoizedProps,ie=z.id,_e=z.onPostCommit;typeof _e=="function"&&_e(ie,x.alternate===null?"mount":"update",m.passiveEffectDuration,-0)}catch(ke){rs(x,x.return,ke)}}else gc(m,x,C,N);break;case 23:break;case 22:z=x.stateNode,x.memoizedState!==null?z._visibility&4?gc(m,x,C,N):bu(m,x):z._visibility&4?gc(m,x,C,N):(z._visibility|=4,za(m,x,C,N,(x.subtreeFlags&10256)!==0)),k&2048&&Yv(x.alternate,x);break;case 24:gc(m,x,C,N),k&2048&&s0(x.alternate,x);break;default:gc(m,x,C,N)}}function za(m,x,C,N,k){for(k=k&&(x.subtreeFlags&10256)!==0,x=x.child;x!==null;){var z=m,ie=x,_e=C,ke=N,ht=ie.flags;switch(ie.tag){case 0:case 11:case 15:za(z,ie,_e,ke,k),Np(8,ie);break;case 23:break;case 22:var Ot=ie.stateNode;ie.memoizedState!==null?Ot._visibility&4?za(z,ie,_e,ke,k):bu(z,ie):(Ot._visibility|=4,za(z,ie,_e,ke,k)),k&&ht&2048&&Yv(ie.alternate,ie);break;case 24:za(z,ie,_e,ke,k),k&&ht&2048&&s0(ie.alternate,ie);break;default:za(z,ie,_e,ke,k)}x=x.sibling}}function bu(m,x){if(x.subtreeFlags&10256)for(x=x.child;x!==null;){var C=m,N=x,k=N.flags;switch(N.tag){case 22:bu(C,N),k&2048&&Yv(N.alternate,N);break;case 24:bu(C,N),k&2048&&s0(N.alternate,N);break;default:bu(C,N)}x=x.sibling}}function ua(m){if(m.subtreeFlags&zh)for(m=m.child;m!==null;)Ch(m),m=m.sibling}function Ch(m){switch(m.tag){case 26:ua(m),m.flags&zh&&(m.memoizedState!==null?Lb(dr,m.memoizedState,m.memoizedProps):mi(m.type,m.memoizedProps));break;case 5:ua(m),m.flags&zh&&mi(m.type,m.memoizedProps);break;case 3:case 4:if(no){var x=dr;dr=T0(m.stateNode.containerInfo),ua(m),dr=x}else ua(m);break;case 22:m.memoizedState===null&&(x=m.alternate,x!==null&&x.memoizedState!==null?(x=zh,zh=16777216,ua(m),zh=x):ua(m));break;default:ua(m)}}function a0(m){var x=m.alternate;if(x!==null&&(m=x.child,m!==null)){x.child=null;do x=m.sibling,m.sibling=null,m=x;while(m!==null)}}function Su(m){var x=m.deletions;if((m.flags&16)!==0){if(x!==null)for(var C=0;C<x.length;C++){var N=x[C];bi=N,_u(N,m)}a0(m)}if(m.subtreeFlags&10256)for(m=m.child;m!==null;)Ip(m),m=m.sibling}function Ip(m){switch(m.tag){case 0:case 11:case 15:Su(m),m.flags&2048&&gu(9,m,m.return);break;case 3:Su(m);break;case 12:Su(m);break;case 22:var x=m.stateNode;m.memoizedState!==null&&x._visibility&4&&(m.return===null||m.return.tag!==13)?(x._visibility&=-5,Gd(m)):Su(m);break;default:Su(m)}}function Gd(m){var x=m.deletions;if((m.flags&16)!==0){if(x!==null)for(var C=0;C<x.length;C++){var N=x[C];bi=N,_u(N,m)}a0(m)}for(m=m.child;m!==null;){switch(x=m,x.tag){case 0:case 11:case 15:gu(8,x,x.return),Gd(x);break;case 22:C=x.stateNode,C._visibility&4&&(C._visibility&=-5,Gd(x));break;default:Gd(x)}m=m.sibling}}function _u(m,x){for(;bi!==null;){var C=bi;switch(C.tag){case 0:case 11:case 15:gu(8,C,x);break;case 23:case 22:if(C.memoizedState!==null&&C.memoizedState.cachePool!==null){var N=C.memoizedState.cachePool.pool;N!=null&&N.refCount++}break;case 24:Dd(C.memoizedState.cache)}if(N=C.child,N!==null)N.return=C,bi=N;else e:for(C=m;bi!==null;){N=bi;var k=N.sibling,z=N.return;if(Pd(N),N===C){bi=null;break e}if(k!==null){k.return=z,bi=k;break e}bi=z}}}function r0(m){var x=db(m);if(x!=null){if(typeof x.memoizedProps["data-testname"]!="string")throw Error(i(364));return x}if(m=Bh(m),m===null)throw Error(i(362));return m.stateNode.current}function Vd(m,x){var C=m.tag;switch(x.$$typeof){case am:if(m.type===x.value)return!0;break;case F0:e:{for(x=x.value,m=[m,0],C=0;C<m.length;){var N=m[C++],k=N.tag,z=m[C++],ie=x[z];if(k!==5&&k!==26&&k!==27||!Pl(N)){for(;ie!=null&&Vd(N,ie);)z++,ie=x[z];if(z===x.length){x=!0;break e}else for(N=N.child;N!==null;)m.push(N,z),N=N.sibling}}x=!1}return x;case U0:if((C===5||C===26||C===27)&&JN(m.stateNode,x.value))return!0;break;case Os:if((C===5||C===6||C===26||C===27)&&(m=Gp(m),m!==null&&0<=m.indexOf(x.value)))return!0;break;case gs:if((C===5||C===26||C===27)&&(m=m.memoizedProps["data-testname"],typeof m=="string"&&m.toLowerCase()===x.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Au(m){switch(m.$$typeof){case am:return"<"+(r(m.value)||"Unknown")+">";case F0:return":has("+(Au(m)||"")+")";case U0:return'[role="'+m.value+'"]';case Os:return'"'+m.value+'"';case gs:return'[data-testname="'+m.value+'"]';default:throw Error(i(365))}}function XA(m,x){var C=[];m=[m,0];for(var N=0;N<m.length;){var k=m[N++],z=k.tag,ie=m[N++],_e=x[ie];if(z!==5&&z!==26&&z!==27||!Pl(k)){for(;_e!=null&&Vd(k,_e);)ie++,_e=x[ie];if(ie===x.length)C.push(k);else for(k=k.child;k!==null;)m.push(k,ie),k=k.sibling}}return C}function lr(m,x){if(!Ul)throw Error(i(363));m=r0(m),m=XA(m,x),x=[],m=Array.from(m);for(var C=0;C<m.length;){var N=m[C++],k=N.tag;if(k===5||k===26||k===27)Pl(N)||x.push(N.stateNode);else for(N=N.child;N!==null;)m.push(N),N=N.sibling}return x}function cr(){if((yn&2)!==0&&Kn!==0)return Kn&-Kn;if(An.T!==null){var m=Rr;return m!==0?m:lt()}return Lo()}function Il(){Or===0&&(Or=(Kn&536870912)===0||bs?U():536870912);var m=co.current;return m!==null&&(m.flags|=32),Or}function $a(m,x,C){(m===ts&&$s===2||m.cancelPendingCommit!==null)&&(al(m,0),il(m,Kn,Or,!1)),L(m,C),((yn&2)===0||m!==ts)&&(m===ts&&((yn&2)===0&&(dl|=C),xs===4&&il(m,Kn,Or,!1)),Tt(m))}function Dp(m,x,C){if((yn&6)!==0)throw Error(i(327));var N=!C&&(x&60)===0&&(x&m.expiredLanes)===0||D(m,x),k=N?Bl(m,x):Dl(m,x,!0),z=N;do{if(k===0){uo&&!N&&il(m,x,0,!1);break}else if(k===6)il(m,x,0,!Bs);else{if(C=m.current.alternate,z&&!qA(C)){k=Dl(m,x,!1),z=!1;continue}if(k===2){if(z=x,m.errorRecoveryDisabledLanes&z)var ie=0;else ie=m.pendingLanes&-536870913,ie=ie!==0?ie:ie&536870912?536870912:0;if(ie!==0){x=ie;e:{var _e=m;k=of;var ke=ur&&_e.current.memoizedState.isDehydrated;if(ke&&(al(_e,ie).flags|=256),ie=Dl(_e,ie,!1),ie!==2){if(Dc&&!ke){_e.errorRecoveryDisabledLanes|=z,dl|=z,k=4;break e}z=fo,fo=k,z!==null&&xc(z)}k=ie}if(z=!1,k!==2)continue}}if(k===1){al(m,0),il(m,x,0,!0);break}e:{switch(N=m,k){case 0:case 1:throw Error(i(345));case 4:if((x&4194176)===x){il(N,x,Or,!Bs);break e}break;case 2:fo=null;break;case 3:case 5:break;default:throw Error(i(329))}if(N.finishedWork=C,N.finishedLanes=x,(x&62914560)===x&&(z=Hl+300-Ea(),10<z)){if(il(N,x,Or,!Bs),R(N,0)!==0)break e;N.timeoutHandle=hb(o0.bind(null,N,C,fo,fl,lf,x,Or,dl,Oc,Bs,2,-0,0),z);break e}o0(N,C,fo,fl,lf,x,Or,dl,Oc,Bs,0,-0,0)}}break}while(!0);Tt(m)}function xc(m){fo===null?fo=m:fo.push.apply(fo,m)}function o0(m,x,C,N,k,z,ie,_e,ke,ht,Ot,Vt,Yt){var Dn=x.subtreeFlags;if((Dn&8192||(Dn&16785408)===16785408)&&(to(),Ch(x),x=g0(),x!==null)){m.cancelPendingCommit=x(Ks.bind(null,m,C,N,k,ie,_e,ke,1,Vt,Yt)),il(m,z,ie,!ht);return}Ks(m,C,N,k,ie,_e,ke,Ot,Vt,Yt)}function qA(m){for(var x=m;;){var C=x.tag;if((C===0||C===11||C===15)&&x.flags&16384&&(C=x.updateQueue,C!==null&&(C=C.stores,C!==null)))for(var N=0;N<C.length;N++){var k=C[N],z=k.getSnapshot;k=k.value;try{if(!so(z(),k))return!1}catch{return!1}}if(C=x.child,x.subtreeFlags&16384&&C!==null)C.return=x,x=C;else{if(x===m)break;for(;x.sibling===null;){if(x.return===null||x.return===m)return!0;x=x.return}x.sibling.return=x.return,x=x.sibling}}return!0}function il(m,x,C,N){x&=~Xa,x&=~dl,m.suspendedLanes|=x,m.pingedLanes&=~x,N&&(m.warmLanes|=x),N=m.expirationTimes;for(var k=x;0<k;){var z=31-Mr(k),ie=1<<z;N[z]=-1,k&=~ie}C!==0&&K(m,C,x)}function Jv(){return(yn&6)===0?(Et(0),!1):!0}function Cr(){if(Bn!==null){if($s===0)var m=Bn.return;else m=Bn,vi=Uu=null,wt(m),$l=null,Po=0,m=Bn;for(;m!==null;)jv(m.alternate,m),m=m.return;Bn=null}}function al(m,x){m.finishedWork=null,m.finishedLanes=0;var C=m.timeoutHandle;C!==Oh&&(m.timeoutHandle=Oh,$p(C)),C=m.cancelPendingCommit,C!==null&&(m.cancelPendingCommit=null,C()),Cr(),ts=m,Bn=C=Ga(m.current,null),Kn=x,$s=0,Bi=null,Bs=!1,uo=D(m,x),Dc=!1,Oc=Or=Xa=dl=ho=xs=0,fo=of=null,lf=!1,(x&8)!==0&&(x|=x&32);var N=m.entangledLanes;if(N!==0)for(m=m.entanglements,N&=x;0<N;){var k=31-Mr(N),z=1<<k;x|=m[k],N&=~z}return hl=x,Je(),C}function Th(m,x){$n=null,An.H=Ss,x===Fs?(x=Ut(),$s=3):x===zb?(x=Ut(),$s=4):$s=x===Ew?8:x!==null&&typeof x=="object"&&typeof x.then=="function"?6:1,Bi=x,Bn===null&&(xs=1,jg(m,se(x,m.current)))}function Op(){var m=co.current;return m===null?!0:(Kn&4194176)===Kn?zo===null:(Kn&62914560)===Kn||(Kn&536870912)!==0?m===zo:!1}function Hd(){var m=An.H;return An.H=Ss,m===null?Ss:m}function Qr(){var m=An.A;return An.A=L0,m}function Tr(){xs=4,Bs||(Kn&4194176)!==Kn&&co.current!==null||(uo=!0),(ho&134217727)===0&&(dl&134217727)===0||ts===null||il(ts,Kn,Or,!1)}function Dl(m,x,C){var N=yn;yn|=2;var k=Hd(),z=Qr();(ts!==m||Kn!==x)&&(fl=null,al(m,x)),x=!1;var ie=xs;e:do try{if($s!==0&&Bn!==null){var _e=Bn,ke=Bi;switch($s){case 8:Cr(),ie=6;break e;case 3:case 2:case 6:co.current===null&&(x=!0);var ht=$s;if($s=0,Bi=null,wu(m,_e,ke,ht),C&&uo){ie=0;break e}break;default:ht=$s,$s=0,Bi=null,wu(m,_e,ke,ht)}}Ol(),ie=xs;break}catch(Ot){Th(m,Ot)}while(!0);return x&&m.shellSuspendCounter++,vi=Uu=null,yn=N,An.H=k,An.A=z,Bn===null&&(ts=null,Kn=0,Je()),ie}function Ol(){for(;Bn!==null;)Zv(Bn)}function Bl(m,x){var C=yn;yn|=2;var N=Hd(),k=Qr();ts!==m||Kn!==x?(fl=null,ui=Ea()+500,al(m,x)):uo=D(m,x);e:do try{if($s!==0&&Bn!==null){x=Bn;var z=Bi;t:switch($s){case 1:$s=0,Bi=null,wu(m,x,z,1);break;case 2:if(Rt(z)){$s=0,Bi=null,l0(x);break}x=function(){$s===2&&ts===m&&($s=7),Tt(m)},z.then(x,x);break e;case 3:$s=7;break e;case 4:$s=5;break e;case 7:Rt(z)?($s=0,Bi=null,l0(x)):($s=0,Bi=null,wu(m,x,z,7));break;case 5:var ie=null;switch(Bn.tag){case 26:ie=Bn.memoizedState;case 5:case 27:var _e=Bn,ke=_e.type,ht=_e.pendingProps;if(ie?kb(ie):Cc(ke,ht)){$s=0,Bi=null;var Ot=_e.sibling;if(Ot!==null)Bn=Ot;else{var Vt=_e.return;Vt!==null?(Bn=Vt,Bp(Vt)):Bn=null}break t}}$s=0,Bi=null,wu(m,x,z,5);break;case 6:$s=0,Bi=null,wu(m,x,z,6);break;case 8:Cr(),xs=6;break e;default:throw Error(i(462))}}yc();break}catch(Yt){Th(m,Yt)}while(!0);return vi=Uu=null,An.H=N,An.A=k,yn=C,Bn!==null?0:(ts=null,Kn=0,Je(),xs)}function yc(){for(;Bn!==null&&!_w();)Zv(Bn)}function Zv(m){var x=zA(m.alternate,m,hl);m.memoizedProps=m.pendingProps,x===null?Bp(m):Bn=x}function l0(m){var x=m,C=x.alternate;switch(x.tag){case 15:case 0:x=kA(C,x,x.pendingProps,x.type,void 0,Kn);break;case 11:x=kA(C,x,x.pendingProps,x.type.render,x.ref,Kn);break;case 5:wt(x);default:jv(C,x),x=Bn=Sc(x,hl),x=zA(C,x,hl)}m.memoizedProps=m.pendingProps,x===null?Bp(m):Bn=x}function wu(m,x,C,N){vi=Uu=null,wt(x),$l=null,Po=0;var k=x.return;try{if(RA(m,k,x,C,Kn)){xs=1,jg(m,se(C,m.current)),Bn=null;return}}catch(z){if(k!==null)throw Bn=k,z;xs=1,jg(m,se(C,m.current)),Bn=null;return}x.flags&32768?(bs||N===1?m=!0:uo||(Kn&536870912)!==0?m=!1:(Bs=m=!0,(N===2||N===3||N===6)&&(N=co.current,N!==null&&N.tag===13&&(N.flags|=16384))),ha(x,m)):Bp(x)}function Bp(m){var x=m;do{if((x.flags&32768)!==0){ha(x,Bs);return}m=x.return;var C=GA(x.alternate,x,hl);if(C!==null){Bn=C;return}if(x=x.sibling,x!==null){Bn=x;return}Bn=x=m}while(x!==null);xs===0&&(xs=5)}function ha(m,x){do{var C=VA(m.alternate,m);if(C!==null){C.flags&=32767,Bn=C;return}if(C=m.return,C!==null&&(C.flags|=32768,C.subtreeFlags=0,C.deletions=null),!x&&(m=m.sibling,m!==null)){Bn=m;return}Bn=m=C}while(m!==null);xs=6,Bn=null}function Ks(m,x,C,N,k,z,ie,_e,ke,ht){var Ot=An.T,Vt=Qi();try{Va(2),An.T=null,us(m,x,C,N,Vt,k,z,ie,_e,ke,ht)}finally{An.T=Ot,Va(Vt)}}function us(m,x,C,N,k,z,ie,_e){do da();while(Bc!==null);if((yn&6)!==0)throw Error(i(327));var ke=m.finishedWork;if(N=m.finishedLanes,ke===null)return null;if(m.finishedWork=null,m.finishedLanes=0,ke===m.current)throw Error(i(177));m.callbackNode=null,m.callbackPriority=0,m.cancelPendingCommit=null;var ht=ke.lanes|ke.childLanes;if(ht|=tf,H(m,N,ht,z,ie,_e),m===ts&&(Bn=ts=null,Kn=0),(ke.subtreeFlags&10256)===0&&(ke.flags&10256)===0||Go||(Go=!0,P0=ht,Gh=C,kp(M0,function(){return da(),null})),C=(ke.flags&15990)!==0,(ke.subtreeFlags&15990)!==0||C?(C=An.T,An.T=null,z=Qi(),Va(2),ie=yn,yn|=4,Ud(m,ke),yu(ke,m),cb(m.containerInfo),m.current=ke,t0(m,ke.alternate,ke),Aw(),yn=ie,Va(z),An.T=C):m.current=ke,Go?(Go=!1,Bc=m,$h=N):vc(m,ht),ht=m.pendingLanes,ht===0&&(po=null),P(ke.stateNode),Tt(m),x!==null)for(k=m.onRecoverableError,ke=0;ke<x.length;ke++)ht=x[ke],k(ht.value,{componentStack:ht.stack});return($h&3)!==0&&da(),ht=m.pendingLanes,(N&4194218)!==0&&(ht&42)!==0?m===fr?Vh++:(Vh=0,fr=m):Vh=0,Et(0),null}function vc(m,x){(m.pooledCacheLanes&=x)===0&&(x=m.pooledCache,x!=null&&(m.pooledCache=null,Dd(x)))}function da(){if(Bc!==null){var m=Bc,x=P0;P0=0;var C=Q($h),N=32>C?32:C;C=An.T;var k=Qi();try{if(Va(N),An.T=null,Bc===null)var z=!1;else{N=Gh,Gh=null;var ie=Bc,_e=$h;if(Bc=null,$h=0,(yn&6)!==0)throw Error(i(331));var ke=yn;if(yn|=4,Ip(ie.current),i0(ie,ie.current,_e,N),yn=ke,Et(0,!1),Nr&&typeof Nr.onPostCommitFiberRoot=="function")try{Nr.onPostCommitFiberRoot(Qd,ie)}catch{}z=!0}return z}finally{Va(k),An.T=C,vc(m,x)}}return!1}function c0(m,x,C){x=se(C,x),x=Ap(m.stateNode,x,2),m=ut(m,x,2),m!==null&&(L(m,2),Tt(m))}function rs(m,x,C){if(m.tag===3)c0(m,m,C);else for(;x!==null;){if(x.tag===3){c0(x,m,C);break}else if(x.tag===1){var N=x.stateNode;if(typeof x.type.getDerivedStateFromError=="function"||typeof N.componentDidCatch=="function"&&(po===null||!po.has(N))){m=se(C,m),C=Id(2),N=ut(x,C,2),N!==null&&(wp(C,N,x,m),L(N,2),Tt(N));break}}x=x.return}}function u0(m,x,C){var N=m.pingCache;if(N===null){N=m.pingCache=new os;var k=new Set;N.set(x,k)}else k=N.get(x),k===void 0&&(k=new Set,N.set(x,k));k.has(C)||(Dc=!0,k.add(C),m=KA.bind(null,m,x,C),x.then(m,m))}function KA(m,x,C){var N=m.pingCache;N!==null&&N.delete(x),m.pingedLanes|=m.suspendedLanes&C,m.warmLanes&=~C,ts===m&&(Kn&C)===C&&(xs===4||xs===3&&(Kn&62914560)===Kn&&300>Ea()-Hl?(yn&2)===0&&al(m,0):Xa|=C,Oc===Kn&&(Oc=0)),Tt(m)}function Eh(m,x){x===0&&(x=O()),m=it(m,x),m!==null&&(L(m,x),Tt(m))}function Mh(m){var x=m.memoizedState,C=0;x!==null&&(C=x.retryLane),Eh(m,C)}function Qv(m,x){var C=0;switch(m.tag){case 13:var N=m.stateNode,k=m.memoizedState;k!==null&&(C=k.retryLane);break;case 19:N=m.stateNode;break;case 22:N=m.stateNode._retryCache;break;default:throw Error(i(314))}N!==null&&N.delete(x),Eh(m,C)}function kp(m,x){return Zd(m,x)}function eb(m,x,C,N){this.tag=m,this.key=C,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=x,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=N,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function bc(m){return m=m.prototype,!(!m||!m.isReactComponent)}function Ga(m,x){var C=m.alternate;return C===null?(C=t(m.tag,x,m.key,m.mode),C.elementType=m.elementType,C.type=m.type,C.stateNode=m.stateNode,C.alternate=m,m.alternate=C):(C.pendingProps=x,C.type=m.type,C.flags=0,C.subtreeFlags=0,C.deletions=null),C.flags=m.flags&31457280,C.childLanes=m.childLanes,C.lanes=m.lanes,C.child=m.child,C.memoizedProps=m.memoizedProps,C.memoizedState=m.memoizedState,C.updateQueue=m.updateQueue,x=m.dependencies,C.dependencies=x===null?null:{lanes:x.lanes,firstContext:x.firstContext},C.sibling=m.sibling,C.index=m.index,C.ref=m.ref,C.refCleanup=m.refCleanup,C}function Sc(m,x){m.flags&=31457282;var C=m.alternate;return C===null?(m.childLanes=0,m.lanes=x,m.child=null,m.subtreeFlags=0,m.memoizedProps=null,m.memoizedState=null,m.updateQueue=null,m.dependencies=null,m.stateNode=null):(m.childLanes=C.childLanes,m.lanes=C.lanes,m.child=C.child,m.subtreeFlags=0,m.deletions=null,m.memoizedProps=C.memoizedProps,m.memoizedState=C.memoizedState,m.updateQueue=C.updateQueue,m.type=C.type,x=C.dependencies,m.dependencies=x===null?null:{lanes:x.lanes,firstContext:x.firstContext}),m}function ko(m,x,C,N,k,z){var ie=0;if(N=m,typeof m=="function")bc(m)&&(ie=1);else if(typeof m=="string")ie=no&&Ta?Mb(m,C,pa.current)?26:Yd(m)?27:5:no?Mb(m,C,pa.current)?26:5:Ta&&Yd(m)?27:5;else e:switch(m){case jd:return _c(C.children,k,z,x);case ab:ie=8,k|=24;break;case rb:return m=t(12,C,x,k|2),m.elementType=rb,m.lanes=z,m;case d0:return m=t(13,C,x,k),m.elementType=d0,m.lanes=z,m;case Eu:return m=t(19,C,x,k),m.elementType=Eu,m.lanes=z,m;case Up:return h0(C,k,z,x);default:if(typeof m=="object"&&m!==null)switch(m.$$typeof){case ZA:case kl:ie=10;break e;case Tu:ie=9;break e;case Xd:ie=11;break e;case Fp:ie=14;break e;case ol:ie=16,N=null;break e}ie=29,C=Error(i(130,m===null?"null":typeof m,"")),N=null}return x=t(ie,C,x,k),x.elementType=m,x.type=N,x.lanes=z,x}function _c(m,x,C,N){return m=t(7,m,N,x),m.lanes=C,m}function h0(m,x,C,N){m=t(22,m,N,x),m.elementType=Up,m.lanes=C;var k={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var z=k._current;if(z===null)throw Error(i(456));if((k._pendingVisibility&2)===0){var ie=it(z,2);ie!==null&&(k._pendingVisibility|=2,$a(ie,z,2))}},attach:function(){var z=k._current;if(z===null)throw Error(i(456));if((k._pendingVisibility&2)!==0){var ie=it(z,2);ie!==null&&(k._pendingVisibility&=-3,$a(ie,z,2))}}};return m.stateNode=k,m}function Cu(m,x,C){return m=t(6,m,null,x),m.lanes=C,m}function Wd(m,x,C){return x=t(4,m.children!==null?m.children:[],m.key,x),x.lanes=C,x.stateNode={containerInfo:m.containerInfo,pendingChildren:null,implementation:m.implementation},x}function Nh(m,x,C,N,k,z,ie,_e){this.tag=1,this.containerInfo=m,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Oh,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=B(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=B(0),this.hiddenUpdates=B(null),this.identifierPrefix=N,this.onUncaughtError=k,this.onCaughtError=z,this.onRecoverableError=ie,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=_e,this.incompleteTransitions=new Map}function fa(m,x,C,N,k,z,ie,_e,ke,ht,Ot,Vt){return m=new Nh(m,x,C,ie,_e,ke,ht,Vt),x=1,z===!0&&(x|=24),z=t(3,null,null,x),m.current=z,z.stateNode=m,x=Yg(),x.refCount++,m.pooledCache=x,x.refCount++,z.memoizedState={element:N,isDehydrated:C,cache:x},tn(z),m}function Lp(m){return m?(m=kh,m):kh}function tb(m){var x=m._reactInternals;if(x===void 0)throw typeof m.render=="function"?Error(i(188)):(m=Object.keys(m).join(","),Error(i(268,m)));return m=g(x),m=m!==null?v(m):null,m===null?null:qd(m.stateNode)}function YA(m,x,C,N,k,z){k=Lp(k),N.context===null?N.context=k:N.pendingContext=k,N=at(x),N.payload={element:C},z=z===void 0?null:z,z!==null&&(N.callback=z),C=ut(m,N,x),C!==null&&($a(C,m,x),Zt(C,m,x))}function JA(m,x){if(m=m.memoizedState,m!==null&&m.dehydrated!==null){var C=m.retryLane;m.retryLane=C!==0&&C<x?C:x}}function nb(m,x){JA(m,x),(m=m.alternate)&&JA(m,x)}var xn={},sb=ay(),wa=wse(),Rh=Object.assign,ib=Symbol.for("react.element"),Ac=Symbol.for("react.transitional.element"),rl=Symbol.for("react.portal"),jd=Symbol.for("react.fragment"),ab=Symbol.for("react.strict_mode"),rb=Symbol.for("react.profiler"),ZA=Symbol.for("react.provider"),Tu=Symbol.for("react.consumer"),kl=Symbol.for("react.context"),Xd=Symbol.for("react.forward_ref"),d0=Symbol.for("react.suspense"),Eu=Symbol.for("react.suspense_list"),Fp=Symbol.for("react.memo"),ol=Symbol.for("react.lazy"),Up=Symbol.for("react.offscreen"),QA=Symbol.for("react.memo_cache_sentinel"),ob=Symbol.iterator,Ih=Symbol.for("react.client.reference"),An=sb.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,f0,lb,Mu=!1,Nu=Array.isArray,p0=e.rendererVersion,Pp=e.rendererPackageName,zp=e.extraDevToolsConfig,qd=e.getPublicInstance,Dh=e.getRootHostContext,ew=e.getChildHostContext,Ru=e.prepareForCommit,cb=e.resetAfterCommit,ub=e.createInstance,Ll=e.appendInitialChild,wc=e.finalizeInitialChildren,Iu=e.shouldSetTextContent,m0=e.createTextInstance,hb=e.scheduleTimeout,$p=e.cancelTimeout,Oh=e.noTimeout,Fl=e.isPrimaryRenderer;e.warnsIfNotActing;var Ca=e.supportsMutation,eo=e.supportsPersistence,ur=e.supportsHydration,db=e.getInstanceFromNode;e.beforeActiveInstanceBlur,e.afterActiveInstanceBlur;var fb=e.preparePortalMount;e.prepareScopeUpdate,e.getInstanceFromScope;var Va=e.setCurrentUpdatePriority,Qi=e.getCurrentUpdatePriority,Lo=e.resolveUpdatePriority;e.resolveEventType,e.resolveEventTimeStamp;var Du=e.shouldAttemptEagerTransition,pb=e.detachDeletedInstance;e.requestPostPaintCallback;var tw=e.maySuspendCommit,Cc=e.preloadInstance,to=e.startSuspendingCommit,mi=e.suspendInstance,g0=e.waitForCommitToBeReady,Er=e.NotPendingTransition,En=e.HostTransitionContext,zs=e.resetFormInstance;e.bindToConsole;var $i=e.supportsMicrotasks,x0=e.scheduleMicrotask,Ul=e.supportsTestSelectors,Bh=e.findFiberRoot,y0=e.getBoundingRect,Gp=e.getTextContent,Pl=e.isHiddenSubtree,JN=e.matchAccessibilityRole,gi=e.setFocusIfFocusable,mb=e.setupIntersectionObserver,gb=e.appendChild,nw=e.appendChildToContainer,sw=e.commitTextUpdate,ZN=e.commitMount,xb=e.commitUpdate,yb=e.insertBefore,vb=e.insertInContainerBefore,hr=e.removeChild,Ri=e.removeChildFromContainer,Vp=e.resetTextContent,Hp=e.hideInstance,v0=e.hideTextInstance,bb=e.unhideInstance,Tc=e.unhideTextInstance,b0=e.clearContainer,Sb=e.cloneInstance,S0=e.createContainerChildSet,_b=e.appendChildToContainerChildSet,iw=e.finalizeContainerChildren,Ab=e.replaceContainerChildren,wb=e.cloneHiddenInstance,Cb=e.cloneHiddenTextInstance,_0=e.isSuspenseInstancePending,Wp=e.isSuspenseInstanceFallback,aw=e.getSuspenseInstanceFallbackErrorDetails,QN=e.registerSuspenseInstanceRetry,rw=e.canHydrateFormStateMarker,ow=e.isFormStateMarkerMatching,Tb=e.getNextHydratableSibling,A0=e.getFirstHydratableChild,lw=e.getFirstHydratableChildWithinContainer,cw=e.getFirstHydratableChildWithinSuspenseInstance,uw=e.canHydrateInstance,hw=e.canHydrateTextInstance,dw=e.canHydrateSuspenseInstance,eR=e.hydrateInstance,fw=e.hydrateTextInstance,Kd=e.hydrateSuspenseInstance,pw=e.getNextHydratableInstanceAfterSuspenseInstance,w0=e.commitHydratedContainer,C0=e.commitHydratedSuspenseInstance,mw=e.clearSuspenseBoundary,Eb=e.clearSuspenseBoundaryFromContainer,gw=e.shouldDeleteUnhydratedTailInstances;e.diffHydratedPropsForDevWarnings,e.diffHydratedTextForDevWarnings,e.describeHydratableInstanceForDevWarnings;var xw=e.validateHydratableInstance,yw=e.validateHydratableTextInstance,no=e.supportsResources,Mb=e.isHostHoistableType,T0=e.getHoistableRoot,E0=e.getResource,Nb=e.acquireResource,Rb=e.releaseResource,Ib=e.hydrateHoistable,Db=e.mountHoistable,Ob=e.unmountHoistable,tR=e.createHoistableInstance,Bb=e.prepareToCommitHoistables,vw=e.mayResourceSuspendCommit,kb=e.preloadResource,Lb=e.suspendResource,Ta=e.supportsSingletons,Fb=e.resolveSingletonInstance,nR=e.clearSingleton,sR=e.acquireSingletonInstance,bw=e.releaseSingletonInstance,Yd=e.isHostSingletonType,jp=[],Ec=-1,kh={},Mr=Math.clz32?Math.clz32:T,Xp=Math.log,Sw=Math.LN2,Jd=128,qp=4194304,Zd=wa.unstable_scheduleCallback,Kp=wa.unstable_cancelCallback,_w=wa.unstable_shouldYield,Aw=wa.unstable_requestPaint,Ea=wa.unstable_now,Ub=wa.unstable_ImmediatePriority,ww=wa.unstable_UserBlockingPriority,M0=wa.unstable_NormalPriority,N0=wa.unstable_IdlePriority,Cw=wa.log,Pb=wa.unstable_setDisableYieldValue,Qd=null,Nr=null,so=typeof Object.is=="function"?Object.is:q,R0=new WeakMap,si=[],xi=0,Yp=null,Jp=0,io=[],ao=0,ll=null,zl=1,Fo="",pa=S(null),Zp=S(null),cl=S(null),ef=S(null),Ha=null,Ma=null,bs=!1,ro=null,Uo=!1,Qp=Error(i(519)),oo=[],Ou=0,tf=0,nf=null,Lh=null,em=!1,tm=!1,ul=!1,Bu=0,nm=null,I0=0,Rr=0,ku=null,Mc=!1,sf=!1,sm=Object.prototype.hasOwnProperty,Fs=Error(i(460)),zb=Error(i(474)),D0={then:function(){}},Fh=null,$l=null,Po=0,Lu=Ni(!0),$b=Ni(!1),Gl=S(null),lo=S(0),co=S(null),zo=null,Gi=S(0),Vl=0,$n=null,Is=null,Ii=null,$o=!1,ii=!1,Nc=!1,im=0,yi=0,af=null,Tw=0,O0=function(){return{lastEffect:null,events:null,stores:null,memoCache:null}},Ss={readContext:Aa,use:Se,useCallback:Un,useContext:Un,useEffect:Un,useImperativeHandle:Un,useLayoutEffect:Un,useInsertionEffect:Un,useMemo:Un,useReducer:Un,useRef:Un,useState:Un,useDebugValue:Un,useDeferredValue:Un,useTransition:Un,useSyncExternalStore:Un,useId:Un};Ss.useCacheRefresh=Un,Ss.useMemoCache=Un,Ss.useHostTransitionStatus=Un,Ss.useFormState=Un,Ss.useActionState=Un,Ss.useOptimistic=Un;var Vi={readContext:Aa,use:Se,useCallback:function(m,x){return Ct().memoizedState=[m,x===void 0?null:x],m},useContext:Aa,useEffect:Nv,useImperativeHandle:function(m,x,C){C=C!=null?C.concat([m]):null,Bo(4194308,4,yp.bind(null,x,m),C)},useLayoutEffect:function(m,x){return Bo(4194308,4,m,x)},useInsertionEffect:function(m,x){Bo(4,2,m,x)},useMemo:function(m,x){var C=Ct();x=x===void 0?null:x;var N=m();if(Nc){W(!0);try{m()}finally{W(!1)}}return C.memoizedState=[N,x],N},useReducer:function(m,x,C){var N=Ct();if(C!==void 0){var k=C(x);if(Nc){W(!0);try{C(x)}finally{W(!1)}}}else k=x;return N.memoizedState=N.baseState=k,m={pending:null,lanes:0,dispatch:null,lastRenderedReducer:m,lastRenderedState:k},N.queue=m,m=m.dispatch=uu.bind(null,$n,m),[N.memoizedState,m]},useRef:function(m){var x=Ct();return m={current:m},x.memoizedState=m},useState:function(m){m=hn(m);var x=m.queue,C=Hg.bind(null,$n,x);return x.dispatch=C,[m.memoizedState,C]},useDebugValue:vp,useDeferredValue:function(m,x){var C=Ct();return cu(C,m,x)},useTransition:function(){var m=hn(!1);return m=Gg.bind(null,$n,m.queue,!0,!1),Ct().memoizedState=m,[!1,m]},useSyncExternalStore:function(m,x,C){var N=$n,k=Ct();if(bs){if(C===void 0)throw Error(i(407));C=C()}else{if(C=x(),ts===null)throw Error(i(349));(Kn&60)!==0||Pt(N,x,C)}k.memoizedState=C;var z={value:C,getSnapshot:x};return k.queue=z,Nv(jt.bind(null,N,z,m),[m]),N.flags|=2048,pi(9,Kt.bind(null,N,z,C,x),{destroy:void 0},null),C},useId:function(){var m=Ct(),x=ts.identifierPrefix;if(bs){var C=Fo,N=zl;C=(N&~(1<<32-Mr(N)-1)).toString(32)+C,x=":"+x+"R"+C,C=im++,0<C&&(x+="H"+C.toString(32)),x+=":"}else C=Tw++,x=":"+x+"r"+C.toString(32)+":";return m.memoizedState=x},useCacheRefresh:function(){return Ct().memoizedState=bp.bind(null,$n)}};Vi.useMemoCache=De,Vi.useHostTransitionStatus=vh,Vi.useFormState=li,Vi.useActionState=li,Vi.useOptimistic=function(m){var x=Ct();x.memoizedState=x.baseState=m;var C={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return x.queue=C,x=Wg.bind(null,$n,!0,C),C.dispatch=x,[m,x]};var Wa={readContext:Aa,use:Se,useCallback:$g,useContext:Aa,useEffect:xp,useImperativeHandle:Ml,useInsertionEffect:MA,useLayoutEffect:NA,useMemo:yh,useReducer:Ke,useRef:nl,useState:function(){return Ke(ye)},useDebugValue:vp,useDeferredValue:function(m,x){var C=X();return Rv(C,Is.memoizedState,m,x)},useTransition:function(){var m=Ke(ye)[0],x=X().memoizedState;return[typeof m=="boolean"?m:de(m),x]},useSyncExternalStore:It,useId:Nl};Wa.useCacheRefresh=Vg,Wa.useMemoCache=De,Wa.useHostTransitionStatus=vh,Wa.useFormState=cs,Wa.useActionState=cs,Wa.useOptimistic=function(m,x){var C=X();return bn(C,Is,m,x)};var Fu={readContext:Aa,use:Se,useCallback:$g,useContext:Aa,useEffect:xp,useImperativeHandle:Ml,useInsertionEffect:MA,useLayoutEffect:NA,useMemo:yh,useReducer:vt,useRef:nl,useState:function(){return vt(ye)},useDebugValue:vp,useDeferredValue:function(m,x){var C=X();return Is===null?cu(C,m,x):Rv(C,Is.memoizedState,m,x)},useTransition:function(){var m=vt(ye)[0],x=X().memoizedState;return[typeof m=="boolean"?m:de(m),x]},useSyncExternalStore:It,useId:Nl};Fu.useCacheRefresh=Vg,Fu.useMemoCache=De,Fu.useHostTransitionStatus=vh,Fu.useFormState=Zi,Fu.useActionState=Zi,Fu.useOptimistic=function(m,x){var C=X();return Is!==null?bn(C,Is,m,x):(C.baseState=m,[m,C.queue.dispatch])};var B0={isMounted:function(m){return(m=m._reactInternals)?d(m)===m:!1},enqueueSetState:function(m,x,C){m=m._reactInternals;var N=cr(),k=at(N);k.payload=x,C!=null&&(k.callback=C),x=ut(m,k,N),x!==null&&($a(x,m,N),Zt(x,m,N))},enqueueReplaceState:function(m,x,C){m=m._reactInternals;var N=cr(),k=at(N);k.tag=1,k.payload=x,C!=null&&(k.callback=C),x=ut(m,k,N),x!==null&&($a(x,m,N),Zt(x,m,N))},enqueueForceUpdate:function(m,x){m=m._reactInternals;var C=cr(),N=at(C);N.tag=2,x!=null&&(N.callback=x),x=ut(m,N,C),x!==null&&($a(x,m,C),Zt(x,m,C))}},Gb=typeof reportError=="function"?reportError:function(m){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var x=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof m=="object"&&m!==null&&typeof m.message=="string"?String(m.message):String(m),error:m});if(!window.dispatchEvent(x))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",m);return}console.error(m)},Ew=Error(i(461)),Di=!1,ja={dehydrated:null,treeContext:null,retryLane:0},Ir=S(null),Uu=null,vi=null,Mw=typeof AbortController<"u"?AbortController:function(){var m=[],x=this.signal={aborted:!1,addEventListener:function(C,N){m.push(N)}};this.abort=function(){x.aborted=!0,m.forEach(function(C){return C()})}},Rc=wa.unstable_scheduleCallback,Uh=wa.unstable_NormalPriority,Ds={$$typeof:kl,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0},k0=An.S;An.S=function(m,x){typeof x=="object"&&x!==null&&typeof x.then=="function"&&Ve(m,x),k0!==null&&k0(m,x)};var Ic=S(null),ea=!1,ci=!1,Pu=!1,rf=typeof WeakSet=="function"?WeakSet:Set,bi=null,Ph=!1,Oi=null,Dr=!1,dr=null,zh=8192,L0={getCacheForType:function(m){var x=Aa(Ds),C=x.data.get(m);return C===void 0&&(C=m(),x.data.set(m,C)),C}},am=0,F0=1,U0=2,gs=3,Os=4;if(typeof Symbol=="function"&&Symbol.for){var Gn=Symbol.for;am=Gn("selector.component"),F0=Gn("selector.has_pseudo_class"),U0=Gn("selector.role"),gs=Gn("selector.test_id"),Os=Gn("selector.text")}var os=typeof WeakMap=="function"?WeakMap:Map,yn=0,ts=null,Bn=null,Kn=0,$s=0,Bi=null,Bs=!1,uo=!1,Dc=!1,hl=0,xs=0,ho=0,dl=0,Xa=0,Or=0,Oc=0,of=null,fo=null,lf=!1,Hl=0,ui=1/0,fl=null,po=null,Go=!1,Bc=null,$h=0,P0=0,Gh=null,Vh=0,fr=null;return xn.attemptContinuousHydration=function(m){if(m.tag===13){var x=it(m,67108864);x!==null&&$a(x,m,67108864),nb(m,67108864)}},xn.attemptHydrationAtCurrentPriority=function(m){if(m.tag===13){var x=cr(),C=it(m,x);C!==null&&$a(C,m,x),nb(m,x)}},xn.attemptSynchronousHydration=function(m){switch(m.tag){case 3:if(m=m.stateNode,m.current.memoizedState.isDehydrated){var x=E(m.pendingLanes);if(x!==0){for(m.pendingLanes|=2,m.entangledLanes|=2;x;){var C=1<<31-Mr(x);m.entanglements[1]|=C,x&=~C}Tt(m),(yn&6)===0&&(ui=Ea()+500,Et(0))}}break;case 13:x=it(m,2),x!==null&&$a(x,m,2),Jv(),nb(m,2)}},xn.batchedUpdates=function(m,x){return m(x)},xn.createComponentSelector=function(m){return{$$typeof:am,value:m}},xn.createContainer=function(m,x,C,N,k,z,ie,_e,ke,ht){return fa(m,x,!1,null,C,N,z,ie,_e,ke,ht,null)},xn.createHasPseudoClassSelector=function(m){return{$$typeof:F0,value:m}},xn.createHydrationContainer=function(m,x,C,N,k,z,ie,_e,ke,ht,Ot,Vt,Yt){return m=fa(C,N,!0,m,k,z,_e,ke,ht,Ot,Vt,Yt),m.context=Lp(null),C=m.current,N=cr(),k=at(N),k.callback=x??null,ut(C,k,N),m.current.lanes=N,L(m,N),Tt(m),m},xn.createPortal=function(m,x,C){var N=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:rl,key:N==null?null:""+N,children:m,containerInfo:x,implementation:C}},xn.createRoleSelector=function(m){return{$$typeof:U0,value:m}},xn.createTestNameSelector=function(m){return{$$typeof:gs,value:m}},xn.createTextSelector=function(m){return{$$typeof:Os,value:m}},xn.defaultOnCaughtError=function(m){console.error(m)},xn.defaultOnRecoverableError=function(m){Gb(m)},xn.defaultOnUncaughtError=function(m){Gb(m)},xn.deferredUpdates=function(m){var x=An.T,C=Qi();try{return Va(32),An.T=null,m()}finally{Va(C),An.T=x}},xn.discreteUpdates=function(m,x,C,N,k){var z=An.T,ie=Qi();try{return Va(2),An.T=null,m(x,C,N,k)}finally{Va(ie),An.T=z,yn===0&&(ui=Ea()+500)}},xn.findAllNodes=lr,xn.findBoundingRects=function(m,x){if(!Ul)throw Error(i(363));x=lr(m,x),m=[];for(var C=0;C<x.length;C++)m.push(y0(x[C]));for(x=m.length-1;0<x;x--){C=m[x];for(var N=C.x,k=N+C.width,z=C.y,ie=z+C.height,_e=x-1;0<=_e;_e--)if(x!==_e){var ke=m[_e],ht=ke.x,Ot=ht+ke.width,Vt=ke.y,Yt=Vt+ke.height;if(N>=ht&&z>=Vt&&k<=Ot&&ie<=Yt){m.splice(x,1);break}else if(N!==ht||C.width!==ke.width||Yt<z||Vt>ie){if(!(z!==Vt||C.height!==ke.height||Ot<N||ht>k)){ht>N&&(ke.width+=ht-N,ke.x=N),Ot<k&&(ke.width=k-ht),m.splice(x,1);break}}else{Vt>z&&(ke.height+=Vt-z,ke.y=z),Yt<ie&&(ke.height=ie-Vt),m.splice(x,1);break}}}return m},xn.findHostInstance=tb,xn.findHostInstanceWithNoPortals=function(m){return m=g(m),m=m!==null?_(m):null,m===null?null:qd(m.stateNode)},xn.findHostInstanceWithWarning=function(m){return tb(m)},xn.flushPassiveEffects=da,xn.flushSyncFromReconciler=function(m){var x=yn;yn|=1;var C=An.T,N=Qi();try{if(Va(2),An.T=null,m)return m()}finally{Va(N),An.T=C,yn=x,(yn&6)===0&&Et(0)}},xn.flushSyncWork=Jv,xn.focusWithin=function(m,x){if(!Ul)throw Error(i(363));for(m=r0(m),x=XA(m,x),x=Array.from(x),m=0;m<x.length;){var C=x[m++],N=C.tag;if(!Pl(C)){if((N===5||N===26||N===27)&&gi(C.stateNode))return!0;for(C=C.child;C!==null;)x.push(C),C=C.sibling}}return!1},xn.getFindAllNodesFailureDescription=function(m,x){if(!Ul)throw Error(i(363));var C=0,N=[];m=[r0(m),0];for(var k=0;k<m.length;){var z=m[k++],ie=z.tag,_e=m[k++],ke=x[_e];if((ie!==5&&ie!==26&&ie!==27||!Pl(z))&&(Vd(z,ke)&&(N.push(Au(ke)),_e++,_e>C&&(C=_e)),_e<x.length))for(z=z.child;z!==null;)m.push(z,_e),z=z.sibling}if(C<x.length){for(m=[];C<x.length;C++)m.push(Au(x[C]));return`findAllNodes was able to match part of the selector:
  `+(N.join(" > ")+`

No matching component was found for:
  `)+m.join(" > ")}return null},xn.getPublicRootInstance=function(m){if(m=m.current,!m.child)return null;switch(m.child.tag){case 27:case 5:return qd(m.child.stateNode);default:return m.child.stateNode}},xn.injectIntoDevTools=function(){var m={bundleType:0,version:p0,rendererPackageName:Pp,currentDispatcherRef:An,findFiberByHostInstance:db,reconcilerVersion:"19.0.0"};if(zp!==null&&(m.rendererConfig=zp),typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")m=!1;else{var x=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(x.isDisabled||!x.supportsFiber)m=!0;else{try{Qd=x.inject(m),Nr=x}catch{}m=!!x.checkDCE}}return m},xn.isAlreadyRendering=function(){return!1},xn.observeVisibleRects=function(m,x,C,N){if(!Ul)throw Error(i(363));m=lr(m,x);var k=mb(m,C,N).disconnect;return{disconnect:function(){k()}}},xn.shouldError=function(){return null},xn.shouldSuspend=function(){return!1},xn.startHostTransition=function(m,x,C,N){if(m.tag!==5)throw Error(i(476));var k=Iv(m).queue;Gg(m,k,x,Er,C===null?s:function(){var z=Iv(m).next.queue;return hu(m,z,{},cr()),C(N)})},xn.updateContainer=function(m,x,C,N){var k=x.current,z=cr();return YA(k,z,m,x,C,N),z},xn.updateContainerSync=function(m,x,C,N){return x.tag===0&&da(),YA(x.current,2,m,x,C,N),2},xn},n.exports.default=n.exports,Object.defineProperty(n.exports,"__esModule",{value:!0})})(BI)),BI.exports}var zP;function Tse(){return zP||(zP=1,OI.exports=Cse()),OI.exports}var Ese=Tse();const Mse=KE(Ese);var FI={exports:{}},UI={};var $P;function Nse(){return $P||($P=1,(function(n){function e(P,W){var q=P.length;P.push(W);e:for(;0<q;){var se=q-1>>>1,le=P[se];if(0<i(le,W))P[se]=W,P[q]=le,q=se;else break e}}function t(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var W=P[0],q=P.pop();if(q!==W){P[0]=q;e:for(var se=0,le=P.length,Y=le>>>1;se<Y;){var re=2*(se+1)-1,he=P[re],me=re+1,Ne=P[me];if(0>i(he,q))me<le&&0>i(Ne,he)?(P[se]=Ne,P[me]=q,se=me):(P[se]=he,P[re]=q,se=re);else if(me<le&&0>i(Ne,q))P[se]=Ne,P[me]=q,se=me;else break e}}return W}function i(P,W){var q=P.sortIndex-W.sortIndex;return q!==0?q:P.id-W.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var a=performance;n.unstable_now=function(){return a.now()}}else{var r=Date,o=r.now();n.unstable_now=function(){return r.now()-o}}var l=[],c=[],h=1,d=null,p=3,g=!1,v=!1,_=!1,S=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,w=typeof setImmediate<"u"?setImmediate:null;function T(P){for(var W=t(c);W!==null;){if(W.callback===null)s(c);else if(W.startTime<=P)s(c),W.sortIndex=W.expirationTime,e(l,W);else break;W=t(c)}}function E(P){if(_=!1,T(P),!v)if(t(l)!==null)v=!0,Z();else{var W=t(c);W!==null&&Q(E,W.startTime-P)}}var R=!1,D=-1,F=5,U=-1;function O(){return!(n.unstable_now()-U<F)}function B(){if(R){var P=n.unstable_now();U=P;var W=!0;try{e:{v=!1,_&&(_=!1,b(D),D=-1),g=!0;var q=p;try{t:{for(T(P),d=t(l);d!==null&&!(d.expirationTime>P&&O());){var se=d.callback;if(typeof se=="function"){d.callback=null,p=d.priorityLevel;var le=se(d.expirationTime<=P);if(P=n.unstable_now(),typeof le=="function"){d.callback=le,T(P),W=!0;break t}d===t(l)&&s(l),T(P)}else s(l);d=t(l)}if(d!==null)W=!0;else{var Y=t(c);Y!==null&&Q(E,Y.startTime-P),W=!1}}break e}finally{d=null,p=q,g=!1}W=void 0}}finally{W?L():R=!1}}}var L;if(typeof w=="function")L=function(){w(B)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,K=H.port2;H.port1.onmessage=B,L=function(){K.postMessage(null)}}else L=function(){S(B,0)};function Z(){R||(R=!0,L())}function Q(P,W){D=S(function(){P(n.unstable_now())},W)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_continueExecution=function(){v||g||(v=!0,Z())},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):F=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return p},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(P){switch(p){case 1:case 2:case 3:var W=3;break;default:W=p}var q=p;p=W;try{return P()}finally{p=q}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(P,W){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var q=p;p=P;try{return W()}finally{p=q}},n.unstable_scheduleCallback=function(P,W,q){var se=n.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?se+q:se):q=se,P){case 1:var le=-1;break;case 2:le=250;break;case 5:le=1073741823;break;case 4:le=1e4;break;default:le=5e3}return le=q+le,P={id:h++,callback:W,priorityLevel:P,startTime:q,expirationTime:le,sortIndex:-1},q>se?(P.sortIndex=q,e(c,P),t(l)===null&&P===t(c)&&(_?(b(D),D=-1):_=!0,Q(E,q-se))):(P.sortIndex=le,e(l,P),v||g||(v=!0,Z())),P},n.unstable_shouldYield=O,n.unstable_wrapCallback=function(P){var W=p;return function(){var q=p;p=W;try{return P.apply(this,arguments)}finally{p=q}}}})(UI)),UI}var GP;function Rse(){return GP||(GP=1,FI.exports=Nse()),FI.exports}var VP=Rse();function UO(n,e,t){if(!n)return;if(t(n)===!0)return n;let s=e?n.return:n.child;for(;s;){const i=UO(s,e,t);if(i)return i;s=e?null:s.sibling}}function pV(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const PO=pV(pe.createContext(null));class mV extends pe.Component{render(){return pe.createElement(PO.Provider,{value:this._reactInternals},this.props.children)}}function gV(){const n=pe.useContext(PO);if(n===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=pe.useId();return pe.useMemo(()=>{for(const t of[n,n?.alternate]){if(!t)continue;const s=UO(t,!1,i=>{let a=i.memoizedState;for(;a;){if(a.memoizedState===e)return!0;a=a.next}});if(s)return s}},[n,e])}const Ise=Symbol.for("react.context"),Dse=n=>n!==null&&typeof n=="object"&&"$$typeof"in n&&n.$$typeof===Ise;function Ose(){const n=gV(),[e]=pe.useState(()=>new Map);e.clear();let t=n;for(;t;){const s=t.type;Dse(s)&&s!==PO&&!e.has(s)&&e.set(s,pe.use(pV(s))),t=t.return}return e}function Bse(){const n=Ose();return pe.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>s=>pe.createElement(e,null,pe.createElement(t.Provider,{...s,value:n.get(t)})),e=>pe.createElement(mV,{...e})),[n])}function xV(n){let e=n.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const yV=n=>n&&n.isOrthographicCamera,kse=n=>n&&n.hasOwnProperty("current"),Lse=n=>n!=null&&(typeof n=="string"||typeof n=="number"||n.isColor),PS=((n,e)=>typeof window<"u"&&(((n=window.document)==null?void 0:n.createElement)||((e=window.navigator)==null?void 0:e.product)==="ReactNative"))()?pe.useLayoutEffect:pe.useEffect;function zO(n){const e=pe.useRef(n);return PS(()=>void(e.current=n),[n]),e}function Fse(){const n=gV(),e=Bse();return pe.useMemo(()=>({children:t})=>{const i=!!UO(n,!0,a=>a.type===pe.StrictMode)?pe.StrictMode:pe.Fragment;return V.jsx(i,{children:V.jsx(e,{children:t})})},[n,e])}function Use({set:n}){return PS(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}const Pse=(n=>(n=class extends pe.Component{constructor(...t){super(...t),this.state={error:!1}}componentDidCatch(t){this.props.set(t)}render(){return this.state.error?null:this.props.children}},n.getDerivedStateFromError=()=>({error:!0}),n))();function vV(n){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(n)?Math.min(Math.max(n[0],t),n[1]):n}function fx(n){var e;return(e=n.__r3f)==null?void 0:e.root.getState()}const Si={obj:n=>n===Object(n)&&!Si.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,nul:n=>n===null,arr:n=>Array.isArray(n),equ(n,e,{arrays:t="shallow",objects:s="reference",strict:i=!0}={}){if(typeof n!=typeof e||!!n!=!!e)return!1;if(Si.str(n)||Si.num(n)||Si.boo(n))return n===e;const a=Si.obj(n);if(a&&s==="reference")return n===e;const r=Si.arr(n);if(r&&t==="reference")return n===e;if((r||a)&&n===e)return!0;let o;for(o in n)if(!(o in e))return!1;if(a&&t==="shallow"&&s==="shallow"){for(o in i?e:n)if(!Si.equ(n[o],e[o],{strict:i,objects:"reference"}))return!1}else for(o in i?e:n)if(n[o]!==e[o])return!1;if(Si.und(o)){if(r&&n.length===0&&e.length===0||a&&Object.keys(n).length===0&&Object.keys(e).length===0)return!0;if(n!==e)return!1}return!0}};function zse(n){const e={nodes:{},materials:{},meshes:{}};return n&&n.traverse(t=>{t.name&&(e.nodes[t.name]=t),t.material&&!e.materials[t.material.name]&&(e.materials[t.material.name]=t.material),t.isMesh&&!e.meshes[t.name]&&(e.meshes[t.name]=t)}),e}function $se(n){n.type!=="Scene"&&(n.dispose==null||n.dispose());for(const e in n){const t=n[e];t?.type!=="Scene"&&(t==null||t.dispose==null||t.dispose())}}const bV=["children","key","ref"];function Gse(n){const e={};for(const t in n)bV.includes(t)||(e[t]=n[t]);return e}function fE(n,e,t,s){const i=n;let a=i?.__r3f;return a||(a={root:e,type:t,parent:null,children:[],props:Gse(s),object:i,eventCount:0,handlers:{},isHidden:!1},i&&(i.__r3f=a)),a}function eS(n,e){if(!e.includes("-"))return{root:n,key:e,target:n[e]};if(e in n)return{root:n,key:e,target:n[e]};let t=n;const s=e.split("-");for(const i of s){if(typeof t!="object"||t===null){if(t!==void 0){const a=s.slice(s.indexOf(i)).join("-");return{root:t,key:a,target:void 0}}return{root:n,key:e,target:void 0}}e=i,n=t,t=t[e]}return{root:n,key:e,target:t}}const HP=/-\d+$/;function pE(n,e){if(Si.str(e.props.attach)){if(HP.test(e.props.attach)){const i=e.props.attach.replace(HP,""),{root:a,key:r}=eS(n.object,i);Array.isArray(a[r])||(a[r]=[])}const{root:t,key:s}=eS(n.object,e.props.attach);e.previousAttach=t[s],t[s]=e.object}else Si.fun(e.props.attach)&&(e.previousAttach=e.props.attach(n.object,e.object))}function mE(n,e){if(Si.str(e.props.attach)){const{root:t,key:s}=eS(n.object,e.props.attach),i=e.previousAttach;i===void 0?delete t[s]:t[s]=i}else e.previousAttach==null||e.previousAttach(n.object,e.object);delete e.previousAttach}const z3=[...bV,"args","dispose","attach","object","onUpdate","dispose"],WP=new Map;function Vse(n){let e=WP.get(n.constructor);try{e||(e=new n.constructor,WP.set(n.constructor,e))}catch{}return e}function Hse(n,e){const t={};for(const s in e)if(!z3.includes(s)&&!Si.equ(e[s],n.props[s])){t[s]=e[s];for(const i in e)i.startsWith(`${s}-`)&&(t[i]=e[i])}for(const s in n.props){if(z3.includes(s)||e.hasOwnProperty(s))continue;const{root:i,key:a}=eS(n.object,s);if(i.constructor&&i.constructor.length===0){const r=Vse(i);Si.und(r)||(t[a]=r[a])}else t[a]=0}return t}const Wse=["map","emissiveMap","sheenColorMap","specularColorMap","envMap"],jse=/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;function Xu(n,e){var t;const s=n.__r3f,i=s&&xV(s).getState(),a=s?.eventCount;for(const o in e){let l=e[o];if(z3.includes(o))continue;if(s&&jse.test(o)){typeof l=="function"?s.handlers[o]=l:delete s.handlers[o],s.eventCount=Object.keys(s.handlers).length;continue}if(l===void 0)continue;let{root:c,key:h,target:d}=eS(n,o);if(d===void 0&&(typeof c!="object"||c===null))throw Error(`R3F: Cannot set "${o}". Ensure it is an object before setting "${h}".`);if(d instanceof Px&&l instanceof Px)d.mask=l.mask;else if(d instanceof $t&&Lse(l))d.set(l);else if(d!==null&&typeof d=="object"&&typeof d.set=="function"&&typeof d.copy=="function"&&l!=null&&l.constructor&&d.constructor===l.constructor)d.copy(l);else if(d!==null&&typeof d=="object"&&typeof d.set=="function"&&Array.isArray(l))typeof d.fromArray=="function"?d.fromArray(l):d.set(...l);else if(d!==null&&typeof d=="object"&&typeof d.set=="function"&&typeof l=="number")typeof d.setScalar=="function"?d.setScalar(l):d.set(l);else{var r;c[h]=l,i&&!i.linear&&Wse.includes(h)&&(r=c[h])!=null&&r.isTexture&&c[h].format===ra&&c[h].type===Co&&(c[h].colorSpace=mr)}}if(s!=null&&s.parent&&i!=null&&i.internal&&(t=s.object)!=null&&t.isObject3D&&a!==s.eventCount){const o=s.object,l=i.internal.interaction.indexOf(o);l>-1&&i.internal.interaction.splice(l,1),s.eventCount&&o.raycast!==null&&i.internal.interaction.push(o)}return s&&s.props.attach===void 0&&(s.object.isBufferGeometry?s.props.attach="geometry":s.object.isMaterial&&(s.props.attach="material")),s&&xy(s),n}function xy(n){var e;if(!n.parent)return;n.props.onUpdate==null||n.props.onUpdate(n.object);const t=(e=n.root)==null||e.getState==null?void 0:e.getState();t&&t.internal.frames===0&&t.invalidate()}function SV(n,e){n.manual||(yV(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix())}const yo=n=>n?.isObject3D;function UC(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function _V(n,e,t,s){const i=t.get(e);i&&(t.delete(e),t.size===0&&(n.delete(s),i.target.releasePointerCapture(s)))}function Xse(n,e){const{internal:t}=n.getState();t.interaction=t.interaction.filter(s=>s!==e),t.initialHits=t.initialHits.filter(s=>s!==e),t.hovered.forEach((s,i)=>{(s.eventObject===e||s.object===e)&&t.hovered.delete(i)}),t.capturedMap.forEach((s,i)=>{_V(t.capturedMap,e,s,i)})}function qse(n){function e(l){const{internal:c}=n.getState(),h=l.offsetX-c.initialClick[0],d=l.offsetY-c.initialClick[1];return Math.round(Math.sqrt(h*h+d*d))}function t(l){return l.filter(c=>["Move","Over","Enter","Out","Leave"].some(h=>{var d;return(d=c.__r3f)==null?void 0:d.handlers["onPointer"+h]}))}function s(l,c){const h=n.getState(),d=new Set,p=[],g=c?c(h.internal.interaction):h.internal.interaction;for(let b=0;b<g.length;b++){const w=fx(g[b]);w&&(w.raycaster.camera=void 0)}h.previousRoot||h.events.compute==null||h.events.compute(l,h);function v(b){const w=fx(b);if(!w||!w.events.enabled||w.raycaster.camera===null)return[];if(w.raycaster.camera===void 0){var T;w.events.compute==null||w.events.compute(l,w,(T=w.previousRoot)==null?void 0:T.getState()),w.raycaster.camera===void 0&&(w.raycaster.camera=null)}return w.raycaster.camera?w.raycaster.intersectObject(b,!0):[]}let _=g.flatMap(v).sort((b,w)=>{const T=fx(b.object),E=fx(w.object);return!T||!E?b.distance-w.distance:E.events.priority-T.events.priority||b.distance-w.distance}).filter(b=>{const w=UC(b);return d.has(w)?!1:(d.add(w),!0)});h.events.filter&&(_=h.events.filter(_,h));for(const b of _){let w=b.object;for(;w;){var S;(S=w.__r3f)!=null&&S.eventCount&&p.push({...b,eventObject:w}),w=w.parent}}if("pointerId"in l&&h.internal.capturedMap.has(l.pointerId))for(let b of h.internal.capturedMap.get(l.pointerId).values())d.has(UC(b.intersection))||p.push(b.intersection);return p}function i(l,c,h,d){if(l.length){const p={stopped:!1};for(const g of l){let v=fx(g.object);if(v||g.object.traverseAncestors(_=>{const S=fx(_);if(S)return v=S,!1}),v){const{raycaster:_,pointer:S,camera:b,internal:w}=v,T=new ue(S.x,S.y,0).unproject(b),E=O=>{var B,L;return(B=(L=w.capturedMap.get(O))==null?void 0:L.has(g.eventObject))!=null?B:!1},R=O=>{const B={intersection:g,target:c.target};w.capturedMap.has(O)?w.capturedMap.get(O).set(g.eventObject,B):w.capturedMap.set(O,new Map([[g.eventObject,B]])),c.target.setPointerCapture(O)},D=O=>{const B=w.capturedMap.get(O);B&&_V(w.capturedMap,g.eventObject,B,O)};let F={};for(let O in c){let B=c[O];typeof B!="function"&&(F[O]=B)}let U={...g,...F,pointer:S,intersections:l,stopped:p.stopped,delta:h,unprojectedPoint:T,ray:_.ray,camera:b,stopPropagation(){const O="pointerId"in c&&w.capturedMap.get(c.pointerId);if((!O||O.has(g.eventObject))&&(U.stopped=p.stopped=!0,w.hovered.size&&Array.from(w.hovered.values()).find(B=>B.eventObject===g.eventObject))){const B=l.slice(0,l.indexOf(g));a([...B,g])}},target:{hasPointerCapture:E,setPointerCapture:R,releasePointerCapture:D},currentTarget:{hasPointerCapture:E,setPointerCapture:R,releasePointerCapture:D},nativeEvent:c};if(d(U),p.stopped===!0)break}}}return l}function a(l){const{internal:c}=n.getState();for(const h of c.hovered.values())if(!l.length||!l.find(d=>d.object===h.object&&d.index===h.index&&d.instanceId===h.instanceId)){const p=h.eventObject.__r3f;if(c.hovered.delete(UC(h)),p!=null&&p.eventCount){const g=p.handlers,v={...h,intersections:l};g.onPointerOut==null||g.onPointerOut(v),g.onPointerLeave==null||g.onPointerLeave(v)}}}function r(l,c){for(let h=0;h<c.length;h++){const d=c[h].__r3f;d==null||d.handlers.onPointerMissed==null||d.handlers.onPointerMissed(l)}}function o(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>a([]);case"onLostPointerCapture":return c=>{const{internal:h}=n.getState();"pointerId"in c&&h.capturedMap.has(c.pointerId)&&requestAnimationFrame(()=>{h.capturedMap.has(c.pointerId)&&(h.capturedMap.delete(c.pointerId),a([]))})}}return function(h){const{onPointerMissed:d,internal:p}=n.getState();p.lastEvent.current=h;const g=l==="onPointerMove",v=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",S=s(h,g?t:void 0),b=v?e(h):0;l==="onPointerDown"&&(p.initialClick=[h.offsetX,h.offsetY],p.initialHits=S.map(T=>T.eventObject)),v&&!S.length&&b<=2&&(r(h,p.interaction),d&&d(h)),g&&a(S);function w(T){const E=T.eventObject,R=E.__r3f;if(!(R!=null&&R.eventCount))return;const D=R.handlers;if(g){if(D.onPointerOver||D.onPointerEnter||D.onPointerOut||D.onPointerLeave){const F=UC(T),U=p.hovered.get(F);U?U.stopped&&T.stopPropagation():(p.hovered.set(F,T),D.onPointerOver==null||D.onPointerOver(T),D.onPointerEnter==null||D.onPointerEnter(T))}D.onPointerMove==null||D.onPointerMove(T)}else{const F=D[l];F?(!v||p.initialHits.includes(E))&&(r(h,p.interaction.filter(U=>!p.initialHits.includes(U))),F(T)):v&&p.initialHits.includes(E)&&r(h,p.interaction.filter(U=>!p.initialHits.includes(U)))}}i(S,h,b,w)}}return{handlePointer:o}}const jP=n=>!!(n!=null&&n.render),$O=pe.createContext(null),Kse=(n,e)=>{const t=hV((o,l)=>{const c=new ue,h=new ue,d=new ue;function p(b=l().camera,w=h,T=l().size){const{width:E,height:R,top:D,left:F}=T,U=E/R;w.isVector3?d.copy(w):d.set(...w);const O=b.getWorldPosition(c).distanceTo(d);if(yV(b))return{width:E/b.zoom,height:R/b.zoom,top:D,left:F,factor:1,distance:O,aspect:U};{const B=b.fov*Math.PI/180,L=2*Math.tan(B/2)*O,H=L*(E/R);return{width:H,height:L,top:D,left:F,factor:E/H,distance:O,aspect:U}}}let g;const v=b=>o(w=>({performance:{...w.performance,current:b}})),_=new rt;return{set:o,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},scene:null,xr:null,invalidate:(b=1)=>n(l(),b),advance:(b,w)=>e(b,w,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new DO,pointer:_,mouse:_,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const b=l();g&&clearTimeout(g),b.performance.current!==b.performance.min&&v(b.performance.min),g=setTimeout(()=>v(l().performance.max),b.performance.debounce)}},size:{width:0,height:0,top:0,left:0},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:p},setEvents:b=>o(w=>({...w,events:{...w.events,...b}})),setSize:(b,w,T=0,E=0)=>{const R=l().camera,D={width:b,height:w,top:T,left:E};o(F=>({size:D,viewport:{...F.viewport,...p(R,h,D)}}))},setDpr:b=>o(w=>{const T=vV(b);return{viewport:{...w.viewport,dpr:T,initialDpr:w.viewport.initialDpr||T}}}),setFrameloop:(b="always")=>{const w=l().clock;w.stop(),w.elapsedTime=0,b!=="never"&&(w.start(),w.elapsedTime=0),o(()=>({frameloop:b}))},previousRoot:void 0,internal:{interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,lastEvent:pe.createRef(),active:!1,frames:0,priority:0,subscribe:(b,w,T)=>{const E=l().internal;return E.priority=E.priority+(w>0?1:0),E.subscribers.push({ref:b,priority:w,store:T}),E.subscribers=E.subscribers.sort((R,D)=>R.priority-D.priority),()=>{const R=l().internal;R!=null&&R.subscribers&&(R.priority=R.priority-(w>0?1:0),R.subscribers=R.subscribers.filter(D=>D.ref!==b))}}}}}),s=t.getState();let i=s.size,a=s.viewport.dpr,r=s.camera;return t.subscribe(()=>{const{camera:o,size:l,viewport:c,gl:h,set:d}=t.getState();if(l.width!==i.width||l.height!==i.height||c.dpr!==a){i=l,a=c.dpr,SV(o,l),c.dpr>0&&h.setPixelRatio(c.dpr);const p=typeof HTMLCanvasElement<"u"&&h.domElement instanceof HTMLCanvasElement;h.setSize(l.width,l.height,p)}o!==r&&(r=o,d(p=>({viewport:{...p.viewport,...p.viewport.getCurrentViewport(o)}})))}),t.subscribe(o=>n(o)),t};function GO(){const n=pe.useContext($O);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function sa(n=t=>t,e){return GO()(n,e)}function D2(n,e=0){const t=GO(),s=t.getState().internal.subscribe,i=zO(n);return PS(()=>s(i,e,t),[e,s,t]),null}const XP=new WeakMap,Yse=n=>{var e;return typeof n=="function"&&(n==null||(e=n.prototype)==null?void 0:e.constructor)===n};function AV(n,e){return function(t,...s){let i;return Yse(t)?(i=XP.get(t),i||(i=new t,XP.set(t,i))):i=t,n&&n(i),Promise.all(s.map(a=>new Promise((r,o)=>i.load(a,l=>{yo(l?.scene)&&Object.assign(l,zse(l.scene)),r(l)},e,l=>o(new Error(`Could not load ${a}: ${l?.message}`))))))}}function md(n,e,t,s){const i=Array.isArray(e)?e:[e],a=bse(AV(t,s),[n,...i],{equal:Si.equ});return Array.isArray(e)?a:a[0]}md.preload=function(n,e,t){const s=Array.isArray(e)?e:[e];return Sse(AV(t),[n,...s])};md.clear=function(n,e){const t=Array.isArray(e)?e:[e];return _se([n,...t])};var Jse={version:"9.4.2"};function Zse(n){const e=Mse(n);return e.injectIntoDevTools(),e}const wV=0,Vx={},Qse=/^three(?=[A-Z])/,O2=n=>`${n[0].toUpperCase()}${n.slice(1)}`;let eie=0;const tie=n=>typeof n=="function";function VO(n){if(tie(n)){const e=`${eie++}`;return Vx[e]=n,e}else Object.assign(Vx,n)}function CV(n,e){const t=O2(n),s=Vx[t];if(n!=="primitive"&&!s)throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(n==="primitive"&&!e.object)throw new Error("R3F: Primitives without 'object' are invalid!");if(e.args!==void 0&&!Array.isArray(e.args))throw new Error("R3F: The args prop must be an array!")}function nie(n,e,t){var s;return n=O2(n)in Vx?n:n.replace(Qse,""),CV(n,e),n==="primitive"&&(s=e.object)!=null&&s.__r3f&&delete e.object.__r3f,fE(e.object,t,n,e)}function sie(n){if(!n.isHidden){var e;n.props.attach&&(e=n.parent)!=null&&e.object?mE(n.parent,n):yo(n.object)&&(n.object.visible=!1),n.isHidden=!0,xy(n)}}function TV(n){if(n.isHidden){var e;n.props.attach&&(e=n.parent)!=null&&e.object?pE(n.parent,n):yo(n.object)&&n.props.visible!==!1&&(n.object.visible=!0),n.isHidden=!1,xy(n)}}function HO(n,e,t){const s=e.root.getState();if(!(!n.parent&&n.object!==s.scene)){if(!e.object){var i,a;const r=Vx[O2(e.type)];e.object=(i=e.props.object)!=null?i:new r(...(a=e.props.args)!=null?a:[]),e.object.__r3f=e}if(Xu(e.object,e.props),e.props.attach)pE(n,e);else if(yo(e.object)&&yo(n.object)){const r=n.object.children.indexOf(t?.object);if(t&&r!==-1){const o=n.object.children.indexOf(e.object);if(o!==-1){n.object.children.splice(o,1);const l=o<r?r-1:r;n.object.children.splice(l,0,e.object)}else e.object.parent=n.object,n.object.children.splice(r,0,e.object),e.object.dispatchEvent({type:"added"}),n.object.dispatchEvent({type:"childadded",child:e.object})}else n.object.add(e.object)}for(const r of e.children)HO(e,r);xy(e)}}function PI(n,e){e&&(e.parent=n,n.children.push(e),HO(n,e))}function qP(n,e,t){if(!e||!t)return;e.parent=n;const s=n.children.indexOf(t);s!==-1?n.children.splice(s,0,e):n.children.push(e),HO(n,e,t)}function EV(n){if(typeof n.dispose=="function"){const e=()=>{try{n.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT<"u"?e():VP.unstable_scheduleCallback(VP.unstable_IdlePriority,e)}}function $3(n,e,t){if(!e)return;e.parent=null;const s=n.children.indexOf(e);s!==-1&&n.children.splice(s,1),e.props.attach?mE(n,e):yo(e.object)&&yo(n.object)&&(n.object.remove(e.object),Xse(xV(e),e.object));const i=e.props.dispose!==null&&t!==!1;for(let a=e.children.length-1;a>=0;a--){const r=e.children[a];$3(e,r,i)}e.children.length=0,delete e.object.__r3f,i&&e.type!=="primitive"&&e.object.type!=="Scene"&&EV(e.object),t===void 0&&xy(e)}function iie(n,e){for(const t of[n,n.alternate])if(t!==null)if(typeof t.ref=="function"){t.refCleanup==null||t.refCleanup();const s=t.ref(e);typeof s=="function"&&(t.refCleanup=s)}else t.ref&&(t.ref.current=e)}const dT=[];function aie(){for(const[t]of dT){const s=t.parent;if(s){t.props.attach?mE(s,t):yo(t.object)&&yo(s.object)&&s.object.remove(t.object);for(const i of t.children)i.props.attach?mE(t,i):yo(i.object)&&yo(t.object)&&t.object.remove(i.object)}t.isHidden&&TV(t),t.object.__r3f&&delete t.object.__r3f,t.type!=="primitive"&&EV(t.object)}for(const[t,s,i]of dT){t.props=s;const a=t.parent;if(a){var n,e;const r=Vx[O2(t.type)];t.object=(n=t.props.object)!=null?n:new r(...(e=t.props.args)!=null?e:[]),t.object.__r3f=t,iie(i,t.object),Xu(t.object,t.props),t.props.attach?pE(a,t):yo(t.object)&&yo(a.object)&&a.object.add(t.object);for(const o of t.children)o.props.attach?pE(t,o):yo(o.object)&&yo(t.object)&&t.object.add(o.object);xy(t)}}dT.length=0}const zI=()=>{},KP={};let PC=wV;const rie=0,oie=4,gE=Zse({isPrimaryRenderer:!1,warnsIfNotActing:!1,supportsMutation:!0,supportsPersistence:!1,supportsHydration:!1,createInstance:nie,removeChild:$3,appendChild:PI,appendInitialChild:PI,insertBefore:qP,appendChildToContainer(n,e){const t=n.getState().scene.__r3f;!e||!t||PI(t,e)},removeChildFromContainer(n,e){const t=n.getState().scene.__r3f;!e||!t||$3(t,e)},insertInContainerBefore(n,e,t){const s=n.getState().scene.__r3f;!e||!t||!s||qP(s,e,t)},getRootHostContext:()=>KP,getChildHostContext:()=>KP,commitUpdate(n,e,t,s,i){var a,r,o;CV(e,s);let l=!1;if((n.type==="primitive"&&t.object!==s.object||((a=s.args)==null?void 0:a.length)!==((r=t.args)==null?void 0:r.length)||(o=s.args)!=null&&o.some((h,d)=>{var p;return h!==((p=t.args)==null?void 0:p[d])}))&&(l=!0),l)dT.push([n,{...s},i]);else{const h=Hse(n,s);Object.keys(h).length&&(Object.assign(n.props,h),Xu(n.object,h))}(i.sibling===null||(i.flags&oie)===rie)&&aie()},finalizeInitialChildren:()=>!1,commitMount(){},getPublicInstance:n=>n?.object,prepareForCommit:()=>null,preparePortalMount:n=>fE(n.getState().scene,n,"",{}),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance:sie,unhideInstance:TV,createTextInstance:zI,hideTextInstance:zI,unhideTextInstance:zI,scheduleTimeout:typeof setTimeout=="function"?setTimeout:void 0,cancelTimeout:typeof clearTimeout=="function"?clearTimeout:void 0,noTimeout:-1,getInstanceFromNode:()=>null,beforeActiveInstanceBlur(){},afterActiveInstanceBlur(){},detachDeletedInstance(){},prepareScopeUpdate(){},getInstanceFromScope:()=>null,shouldAttemptEagerTransition:()=>!1,trackSchedulerEvent:()=>{},resolveEventType:()=>null,resolveEventTimeStamp:()=>-1.1,requestPostPaintCallback(){},maySuspendCommit:()=>!1,preloadInstance:()=>!0,startSuspendingCommit(){},suspendInstance(){},waitForCommitToBeReady:()=>null,NotPendingTransition:null,HostTransitionContext:pe.createContext(null),setCurrentUpdatePriority(n){PC=n},getCurrentUpdatePriority(){return PC},resolveUpdatePriority(){var n;if(PC!==wV)return PC;switch(typeof window<"u"&&((n=window.event)==null?void 0:n.type)){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return lT.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return lT.ContinuousEventPriority;default:return lT.DefaultEventPriority}},resetFormInstance(){},rendererPackageName:"@react-three/fiber",rendererVersion:Jse.version}),og=new Map,px={objects:"shallow",strict:!1};function lie(n,e){if(!e&&typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement&&n.parentElement){const{width:t,height:s,top:i,left:a}=n.parentElement.getBoundingClientRect();return{width:t,height:s,top:i,left:a}}else if(!e&&typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas)return{width:n.width,height:n.height,top:0,left:0};return{width:0,height:0,top:0,left:0,...e}}function cie(n){const e=og.get(n),t=e?.fiber,s=e?.store;e&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,a=s||Kse(H3,JP),r=t||gE.createContainer(a,lT.ConcurrentRoot,null,!1,null,"",i,i,i,null);e||og.set(n,{fiber:r,store:a});let o,l,c=!1,h=null;return{async configure(d={}){let p;h=new Promise(Y=>p=Y);let{gl:g,size:v,scene:_,events:S,onCreated:b,shadows:w=!1,linear:T=!1,flat:E=!1,legacy:R=!1,orthographic:D=!1,frameloop:F="always",dpr:U=[1,2],performance:O,raycaster:B,camera:L,onPointerMissed:H}=d,K=a.getState(),Z=K.gl;if(!K.gl){const Y={canvas:n,powerPreference:"high-performance",antialias:!0,alpha:!0},re=typeof g=="function"?await g(Y):g;jP(re)?Z=re:Z=new FO({...Y,...g}),K.set({gl:Z})}let Q=K.raycaster;Q||K.set({raycaster:Q=new kO});const{params:P,...W}=B||{};if(Si.equ(W,Q,px)||Xu(Q,{...W}),Si.equ(P,Q.params,px)||Xu(Q,{params:{...Q.params,...P}}),!K.camera||K.camera===l&&!Si.equ(l,L,px)){l=L;const Y=L?.isCamera,re=Y?L:D?new Zu(0,0,0,0,.1,1e3):new ki(75,0,.1,1e3);Y||(re.position.z=5,L&&(Xu(re,L),re.manual||("aspect"in L||"left"in L||"right"in L||"bottom"in L||"top"in L)&&(re.manual=!0,re.updateProjectionMatrix())),!K.camera&&!(L!=null&&L.rotation)&&re.lookAt(0,0,0)),K.set({camera:re}),Q.camera=re}if(!K.scene){let Y;_!=null&&_.isScene?(Y=_,fE(Y,a,"",{})):(Y=new dy,fE(Y,a,"",{}),_&&Xu(Y,_)),K.set({scene:Y})}S&&!K.events.handlers&&K.set({events:S(a)});const q=lie(n,v);if(Si.equ(q,K.size,px)||K.setSize(q.width,q.height,q.top,q.left),U&&K.viewport.dpr!==vV(U)&&K.setDpr(U),K.frameloop!==F&&K.setFrameloop(F),K.onPointerMissed||K.set({onPointerMissed:H}),O&&!Si.equ(O,K.performance,px)&&K.set(Y=>({performance:{...Y.performance,...O}})),!K.xr){var se;const Y=(me,Ne)=>{const fe=a.getState();fe.frameloop!=="never"&&JP(me,!0,fe,Ne)},re=()=>{const me=a.getState();me.gl.xr.enabled=me.gl.xr.isPresenting,me.gl.xr.setAnimationLoop(me.gl.xr.isPresenting?Y:null),me.gl.xr.isPresenting||H3(me)},he={connect(){const me=a.getState().gl;me.xr.addEventListener("sessionstart",re),me.xr.addEventListener("sessionend",re)},disconnect(){const me=a.getState().gl;me.xr.removeEventListener("sessionstart",re),me.xr.removeEventListener("sessionend",re)}};typeof((se=Z.xr)==null?void 0:se.addEventListener)=="function"&&he.connect(),K.set({xr:he})}if(Z.shadowMap){const Y=Z.shadowMap.enabled,re=Z.shadowMap.type;if(Z.shadowMap.enabled=!!w,Si.boo(w))Z.shadowMap.type=D1;else if(Si.str(w)){var le;const he={basic:y4,percentage:ZE,soft:D1,variance:Gc};Z.shadowMap.type=(le=he[w])!=null?le:D1}else Si.obj(w)&&Object.assign(Z.shadowMap,w);(Y!==Z.shadowMap.enabled||re!==Z.shadowMap.type)&&(Z.shadowMap.needsUpdate=!0)}return ws.enabled=!R,c||(Z.outputColorSpace=T?Qc:mr,Z.toneMapping=E?Ju:YD),K.legacy!==R&&K.set(()=>({legacy:R})),K.linear!==T&&K.set(()=>({linear:T})),K.flat!==E&&K.set(()=>({flat:E})),g&&!Si.fun(g)&&!jP(g)&&!Si.equ(g,Z,px)&&Xu(Z,g),o=b,c=!0,p(),this},render(d){return!c&&!h&&this.configure(),h.then(()=>{gE.updateContainer(V.jsx(uie,{store:a,children:d,onCreated:o,rootElement:n}),r,null,()=>{})}),a},unmount(){MV(n)}}}function uie({store:n,children:e,onCreated:t,rootElement:s}){return PS(()=>{const i=n.getState();i.set(a=>({internal:{...a.internal,active:!0}})),t&&t(i),n.getState().events.connected||i.events.connect==null||i.events.connect(s)},[]),V.jsx($O.Provider,{value:n,children:e})}function MV(n,e){const t=og.get(n),s=t?.fiber;if(s){const i=t?.store.getState();i&&(i.internal.active=!1),gE.updateContainer(null,s,null,()=>{i&&setTimeout(()=>{try{var a,r,o,l;i.events.disconnect==null||i.events.disconnect(),(a=i.gl)==null||(r=a.renderLists)==null||r.dispose==null||r.dispose(),(o=i.gl)==null||o.forceContextLoss==null||o.forceContextLoss(),(l=i.gl)!=null&&l.xr&&i.xr.disconnect(),$se(i.scene),og.delete(n)}catch{}},500)})}}function hie(n,e,t){return V.jsx(die,{children:n,container:e,state:t})}function die({state:n={},children:e,container:t}){const{events:s,size:i,...a}=n,r=GO(),[o]=pe.useState(()=>new kO),[l]=pe.useState(()=>new rt),c=zO((d,p)=>{let g;if(p.camera&&i){const v=p.camera;g=d.viewport.getCurrentViewport(v,new ue,i),v!==d.camera&&SV(v,i)}return{...d,...p,scene:t,raycaster:o,pointer:l,mouse:l,previousRoot:r,events:{...d.events,...p.events,...s},size:{...d.size,...i},viewport:{...d.viewport,...g},setEvents:v=>p.set(_=>({..._,events:{..._.events,...v}}))}}),h=pe.useMemo(()=>{const d=hV((g,v)=>({...a,set:g,get:v})),p=g=>d.setState(v=>c.current(g,v));return p(r.getState()),r.subscribe(p),d},[r,t]);return V.jsx(V.Fragment,{children:gE.createPortal(V.jsx($O.Provider,{value:h,children:e}),h,null)})}const fie=new Set,pie=new Set,mie=new Set;function $I(n,e){if(n.size)for(const{callback:t}of n.values())t(e)}function z1(n,e){switch(n){case"before":return $I(fie,e);case"after":return $I(pie,e);case"tail":return $I(mie,e)}}let GI,VI;function G3(n,e,t){let s=e.clock.getDelta();e.frameloop==="never"&&typeof n=="number"&&(s=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),GI=e.internal.subscribers;for(let i=0;i<GI.length;i++)VI=GI[i],VI.ref.current(VI.store.getState(),s,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}let xE=!1,V3=!1,HI,YP,mx;function NV(n){YP=requestAnimationFrame(NV),xE=!0,HI=0,z1("before",n),V3=!0;for(const t of og.values()){var e;mx=t.store.getState(),mx.internal.active&&(mx.frameloop==="always"||mx.internal.frames>0)&&!((e=mx.gl.xr)!=null&&e.isPresenting)&&(HI+=G3(n,mx))}if(V3=!1,z1("after",n),HI===0)return z1("tail",n),xE=!1,cancelAnimationFrame(YP)}function H3(n,e=1){var t;if(!n)return og.forEach(s=>H3(s.store.getState(),e));(t=n.gl.xr)!=null&&t.isPresenting||!n.internal.active||n.frameloop==="never"||(e>1?n.internal.frames=Math.min(60,n.internal.frames+e):V3?n.internal.frames=2:n.internal.frames=1,xE||(xE=!0,requestAnimationFrame(NV)))}function JP(n,e=!0,t,s){if(e&&z1("before",n),t)G3(n,t,s);else for(const i of og.values())G3(n,i.store.getState());e&&z1("after",n)}const WI={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function gie(n){const{handlePointer:e}=qse(n);return{priority:1,enabled:!0,compute(t,s,i){s.pointer.set(t.offsetX/s.size.width*2-1,-(t.offsetY/s.size.height)*2+1),s.raycaster.setFromCamera(s.pointer,s.camera)},connected:void 0,handlers:Object.keys(WI).reduce((t,s)=>({...t,[s]:e(s)}),{}),update:()=>{var t;const{events:s,internal:i}=n.getState();(t=i.lastEvent)!=null&&t.current&&s.handlers&&s.handlers.onPointerMove(i.lastEvent.current)},connect:t=>{const{set:s,events:i}=n.getState();if(i.disconnect==null||i.disconnect(),s(a=>({events:{...a.events,connected:t}})),i.handlers)for(const a in i.handlers){const r=i.handlers[a],[o,l]=WI[a];t.addEventListener(o,r,{passive:l})}},disconnect:()=>{const{set:t,events:s}=n.getState();if(s.connected){if(s.handlers)for(const i in s.handlers){const a=s.handlers[i],[r]=WI[i];s.connected.removeEventListener(r,a)}t(i=>({events:{...i.events,connected:void 0}}))}}}}function ZP(n,e){let t;return(...s)=>{window.clearTimeout(t),t=window.setTimeout(()=>n(...s),e)}}function xie({debounce:n,scroll:e,polyfill:t,offsetSize:s}={debounce:0,scroll:!1,offsetSize:!1}){const i=t||(typeof window>"u"?class{}:window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[a,r]=pe.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),o=pe.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:a,orientationHandler:null}),l=n?typeof n=="number"?n:n.scroll:null,c=n?typeof n=="number"?n:n.resize:null,h=pe.useRef(!1);pe.useEffect(()=>(h.current=!0,()=>void(h.current=!1)));const[d,p,g]=pe.useMemo(()=>{const b=()=>{if(!o.current.element)return;const{left:w,top:T,width:E,height:R,bottom:D,right:F,x:U,y:O}=o.current.element.getBoundingClientRect(),B={left:w,top:T,width:E,height:R,bottom:D,right:F,x:U,y:O};o.current.element instanceof HTMLElement&&s&&(B.height=o.current.element.offsetHeight,B.width=o.current.element.offsetWidth),Object.freeze(B),h.current&&!Sie(o.current.lastBounds,B)&&r(o.current.lastBounds=B)};return[b,c?ZP(b,c):b,l?ZP(b,l):b]},[r,s,l,c]);function v(){o.current.scrollContainers&&(o.current.scrollContainers.forEach(b=>b.removeEventListener("scroll",g,!0)),o.current.scrollContainers=null),o.current.resizeObserver&&(o.current.resizeObserver.disconnect(),o.current.resizeObserver=null),o.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",o.current.orientationHandler))}function _(){o.current.element&&(o.current.resizeObserver=new i(g),o.current.resizeObserver.observe(o.current.element),e&&o.current.scrollContainers&&o.current.scrollContainers.forEach(b=>b.addEventListener("scroll",g,{capture:!0,passive:!0})),o.current.orientationHandler=()=>{g()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",o.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",o.current.orientationHandler))}const S=b=>{!b||b===o.current.element||(v(),o.current.element=b,o.current.scrollContainers=RV(b),_())};return vie(g,!!e),yie(p),pe.useEffect(()=>{v(),_()},[e,g,p]),pe.useEffect(()=>v,[]),[S,a,d]}function yie(n){pe.useEffect(()=>{const e=n;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[n])}function vie(n,e){pe.useEffect(()=>{if(e){const t=n;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[n,e])}function RV(n){const e=[];if(!n||n===document.body)return e;const{overflow:t,overflowX:s,overflowY:i}=window.getComputedStyle(n);return[t,s,i].some(a=>a==="auto"||a==="scroll")&&e.push(n),[...e,...RV(n.parentElement)]}const bie=["x","y","top","bottom","left","right","width","height"],Sie=(n,e)=>bie.every(t=>n[t]===e[t]);function _ie({ref:n,children:e,fallback:t,resize:s,style:i,gl:a,events:r=gie,eventSource:o,eventPrefix:l,shadows:c,linear:h,flat:d,legacy:p,orthographic:g,frameloop:v,dpr:_,performance:S,raycaster:b,camera:w,scene:T,onPointerMissed:E,onCreated:R,...D}){pe.useMemo(()=>VO(lse),[]);const F=Fse(),[U,O]=xie({scroll:!0,debounce:{scroll:50,resize:0},...s}),B=pe.useRef(null),L=pe.useRef(null);pe.useImperativeHandle(n,()=>B.current);const H=zO(E),[K,Z]=pe.useState(!1),[Q,P]=pe.useState(!1);if(K)throw K;if(Q)throw Q;const W=pe.useRef(null);PS(()=>{const se=B.current;if(O.width>0&&O.height>0&&se){W.current||(W.current=cie(se));async function le(){await W.current.configure({gl:a,scene:T,events:r,shadows:c,linear:h,flat:d,legacy:p,orthographic:g,frameloop:v,dpr:_,performance:S,raycaster:b,camera:w,size:O,onPointerMissed:(...Y)=>H.current==null?void 0:H.current(...Y),onCreated:Y=>{Y.events.connect==null||Y.events.connect(o?kse(o)?o.current:o:L.current),l&&Y.setEvents({compute:(re,he)=>{const me=re[l+"X"],Ne=re[l+"Y"];he.pointer.set(me/he.size.width*2-1,-(Ne/he.size.height)*2+1),he.raycaster.setFromCamera(he.pointer,he.camera)}}),R?.(Y)}}),W.current.render(V.jsx(F,{children:V.jsx(Pse,{set:P,children:V.jsx(pe.Suspense,{fallback:V.jsx(Use,{set:Z}),children:e??null})})}))}le()}}),pe.useEffect(()=>{const se=B.current;if(se)return()=>MV(se)},[]);const q=o?"none":"auto";return V.jsx("div",{ref:L,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:q,...i},...D,children:V.jsx("div",{ref:U,style:{width:"100%",height:"100%"},children:V.jsx("canvas",{ref:B,style:{display:"block"},children:t})})})}function Aie(n){return V.jsx(mV,{children:V.jsx(_ie,{...n})})}function Hx(){return Hx=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var s in t)({}).hasOwnProperty.call(t,s)&&(n[s]=t[s])}return n},Hx.apply(null,arguments)}const WO=parseInt(uy.replace(/\D+/g,""));function QP(n,e){if(e===K4)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===lE||e===nO){let t=n.getIndex();if(t===null){const r=[],o=n.getAttribute("position");if(o!==void 0){for(let l=0;l<o.count;l++)r.push(l);n.setIndex(r),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const s=t.count-2,i=[];if(t)if(e===lE)for(let r=1;r<=s;r++)i.push(t.getX(0)),i.push(t.getX(r)),i.push(t.getX(r+1));else for(let r=0;r<s;r++)r%2===0?(i.push(t.getX(r)),i.push(t.getX(r+1)),i.push(t.getX(r+2))):(i.push(t.getX(r+2)),i.push(t.getX(r+1)),i.push(t.getX(r)));i.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=n.clone();return a.setIndex(i),a.clearGroups(),a}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}var ec=Uint8Array,Nf=Uint16Array,W3=Uint32Array,IV=new ec([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),DV=new ec([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),wie=new ec([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),OV=function(n,e){for(var t=new Nf(31),s=0;s<31;++s)t[s]=e+=1<<n[s-1];for(var i=new W3(t[30]),s=1;s<30;++s)for(var a=t[s];a<t[s+1];++a)i[a]=a-t[s]<<5|s;return[t,i]},BV=OV(IV,2),kV=BV[0],Cie=BV[1];kV[28]=258,Cie[258]=28;var Tie=OV(DV,0),Eie=Tie[0],j3=new Nf(32768);for(var hi=0;hi<32768;++hi){var Af=(hi&43690)>>>1|(hi&21845)<<1;Af=(Af&52428)>>>2|(Af&13107)<<2,Af=(Af&61680)>>>4|(Af&3855)<<4,j3[hi]=((Af&65280)>>>8|(Af&255)<<8)>>>1}var $1=(function(n,e,t){for(var s=n.length,i=0,a=new Nf(e);i<s;++i)++a[n[i]-1];var r=new Nf(e);for(i=0;i<e;++i)r[i]=r[i-1]+a[i-1]<<1;var o;if(t){o=new Nf(1<<e);var l=15-e;for(i=0;i<s;++i)if(n[i])for(var c=i<<4|n[i],h=e-n[i],d=r[n[i]-1]++<<h,p=d|(1<<h)-1;d<=p;++d)o[j3[d]>>>l]=c}else for(o=new Nf(s),i=0;i<s;++i)n[i]&&(o[i]=j3[r[n[i]-1]++]>>>15-n[i]);return o}),zS=new ec(288);for(var hi=0;hi<144;++hi)zS[hi]=8;for(var hi=144;hi<256;++hi)zS[hi]=9;for(var hi=256;hi<280;++hi)zS[hi]=7;for(var hi=280;hi<288;++hi)zS[hi]=8;var LV=new ec(32);for(var hi=0;hi<32;++hi)LV[hi]=5;var Mie=$1(zS,9,1),Nie=$1(LV,5,1),jI=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},Pc=function(n,e,t){var s=e/8|0;return(n[s]|n[s+1]<<8)>>(e&7)&t},XI=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(e&7)},Rie=function(n){return(n/8|0)+(n&7&&1)},Iie=function(n,e,t){(t==null||t>n.length)&&(t=n.length);var s=new(n instanceof Nf?Nf:n instanceof W3?W3:ec)(t-e);return s.set(n.subarray(e,t)),s},Die=function(n,e,t){var s=n.length;if(!s||t&&!t.l&&s<5)return e||new ec(0);var i=!e||t,a=!t||t.i;t||(t={}),e||(e=new ec(s*3));var r=function(fe){var Te=e.length;if(fe>Te){var Ge=new ec(Math.max(Te*2,fe));Ge.set(e),e=Ge}},o=t.f||0,l=t.p||0,c=t.b||0,h=t.l,d=t.d,p=t.m,g=t.n,v=s*8;do{if(!h){t.f=o=Pc(n,l,1);var _=Pc(n,l+1,3);if(l+=3,_)if(_==1)h=Mie,d=Nie,p=9,g=5;else if(_==2){var T=Pc(n,l,31)+257,E=Pc(n,l+10,15)+4,R=T+Pc(n,l+5,31)+1;l+=14;for(var D=new ec(R),F=new ec(19),U=0;U<E;++U)F[wie[U]]=Pc(n,l+U*3,7);l+=E*3;for(var O=jI(F),B=(1<<O)-1,L=$1(F,O,1),U=0;U<R;){var H=L[Pc(n,l,B)];l+=H&15;var S=H>>>4;if(S<16)D[U++]=S;else{var K=0,Z=0;for(S==16?(Z=3+Pc(n,l,3),l+=2,K=D[U-1]):S==17?(Z=3+Pc(n,l,7),l+=3):S==18&&(Z=11+Pc(n,l,127),l+=7);Z--;)D[U++]=K}}var Q=D.subarray(0,T),P=D.subarray(T);p=jI(Q),g=jI(P),h=$1(Q,p,1),d=$1(P,g,1)}else throw"invalid block type";else{var S=Rie(l)+4,b=n[S-4]|n[S-3]<<8,w=S+b;if(w>s){if(a)throw"unexpected EOF";break}i&&r(c+b),e.set(n.subarray(S,w),c),t.b=c+=b,t.p=l=w*8;continue}if(l>v){if(a)throw"unexpected EOF";break}}i&&r(c+131072);for(var W=(1<<p)-1,q=(1<<g)-1,se=l;;se=l){var K=h[XI(n,l)&W],le=K>>>4;if(l+=K&15,l>v){if(a)throw"unexpected EOF";break}if(!K)throw"invalid length/literal";if(le<256)e[c++]=le;else if(le==256){se=l,h=null;break}else{var Y=le-254;if(le>264){var U=le-257,re=IV[U];Y=Pc(n,l,(1<<re)-1)+kV[U],l+=re}var he=d[XI(n,l)&q],me=he>>>4;if(!he)throw"invalid distance";l+=he&15;var P=Eie[me];if(me>3){var re=DV[me];P+=XI(n,l)&(1<<re)-1,l+=re}if(l>v){if(a)throw"unexpected EOF";break}i&&r(c+131072);for(var Ne=c+Y;c<Ne;c+=4)e[c]=e[c-P],e[c+1]=e[c+1-P],e[c+2]=e[c+2-P],e[c+3]=e[c+3-P];c=Ne}}t.l=h,t.p=se,t.b=c,h&&(o=1,t.m=p,t.d=d,t.n=g)}while(!o);return c==e.length?e:Iie(e,0,c)},Oie=new ec(0),Bie=function(n){if((n[0]&15)!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(n[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function zC(n,e){return Die((Bie(n),n.subarray(2,-4)),e)}var kie=typeof TextDecoder<"u"&&new TextDecoder,Lie=0;try{kie.decode(Oie,{stream:!0}),Lie=1}catch{}const Fie=n=>n&&n.isCubeTexture;class Uie extends Ti{constructor(e,t){var s,i;const a=Fie(e),o=((i=a?(s=e.image[0])==null?void 0:s.width:e.image.width)!=null?i:1024)/4,l=Math.floor(Math.log2(o)),c=Math.pow(2,l),h=3*Math.max(c,112),d=4*c,p=[a?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/h}`,`#define CUBEUV_TEXEL_HEIGHT ${1/d}`,`#define CUBEUV_MAX_MIP ${l}.0`],g=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,v=p.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${WO>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,_={map:{value:e},height:{value:t?.height||15},radius:{value:t?.radius||100}},S=new LS(1,16),b=new jr({uniforms:_,fragmentShader:v,vertexShader:g,side:Ql});super(S,b)}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}var Pie=Object.defineProperty,zie=(n,e,t)=>e in n?Pie(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,$ie=(n,e,t)=>(zie(n,e+"",t),t);class Gie{constructor(){$ie(this,"_listeners")}addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const a=i.indexOf(t);a!==-1&&i.splice(a,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let a=0,r=i.length;a<r;a++)i[a].call(this,e);e.target=null}}}var Vie=Object.defineProperty,Hie=(n,e,t)=>e in n?Vie(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,wn=(n,e,t)=>(Hie(n,typeof e!="symbol"?e+"":e,t),t);const $C=new Ag,ez=new Vu,Wie=Math.cos(70*(Math.PI/180)),tz=(n,e)=>(n%e+e)%e;let jie=class extends Gie{constructor(e,t){super(),wn(this,"object"),wn(this,"domElement"),wn(this,"enabled",!0),wn(this,"target",new ue),wn(this,"minDistance",0),wn(this,"maxDistance",1/0),wn(this,"minZoom",0),wn(this,"maxZoom",1/0),wn(this,"minPolarAngle",0),wn(this,"maxPolarAngle",Math.PI),wn(this,"minAzimuthAngle",-1/0),wn(this,"maxAzimuthAngle",1/0),wn(this,"enableDamping",!1),wn(this,"dampingFactor",.05),wn(this,"enableZoom",!0),wn(this,"zoomSpeed",1),wn(this,"enableRotate",!0),wn(this,"rotateSpeed",1),wn(this,"enablePan",!0),wn(this,"panSpeed",1),wn(this,"screenSpacePanning",!0),wn(this,"keyPanSpeed",7),wn(this,"zoomToCursor",!1),wn(this,"autoRotate",!1),wn(this,"autoRotateSpeed",2),wn(this,"reverseOrbit",!1),wn(this,"reverseHorizontalOrbit",!1),wn(this,"reverseVerticalOrbit",!1),wn(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),wn(this,"mouseButtons",{LEFT:Cm.ROTATE,MIDDLE:Cm.DOLLY,RIGHT:Cm.PAN}),wn(this,"touches",{ONE:Tm.ROTATE,TWO:Tm.DOLLY_PAN}),wn(this,"target0"),wn(this,"position0"),wn(this,"zoom0"),wn(this,"_domElementKeyEvents",null),wn(this,"getPolarAngle"),wn(this,"getAzimuthalAngle"),wn(this,"setPolarAngle"),wn(this,"setAzimuthalAngle"),wn(this,"getDistance"),wn(this,"getZoomScale"),wn(this,"listenToKeyEvents"),wn(this,"stopListenToKeyEvents"),wn(this,"saveState"),wn(this,"reset"),wn(this,"update"),wn(this,"connect"),wn(this,"dispose"),wn(this,"dollyIn"),wn(this,"dollyOut"),wn(this,"getScale"),wn(this,"setScale"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>h.phi,this.getAzimuthalAngle=()=>h.theta,this.setPolarAngle=xe=>{let Fe=tz(xe,2*Math.PI),mt=h.phi;mt<0&&(mt+=2*Math.PI),Fe<0&&(Fe+=2*Math.PI);let ge=Math.abs(Fe-mt);2*Math.PI-ge<ge&&(Fe<mt?Fe+=2*Math.PI:mt+=2*Math.PI),d.phi=Fe-mt,s.update()},this.setAzimuthalAngle=xe=>{let Fe=tz(xe,2*Math.PI),mt=h.theta;mt<0&&(mt+=2*Math.PI),Fe<0&&(Fe+=2*Math.PI);let ge=Math.abs(Fe-mt);2*Math.PI-ge<ge&&(Fe<mt?Fe+=2*Math.PI:mt+=2*Math.PI),d.theta=Fe-mt,s.update()},this.getDistance=()=>s.object.position.distanceTo(s.target),this.listenToKeyEvents=xe=>{xe.addEventListener("keydown",Ve),this._domElementKeyEvents=xe},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Ve),this._domElementKeyEvents=null},this.saveState=()=>{s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=()=>{s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(i),s.update(),l=o.NONE},this.update=(()=>{const xe=new ue,Fe=new ue(0,1,0),mt=new Za().setFromUnitVectors(e.up,Fe),ge=mt.clone().invert(),Ue=new ue,At=new Za,Rt=2*Math.PI;return function(){const dt=s.object.position;mt.setFromUnitVectors(e.up,Fe),ge.copy(mt).invert(),xe.copy(dt).sub(s.target),xe.applyQuaternion(mt),h.setFromVector3(xe),s.autoRotate&&l===o.NONE&&Z(H()),s.enableDamping?(h.theta+=d.theta*s.dampingFactor,h.phi+=d.phi*s.dampingFactor):(h.theta+=d.theta,h.phi+=d.phi);let Ut=s.minAzimuthAngle,cn=s.maxAzimuthAngle;isFinite(Ut)&&isFinite(cn)&&(Ut<-Math.PI?Ut+=Rt:Ut>Math.PI&&(Ut-=Rt),cn<-Math.PI?cn+=Rt:cn>Math.PI&&(cn-=Rt),Ut<=cn?h.theta=Math.max(Ut,Math.min(cn,h.theta)):h.theta=h.theta>(Ut+cn)/2?Math.max(Ut,h.theta):Math.min(cn,h.theta)),h.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,h.phi)),h.makeSafe(),s.enableDamping===!0?s.target.addScaledVector(g,s.dampingFactor):s.target.add(g),s.zoomToCursor&&O||s.object.isOrthographicCamera?h.radius=he(h.radius):h.radius=he(h.radius*p),xe.setFromSpherical(h),xe.applyQuaternion(ge),dt.copy(s.target).add(xe),s.object.matrixAutoUpdate||s.object.updateMatrix(),s.object.lookAt(s.target),s.enableDamping===!0?(d.theta*=1-s.dampingFactor,d.phi*=1-s.dampingFactor,g.multiplyScalar(1-s.dampingFactor)):(d.set(0,0,0),g.set(0,0,0));let Wn=!1;if(s.zoomToCursor&&O){let Fn=null;if(s.object instanceof ki&&s.object.isPerspectiveCamera){const ei=xe.length();Fn=he(ei*p);const Ni=ei-Fn;s.object.position.addScaledVector(F,Ni),s.object.updateMatrixWorld()}else if(s.object.isOrthographicCamera){const ei=new ue(U.x,U.y,0);ei.unproject(s.object),s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/p)),s.object.updateProjectionMatrix(),Wn=!0;const Ni=new ue(U.x,U.y,0);Ni.unproject(s.object),s.object.position.sub(Ni).add(ei),s.object.updateMatrixWorld(),Fn=xe.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;Fn!==null&&(s.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(Fn).add(s.object.position):($C.origin.copy(s.object.position),$C.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot($C.direction))<Wie?e.lookAt(s.target):(ez.setFromNormalAndCoplanarPoint(s.object.up,s.target),$C.intersectPlane(ez,s.target))))}else s.object instanceof Zu&&s.object.isOrthographicCamera&&(Wn=p!==1,Wn&&(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/p)),s.object.updateProjectionMatrix()));return p=1,O=!1,Wn||Ue.distanceToSquared(s.object.position)>c||8*(1-At.dot(s.object.quaternion))>c?(s.dispatchEvent(i),Ue.copy(s.object.position),At.copy(s.object.quaternion),Wn=!1,!0):!1}})(),this.connect=xe=>{s.domElement=xe,s.domElement.style.touchAction="none",s.domElement.addEventListener("contextmenu",tn),s.domElement.addEventListener("pointerdown",kt),s.domElement.addEventListener("pointercancel",J),s.domElement.addEventListener("wheel",lt)},this.dispose=()=>{var xe,Fe,mt,ge,Ue,At;s.domElement&&(s.domElement.style.touchAction="auto"),(xe=s.domElement)==null||xe.removeEventListener("contextmenu",tn),(Fe=s.domElement)==null||Fe.removeEventListener("pointerdown",kt),(mt=s.domElement)==null||mt.removeEventListener("pointercancel",J),(ge=s.domElement)==null||ge.removeEventListener("wheel",lt),(Ue=s.domElement)==null||Ue.ownerDocument.removeEventListener("pointermove",ce),(At=s.domElement)==null||At.ownerDocument.removeEventListener("pointerup",J),s._domElementKeyEvents!==null&&s._domElementKeyEvents.removeEventListener("keydown",Ve)};const s=this,i={type:"change"},a={type:"start"},r={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=o.NONE;const c=1e-6,h=new L3,d=new L3;let p=1;const g=new ue,v=new rt,_=new rt,S=new rt,b=new rt,w=new rt,T=new rt,E=new rt,R=new rt,D=new rt,F=new ue,U=new rt;let O=!1;const B=[],L={};function H(){return 2*Math.PI/60/60*s.autoRotateSpeed}function K(){return Math.pow(.95,s.zoomSpeed)}function Z(xe){s.reverseOrbit||s.reverseHorizontalOrbit?d.theta+=xe:d.theta-=xe}function Q(xe){s.reverseOrbit||s.reverseVerticalOrbit?d.phi+=xe:d.phi-=xe}const P=(()=>{const xe=new ue;return function(mt,ge){xe.setFromMatrixColumn(ge,0),xe.multiplyScalar(-mt),g.add(xe)}})(),W=(()=>{const xe=new ue;return function(mt,ge){s.screenSpacePanning===!0?xe.setFromMatrixColumn(ge,1):(xe.setFromMatrixColumn(ge,0),xe.crossVectors(s.object.up,xe)),xe.multiplyScalar(mt),g.add(xe)}})(),q=(()=>{const xe=new ue;return function(mt,ge){const Ue=s.domElement;if(Ue&&s.object instanceof ki&&s.object.isPerspectiveCamera){const At=s.object.position;xe.copy(At).sub(s.target);let Rt=xe.length();Rt*=Math.tan(s.object.fov/2*Math.PI/180),P(2*mt*Rt/Ue.clientHeight,s.object.matrix),W(2*ge*Rt/Ue.clientHeight,s.object.matrix)}else Ue&&s.object instanceof Zu&&s.object.isOrthographicCamera?(P(mt*(s.object.right-s.object.left)/s.object.zoom/Ue.clientWidth,s.object.matrix),W(ge*(s.object.top-s.object.bottom)/s.object.zoom/Ue.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}})();function se(xe){s.object instanceof ki&&s.object.isPerspectiveCamera||s.object instanceof Zu&&s.object.isOrthographicCamera?p=xe:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function le(xe){se(p/xe)}function Y(xe){se(p*xe)}function re(xe){if(!s.zoomToCursor||!s.domElement)return;O=!0;const Fe=s.domElement.getBoundingClientRect(),mt=xe.clientX-Fe.left,ge=xe.clientY-Fe.top,Ue=Fe.width,At=Fe.height;U.x=mt/Ue*2-1,U.y=-(ge/At)*2+1,F.set(U.x,U.y,1).unproject(s.object).sub(s.object.position).normalize()}function he(xe){return Math.max(s.minDistance,Math.min(s.maxDistance,xe))}function me(xe){v.set(xe.clientX,xe.clientY)}function Ne(xe){re(xe),E.set(xe.clientX,xe.clientY)}function fe(xe){b.set(xe.clientX,xe.clientY)}function Te(xe){_.set(xe.clientX,xe.clientY),S.subVectors(_,v).multiplyScalar(s.rotateSpeed);const Fe=s.domElement;Fe&&(Z(2*Math.PI*S.x/Fe.clientHeight),Q(2*Math.PI*S.y/Fe.clientHeight)),v.copy(_),s.update()}function Ge(xe){R.set(xe.clientX,xe.clientY),D.subVectors(R,E),D.y>0?le(K()):D.y<0&&Y(K()),E.copy(R),s.update()}function nt(xe){w.set(xe.clientX,xe.clientY),T.subVectors(w,b).multiplyScalar(s.panSpeed),q(T.x,T.y),b.copy(w),s.update()}function yt(xe){re(xe),xe.deltaY<0?Y(K()):xe.deltaY>0&&le(K()),s.update()}function Dt(xe){let Fe=!1;switch(xe.code){case s.keys.UP:q(0,s.keyPanSpeed),Fe=!0;break;case s.keys.BOTTOM:q(0,-s.keyPanSpeed),Fe=!0;break;case s.keys.LEFT:q(s.keyPanSpeed,0),Fe=!0;break;case s.keys.RIGHT:q(-s.keyPanSpeed,0),Fe=!0;break}Fe&&(xe.preventDefault(),s.update())}function qt(){if(B.length==1)v.set(B[0].pageX,B[0].pageY);else{const xe=.5*(B[0].pageX+B[1].pageX),Fe=.5*(B[0].pageY+B[1].pageY);v.set(xe,Fe)}}function Bt(){if(B.length==1)b.set(B[0].pageX,B[0].pageY);else{const xe=.5*(B[0].pageX+B[1].pageX),Fe=.5*(B[0].pageY+B[1].pageY);b.set(xe,Fe)}}function Je(){const xe=B[0].pageX-B[1].pageX,Fe=B[0].pageY-B[1].pageY,mt=Math.sqrt(xe*xe+Fe*Fe);E.set(0,mt)}function oe(){s.enableZoom&&Je(),s.enablePan&&Bt()}function Ze(){s.enableZoom&&Je(),s.enableRotate&&qt()}function it(xe){if(B.length==1)_.set(xe.pageX,xe.pageY);else{const mt=Zt(xe),ge=.5*(xe.pageX+mt.x),Ue=.5*(xe.pageY+mt.y);_.set(ge,Ue)}S.subVectors(_,v).multiplyScalar(s.rotateSpeed);const Fe=s.domElement;Fe&&(Z(2*Math.PI*S.x/Fe.clientHeight),Q(2*Math.PI*S.y/Fe.clientHeight)),v.copy(_)}function ft(xe){if(B.length==1)w.set(xe.pageX,xe.pageY);else{const Fe=Zt(xe),mt=.5*(xe.pageX+Fe.x),ge=.5*(xe.pageY+Fe.y);w.set(mt,ge)}T.subVectors(w,b).multiplyScalar(s.panSpeed),q(T.x,T.y),b.copy(w)}function gt(xe){const Fe=Zt(xe),mt=xe.pageX-Fe.x,ge=xe.pageY-Fe.y,Ue=Math.sqrt(mt*mt+ge*ge);R.set(0,Ue),D.set(0,Math.pow(R.y/E.y,s.zoomSpeed)),le(D.y),E.copy(R)}function Tt(xe){s.enableZoom&&gt(xe),s.enablePan&&ft(xe)}function Et(xe){s.enableZoom&&gt(xe),s.enableRotate&&it(xe)}function kt(xe){var Fe,mt;s.enabled!==!1&&(B.length===0&&((Fe=s.domElement)==null||Fe.ownerDocument.addEventListener("pointermove",ce),(mt=s.domElement)==null||mt.ownerDocument.addEventListener("pointerup",J)),Jt(xe),xe.pointerType==="touch"?Gt(xe):Ie(xe))}function ce(xe){s.enabled!==!1&&(xe.pointerType==="touch"?Lt(xe):Ye(xe))}function J(xe){var Fe,mt,ge;at(xe),B.length===0&&((Fe=s.domElement)==null||Fe.releasePointerCapture(xe.pointerId),(mt=s.domElement)==null||mt.ownerDocument.removeEventListener("pointermove",ce),(ge=s.domElement)==null||ge.ownerDocument.removeEventListener("pointerup",J)),s.dispatchEvent(r),l=o.NONE}function Ie(xe){let Fe;switch(xe.button){case 0:Fe=s.mouseButtons.LEFT;break;case 1:Fe=s.mouseButtons.MIDDLE;break;case 2:Fe=s.mouseButtons.RIGHT;break;default:Fe=-1}switch(Fe){case Cm.DOLLY:if(s.enableZoom===!1)return;Ne(xe),l=o.DOLLY;break;case Cm.ROTATE:if(xe.ctrlKey||xe.metaKey||xe.shiftKey){if(s.enablePan===!1)return;fe(xe),l=o.PAN}else{if(s.enableRotate===!1)return;me(xe),l=o.ROTATE}break;case Cm.PAN:if(xe.ctrlKey||xe.metaKey||xe.shiftKey){if(s.enableRotate===!1)return;me(xe),l=o.ROTATE}else{if(s.enablePan===!1)return;fe(xe),l=o.PAN}break;default:l=o.NONE}l!==o.NONE&&s.dispatchEvent(a)}function Ye(xe){if(s.enabled!==!1)switch(l){case o.ROTATE:if(s.enableRotate===!1)return;Te(xe);break;case o.DOLLY:if(s.enableZoom===!1)return;Ge(xe);break;case o.PAN:if(s.enablePan===!1)return;nt(xe);break}}function lt(xe){s.enabled===!1||s.enableZoom===!1||l!==o.NONE&&l!==o.ROTATE||(xe.preventDefault(),s.dispatchEvent(a),yt(xe),s.dispatchEvent(r))}function Ve(xe){s.enabled===!1||s.enablePan===!1||Dt(xe)}function Gt(xe){switch(ut(xe),B.length){case 1:switch(s.touches.ONE){case Tm.ROTATE:if(s.enableRotate===!1)return;qt(),l=o.TOUCH_ROTATE;break;case Tm.PAN:if(s.enablePan===!1)return;Bt(),l=o.TOUCH_PAN;break;default:l=o.NONE}break;case 2:switch(s.touches.TWO){case Tm.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;oe(),l=o.TOUCH_DOLLY_PAN;break;case Tm.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Ze(),l=o.TOUCH_DOLLY_ROTATE;break;default:l=o.NONE}break;default:l=o.NONE}l!==o.NONE&&s.dispatchEvent(a)}function Lt(xe){switch(ut(xe),l){case o.TOUCH_ROTATE:if(s.enableRotate===!1)return;it(xe),s.update();break;case o.TOUCH_PAN:if(s.enablePan===!1)return;ft(xe),s.update();break;case o.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;Tt(xe),s.update();break;case o.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Et(xe),s.update();break;default:l=o.NONE}}function tn(xe){s.enabled!==!1&&xe.preventDefault()}function Jt(xe){B.push(xe)}function at(xe){delete L[xe.pointerId];for(let Fe=0;Fe<B.length;Fe++)if(B[Fe].pointerId==xe.pointerId){B.splice(Fe,1);return}}function ut(xe){let Fe=L[xe.pointerId];Fe===void 0&&(Fe=new rt,L[xe.pointerId]=Fe),Fe.set(xe.pageX,xe.pageY)}function Zt(xe){const Fe=xe.pointerId===B[0].pointerId?B[1]:B[0];return L[Fe.pointerId]}this.dollyIn=(xe=K())=>{Y(xe),s.update()},this.dollyOut=(xe=K())=>{le(xe),s.update()},this.getScale=()=>p,this.setScale=xe=>{se(xe),s.update()},this.getZoomScale=()=>K(),t!==void 0&&this.connect(t),this.update()}};function yE(n){if(typeof TextDecoder<"u")return new TextDecoder().decode(n);let e="";for(let t=0,s=n.length;t<s;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}}const Gm="srgb",hd="srgb-linear",nz=3001,Xie=3e3;class jO extends br{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Zie(t)}),this.register(function(t){return new Qie(t)}),this.register(function(t){return new lae(t)}),this.register(function(t){return new cae(t)}),this.register(function(t){return new uae(t)}),this.register(function(t){return new tae(t)}),this.register(function(t){return new nae(t)}),this.register(function(t){return new sae(t)}),this.register(function(t){return new iae(t)}),this.register(function(t){return new Jie(t)}),this.register(function(t){return new aae(t)}),this.register(function(t){return new eae(t)}),this.register(function(t){return new oae(t)}),this.register(function(t){return new rae(t)}),this.register(function(t){return new Kie(t)}),this.register(function(t){return new hae(t)}),this.register(function(t){return new dae(t)})}load(e,t,s,i){const a=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const c=Of.extractUrlBase(e);r=Of.resolveURL(c,this.path)}else r=Of.extractUrlBase(e);this.manager.itemStart(e);const o=function(c){i?i(c):console.error(c),a.manager.itemError(e),a.manager.itemEnd(e)},l=new vr(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{a.parse(c,r,function(h){t(h),a.manager.itemEnd(e)},o)}catch(h){o(h)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,i){let a;const r={},o={};if(typeof e=="string")a=JSON.parse(e);else if(e instanceof ArrayBuffer)if(yE(new Uint8Array(e.slice(0,4)))===FV){try{r[fs.KHR_BINARY_GLTF]=new fae(e)}catch(h){i&&i(h);return}a=JSON.parse(r[fs.KHR_BINARY_GLTF].content)}else a=JSON.parse(yE(new Uint8Array(e)));else a=e;if(a.asset===void 0||a.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new Tae(a,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const h=this.pluginCallbacks[c](l);h.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[h.name]=h,r[h.name]=!0}if(a.extensionsUsed)for(let c=0;c<a.extensionsUsed.length;++c){const h=a.extensionsUsed[c],d=a.extensionsRequired||[];switch(h){case fs.KHR_MATERIALS_UNLIT:r[h]=new Yie;break;case fs.KHR_DRACO_MESH_COMPRESSION:r[h]=new pae(a,this.dracoLoader);break;case fs.KHR_TEXTURE_TRANSFORM:r[h]=new mae;break;case fs.KHR_MESH_QUANTIZATION:r[h]=new gae;break;default:d.indexOf(h)>=0&&o[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}l.setExtensions(r),l.setPlugins(o),l.parse(s,i)}parseAsync(e,t){const s=this;return new Promise(function(i,a){s.parse(e,t,i,a)})}}function qie(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const fs={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Kie{constructor(e){this.parser=e,this.name=fs.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,i=t.length;s<i;s++){const a=t[s];a.extensions&&a.extensions[this.name]&&a.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,a.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let i=t.cache.get(s);if(i)return i;const a=t.json,l=((a.extensions&&a.extensions[this.name]||{}).lights||[])[e];let c;const h=new $t(16777215);l.color!==void 0&&h.setRGB(l.color[0],l.color[1],l.color[2],hd);const d=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new RO(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new NO(h),c.distance=d;break;case"spot":c=new MO(h),c.distance=d,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,ed(c,l),l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),t.cache.add(s,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,a=s.json.nodes[e],o=(a.extensions&&a.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(l){return s._getNodeRef(t.cache,o,l)})}}class Yie{constructor(){this.name=fs.KHR_MATERIALS_UNLIT}getMaterialType(){return Yo}extendParams(e,t,s){const i=[];e.color=new $t(1,1,1),e.opacity=1;const a=t.pbrMetallicRoughness;if(a){if(Array.isArray(a.baseColorFactor)){const r=a.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],hd),e.opacity=r[3]}a.baseColorTexture!==void 0&&i.push(s.assignTexture(e,"map",a.baseColorTexture,Gm))}return Promise.all(i)}}class Jie{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=i.extensions[this.name].emissiveStrength;return a!==void 0&&(t.emissiveIntensity=a),Promise.resolve()}}class Zie{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&a.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&a.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(a.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const o=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new rt(o,o)}return Promise.all(a)}}class Qie{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=i.extensions[this.name];return t.dispersion=a.dispersion!==void 0?a.dispersion:0,Promise.resolve()}}class eae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&a.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&a.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(a)}}class tae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[];t.sheenColor=new $t(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=i.extensions[this.name];if(r.sheenColorFactor!==void 0){const o=r.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],hd)}return r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&a.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,Gm)),r.sheenRoughnessTexture!==void 0&&a.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(a)}}class nae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&a.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(a)}}class sae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&a.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const o=r.attenuationColor||[1,1,1];return t.attenuationColor=new $t().setRGB(o[0],o[1],o[2],hd),Promise.all(a)}}class iae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=i.extensions[this.name];return t.ior=a.ior!==void 0?a.ior:1.5,Promise.resolve()}}class aae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&a.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const o=r.specularColorFactor||[1,1,1];return t.specularColor=new $t().setRGB(o[0],o[1],o[2],hd),r.specularColorTexture!==void 0&&a.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,Gm)),Promise.all(a)}}class rae{constructor(e){this.parser=e,this.name=fs.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];return t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&a.push(s.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(a)}}class oae{constructor(e){this.parser=e,this.name=fs.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:lc}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=[],r=i.extensions[this.name];return r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&a.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(a)}}class lae{constructor(e){this.parser=e,this.name=fs.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,i=s.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const a=i.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,a.source,r)}}class cae{constructor(e){this.parser=e,this.name=fs.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,a=i.textures[e];if(!a.extensions||!a.extensions[t])return null;const r=a.extensions[t],o=i.images[r.source];let l=s.textureLoader;if(o.uri){const c=s.options.manager.getHandler(o.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,r.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class uae{constructor(e){this.parser=e,this.name=fs.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,a=i.textures[e];if(!a.extensions||!a.extensions[t])return null;const r=a.extensions[t],o=i.images[r.source];let l=s.textureLoader;if(o.uri){const c=s.options.manager.getHandler(o.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,r.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class hae{constructor(e){this.name=fs.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const i=s.extensions[this.name],a=this.parser.getDependency("buffer",i.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return a.then(function(o){const l=i.byteOffset||0,c=i.byteLength||0,h=i.count,d=i.byteStride,p=new Uint8Array(o,l,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,d,p,i.mode,i.filter).then(function(g){return g.buffer}):r.ready.then(function(){const g=new ArrayBuffer(h*d);return r.decodeGltfBuffer(new Uint8Array(g),h,d,p,i.mode,i.filter),g})})}else return null}}class dae{constructor(e){this.name=fs.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const i=t.meshes[s.mesh];for(const c of i.primitives)if(c.mode!==Yl.TRIANGLES&&c.mode!==Yl.TRIANGLE_STRIP&&c.mode!==Yl.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=s.extensions[this.name].attributes,o=[],l={};for(const c in r)o.push(this.parser.getDependency("accessor",r[c]).then(h=>(l[c]=h,l[c])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(c=>{const h=c.pop(),d=h.isGroup?h.children:[h],p=c[0].count,g=[];for(const v of d){const _=new _n,S=new ue,b=new Za,w=new ue(1,1,1),T=new hO(v.geometry,v.material,p);for(let E=0;E<p;E++)l.TRANSLATION&&S.fromBufferAttribute(l.TRANSLATION,E),l.ROTATION&&b.fromBufferAttribute(l.ROTATION,E),l.SCALE&&w.fromBufferAttribute(l.SCALE,E),T.setMatrixAt(E,_.compose(S,b,w));for(const E in l)if(E==="_COLOR_0"){const R=l[E];T.instanceColor=new ng(R.array,R.itemSize,R.normalized)}else E!=="TRANSLATION"&&E!=="ROTATION"&&E!=="SCALE"&&v.geometry.setAttribute(E,l[E]);Ts.prototype.copy.call(T,v),this.parser.assignFinalMaterial(T),g.push(T)}return h.isGroup?(h.clear(),h.add(...g),h):g[0]}))}}const FV="glTF",m1=12,sz={JSON:1313821514,BIN:5130562};class fae{constructor(e){this.name=fs.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,m1);if(this.header={magic:yE(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==FV)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-m1,i=new DataView(e,m1);let a=0;for(;a<s;){const r=i.getUint32(a,!0);a+=4;const o=i.getUint32(a,!0);if(a+=4,o===sz.JSON){const l=new Uint8Array(e,m1+a,r);this.content=yE(l)}else if(o===sz.BIN){const l=m1+a;this.body=e.slice(l,l+r)}a+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class pae{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=fs.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,i=this.dracoLoader,a=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,o={},l={},c={};for(const h in r){const d=X3[h]||h.toLowerCase();o[d]=r[h]}for(const h in e.attributes){const d=X3[h]||h.toLowerCase();if(r[h]!==void 0){const p=s.accessors[e.attributes[h]],g=Ax[p.componentType];c[d]=g.name,l[d]=p.normalized===!0}}return t.getDependency("bufferView",a).then(function(h){return new Promise(function(d,p){i.decodeDracoFile(h,function(g){for(const v in g.attributes){const _=g.attributes[v],S=l[v];S!==void 0&&(_.normalized=S)}d(g)},o,c,hd,p)})})}}class mae{constructor(){this.name=fs.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class gae{constructor(){this.name=fs.KHR_MESH_QUANTIZATION}}class UV extends my{constructor(e,t,s,i){super(e,t,s,i)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,a=e*i*3+i;for(let r=0;r!==i;r++)t[r]=s[a+r];return t}interpolate_(e,t,s,i){const a=this.resultBuffer,r=this.sampleValues,o=this.valueSize,l=o*2,c=o*3,h=i-t,d=(s-t)/h,p=d*d,g=p*d,v=e*c,_=v-c,S=-2*g+3*p,b=g-p,w=1-S,T=b-p+d;for(let E=0;E!==o;E++){const R=r[_+E+o],D=r[_+E+l]*h,F=r[v+E+o],U=r[v+E]*h;a[E]=w*R+T*D+S*F+b*U}return a}}const xae=new Za;class yae extends UV{interpolate_(e,t,s,i){const a=super.interpolate_(e,t,s,i);return xae.fromArray(a).normalize().toArray(a),a}}const Yl={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Ax={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},iz={9728:Ja,9729:is,9984:QE,9985:Sx,9986:Lm,9987:tc},az={33071:Fi,33648:Ix,10497:Pf},qI={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},X3={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...WO>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},wf={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},vae={CUBICSPLINE:void 0,LINEAR:kx,STEP:Bx},KI={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function bae(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new py({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ih})),n.DefaultMaterial}function Sm(n,e,t){for(const s in t.extensions)n[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function ed(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Sae(n,e,t){let s=!1,i=!1,a=!1;for(let c=0,h=e.length;c<h;c++){const d=e[c];if(d.POSITION!==void 0&&(s=!0),d.NORMAL!==void 0&&(i=!0),d.COLOR_0!==void 0&&(a=!0),s&&i&&a)break}if(!s&&!i&&!a)return Promise.resolve(n);const r=[],o=[],l=[];for(let c=0,h=e.length;c<h;c++){const d=e[c];if(s){const p=d.POSITION!==void 0?t.getDependency("accessor",d.POSITION):n.attributes.position;r.push(p)}if(i){const p=d.NORMAL!==void 0?t.getDependency("accessor",d.NORMAL):n.attributes.normal;o.push(p)}if(a){const p=d.COLOR_0!==void 0?t.getDependency("accessor",d.COLOR_0):n.attributes.color;l.push(p)}}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(l)]).then(function(c){const h=c[0],d=c[1],p=c[2];return s&&(n.morphAttributes.position=h),i&&(n.morphAttributes.normal=d),a&&(n.morphAttributes.color=p),n.morphTargetsRelative=!0,n})}function _ae(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let s=0,i=t.length;s<i;s++)n.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Aae(n){let e;const t=n.extensions&&n.extensions[fs.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+YI(t.attributes):e=n.indices+":"+YI(n.attributes)+":"+n.mode,n.targets!==void 0)for(let s=0,i=n.targets.length;s<i;s++)e+=":"+YI(n.targets[s]);return e}function YI(n){let e="";const t=Object.keys(n).sort();for(let s=0,i=t.length;s<i;s++)e+=t[s]+":"+n[t[s]]+";";return e}function q3(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function wae(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Cae=new _n;class Tae{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new qie,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,i=!1,a=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,a=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||i&&a<98?this.textureLoader=new WG(this.options.manager):this.textureLoader=new QG(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new vr(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,i=this.json,a=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(r){const o={scene:r[0][i.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:i.asset,parser:s,userData:{}};return Sm(a,o,i),ed(o,i),Promise.all(s._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){for(const l of o.scenes)l.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let i=0,a=t.length;i<a;i++){const r=t[i].joints;for(let o=0,l=r.length;o<l;o++)e[r[o]].isBone=!0}for(let i=0,a=e.length;i<a;i++){const r=e[i];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(s[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const i=s.clone(),a=(r,o)=>{const l=this.associations.get(r);l!=null&&this.associations.set(o,l);for(const[c,h]of r.children.entries())a(h,o.children[c])};return a(s,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const i=e(t[s]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let i=0;i<t.length;i++){const a=e(t[i]);a&&s.push(a)}return s}getDependency(e,t){const s=e+":"+t;let i=this.cache.get(s);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(a){return a.loadNode&&a.loadNode(t)});break;case"mesh":i=this._invokeOne(function(a){return a.loadMesh&&a.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(a){return a.loadBufferView&&a.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(a){return a.loadMaterial&&a.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(a){return a.loadTexture&&a.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(a){return a.loadAnimation&&a.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(a){return a!=this&&a.getDependency&&a.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(s,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(a,r){return s.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[fs.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(a,r){s.load(Of.resolveURL(t.uri,i.path),a,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const i=t.byteLength||0,a=t.byteOffset||0;return s.slice(a,a+i)})}loadAccessor(e){const t=this,s=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const r=qI[i.type],o=Ax[i.componentType],l=i.normalized===!0,c=new o(i.count*r);return Promise.resolve(new Es(c,r,l))}const a=[];return i.bufferView!==void 0?a.push(this.getDependency("bufferView",i.bufferView)):a.push(null),i.sparse!==void 0&&(a.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),a.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(a).then(function(r){const o=r[0],l=qI[i.type],c=Ax[i.componentType],h=c.BYTES_PER_ELEMENT,d=h*l,p=i.byteOffset||0,g=i.bufferView!==void 0?s.bufferViews[i.bufferView].byteStride:void 0,v=i.normalized===!0;let _,S;if(g&&g!==d){const b=Math.floor(p/g),w="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+b+":"+i.count;let T=t.cache.get(w);T||(_=new c(o,b*g,i.count*g/h),T=new IS(_,g/h),t.cache.add(w,T)),S=new $f(T,l,p%g/h,v)}else o===null?_=new c(i.count*l):_=new c(o,p,i.count*l),S=new Es(_,l,v);if(i.sparse!==void 0){const b=qI.SCALAR,w=Ax[i.sparse.indices.componentType],T=i.sparse.indices.byteOffset||0,E=i.sparse.values.byteOffset||0,R=new w(r[1],T,i.sparse.count*b),D=new c(r[2],E,i.sparse.count*l);o!==null&&(S=new Es(S.array.slice(),S.itemSize,S.normalized));for(let F=0,U=R.length;F<U;F++){const O=R[F];if(S.setX(O,D[F*l]),l>=2&&S.setY(O,D[F*l+1]),l>=3&&S.setZ(O,D[F*l+2]),l>=4&&S.setW(O,D[F*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return S})}loadTexture(e){const t=this.json,s=this.options,a=t.textures[e].source,r=t.images[a];let o=this.textureLoader;if(r.uri){const l=s.manager.getHandler(r.uri);l!==null&&(o=l)}return this.loadTextureImage(e,a,o)}loadTextureImage(e,t,s){const i=this,a=this.json,r=a.textures[e],o=a.images[t],l=(o.uri||o.bufferView)+":"+r.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=r.name||o.name||"",h.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(h.name=o.uri);const p=(a.samplers||{})[r.sampler]||{};return h.magFilter=iz[p.magFilter]||is,h.minFilter=iz[p.minFilter]||tc,h.wrapS=az[p.wrapS]||Pf,h.wrapT=az[p.wrapT]||Pf,i.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const s=this,i=this.json,a=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const r=i.images[e],o=self.URL||self.webkitURL;let l=r.uri||"",c=!1;if(r.bufferView!==void 0)l=s.getDependency("bufferView",r.bufferView).then(function(d){c=!0;const p=new Blob([d],{type:r.mimeType});return l=o.createObjectURL(p),l});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(l).then(function(d){return new Promise(function(p,g){let v=p;t.isImageBitmapLoader===!0&&(v=function(_){const S=new Vs(_);S.needsUpdate=!0,p(S)}),t.load(Of.resolveURL(d,a.path),v,void 0,g)})}).then(function(d){return c===!0&&o.revokeObjectURL(l),ed(d,r),d.userData.mimeType=r.mimeType||wae(r.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),d});return this.sourceCache[e]=h,h}assignTexture(e,t,s,i){const a=this;return this.getDependency("texture",s.index).then(function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(r=r.clone(),r.channel=s.texCoord),a.extensions[fs.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[fs.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=a.associations.get(r);r=a.extensions[fs.KHR_TEXTURE_TRANSFORM].extendTexture(r,o),a.associations.set(r,l)}}return i!==void 0&&(typeof i=="number"&&(i=i===nz?Gm:hd),"colorSpace"in r?r.colorSpace=i:r.encoding=i===Gm?nz:Xie),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const i=t.attributes.tangent===void 0,a=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let l=this.cache.get(o);l||(l=new p2,Da.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,l.sizeAttenuation=!1,this.cache.add(o,l)),s=l}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let l=this.cache.get(o);l||(l=new qr,Da.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,this.cache.add(o,l)),s=l}if(i||a||r){let o="ClonedMaterial:"+s.uuid+":";i&&(o+="derivative-tangents:"),a&&(o+="vertex-colors:"),r&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=s.clone(),a&&(l.vertexColors=!0),r&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(s))),s=l}e.material=s}getMaterialType(){return py}loadMaterial(e){const t=this,s=this.json,i=this.extensions,a=s.materials[e];let r;const o={},l=a.extensions||{},c=[];if(l[fs.KHR_MATERIALS_UNLIT]){const d=i[fs.KHR_MATERIALS_UNLIT];r=d.getMaterialType(),c.push(d.extendParams(o,a,t))}else{const d=a.pbrMetallicRoughness||{};if(o.color=new $t(1,1,1),o.opacity=1,Array.isArray(d.baseColorFactor)){const p=d.baseColorFactor;o.color.setRGB(p[0],p[1],p[2],hd),o.opacity=p[3]}d.baseColorTexture!==void 0&&c.push(t.assignTexture(o,"map",d.baseColorTexture,Gm)),o.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,o.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(o,"metalnessMap",d.metallicRoughnessTexture)),c.push(t.assignTexture(o,"roughnessMap",d.metallicRoughnessTexture))),r=this._invokeOne(function(p){return p.getMaterialType&&p.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(p){return p.extendMaterialParams&&p.extendMaterialParams(e,o)})))}a.doubleSided===!0&&(o.side=Ql);const h=a.alphaMode||KI.OPAQUE;if(h===KI.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,h===KI.MASK&&(o.alphaTest=a.alphaCutoff!==void 0?a.alphaCutoff:.5)),a.normalTexture!==void 0&&r!==Yo&&(c.push(t.assignTexture(o,"normalMap",a.normalTexture)),o.normalScale=new rt(1,1),a.normalTexture.scale!==void 0)){const d=a.normalTexture.scale;o.normalScale.set(d,d)}if(a.occlusionTexture!==void 0&&r!==Yo&&(c.push(t.assignTexture(o,"aoMap",a.occlusionTexture)),a.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=a.occlusionTexture.strength)),a.emissiveFactor!==void 0&&r!==Yo){const d=a.emissiveFactor;o.emissive=new $t().setRGB(d[0],d[1],d[2],hd)}return a.emissiveTexture!==void 0&&r!==Yo&&c.push(t.assignTexture(o,"emissiveMap",a.emissiveTexture,Gm)),Promise.all(c).then(function(){const d=new r(o);return a.name&&(d.name=a.name),ed(d,a),t.associations.set(d,{materials:e}),a.extensions&&Sm(i,d,a),d})}createUniqueName(e){const t=Ns.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,i=this.primitiveCache;function a(o){return s[fs.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(l){return rz(l,o,t)})}const r=[];for(let o=0,l=e.length;o<l;o++){const c=e[o],h=Aae(c),d=i[h];if(d)r.push(d.promise);else{let p;c.extensions&&c.extensions[fs.KHR_DRACO_MESH_COMPRESSION]?p=a(c):p=rz(new Ln,c,t),i[h]={primitive:c,promise:p},r.push(p)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,i=this.extensions,a=s.meshes[e],r=a.primitives,o=[];for(let l=0,c=r.length;l<c;l++){const h=r[l].material===void 0?bae(this.cache):this.getDependency("material",r[l].material);o.push(h)}return o.push(t.loadGeometries(r)),Promise.all(o).then(function(l){const c=l.slice(0,l.length-1),h=l[l.length-1],d=[];for(let g=0,v=h.length;g<v;g++){const _=h[g],S=r[g];let b;const w=c[g];if(S.mode===Yl.TRIANGLES||S.mode===Yl.TRIANGLE_STRIP||S.mode===Yl.TRIANGLE_FAN||S.mode===void 0)b=a.isSkinnedMesh===!0?new uO(_,w):new Ti(_,w),b.isSkinnedMesh===!0&&b.normalizeSkinWeights(),S.mode===Yl.TRIANGLE_STRIP?b.geometry=QP(b.geometry,nO):S.mode===Yl.TRIANGLE_FAN&&(b.geometry=QP(b.geometry,lE));else if(S.mode===Yl.LINES)b=new iu(_,w);else if(S.mode===Yl.LINE_STRIP)b=new pd(_,w);else if(S.mode===Yl.LINE_LOOP)b=new dO(_,w);else if(S.mode===Yl.POINTS)b=new fO(_,w);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+S.mode);Object.keys(b.geometry.morphAttributes).length>0&&_ae(b,a),b.name=t.createUniqueName(a.name||"mesh_"+e),ed(b,a),S.extensions&&Sm(i,b,S),t.assignFinalMaterial(b),d.push(b)}for(let g=0,v=d.length;g<v;g++)t.associations.set(d[g],{meshes:e,primitives:g});if(d.length===1)return a.extensions&&Sm(i,d[0],a),d[0];const p=new ld;a.extensions&&Sm(i,p,a),t.associations.set(p,{meshes:e});for(let g=0,v=d.length;g<v;g++)p.add(d[g]);return p})}loadCamera(e){let t;const s=this.json.cameras[e],i=s[s.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new ki(lG.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):s.type==="orthographic"&&(t=new Zu(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),ed(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let i=0,a=t.joints.length;i<a;i++)s.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(i){const a=i.pop(),r=i,o=[],l=[];for(let c=0,h=r.length;c<h;c++){const d=r[c];if(d){o.push(d);const p=new _n;a!==null&&p.fromArray(a.array,c*16),l.push(p)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new DS(o,l)})}loadAnimation(e){const t=this.json,s=this,i=t.animations[e],a=i.name?i.name:"animation_"+e,r=[],o=[],l=[],c=[],h=[];for(let d=0,p=i.channels.length;d<p;d++){const g=i.channels[d],v=i.samplers[g.sampler],_=g.target,S=_.node,b=i.parameters!==void 0?i.parameters[v.input]:v.input,w=i.parameters!==void 0?i.parameters[v.output]:v.output;_.node!==void 0&&(r.push(this.getDependency("node",S)),o.push(this.getDependency("accessor",b)),l.push(this.getDependency("accessor",w)),c.push(v),h.push(_))}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(l),Promise.all(c),Promise.all(h)]).then(function(d){const p=d[0],g=d[1],v=d[2],_=d[3],S=d[4],b=[];for(let w=0,T=p.length;w<T;w++){const E=p[w],R=g[w],D=v[w],F=_[w],U=S[w];if(E===void 0)continue;E.updateMatrix&&E.updateMatrix();const O=s._createAnimationTracks(E,R,D,F,U);if(O)for(let B=0;B<O.length;B++)b.push(O[B])}return new Gx(a,void 0,b)})}createNodeMesh(e){const t=this.json,s=this,i=t.nodes[e];return i.mesh===void 0?null:s.getDependency("mesh",i.mesh).then(function(a){const r=s._getNodeRef(s.meshCache,i.mesh,a);return i.weights!==void 0&&r.traverse(function(o){if(o.isMesh)for(let l=0,c=i.weights.length;l<c;l++)o.morphTargetInfluences[l]=i.weights[l]}),r})}loadNode(e){const t=this.json,s=this,i=t.nodes[e],a=s._loadNodeShallow(e),r=[],o=i.children||[];for(let c=0,h=o.length;c<h;c++)r.push(s.getDependency("node",o[c]));const l=i.skin===void 0?Promise.resolve(null):s.getDependency("skin",i.skin);return Promise.all([a,Promise.all(r),l]).then(function(c){const h=c[0],d=c[1],p=c[2];p!==null&&h.traverse(function(g){g.isSkinnedMesh&&g.bind(p,Cae)});for(let g=0,v=d.length;g<v;g++)h.add(d[g]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const a=t.nodes[e],r=a.name?i.createUniqueName(a.name):"",o=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&o.push(l),a.camera!==void 0&&o.push(i.getDependency("camera",a.camera).then(function(c){return i._getNodeRef(i.cameraCache,a.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){o.push(c)}),this.nodeCache[e]=Promise.all(o).then(function(c){let h;if(a.isBone===!0?h=new d2:c.length>1?h=new ld:c.length===1?h=c[0]:h=new Ts,h!==c[0])for(let d=0,p=c.length;d<p;d++)h.add(c[d]);if(a.name&&(h.userData.name=a.name,h.name=r),ed(h,a),a.extensions&&Sm(s,h,a),a.matrix!==void 0){const d=new _n;d.fromArray(a.matrix),h.applyMatrix4(d)}else a.translation!==void 0&&h.position.fromArray(a.translation),a.rotation!==void 0&&h.quaternion.fromArray(a.rotation),a.scale!==void 0&&h.scale.fromArray(a.scale);return i.associations.has(h)||i.associations.set(h,{}),i.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],i=this,a=new ld;s.name&&(a.name=i.createUniqueName(s.name)),ed(a,s),s.extensions&&Sm(t,a,s);const r=s.nodes||[],o=[];for(let l=0,c=r.length;l<c;l++)o.push(i.getDependency("node",r[l]));return Promise.all(o).then(function(l){for(let h=0,d=l.length;h<d;h++)a.add(l[h]);const c=h=>{const d=new Map;for(const[p,g]of i.associations)(p instanceof Da||p instanceof Vs)&&d.set(p,g);return h.traverse(p=>{const g=i.associations.get(p);g!=null&&d.set(p,g)}),d};return i.associations=c(a),a})}_createAnimationTracks(e,t,s,i,a){const r=[],o=e.name?e.name:e.uuid,l=[];wf[a.path]===wf.weights?e.traverse(function(p){p.morphTargetInfluences&&l.push(p.name?p.name:p.uuid)}):l.push(o);let c;switch(wf[a.path]){case wf.weights:c=ig;break;case wf.rotation:c=ag;break;case wf.position:case wf.scale:c=rg;break;default:switch(s.itemSize){case 1:c=ig;break;case 2:case 3:default:c=rg;break}break}const h=i.interpolation!==void 0?vae[i.interpolation]:kx,d=this._getArrayFromAccessor(s);for(let p=0,g=l.length;p<g;p++){const v=new c(l[p]+"."+wf[a.path],t.array,d,h);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(v),r.push(v)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=q3(t.constructor),i=new Float32Array(t.length);for(let a=0,r=t.length;a<r;a++)i[a]=t[a]*s;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const i=this instanceof ag?yae:UV;return new i(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Eae(n,e,t){const s=e.attributes,i=new yr;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],l=o.min,c=o.max;if(l!==void 0&&c!==void 0){if(i.set(new ue(l[0],l[1],l[2]),new ue(c[0],c[1],c[2])),o.normalized){const h=q3(Ax[o.componentType]);i.min.multiplyScalar(h),i.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const a=e.targets;if(a!==void 0){const o=new ue,l=new ue;for(let c=0,h=a.length;c<h;c++){const d=a[c];if(d.POSITION!==void 0){const p=t.json.accessors[d.POSITION],g=p.min,v=p.max;if(g!==void 0&&v!==void 0){if(l.setX(Math.max(Math.abs(g[0]),Math.abs(v[0]))),l.setY(Math.max(Math.abs(g[1]),Math.abs(v[1]))),l.setZ(Math.max(Math.abs(g[2]),Math.abs(v[2]))),p.normalized){const _=q3(Ax[p.componentType]);l.multiplyScalar(_)}o.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}n.boundingBox=i;const r=new Qa;i.getCenter(r.center),r.radius=i.min.distanceTo(i.max)/2,n.boundingSphere=r}function rz(n,e,t){const s=e.attributes,i=[];function a(r,o){return t.getDependency("accessor",r).then(function(l){n.setAttribute(o,l)})}for(const r in s){const o=X3[r]||r.toLowerCase();o in n.attributes||i.push(a(s[r],o))}if(e.indices!==void 0&&!n.index){const r=t.getDependency("accessor",e.indices).then(function(o){n.setIndex(o)});i.push(r)}return ed(n,e),Eae(n,e,t),Promise.all(i).then(function(){return e.targets!==void 0?Sae(n,e.targets,t):n})}class Mae extends TO{constructor(e){super(e),this.type=Wi}parse(e){const r=function(U,O){switch(U){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(O||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(O||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(O||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(O||""))}},d=function(U,O,B){O=O||1024;let H=U.pos,K=-1,Z=0,Q="",P=String.fromCharCode.apply(null,new Uint16Array(U.subarray(H,H+128)));for(;0>(K=P.indexOf(`
`))&&Z<O&&H<U.byteLength;)Q+=P,Z+=P.length,H+=128,P+=String.fromCharCode.apply(null,new Uint16Array(U.subarray(H,H+128)));return-1<K?(U.pos+=Z+K+1,Q+P.slice(0,K)):!1},p=function(U){const O=/^#\?(\S+)/,B=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,L=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,H=/^\s*FORMAT=(\S+)\s*$/,K=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,Z={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let Q,P;for((U.pos>=U.byteLength||!(Q=d(U)))&&r(1,"no header found"),(P=Q.match(O))||r(3,"bad initial token"),Z.valid|=1,Z.programtype=P[1],Z.string+=Q+`
`;Q=d(U),Q!==!1;){if(Z.string+=Q+`
`,Q.charAt(0)==="#"){Z.comments+=Q+`
`;continue}if((P=Q.match(B))&&(Z.gamma=parseFloat(P[1])),(P=Q.match(L))&&(Z.exposure=parseFloat(P[1])),(P=Q.match(H))&&(Z.valid|=2,Z.format=P[1]),(P=Q.match(K))&&(Z.valid|=4,Z.height=parseInt(P[1],10),Z.width=parseInt(P[2],10)),Z.valid&2&&Z.valid&4)break}return Z.valid&2||r(3,"missing format specifier"),Z.valid&4||r(3,"missing image size specifier"),Z},g=function(U,O,B){const L=O;if(L<8||L>32767||U[0]!==2||U[1]!==2||U[2]&128)return new Uint8Array(U);L!==(U[2]<<8|U[3])&&r(3,"wrong scanline width");const H=new Uint8Array(4*O*B);H.length||r(4,"unable to allocate buffer space");let K=0,Z=0;const Q=4*L,P=new Uint8Array(4),W=new Uint8Array(Q);let q=B;for(;q>0&&Z<U.byteLength;){Z+4>U.byteLength&&r(1),P[0]=U[Z++],P[1]=U[Z++],P[2]=U[Z++],P[3]=U[Z++],(P[0]!=2||P[1]!=2||(P[2]<<8|P[3])!=L)&&r(3,"bad rgbe scanline format");let se=0,le;for(;se<Q&&Z<U.byteLength;){le=U[Z++];const re=le>128;if(re&&(le-=128),(le===0||se+le>Q)&&r(3,"bad scanline data"),re){const he=U[Z++];for(let me=0;me<le;me++)W[se++]=he}else W.set(U.subarray(Z,Z+le),se),se+=le,Z+=le}const Y=L;for(let re=0;re<Y;re++){let he=0;H[K]=W[re+he],he+=L,H[K+1]=W[re+he],he+=L,H[K+2]=W[re+he],he+=L,H[K+3]=W[re+he],K+=4}q--}return H},v=function(U,O,B,L){const H=U[O+3],K=Math.pow(2,H-128)/255;B[L+0]=U[O+0]*K,B[L+1]=U[O+1]*K,B[L+2]=U[O+2]*K,B[L+3]=1},_=function(U,O,B,L){const H=U[O+3],K=Math.pow(2,H-128)/255;B[L+0]=Pm.toHalfFloat(Math.min(U[O+0]*K,65504)),B[L+1]=Pm.toHalfFloat(Math.min(U[O+1]*K,65504)),B[L+2]=Pm.toHalfFloat(Math.min(U[O+2]*K,65504)),B[L+3]=Pm.toHalfFloat(1)},S=new Uint8Array(e);S.pos=0;const b=p(S),w=b.width,T=b.height,E=g(S.subarray(S.pos),w,T);let R,D,F;switch(this.type){case wi:F=E.length/4;const U=new Float32Array(F*4);for(let B=0;B<F;B++)v(E,B*4,U,B*4);R=U,D=wi;break;case Wi:F=E.length/4;const O=new Uint16Array(F*4);for(let B=0;B<F;B++)_(E,B*4,O,B*4);R=O,D=Wi;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:w,height:T,data:R,header:b.string,gamma:b.gamma,exposure:b.exposure,type:D}}setDataType(e){return this.type=e,this}load(e,t,s,i){function a(r,o){switch(r.type){case wi:case Wi:"colorSpace"in r?r.colorSpace="srgb-linear":r.encoding=3e3,r.minFilter=is,r.magFilter=is,r.generateMipmaps=!1,r.flipY=!0;break}t&&t(r,o)}return super.load(e,a,s,i)}}const g1=WO>=152;class Nae extends TO{constructor(e){super(e),this.type=Wi}parse(e){const O=Math.pow(2.7182818,2.2);function B(j,ae){for(var Ce=0,We=0;We<65536;++We)(We==0||j[We>>3]&1<<(We&7))&&(ae[Ce++]=We);for(var st=Ce-1;Ce<65536;)ae[Ce++]=0;return st}function L(j){for(var ae=0;ae<16384;ae++)j[ae]={},j[ae].len=0,j[ae].lit=0,j[ae].p=null}const H={l:0,c:0,lc:0};function K(j,ae,Ce,We,st){for(;Ce<j;)ae=ae<<8|Zt(We,st),Ce+=8;Ce-=j,H.l=ae>>Ce&(1<<j)-1,H.c=ae,H.lc=Ce}const Z=new Array(59);function Q(j){for(var ae=0;ae<=58;++ae)Z[ae]=0;for(var ae=0;ae<65537;++ae)Z[j[ae]]+=1;for(var Ce=0,ae=58;ae>0;--ae){var We=Ce+Z[ae]>>1;Z[ae]=Ce,Ce=We}for(var ae=0;ae<65537;++ae){var st=j[ae];st>0&&(j[ae]=st|Z[st]++<<6)}}function P(j,ae,Ce,We,st,tt,Mt){for(var wt=Ce,Ct=0,X=0;st<=tt;st++){if(wt.value-Ce.value>We)return!1;K(6,Ct,X,j,wt);var de=H.l;if(Ct=H.c,X=H.lc,Mt[st]=de,de==63){if(wt.value-Ce.value>We)throw"Something wrong with hufUnpackEncTable";K(8,Ct,X,j,wt);var Se=H.l+6;if(Ct=H.c,X=H.lc,st+Se>tt+1)throw"Something wrong with hufUnpackEncTable";for(;Se--;)Mt[st++]=0;st--}else if(de>=59){var Se=de-59+2;if(st+Se>tt+1)throw"Something wrong with hufUnpackEncTable";for(;Se--;)Mt[st++]=0;st--}}Q(Mt)}function W(j){return j&63}function q(j){return j>>6}function se(j,ae,Ce,We){for(;ae<=Ce;ae++){var st=q(j[ae]),tt=W(j[ae]);if(st>>tt)throw"Invalid table entry";if(tt>14){var Mt=We[st>>tt-14];if(Mt.len)throw"Invalid table entry";if(Mt.lit++,Mt.p){var wt=Mt.p;Mt.p=new Array(Mt.lit);for(var Ct=0;Ct<Mt.lit-1;++Ct)Mt.p[Ct]=wt[Ct]}else Mt.p=new Array(1);Mt.p[Mt.lit-1]=ae}else if(tt)for(var X=0,Ct=1<<14-tt;Ct>0;Ct--){var Mt=We[(st<<14-tt)+X];if(Mt.len||Mt.p)throw"Invalid table entry";Mt.len=tt,Mt.lit=ae,X++}}return!0}const le={c:0,lc:0};function Y(j,ae,Ce,We){j=j<<8|Zt(Ce,We),ae+=8,le.c=j,le.lc=ae}const re={c:0,lc:0};function he(j,ae,Ce,We,st,tt,Mt,wt,Ct,X){if(j==ae){We<8&&(Y(Ce,We,st,Mt),Ce=le.c,We=le.lc),We-=8;var de=Ce>>We,de=new Uint8Array([de])[0];if(Ct.value+de>X)return!1;for(var Se=wt[Ct.value-1];de-- >0;)wt[Ct.value++]=Se}else if(Ct.value<X)wt[Ct.value++]=j;else return!1;re.c=Ce,re.lc=We}function me(j){return j&65535}function Ne(j){var ae=me(j);return ae>32767?ae-65536:ae}const fe={a:0,b:0};function Te(j,ae){var Ce=Ne(j),We=Ne(ae),st=We,tt=Ce+(st&1)+(st>>1),Mt=tt,wt=tt-st;fe.a=Mt,fe.b=wt}function Ge(j,ae){var Ce=me(j),We=me(ae),st=Ce-(We>>1)&65535,tt=We+st-32768&65535;fe.a=tt,fe.b=st}function nt(j,ae,Ce,We,st,tt,Mt){for(var wt=Mt<16384,Ct=Ce>st?st:Ce,X=1,de;X<=Ct;)X<<=1;for(X>>=1,de=X,X>>=1;X>=1;){for(var Se=0,De=Se+tt*(st-de),ye=tt*X,Ke=tt*de,ct=We*X,vt=We*de,It,Pt,Kt,jt;Se<=De;Se+=Ke){for(var Qt=Se,In=Se+We*(Ce-de);Qt<=In;Qt+=vt){var hn=Qt+ct,bn=Qt+ye,jn=bn+ct;wt?(Te(j[Qt+ae],j[bn+ae]),It=fe.a,Kt=fe.b,Te(j[hn+ae],j[jn+ae]),Pt=fe.a,jt=fe.b,Te(It,Pt),j[Qt+ae]=fe.a,j[hn+ae]=fe.b,Te(Kt,jt),j[bn+ae]=fe.a,j[jn+ae]=fe.b):(Ge(j[Qt+ae],j[bn+ae]),It=fe.a,Kt=fe.b,Ge(j[hn+ae],j[jn+ae]),Pt=fe.a,jt=fe.b,Ge(It,Pt),j[Qt+ae]=fe.a,j[hn+ae]=fe.b,Ge(Kt,jt),j[bn+ae]=fe.a,j[jn+ae]=fe.b)}if(Ce&X){var bn=Qt+ye;wt?Te(j[Qt+ae],j[bn+ae]):Ge(j[Qt+ae],j[bn+ae]),It=fe.a,j[bn+ae]=fe.b,j[Qt+ae]=It}}if(st&X)for(var Qt=Se,In=Se+We*(Ce-de);Qt<=In;Qt+=vt){var hn=Qt+ct;wt?Te(j[Qt+ae],j[hn+ae]):Ge(j[Qt+ae],j[hn+ae]),It=fe.a,j[hn+ae]=fe.b,j[Qt+ae]=It}de=X,X>>=1}return Se}function yt(j,ae,Ce,We,st,tt,Mt,wt,Ct,X){for(var de=0,Se=0,De=wt,ye=Math.trunc(st.value+(tt+7)/8);st.value<ye;)for(Y(de,Se,Ce,st),de=le.c,Se=le.lc;Se>=14;){var Ke=de>>Se-14&16383,ct=ae[Ke];if(ct.len)Se-=ct.len,he(ct.lit,Mt,de,Se,Ce,We,st,Ct,X,De),de=re.c,Se=re.lc;else{if(!ct.p)throw"hufDecode issues";var vt;for(vt=0;vt<ct.lit;vt++){for(var It=W(j[ct.p[vt]]);Se<It&&st.value<ye;)Y(de,Se,Ce,st),de=le.c,Se=le.lc;if(Se>=It&&q(j[ct.p[vt]])==(de>>Se-It&(1<<It)-1)){Se-=It,he(ct.p[vt],Mt,de,Se,Ce,We,st,Ct,X,De),de=re.c,Se=re.lc;break}}if(vt==ct.lit)throw"hufDecode issues"}}var Pt=8-tt&7;for(de>>=Pt,Se-=Pt;Se>0;){var ct=ae[de<<14-Se&16383];if(ct.len)Se-=ct.len,he(ct.lit,Mt,de,Se,Ce,We,st,Ct,X,De),de=re.c,Se=re.lc;else throw"hufDecode issues"}return!0}function Dt(j,ae,Ce,We,st,tt){var Mt={value:0},wt=Ce.value,Ct=ut(ae,Ce),X=ut(ae,Ce);Ce.value+=4;var de=ut(ae,Ce);if(Ce.value+=4,Ct<0||Ct>=65537||X<0||X>=65537)throw"Something wrong with HUF_ENCSIZE";var Se=new Array(65537),De=new Array(16384);L(De);var ye=We-(Ce.value-wt);if(P(j,ae,Ce,ye,Ct,X,Se),de>8*(We-(Ce.value-wt)))throw"Something wrong with hufUncompress";se(Se,Ct,X,De),yt(Se,De,j,ae,Ce,de,X,tt,st,Mt)}function qt(j,ae,Ce){for(var We=0;We<Ce;++We)ae[We]=j[ae[We]]}function Bt(j){for(var ae=1;ae<j.length;ae++){var Ce=j[ae-1]+j[ae]-128;j[ae]=Ce}}function Je(j,ae){for(var Ce=0,We=Math.floor((j.length+1)/2),st=0,tt=j.length-1;!(st>tt||(ae[st++]=j[Ce++],st>tt));)ae[st++]=j[We++]}function oe(j){for(var ae=j.byteLength,Ce=new Array,We=0,st=new DataView(j);ae>0;){var tt=st.getInt8(We++);if(tt<0){var Mt=-tt;ae-=Mt+1;for(var wt=0;wt<Mt;wt++)Ce.push(st.getUint8(We++))}else{var Mt=tt;ae-=2;for(var Ct=st.getUint8(We++),wt=0;wt<Mt+1;wt++)Ce.push(Ct)}}return Ce}function Ze(j,ae,Ce,We,st,tt){var hn=new DataView(tt.buffer),Mt=Ce[j.idx[0]].width,wt=Ce[j.idx[0]].height,Ct=3,X=Math.floor(Mt/8),de=Math.ceil(Mt/8),Se=Math.ceil(wt/8),De=Mt-(de-1)*8,ye=wt-(Se-1)*8,Ke={value:0},ct=new Array(Ct),vt=new Array(Ct),It=new Array(Ct),Pt=new Array(Ct),Kt=new Array(Ct);for(let nn=0;nn<Ct;++nn)Kt[nn]=ae[j.idx[nn]],ct[nn]=nn<1?0:ct[nn-1]+de*Se,vt[nn]=new Float32Array(64),It[nn]=new Uint16Array(64),Pt[nn]=new Uint16Array(de*64);for(let nn=0;nn<Se;++nn){var jt=8;nn==Se-1&&(jt=ye);var Qt=8;for(let ms=0;ms<de;++ms){ms==de-1&&(Qt=De);for(let mn=0;mn<Ct;++mn)It[mn].fill(0),It[mn][0]=st[ct[mn]++],it(Ke,We,It[mn]),ft(It[mn],vt[mn]),gt(vt[mn]);Tt(vt);for(let mn=0;mn<Ct;++mn)Et(vt[mn],Pt[mn],ms*64)}let ss=0;for(let ms=0;ms<Ct;++ms){const mn=Ce[j.idx[ms]].type;for(let li=8*nn;li<8*nn+jt;++li){ss=Kt[ms][li];for(let cs=0;cs<X;++cs){const vs=cs*64+(li&7)*8;hn.setUint16(ss+0*mn,Pt[ms][vs+0],!0),hn.setUint16(ss+2*mn,Pt[ms][vs+1],!0),hn.setUint16(ss+4*mn,Pt[ms][vs+2],!0),hn.setUint16(ss+6*mn,Pt[ms][vs+3],!0),hn.setUint16(ss+8*mn,Pt[ms][vs+4],!0),hn.setUint16(ss+10*mn,Pt[ms][vs+5],!0),hn.setUint16(ss+12*mn,Pt[ms][vs+6],!0),hn.setUint16(ss+14*mn,Pt[ms][vs+7],!0),ss+=16*mn}}if(X!=de)for(let li=8*nn;li<8*nn+jt;++li){const cs=Kt[ms][li]+8*X*2*mn,vs=X*64+(li&7)*8;for(let Ps=0;Ps<Qt;++Ps)hn.setUint16(cs+Ps*2*mn,Pt[ms][vs+Ps],!0)}}}for(var In=new Uint16Array(Mt),hn=new DataView(tt.buffer),bn=0;bn<Ct;++bn){Ce[j.idx[bn]].decoded=!0;var jn=Ce[j.idx[bn]].type;if(Ce[bn].type==2)for(var dn=0;dn<wt;++dn){const nn=Kt[bn][dn];for(var zn=0;zn<Mt;++zn)In[zn]=hn.getUint16(nn+zn*2*jn,!0);for(var zn=0;zn<Mt;++zn)hn.setFloat32(nn+zn*2*jn,Ue(In[zn]),!0)}}}function it(j,ae,Ce){for(var We,st=1;st<64;)We=ae[j.value],We==65280?st=64:We>>8==255?st+=We&255:(Ce[st]=We,st++),j.value++}function ft(j,ae){ae[0]=Ue(j[0]),ae[1]=Ue(j[1]),ae[2]=Ue(j[5]),ae[3]=Ue(j[6]),ae[4]=Ue(j[14]),ae[5]=Ue(j[15]),ae[6]=Ue(j[27]),ae[7]=Ue(j[28]),ae[8]=Ue(j[2]),ae[9]=Ue(j[4]),ae[10]=Ue(j[7]),ae[11]=Ue(j[13]),ae[12]=Ue(j[16]),ae[13]=Ue(j[26]),ae[14]=Ue(j[29]),ae[15]=Ue(j[42]),ae[16]=Ue(j[3]),ae[17]=Ue(j[8]),ae[18]=Ue(j[12]),ae[19]=Ue(j[17]),ae[20]=Ue(j[25]),ae[21]=Ue(j[30]),ae[22]=Ue(j[41]),ae[23]=Ue(j[43]),ae[24]=Ue(j[9]),ae[25]=Ue(j[11]),ae[26]=Ue(j[18]),ae[27]=Ue(j[24]),ae[28]=Ue(j[31]),ae[29]=Ue(j[40]),ae[30]=Ue(j[44]),ae[31]=Ue(j[53]),ae[32]=Ue(j[10]),ae[33]=Ue(j[19]),ae[34]=Ue(j[23]),ae[35]=Ue(j[32]),ae[36]=Ue(j[39]),ae[37]=Ue(j[45]),ae[38]=Ue(j[52]),ae[39]=Ue(j[54]),ae[40]=Ue(j[20]),ae[41]=Ue(j[22]),ae[42]=Ue(j[33]),ae[43]=Ue(j[38]),ae[44]=Ue(j[46]),ae[45]=Ue(j[51]),ae[46]=Ue(j[55]),ae[47]=Ue(j[60]),ae[48]=Ue(j[21]),ae[49]=Ue(j[34]),ae[50]=Ue(j[37]),ae[51]=Ue(j[47]),ae[52]=Ue(j[50]),ae[53]=Ue(j[56]),ae[54]=Ue(j[59]),ae[55]=Ue(j[61]),ae[56]=Ue(j[35]),ae[57]=Ue(j[36]),ae[58]=Ue(j[48]),ae[59]=Ue(j[49]),ae[60]=Ue(j[57]),ae[61]=Ue(j[58]),ae[62]=Ue(j[62]),ae[63]=Ue(j[63])}function gt(j){const ae=.5*Math.cos(.7853975),Ce=.5*Math.cos(3.14159/16),We=.5*Math.cos(3.14159/8),st=.5*Math.cos(3*3.14159/16),tt=.5*Math.cos(5*3.14159/16),Mt=.5*Math.cos(3*3.14159/8),wt=.5*Math.cos(7*3.14159/16);for(var Ct=new Array(4),X=new Array(4),de=new Array(4),Se=new Array(4),De=0;De<8;++De){var ye=De*8;Ct[0]=We*j[ye+2],Ct[1]=Mt*j[ye+2],Ct[2]=We*j[ye+6],Ct[3]=Mt*j[ye+6],X[0]=Ce*j[ye+1]+st*j[ye+3]+tt*j[ye+5]+wt*j[ye+7],X[1]=st*j[ye+1]-wt*j[ye+3]-Ce*j[ye+5]-tt*j[ye+7],X[2]=tt*j[ye+1]-Ce*j[ye+3]+wt*j[ye+5]+st*j[ye+7],X[3]=wt*j[ye+1]-tt*j[ye+3]+st*j[ye+5]-Ce*j[ye+7],de[0]=ae*(j[ye+0]+j[ye+4]),de[3]=ae*(j[ye+0]-j[ye+4]),de[1]=Ct[0]+Ct[3],de[2]=Ct[1]-Ct[2],Se[0]=de[0]+de[1],Se[1]=de[3]+de[2],Se[2]=de[3]-de[2],Se[3]=de[0]-de[1],j[ye+0]=Se[0]+X[0],j[ye+1]=Se[1]+X[1],j[ye+2]=Se[2]+X[2],j[ye+3]=Se[3]+X[3],j[ye+4]=Se[3]-X[3],j[ye+5]=Se[2]-X[2],j[ye+6]=Se[1]-X[1],j[ye+7]=Se[0]-X[0]}for(var Ke=0;Ke<8;++Ke)Ct[0]=We*j[16+Ke],Ct[1]=Mt*j[16+Ke],Ct[2]=We*j[48+Ke],Ct[3]=Mt*j[48+Ke],X[0]=Ce*j[8+Ke]+st*j[24+Ke]+tt*j[40+Ke]+wt*j[56+Ke],X[1]=st*j[8+Ke]-wt*j[24+Ke]-Ce*j[40+Ke]-tt*j[56+Ke],X[2]=tt*j[8+Ke]-Ce*j[24+Ke]+wt*j[40+Ke]+st*j[56+Ke],X[3]=wt*j[8+Ke]-tt*j[24+Ke]+st*j[40+Ke]-Ce*j[56+Ke],de[0]=ae*(j[Ke]+j[32+Ke]),de[3]=ae*(j[Ke]-j[32+Ke]),de[1]=Ct[0]+Ct[3],de[2]=Ct[1]-Ct[2],Se[0]=de[0]+de[1],Se[1]=de[3]+de[2],Se[2]=de[3]-de[2],Se[3]=de[0]-de[1],j[0+Ke]=Se[0]+X[0],j[8+Ke]=Se[1]+X[1],j[16+Ke]=Se[2]+X[2],j[24+Ke]=Se[3]+X[3],j[32+Ke]=Se[3]-X[3],j[40+Ke]=Se[2]-X[2],j[48+Ke]=Se[1]-X[1],j[56+Ke]=Se[0]-X[0]}function Tt(j){for(var ae=0;ae<64;++ae){var Ce=j[0][ae],We=j[1][ae],st=j[2][ae];j[0][ae]=Ce+1.5747*st,j[1][ae]=Ce-.1873*We-.4682*st,j[2][ae]=Ce+1.8556*We}}function Et(j,ae,Ce){for(var We=0;We<64;++We)ae[Ce+We]=Pm.toHalfFloat(kt(j[We]))}function kt(j){return j<=1?Math.sign(j)*Math.pow(Math.abs(j),2.2):Math.sign(j)*Math.pow(O,Math.abs(j)-1)}function ce(j){return new DataView(j.array.buffer,j.offset.value,j.size)}function J(j){var ae=j.viewer.buffer.slice(j.offset.value,j.offset.value+j.size),Ce=new Uint8Array(oe(ae)),We=new Uint8Array(Ce.length);return Bt(Ce),Je(Ce,We),new DataView(We.buffer)}function Ie(j){var ae=j.array.slice(j.offset.value,j.offset.value+j.size),Ce=zC(ae),We=new Uint8Array(Ce.length);return Bt(Ce),Je(Ce,We),new DataView(We.buffer)}function Ye(j){for(var ae=j.viewer,Ce={value:j.offset.value},We=new Uint16Array(j.width*j.scanlineBlockSize*(j.channels*j.type)),st=new Uint8Array(8192),tt=0,Mt=new Array(j.channels),wt=0;wt<j.channels;wt++)Mt[wt]={},Mt[wt].start=tt,Mt[wt].end=Mt[wt].start,Mt[wt].nx=j.width,Mt[wt].ny=j.lines,Mt[wt].size=j.type,tt+=Mt[wt].nx*Mt[wt].ny*Mt[wt].size;var Ct=At(ae,Ce),X=At(ae,Ce);if(X>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(Ct<=X)for(var wt=0;wt<X-Ct+1;wt++)st[wt+Ct]=xe(ae,Ce);var de=new Uint16Array(65536),Se=B(st,de),De=ut(ae,Ce);Dt(j.array,ae,Ce,De,We,tt);for(var wt=0;wt<j.channels;++wt)for(var ye=Mt[wt],Ke=0;Ke<Mt[wt].size;++Ke)nt(We,ye.start+Ke,ye.nx,ye.size,ye.ny,ye.nx*ye.size,Se);qt(de,We,tt);for(var ct=0,vt=new Uint8Array(We.buffer.byteLength),It=0;It<j.lines;It++)for(var Pt=0;Pt<j.channels;Pt++){var ye=Mt[Pt],Kt=ye.nx*ye.size,jt=new Uint8Array(We.buffer,ye.end*2,Kt*2);vt.set(jt,ct),ct+=Kt*2,ye.end+=Kt}return new DataView(vt.buffer)}function lt(j){var ae=j.array.slice(j.offset.value,j.offset.value+j.size),Ce=zC(ae);const We=j.lines*j.channels*j.width,st=j.type==1?new Uint16Array(We):new Uint32Array(We);let tt=0,Mt=0;const wt=new Array(4);for(let Ct=0;Ct<j.lines;Ct++)for(let X=0;X<j.channels;X++){let de=0;switch(j.type){case 1:wt[0]=tt,wt[1]=wt[0]+j.width,tt=wt[1]+j.width;for(let Se=0;Se<j.width;++Se){const De=Ce[wt[0]++]<<8|Ce[wt[1]++];de+=De,st[Mt]=de,Mt++}break;case 2:wt[0]=tt,wt[1]=wt[0]+j.width,wt[2]=wt[1]+j.width,tt=wt[2]+j.width;for(let Se=0;Se<j.width;++Se){const De=Ce[wt[0]++]<<24|Ce[wt[1]++]<<16|Ce[wt[2]++]<<8;de+=De,st[Mt]=de,Mt++}break}}return new DataView(st.buffer)}function Ve(j){var ae=j.viewer,Ce={value:j.offset.value},We=new Uint8Array(j.width*j.lines*(j.channels*j.type*2)),st={version:Fe(ae,Ce),unknownUncompressedSize:Fe(ae,Ce),unknownCompressedSize:Fe(ae,Ce),acCompressedSize:Fe(ae,Ce),dcCompressedSize:Fe(ae,Ce),rleCompressedSize:Fe(ae,Ce),rleUncompressedSize:Fe(ae,Ce),rleRawSize:Fe(ae,Ce),totalAcUncompressedCount:Fe(ae,Ce),totalDcUncompressedCount:Fe(ae,Ce),acCompression:Fe(ae,Ce)};if(st.version<2)throw"EXRLoader.parse: "+ca.compression+" version "+st.version+" is unsupported";for(var tt=new Array,Mt=At(ae,Ce)-2;Mt>0;){var wt=Gt(ae.buffer,Ce),Ct=xe(ae,Ce),X=Ct>>2&3,de=(Ct>>4)-1,Se=new Int8Array([de])[0],De=xe(ae,Ce);tt.push({name:wt,index:Se,type:De,compression:X}),Mt-=wt.length+3}for(var ye=ca.channels,Ke=new Array(j.channels),ct=0;ct<j.channels;++ct){var vt=Ke[ct]={},It=ye[ct];vt.name=It.name,vt.compression=0,vt.decoded=!1,vt.type=It.pixelType,vt.pLinear=It.pLinear,vt.width=j.width,vt.height=j.lines}for(var Pt={idx:new Array(3)},Kt=0;Kt<j.channels;++Kt)for(var vt=Ke[Kt],ct=0;ct<tt.length;++ct){var jt=tt[ct];vt.name==jt.name&&(vt.compression=jt.compression,jt.index>=0&&(Pt.idx[jt.index]=Kt),vt.offset=Kt)}if(st.acCompressedSize>0)switch(st.acCompression){case 0:var hn=new Uint16Array(st.totalAcUncompressedCount);Dt(j.array,ae,Ce,st.acCompressedSize,hn,st.totalAcUncompressedCount);break;case 1:var Qt=j.array.slice(Ce.value,Ce.value+st.totalAcUncompressedCount),In=zC(Qt),hn=new Uint16Array(In.buffer);Ce.value+=st.totalAcUncompressedCount;break}if(st.dcCompressedSize>0){var bn={array:j.array,offset:Ce,size:st.dcCompressedSize},jn=new Uint16Array(Ie(bn).buffer);Ce.value+=st.dcCompressedSize}if(st.rleRawSize>0){var Qt=j.array.slice(Ce.value,Ce.value+st.rleCompressedSize),In=zC(Qt),dn=oe(In.buffer);Ce.value+=st.rleCompressedSize}for(var zn=0,nn=new Array(Ke.length),ct=0;ct<nn.length;++ct)nn[ct]=new Array;for(var ss=0;ss<j.lines;++ss)for(var ms=0;ms<Ke.length;++ms)nn[ms].push(zn),zn+=Ke[ms].width*j.type*2;Ze(Pt,nn,Ke,hn,jn,We);for(var ct=0;ct<Ke.length;++ct){var vt=Ke[ct];if(!vt.decoded)switch(vt.compression){case 2:for(var mn=0,li=0,ss=0;ss<j.lines;++ss){for(var cs=nn[ct][mn],vs=0;vs<vt.width;++vs){for(var Ps=0;Ps<2*vt.type;++Ps)We[cs++]=dn[li+Ps*vt.width*vt.height];li++}mn++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(We.buffer)}function Gt(j,ae){for(var Ce=new Uint8Array(j),We=0;Ce[ae.value+We]!=0;)We+=1;var st=new TextDecoder().decode(Ce.slice(ae.value,ae.value+We));return ae.value=ae.value+We+1,st}function Lt(j,ae,Ce){var We=new TextDecoder().decode(new Uint8Array(j).slice(ae.value,ae.value+Ce));return ae.value=ae.value+Ce,We}function tn(j,ae){var Ce=at(j,ae),We=ut(j,ae);return[Ce,We]}function Jt(j,ae){var Ce=ut(j,ae),We=ut(j,ae);return[Ce,We]}function at(j,ae){var Ce=j.getInt32(ae.value,!0);return ae.value=ae.value+4,Ce}function ut(j,ae){var Ce=j.getUint32(ae.value,!0);return ae.value=ae.value+4,Ce}function Zt(j,ae){var Ce=j[ae.value];return ae.value=ae.value+1,Ce}function xe(j,ae){var Ce=j.getUint8(ae.value);return ae.value=ae.value+1,Ce}const Fe=function(j,ae){let Ce;return"getBigInt64"in DataView.prototype?Ce=Number(j.getBigInt64(ae.value,!0)):Ce=j.getUint32(ae.value+4,!0)+Number(j.getUint32(ae.value,!0)<<32),ae.value+=8,Ce};function mt(j,ae){var Ce=j.getFloat32(ae.value,!0);return ae.value+=4,Ce}function ge(j,ae){return Pm.toHalfFloat(mt(j,ae))}function Ue(j){var ae=(j&31744)>>10,Ce=j&1023;return(j>>15?-1:1)*(ae?ae===31?Ce?NaN:1/0:Math.pow(2,ae-15)*(1+Ce/1024):6103515625e-14*(Ce/1024))}function At(j,ae){var Ce=j.getUint16(ae.value,!0);return ae.value+=2,Ce}function Rt(j,ae){return Ue(At(j,ae))}function St(j,ae,Ce,We){for(var st=Ce.value,tt=[];Ce.value<st+We-1;){var Mt=Gt(ae,Ce),wt=at(j,Ce),Ct=xe(j,Ce);Ce.value+=3;var X=at(j,Ce),de=at(j,Ce);tt.push({name:Mt,pixelType:wt,pLinear:Ct,xSampling:X,ySampling:de})}return Ce.value+=1,tt}function dt(j,ae){var Ce=mt(j,ae),We=mt(j,ae),st=mt(j,ae),tt=mt(j,ae),Mt=mt(j,ae),wt=mt(j,ae),Ct=mt(j,ae),X=mt(j,ae);return{redX:Ce,redY:We,greenX:st,greenY:tt,blueX:Mt,blueY:wt,whiteX:Ct,whiteY:X}}function Ut(j,ae){var Ce=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],We=xe(j,ae);return Ce[We]}function cn(j,ae){var Ce=ut(j,ae),We=ut(j,ae),st=ut(j,ae),tt=ut(j,ae);return{xMin:Ce,yMin:We,xMax:st,yMax:tt}}function Wn(j,ae){var Ce=["INCREASING_Y"],We=xe(j,ae);return Ce[We]}function Fn(j,ae){var Ce=mt(j,ae),We=mt(j,ae);return[Ce,We]}function ei(j,ae){var Ce=mt(j,ae),We=mt(j,ae),st=mt(j,ae);return[Ce,We,st]}function Ni(j,ae,Ce,We,st){if(We==="string"||We==="stringvector"||We==="iccProfile")return Lt(ae,Ce,st);if(We==="chlist")return St(j,ae,Ce,st);if(We==="chromaticities")return dt(j,Ce);if(We==="compression")return Ut(j,Ce);if(We==="box2i")return cn(j,Ce);if(We==="lineOrder")return Wn(j,Ce);if(We==="float")return mt(j,Ce);if(We==="v2f")return Fn(j,Ce);if(We==="v3f")return ei(j,Ce);if(We==="int")return at(j,Ce);if(We==="rational")return tn(j,Ce);if(We==="timecode")return Jt(j,Ce);if(We==="preview")return Ce.value+=st,"skipped";Ce.value+=st}function xh(j,ae,Ce){const We={};if(j.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";We.version=j.getUint8(4);const st=j.getUint8(5);We.spec={singleTile:!!(st&2),longName:!!(st&4),deepFormat:!!(st&8),multiPart:!!(st&16)},Ce.value=8;for(var tt=!0;tt;){var Mt=Gt(ae,Ce);if(Mt==0)tt=!1;else{var wt=Gt(ae,Ce),Ct=ut(j,Ce),X=Ni(j,ae,Ce,wt,Ct);X===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${wt}'.`):We[Mt]=X}}if((st&-5)!=0)throw console.error("EXRHeader:",We),"THREE.EXRLoader: provided file is currently unsupported.";return We}function fc(j,ae,Ce,We,st){const tt={size:0,viewer:ae,array:Ce,offset:We,width:j.dataWindow.xMax-j.dataWindow.xMin+1,height:j.dataWindow.yMax-j.dataWindow.yMin+1,channels:j.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:j.channels[0].pixelType,uncompress:null,getter:null,format:null,[g1?"colorSpace":"encoding"]:null};switch(j.compression){case"NO_COMPRESSION":tt.lines=1,tt.uncompress=ce;break;case"RLE_COMPRESSION":tt.lines=1,tt.uncompress=J;break;case"ZIPS_COMPRESSION":tt.lines=1,tt.uncompress=Ie;break;case"ZIP_COMPRESSION":tt.lines=16,tt.uncompress=Ie;break;case"PIZ_COMPRESSION":tt.lines=32,tt.uncompress=Ye;break;case"PXR24_COMPRESSION":tt.lines=16,tt.uncompress=lt;break;case"DWAA_COMPRESSION":tt.lines=32,tt.uncompress=Ve;break;case"DWAB_COMPRESSION":tt.lines=256,tt.uncompress=Ve;break;default:throw"EXRLoader.parse: "+j.compression+" is unsupported"}if(tt.scanlineBlockSize=tt.lines,tt.type==1)switch(st){case wi:tt.getter=Rt,tt.inputSize=2;break;case Wi:tt.getter=At,tt.inputSize=2;break}else if(tt.type==2)switch(st){case wi:tt.getter=mt,tt.inputSize=4;break;case Wi:tt.getter=ge,tt.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+tt.type+" for "+j.compression+".";tt.blockCount=(j.dataWindow.yMax+1)/tt.scanlineBlockSize;for(var Mt=0;Mt<tt.blockCount;Mt++)Fe(ae,We);tt.outputChannels=tt.channels==3?4:tt.channels;const wt=tt.width*tt.height*tt.outputChannels;switch(st){case wi:tt.byteArray=new Float32Array(wt),tt.channels<tt.outputChannels&&tt.byteArray.fill(1,0,wt);break;case Wi:tt.byteArray=new Uint16Array(wt),tt.channels<tt.outputChannels&&tt.byteArray.fill(15360,0,wt);break;default:console.error("THREE.EXRLoader: unsupported type: ",st);break}return tt.bytesPerLine=tt.width*tt.inputSize*tt.channels,tt.outputChannels==4?tt.format=ra:tt.format=ES,g1?tt.colorSpace="srgb-linear":tt.encoding=3e3,tt}const Oo=new DataView(e),zi=new Uint8Array(e),Ar={value:0},ca=xh(Oo,e,Ar),Cn=fc(ca,Oo,zi,Ar,this.type),Ji={value:0},Un={R:0,G:1,B:2,A:3,Y:0};for(let j=0;j<Cn.height/Cn.scanlineBlockSize;j++){const ae=ut(Oo,Ar);Cn.size=ut(Oo,Ar),Cn.lines=ae+Cn.scanlineBlockSize>Cn.height?Cn.height-ae:Cn.scanlineBlockSize;const We=Cn.size<Cn.lines*Cn.bytesPerLine?Cn.uncompress(Cn):ce(Cn);Ar.value+=Cn.size;for(let st=0;st<Cn.scanlineBlockSize;st++){const tt=st+j*Cn.scanlineBlockSize;if(tt>=Cn.height)break;for(let Mt=0;Mt<Cn.channels;Mt++){const wt=Un[ca.channels[Mt].name];for(let Ct=0;Ct<Cn.width;Ct++){Ji.value=(st*(Cn.channels*Cn.width)+Mt*Cn.width+Ct)*Cn.inputSize;const X=(Cn.height-1-tt)*(Cn.width*Cn.outputChannels)+Ct*Cn.outputChannels+wt;Cn.byteArray[X]=Cn.getter(We,Ji)}}}}return{header:ca,width:Cn.width,height:Cn.height,data:Cn.byteArray,format:Cn.format,[g1?"colorSpace":"encoding"]:Cn[g1?"colorSpace":"encoding"],type:this.type}}setDataType(e){return this.type=e,this}load(e,t,s,i){function a(r,o){g1?r.colorSpace=o.colorSpace:r.encoding=o.encoding,r.minFilter=is,r.magFilter=is,r.generateMipmaps=!1,r.flipY=!1,t&&t(r,o)}return super.load(e,a,s,i)}}const JI=new WeakMap;class Rae extends br{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,s,i){const a=new vr(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,r=>{const o={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(r,o).then(t).catch(i)},s,i)}decodeDracoFile(e,t,s,i){const a={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!s};this.decodeGeometry(e,a).then(t)}decodeGeometry(e,t){for(const l in t.attributeTypes){const c=t.attributeTypes[l];c.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[l]=c.name)}const s=JSON.stringify(t);if(JI.has(e)){const l=JI.get(e);if(l.key===s)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const a=this.workerNextTaskID++,r=e.byteLength,o=this._getWorker(a,r).then(l=>(i=l,new Promise((c,h)=>{i._callbacks[a]={resolve:c,reject:h},i.postMessage({type:"decode",id:a,taskConfig:t,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return o.catch(()=>!0).then(()=>{i&&a&&this._releaseTask(i,a)}),JI.set(e,{key:s,promise:o}),o}_createGeometry(e){const t=new Ln;e.index&&t.setIndex(new Es(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const i=e.attributes[s],a=i.name,r=i.array,o=i.itemSize;t.setAttribute(a,new Es(r,o))}return t}_loadLibrary(e,t){const s=new vr(this.manager);return s.setPath(this.decoderPath),s.setResponseType(t),s.setWithCredentials(this.withCredentials),new Promise((i,a)=>{s.load(e,i,void 0,a)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(s=>{const i=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const a=Iae.toString(),r=["/* draco decoder */",i,"","/* worker */",a.substring(a.indexOf("{")+1,a.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([r]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(a){const r=a.data;switch(r.type){case"decode":i._callbacks[r.id].resolve(r);break;case"error":i._callbacks[r.id].reject(r);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+r.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,a){return i._taskLoad>a._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=t,s._taskLoad+=t,s})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function Iae(){let n,e;onmessage=function(r){const o=r.data;switch(o.type){case"init":n=o.decoderConfig,e=new Promise(function(h){n.onModuleLoaded=function(d){h({draco:d})},DracoDecoderModule(n)});break;case"decode":const l=o.buffer,c=o.taskConfig;e.then(h=>{const d=h.draco,p=new d.Decoder,g=new d.DecoderBuffer;g.Init(new Int8Array(l),l.byteLength);try{const v=t(d,p,g,c),_=v.attributes.map(S=>S.array.buffer);v.index&&_.push(v.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:v},_)}catch(v){console.error(v),self.postMessage({type:"error",id:o.id,error:v.message})}finally{d.destroy(g),d.destroy(p)}});break}};function t(r,o,l,c){const h=c.attributeIDs,d=c.attributeTypes;let p,g;const v=o.GetEncodedGeometryType(l);if(v===r.TRIANGULAR_MESH)p=new r.Mesh,g=o.DecodeBufferToMesh(l,p);else if(v===r.POINT_CLOUD)p=new r.PointCloud,g=o.DecodeBufferToPointCloud(l,p);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!g.ok()||p.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+g.error_msg());const _={index:null,attributes:[]};for(const S in h){const b=self[d[S]];let w,T;if(c.useUniqueIDs)T=h[S],w=o.GetAttributeByUniqueId(p,T);else{if(T=o.GetAttributeId(p,r[h[S]]),T===-1)continue;w=o.GetAttribute(p,T)}_.attributes.push(i(r,o,p,S,b,w))}return v===r.TRIANGULAR_MESH&&(_.index=s(r,o,p)),r.destroy(p),_}function s(r,o,l){const h=l.num_faces()*3,d=h*4,p=r._malloc(d);o.GetTrianglesUInt32Array(l,d,p);const g=new Uint32Array(r.HEAPF32.buffer,p,h).slice();return r._free(p),{array:g,itemSize:1}}function i(r,o,l,c,h,d){const p=d.num_components(),v=l.num_points()*p,_=v*h.BYTES_PER_ELEMENT,S=a(r,h),b=r._malloc(_);o.GetAttributeDataArrayForAllPoints(l,d,S,_,b);const w=new h(r.HEAPF32.buffer,b,v).slice();return r._free(b),{name:c,array:w,itemSize:p}}function a(r,o){switch(o){case Float32Array:return r.DT_FLOAT32;case Int8Array:return r.DT_INT8;case Int16Array:return r.DT_INT16;case Int32Array:return r.DT_INT32;case Uint8Array:return r.DT_UINT8;case Uint16Array:return r.DT_UINT16;case Uint32Array:return r.DT_UINT32}}}let GC;const ZI=()=>{if(GC)return GC;const n="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),s=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let i=n;WebAssembly.validate(t)&&(i=e);let a;const r=WebAssembly.instantiate(o(i),{}).then(d=>{a=d.instance,a.exports.__wasm_call_ctors()});function o(d){const p=new Uint8Array(d.length);for(let v=0;v<d.length;++v){const _=d.charCodeAt(v);p[v]=_>96?_-71:_>64?_-65:_>47?_+4:_>46?63:62}let g=0;for(let v=0;v<d.length;++v)p[g++]=p[v]<60?s[p[v]]:(p[v]-60)*64+p[++v];return p.buffer.slice(0,g)}function l(d,p,g,v,_,S){const b=a.exports.sbrk,w=g+3&-4,T=b(w*v),E=b(_.length),R=new Uint8Array(a.exports.memory.buffer);R.set(_,E);const D=d(T,g,v,E,_.length);if(D===0&&S&&S(T,w,v),p.set(R.subarray(T,T+g*v)),b(T-b(0)),D!==0)throw new Error(`Malformed buffer data: ${D}`)}const c={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},h={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return GC={ready:r,supported:!0,decodeVertexBuffer(d,p,g,v,_){l(a.exports.meshopt_decodeVertexBuffer,d,p,g,v,a.exports[c[_]])},decodeIndexBuffer(d,p,g,v){l(a.exports.meshopt_decodeIndexBuffer,d,p,g,v)},decodeIndexSequence(d,p,g,v){l(a.exports.meshopt_decodeIndexSequence,d,p,g,v)},decodeGltfBuffer(d,p,g,v,_,S){l(a.exports[h[_]],d,p,g,v,a.exports[c[S]])}},GC},Dae=()=>parseInt(uy.replace(/\D+/g,"")),Oae=Dae();let VC=null,PV="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function zV(n=!0,e=!0,t){return s=>{t&&t(s),n&&(VC||(VC=new Rae),VC.setDecoderPath(typeof n=="string"?n:PV),s.setDRACOLoader(VC)),e&&s.setMeshoptDecoder(typeof ZI=="function"?ZI():ZI)}}const $S=(n,e,t,s)=>md(jO,n,zV(e,t,s));$S.preload=(n,e,t,s)=>md.preload(jO,n,zV(e,t,s));$S.clear=n=>md.clear(jO,n);$S.setDecoderPath=n=>{PV=n};function Bae(n,e,t){const s=sa(g=>g.size),i=sa(g=>g.viewport),a=typeof n=="number"?n:s.width*i.dpr,r=s.height*i.dpr,o=(typeof n=="number"?t:n)||{},{samples:l=0,depth:c,...h}=o,d=c??o.depthBuffer,p=pe.useMemo(()=>{const g=new Wr(a,r,{minFilter:is,magFilter:is,type:Wi,...h});return d&&(g.depthTexture=new OS(a,r,wi)),g.samples=l,g},[]);return pe.useLayoutEffect(()=>{p.setSize(a,r),l&&(p.samples=l)},[l,p,a,r]),pe.useEffect(()=>()=>p.dispose(),[]),p}const kae=n=>typeof n=="function",Lae=pe.forwardRef(({envMap:n,resolution:e=256,frames:t=1/0,makeDefault:s,children:i,...a},r)=>{const o=sa(({set:S})=>S),l=sa(({camera:S})=>S),c=sa(({size:S})=>S),h=pe.useRef(null);pe.useImperativeHandle(r,()=>h.current,[]);const d=pe.useRef(null),p=Bae(e);pe.useLayoutEffect(()=>{a.manual||(h.current.aspect=c.width/c.height)},[c,a]),pe.useLayoutEffect(()=>{h.current.updateProjectionMatrix()});let g=0,v=null;const _=kae(i);return D2(S=>{_&&(t===1/0||g<t)&&(d.current.visible=!1,S.gl.setRenderTarget(p),v=S.scene.background,n&&(S.scene.background=n),S.gl.render(S.scene,h.current),S.scene.background=v,S.gl.setRenderTarget(null),d.current.visible=!0,g++)}),pe.useLayoutEffect(()=>{if(s){const S=l;return o(()=>({camera:h.current})),()=>o(()=>({camera:S}))}},[h,s,o]),pe.createElement(pe.Fragment,null,pe.createElement("perspectiveCamera",Hx({ref:h},a),!_&&i),pe.createElement("group",{ref:d},_&&i(p.texture)))}),Fae=pe.forwardRef(({makeDefault:n,camera:e,regress:t,domElement:s,enableDamping:i=!0,keyEvents:a=!1,onChange:r,onStart:o,onEnd:l,...c},h)=>{const d=sa(D=>D.invalidate),p=sa(D=>D.camera),g=sa(D=>D.gl),v=sa(D=>D.events),_=sa(D=>D.setEvents),S=sa(D=>D.set),b=sa(D=>D.get),w=sa(D=>D.performance),T=e||p,E=s||v.connected||g.domElement,R=pe.useMemo(()=>new jie(T),[T]);return D2(()=>{R.enabled&&R.update()},-1),pe.useEffect(()=>(a&&R.connect(a===!0?E:a),R.connect(E),()=>void R.dispose()),[a,E,t,R,d]),pe.useEffect(()=>{const D=O=>{d(),t&&w.regress(),r&&r(O)},F=O=>{o&&o(O)},U=O=>{l&&l(O)};return R.addEventListener("change",D),R.addEventListener("start",F),R.addEventListener("end",U),()=>{R.removeEventListener("start",F),R.removeEventListener("end",U),R.removeEventListener("change",D)}},[r,o,l,R,d,_]),pe.useEffect(()=>{if(n){const D=b().controls;return S({controls:R}),()=>S({controls:D})}},[n,R]),pe.createElement("primitive",Hx({ref:h,object:R,enableDamping:i},c))});class Uae extends jr{constructor(e=new rt){super({uniforms:{inputBuffer:new Pr(null),depthBuffer:new Pr(null),resolution:new Pr(new rt),texelSize:new Pr(new rt),halfTexelSize:new Pr(new rt),kernel:new Pr(0),scale:new Pr(1),cameraNear:new Pr(0),cameraFar:new Pr(1),minDepthThreshold:new Pr(0),maxDepthThreshold:new Pr(1),depthScale:new Pr(0),depthToBlurRatioBias:new Pr(.25)},fragmentShader:`#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${Oae>=154?"colorspace_fragment":"encodings_fragment"}>
        }`,vertexShader:`uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,blending:ic,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class Pae{constructor({gl:e,resolution:t,width:s=500,height:i=500,minDepthThreshold:a=0,maxDepthThreshold:r=1,depthScale:o=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new Wr(t,t,{minFilter:is,magFilter:is,stencilBuffer:!1,depthBuffer:!1,type:Wi}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Uae,this.convolutionMaterial.setTexelSize(1/s,1/i),this.convolutionMaterial.setResolution(new rt(s,i)),this.scene=new dy,this.camera=new NS,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=r,this.convolutionMaterial.uniforms.depthScale.value=o,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=o>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),h=new Float32Array([0,0,2,0,0,2]),d=new Ln;d.setAttribute("position",new Es(c,3)),d.setAttribute("uv",new Es(h,2)),this.screen=new Ti(d,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,s){const i=this.scene,a=this.camera,r=this.renderTargetA,o=this.renderTargetB;let l=this.convolutionMaterial,c=l.uniforms;c.depthBuffer.value=t.depthTexture;const h=l.kernel;let d=t,p,g,v;for(g=0,v=h.length-1;g<v;++g)p=(g&1)===0?r:o,c.kernel.value=h[g],c.inputBuffer.value=d.texture,e.setRenderTarget(p),e.render(i,a),d=p;c.kernel.value=h[g],c.inputBuffer.value=d.texture,e.setRenderTarget(this.renderToScreen?null:s),e.render(i,a)}}let zae=class extends py{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;(t=e.defines)!=null&&t.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>",`#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`),e.fragmentShader=`
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>",`#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `)}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}};const $ae=pe.forwardRef(({mixBlur:n=0,mixStrength:e=1,resolution:t=256,blur:s=[0,0],minDepthThreshold:i=.9,maxDepthThreshold:a=1,depthScale:r=0,depthToBlurRatioBias:o=.25,mirror:l=0,distortion:c=1,mixContrast:h=1,distortionMap:d,reflectorOffset:p=0,...g},v)=>{VO({MeshReflectorMaterialImpl:zae});const _=sa(({gl:he})=>he),S=sa(({camera:he})=>he),b=sa(({scene:he})=>he);s=Array.isArray(s)?s:[s,s];const w=s[0]+s[1]>0,T=s[0],E=s[1],R=pe.useRef(null);pe.useImperativeHandle(v,()=>R.current,[]);const[D]=pe.useState(()=>new Vu),[F]=pe.useState(()=>new ue),[U]=pe.useState(()=>new ue),[O]=pe.useState(()=>new ue),[B]=pe.useState(()=>new _n),[L]=pe.useState(()=>new ue(0,0,-1)),[H]=pe.useState(()=>new Cs),[K]=pe.useState(()=>new ue),[Z]=pe.useState(()=>new ue),[Q]=pe.useState(()=>new Cs),[P]=pe.useState(()=>new _n),[W]=pe.useState(()=>new ki),q=pe.useCallback(()=>{var he;const me=R.current.parent||((he=R.current)==null||(he=he.__r3f.parent)==null?void 0:he.object);if(!me||(U.setFromMatrixPosition(me.matrixWorld),O.setFromMatrixPosition(S.matrixWorld),B.extractRotation(me.matrixWorld),F.set(0,0,1),F.applyMatrix4(B),U.addScaledVector(F,p),K.subVectors(U,O),K.dot(F)>0))return;K.reflect(F).negate(),K.add(U),B.extractRotation(S.matrixWorld),L.set(0,0,-1),L.applyMatrix4(B),L.add(O),Z.subVectors(U,L),Z.reflect(F).negate(),Z.add(U),W.position.copy(K),W.up.set(0,1,0),W.up.applyMatrix4(B),W.up.reflect(F),W.lookAt(Z),W.far=S.far,W.updateMatrixWorld(),W.projectionMatrix.copy(S.projectionMatrix),P.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),P.multiply(W.projectionMatrix),P.multiply(W.matrixWorldInverse),P.multiply(me.matrixWorld),D.setFromNormalAndCoplanarPoint(F,U),D.applyMatrix4(W.matrixWorldInverse),H.set(D.normal.x,D.normal.y,D.normal.z,D.constant);const Ne=W.projectionMatrix;Q.x=(Math.sign(H.x)+Ne.elements[8])/Ne.elements[0],Q.y=(Math.sign(H.y)+Ne.elements[9])/Ne.elements[5],Q.z=-1,Q.w=(1+Ne.elements[10])/Ne.elements[14],H.multiplyScalar(2/H.dot(Q)),Ne.elements[2]=H.x,Ne.elements[6]=H.y,Ne.elements[10]=H.z+1,Ne.elements[14]=H.w},[S,p]),[se,le,Y,re]=pe.useMemo(()=>{const he={minFilter:is,magFilter:is,type:Wi},me=new Wr(t,t,he);me.depthBuffer=!0,me.depthTexture=new OS(t,t),me.depthTexture.format=tg,me.depthTexture.type=eg;const Ne=new Wr(t,t,he),fe=new Pae({gl:_,resolution:t,width:T,height:E,minDepthThreshold:i,maxDepthThreshold:a,depthScale:r,depthToBlurRatioBias:o}),Te={mirror:l,textureMatrix:P,mixBlur:n,tDiffuse:me.texture,tDepth:me.depthTexture,tDiffuseBlur:Ne.texture,hasBlur:w,mixStrength:e,minDepthThreshold:i,maxDepthThreshold:a,depthScale:r,depthToBlurRatioBias:o,distortion:c,distortionMap:d,mixContrast:h,"defines-USE_BLUR":w?"":void 0,"defines-USE_DEPTH":r>0?"":void 0,"defines-USE_DISTORTION":d?"":void 0};return[me,Ne,fe,Te]},[_,T,E,P,t,l,w,n,e,i,a,r,o,c,d,h]);return D2(()=>{var he;const me=R.current.parent||((he=R.current)==null||(he=he.__r3f.parent)==null?void 0:he.object);if(!me)return;me.visible=!1;const Ne=_.xr.enabled,fe=_.shadowMap.autoUpdate;q(),_.xr.enabled=!1,_.shadowMap.autoUpdate=!1,_.setRenderTarget(se),_.state.buffers.depth.setMask(!0),_.autoClear||_.clear(),_.render(b,W),w&&Y.render(_,se,le),_.xr.enabled=Ne,_.shadowMap.autoUpdate=fe,me.visible=!0,_.setRenderTarget(null)}),pe.createElement("meshReflectorMaterialImpl",Hx({attach:"material",key:"key"+re["defines-USE_BLUR"]+re["defines-USE_DEPTH"]+re["defines-USE_DISTORTION"],ref:R},re,g))}),$V=(n,e,t)=>{let s;switch(n){case Co:s=new Uint8ClampedArray(e*t*4);break;case Wi:s=new Uint16Array(e*t*4);break;case rh:s=new Uint32Array(e*t*4);break;case e2:s=new Int8Array(e*t*4);break;case t2:s=new Int16Array(e*t*4);break;case TS:s=new Int32Array(e*t*4);break;case wi:s=new Float32Array(e*t*4);break;default:throw new Error("Unsupported data type")}return s};let HC;const Gae=(n,e,t,s)=>{if(HC!==void 0)return HC;const i=new Wr(1,1,s);e.setRenderTarget(i);const a=new Ti(new sp,new Yo({color:16777215}));e.render(a,t),e.setRenderTarget(null);const r=$V(n,i.width,i.height);return e.readRenderTargetPixels(i,0,0,i.width,i.height,r),i.dispose(),a.geometry.dispose(),a.material.dispose(),HC=r[0]!==0,HC};class XO{_renderer;_rendererIsDisposable=!1;_material;_scene;_camera;_quad;_renderTarget;_width;_height;_type;_colorSpace;_supportsReadPixels=!0;constructor(e){this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const t={format:ra,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:e.renderTargetOptions?.anisotropy!==void 0?e.renderTargetOptions?.anisotropy:1,generateMipmaps:e.renderTargetOptions?.generateMipmaps!==void 0?e.renderTargetOptions?.generateMipmaps:!1,magFilter:e.renderTargetOptions?.magFilter!==void 0?e.renderTargetOptions?.magFilter:is,minFilter:e.renderTargetOptions?.minFilter!==void 0?e.renderTargetOptions?.minFilter:is,samples:e.renderTargetOptions?.samples!==void 0?e.renderTargetOptions?.samples:void 0,wrapS:e.renderTargetOptions?.wrapS!==void 0?e.renderTargetOptions?.wrapS:Fi,wrapT:e.renderTargetOptions?.wrapT!==void 0?e.renderTargetOptions?.wrapT:Fi};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=XO.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new dy,this._camera=new Zu,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!Gae(this._type,this._renderer,this._camera,t)){let s;switch(this._type){case Wi:s=this._renderer.extensions.has("EXT_color_buffer_float")?wi:void 0;break}s!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${wi}`),this._type=s):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Ti(new sp,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new Wr(this.width,this.height,t),this._renderTarget.texture.mapping=e.renderTargetOptions?.mapping!==void 0?e.renderTargetOptions?.mapping:Ff}static instantiateRenderer(){const e=new FO;return e.setSize(128,128),e}render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(e){throw this._renderer.setRenderTarget(null),e}this._renderer.setRenderTarget(null)};toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=$V(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const t=new ac(this.toArray(),this.width,this.height,ra,this._type,e?.mapping||Ff,e?.wrapS||Fi,e?.wrapT||Fi,e?.magFilter||is,e?.minFilter||is,e?.anisotropy||1,Qc);return t.generateMipmaps=e?.generateMipmaps!==void 0?e?.generateMipmaps:!1,t}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof jr&&Object.values(this.material.uniforms).forEach(t=>{t.value instanceof Vs&&t.value.dispose()}),Object.values(this.material).forEach(t=>{t instanceof Vs&&t.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}class GV extends Error{}class VV extends Error{}const x1=(n,e,t)=>{const s=new RegExp(`${e}="([^"]*)"`,"i").exec(n);if(s)return s[1];const i=new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`,"i").exec(n);if(i){const a=i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return a&&a.length===3?a.map(r=>r.replace(/<\/?rdf:li>/g,"")):i[1].trim()}if(t!==void 0)return t;throw new Error(`Can't find ${e} in gainmap metadata`)},Vae=n=>{let e;typeof TextDecoder<"u"?e=new TextDecoder().decode(n):e=n.toString();let t=e.indexOf("<x:xmpmeta");for(;t!==-1;){const s=e.indexOf("x:xmpmeta>",t),i=e.slice(t,s+10);try{const a=x1(i,"hdrgm:GainMapMin","0"),r=x1(i,"hdrgm:GainMapMax"),o=x1(i,"hdrgm:Gamma","1"),l=x1(i,"hdrgm:OffsetSDR","0.015625"),c=x1(i,"hdrgm:OffsetHDR","0.015625"),h=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),d=h?h[1]:"0",p=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);if(!p)throw new Error("Incomplete gainmap metadata");const g=p[1];return{gainMapMin:Array.isArray(a)?a.map(v=>parseFloat(v)):[parseFloat(a),parseFloat(a),parseFloat(a)],gainMapMax:Array.isArray(r)?r.map(v=>parseFloat(v)):[parseFloat(r),parseFloat(r),parseFloat(r)],gamma:Array.isArray(o)?o.map(v=>parseFloat(v)):[parseFloat(o),parseFloat(o),parseFloat(o)],offsetSdr:Array.isArray(l)?l.map(v=>parseFloat(v)):[parseFloat(l),parseFloat(l),parseFloat(l)],offsetHdr:Array.isArray(c)?c.map(v=>parseFloat(v)):[parseFloat(c),parseFloat(c),parseFloat(c)],hdrCapacityMin:parseFloat(d),hdrCapacityMax:parseFloat(g)}}catch{}t=e.indexOf("<x:xmpmeta",s)}};class Hae{options;constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((t,s)=>{const i=this.options.debug,a=new DataView(e.buffer);if(a.getUint16(0)!==65496){s(new Error("Not a valid jpeg"));return}const r=a.byteLength;let o=2,l=0,c;for(;o<r;){if(++l>250){s(new Error(`Found no marker after ${l} loops `));return}if(a.getUint8(o)!==255){s(new Error(`Not a valid marker at offset 0x${o.toString(16)}, found: 0x${a.getUint8(o).toString(16)}`));return}if(c=a.getUint8(o+1),i&&console.log(`Marker: ${c.toString(16)}`),c===226){i&&console.log("Found APP2 marker (0xffe2)");const h=o+4;if(a.getUint32(h)===1297106432){const d=h+4;let p;if(a.getUint16(d)===18761)p=!1;else if(a.getUint16(d)===19789)p=!0;else{s(new Error("No valid endianness marker found in TIFF header"));return}if(a.getUint16(d+2,!p)!==42){s(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const g=a.getUint32(d+4,!p);if(g<8){s(new Error("Not valid TIFF data! (First offset less than 8)"));return}const v=d+g,_=a.getUint16(v,!p),S=v+2;let b=0;for(let R=S;R<S+12*_;R+=12)a.getUint16(R,!p)===45057&&(b=a.getUint32(R+8,!p));const T=v+2+_*12+4,E=[];for(let R=T;R<T+b*16;R+=16){const D={MPType:a.getUint32(R,!p),size:a.getUint32(R+4,!p),dataOffset:a.getUint32(R+8,!p),dependantImages:a.getUint32(R+12,!p),start:-1,end:-1,isFII:!1};D.dataOffset?(D.start=d+D.dataOffset,D.isFII=!1):(D.start=0,D.isFII=!0),D.end=D.start+D.size,E.push(D)}if(this.options.extractNonFII&&E.length){const R=new Blob([a]),D=[];for(const F of E){if(F.isFII&&!this.options.extractFII)continue;const U=R.slice(F.start,F.end+1,"image/jpeg");D.push(U)}t(D)}}}o+=2+a.getUint16(o+2)}})}}const Wae=async n=>{const e=Vae(n);if(!e)throw new VV("Gain map XMP metadata not found");const s=await new Hae({extractFII:!0,extractNonFII:!0}).extract(n);if(s.length!==2)throw new GV("Gain map recovery image not found");return{sdr:new Uint8Array(await s[0].arrayBuffer()),gainMap:new Uint8Array(await s[1].arrayBuffer()),metadata:e}},oz=n=>new Promise((e,t)=>{const s=document.createElement("img");s.onload=()=>{e(s)},s.onerror=i=>{t(i)},s.src=URL.createObjectURL(n)});class jae extends br{_renderer;_renderTargetOptions;_internalLoadingManager;_config;constructor(e,t){super(t),this._config=e,e.renderer&&(this._renderer=e.renderer),this._internalLoadingManager=new M2}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=this._config.createMaterial({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new Vs,sdr:new Vs});return this._config.createQuadRenderer({width:16,height:16,type:Wi,colorSpace:Qc,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async processImages(e,t,s){const i=t?new Blob([t],{type:"image/jpeg"}):void 0,a=new Blob([e],{type:"image/jpeg"});let r,o,l=!1;if(typeof createImageBitmap>"u"){const c=await Promise.all([i?oz(i):Promise.resolve(void 0),oz(a)]);o=c[0],r=c[1],l=s==="flipY"}else{const c=await Promise.all([i?createImageBitmap(i,{imageOrientation:s||"flipY"}):Promise.resolve(void 0),createImageBitmap(a,{imageOrientation:s||"flipY"})]);o=c[0],r=c[1]}return{sdrImage:r,gainMapImage:o,needsFlip:l}}createTextures(e,t,s){const i=new Vs(t||new ImageData(2,2),Ff,Fi,Fi,is,M3,ra,Co,1,Qc);i.flipY=s,i.needsUpdate=!0;const a=new Vs(e,Ff,Fi,Fi,is,M3,ra,Co,1,mr);return a.flipY=s,a.needsUpdate=!0,{gainMap:i,sdr:a}}updateQuadRenderer(e,t,s,i,a){e.width=t.width,e.height=t.height,e.material.gainMap=s,e.material.sdr=i,e.material.gainMapMin=a.gainMapMin,e.material.gainMapMax=a.gainMapMax,e.material.offsetHdr=a.offsetHdr,e.material.offsetSdr=a.offsetSdr,e.material.gamma=a.gamma,e.material.hdrCapacityMin=a.hdrCapacityMin,e.material.hdrCapacityMax=a.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,a.hdrCapacityMax),e.material.needsUpdate=!0}}const Xae=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,qae=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class Kae extends jr{_maxDisplayBoost;_hdrCapacityMin;_hdrCapacityMax;constructor({gamma:e,offsetHdr:t,offsetSdr:s,gainMapMin:i,gainMapMax:a,maxDisplayBoost:r,hdrCapacityMin:o,hdrCapacityMax:l,sdr:c,gainMap:h}){super({name:"GainMapDecoderMaterial",vertexShader:Xae,fragmentShader:qae,uniforms:{sdr:{value:c},gainMap:{value:h},gamma:{value:new ue(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new ue().fromArray(t)},offsetSdr:{value:new ue().fromArray(s)},gainMapMin:{value:new ue().fromArray(i)},gainMapMax:{value:new ue().fromArray(a)},weightFactor:{value:(Math.log2(r)-o)/(l-o)}},blending:ic,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=r,this._hdrCapacityMin=o,this._hdrCapacityMax=l,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const t=this.uniforms.gamma.value;t.x=1/e[0],t.y=1/e[1],t.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class HV extends jae{constructor(e,t){super({renderer:e,createMaterial:s=>new Kae(s),createQuadRenderer:s=>new XO(s)},t)}async render(e,t,s,i){const{sdrImage:a,gainMapImage:r,needsFlip:o}=await this.processImages(s,i,"flipY"),{gainMap:l,sdr:c}=this.createTextures(a,r,o);this.updateQuadRenderer(e,a,l,c,t),e.render()}}class Yae extends HV{load([e,t,s],i,a,r){const o=this.prepareQuadRenderer();let l,c,h;const d=async()=>{if(l&&c&&h){try{await this.render(o,h,l,c)}catch(O){this.manager.itemError(e),this.manager.itemError(t),this.manager.itemError(s),typeof r=="function"&&r(O),o.disposeOnDemandRenderer();return}typeof i=="function"&&i(o),this.manager.itemEnd(e),this.manager.itemEnd(t),this.manager.itemEnd(s),o.disposeOnDemandRenderer()}};let p=!0,g=0,v=0,_=!0,S=0,b=0,w=!0,T=0,E=0;const R=()=>{if(typeof a=="function"){const O=g+S+T,B=v+b+E,L=p&&_&&w;a(new ProgressEvent("progress",{lengthComputable:L,loaded:B,total:O}))}};this.manager.itemStart(e),this.manager.itemStart(t),this.manager.itemStart(s);const D=new vr(this._internalLoadingManager);D.setResponseType("arraybuffer"),D.setRequestHeader(this.requestHeader),D.setPath(this.path),D.setWithCredentials(this.withCredentials),D.load(e,async O=>{if(typeof O=="string")throw new Error("Invalid sdr buffer");l=O,await d()},O=>{p=O.lengthComputable,v=O.loaded,g=O.total,R()},O=>{this.manager.itemError(e),typeof r=="function"&&r(O)});const F=new vr(this._internalLoadingManager);F.setResponseType("arraybuffer"),F.setRequestHeader(this.requestHeader),F.setPath(this.path),F.setWithCredentials(this.withCredentials),F.load(t,async O=>{if(typeof O=="string")throw new Error("Invalid gainmap buffer");c=O,await d()},O=>{_=O.lengthComputable,b=O.loaded,S=O.total,R()},O=>{this.manager.itemError(t),typeof r=="function"&&r(O)});const U=new vr(this._internalLoadingManager);return U.setRequestHeader(this.requestHeader),U.setPath(this.path),U.setWithCredentials(this.withCredentials),U.load(s,async O=>{if(typeof O!="string")throw new Error("Invalid metadata string");h=JSON.parse(O),await d()},O=>{w=O.lengthComputable,E=O.loaded,T=O.total,R()},O=>{this.manager.itemError(s),typeof r=="function"&&r(O)}),o}}class Jae extends HV{load(e,t,s,i){const a=this.prepareQuadRenderer(),r=new vr(this._internalLoadingManager);return r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setPath(this.path),r.setWithCredentials(this.withCredentials),this.manager.itemStart(e),r.load(e,async o=>{if(typeof o=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const l=new Uint8Array(o);let c,h,d;try{const p=await Wae(l);c=p.sdr,h=p.gainMap,d=p.metadata}catch(p){if(p instanceof VV||p instanceof GV)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),d={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},c=l;else throw p}try{await this.render(a,d,c.buffer,h?.buffer)}catch(p){this.manager.itemError(e),typeof i=="function"&&i(p),a.disposeOnDemandRenderer();return}typeof t=="function"&&t(a),this.manager.itemEnd(e),a.disposeOnDemandRenderer()},s,o=>{this.manager.itemError(e),typeof i=="function"&&i(o)}),a}}const tS={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},WV="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",wx=n=>Array.isArray(n),qO=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function B2({files:n=qO,path:e="",preset:t=void 0,colorSpace:s=void 0,extensions:i}={}){t&&(KO(t),n=tS[t],e=WV);const a=wx(n),{extension:r,isCubemap:o}=YO(n),l=JO(r);if(!l)throw new Error("useEnvironment: Unrecognized file extension: "+n);const c=sa(g=>g.gl);pe.useLayoutEffect(()=>{if(r!=="webp"&&r!=="jpg"&&r!=="jpeg")return;function g(){md.clear(l,a?[n]:n)}c.domElement.addEventListener("webglcontextlost",g,{once:!0})},[n,c.domElement]);const h=md(l,a?[n]:n,g=>{(r==="webp"||r==="jpg"||r==="jpeg")&&g.setRenderer(c),g.setPath==null||g.setPath(e),i&&i(g)});let d=a?h[0]:h;if(r==="jpg"||r==="jpeg"||r==="webp"){var p;d=(p=d.renderTarget)==null?void 0:p.texture}return d.mapping=o?ah:Rx,d.colorSpace=s??(o?"srgb":"srgb-linear"),d}const Zae={files:qO,path:"",preset:void 0,extensions:void 0};B2.preload=n=>{const e={...Zae,...n};let{files:t,path:s=""}=e;const{preset:i,extensions:a}=e;i&&(KO(i),t=tS[i],s=WV);const{extension:r}=YO(t);if(r==="webp"||r==="jpg"||r==="jpeg")throw new Error("useEnvironment: Preloading gainmaps is not supported");const o=JO(r);if(!o)throw new Error("useEnvironment: Unrecognized file extension: "+t);md.preload(o,wx(t)?[t]:t,l=>{l.setPath==null||l.setPath(s),a&&a(l)})};const Qae={files:qO,preset:void 0};B2.clear=n=>{const e={...Qae,...n};let{files:t}=e;const{preset:s}=e;s&&(KO(s),t=tS[s]);const{extension:i}=YO(t),a=JO(i);if(!a)throw new Error("useEnvironment: Unrecognized file extension: "+t);md.clear(a,wx(t)?[t]:t)};function KO(n){if(!(n in tS))throw new Error("Preset must be one of: "+Object.keys(tS).join(", "))}function YO(n){var e;const t=wx(n)&&n.length===6,s=wx(n)&&n.length===3&&n.some(r=>r.endsWith("json")),i=wx(n)?n[0]:n;return{extension:t?"cube":s?"webp":i.startsWith("data:application/exr")?"exr":i.startsWith("data:application/hdr")?"hdr":i.startsWith("data:image/jpeg")?"jpg":(e=i.split(".").pop())==null||(e=e.split("?"))==null||(e=e.shift())==null?void 0:e.toLowerCase(),isCubemap:t,isGainmap:s}}function JO(n){return n==="cube"?HG:n==="hdr"?Mae:n==="exr"?Nae:n==="jpg"||n==="jpeg"?Jae:n==="webp"?Yae:null}const ere=n=>n.current&&n.current.isScene,tre=n=>ere(n)?n.current:n;function ZO(n,e,t,s,i={}){var a,r,o,l;i={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...i};const c=tre(e||t),h=c.background,d=c.environment,p={backgroundBlurriness:c.backgroundBlurriness,backgroundIntensity:c.backgroundIntensity,backgroundRotation:(a=(r=c.backgroundRotation)==null||r.clone==null?void 0:r.clone())!==null&&a!==void 0?a:[0,0,0],environmentIntensity:c.environmentIntensity,environmentRotation:(o=(l=c.environmentRotation)==null||l.clone==null?void 0:l.clone())!==null&&o!==void 0?o:[0,0,0]};return n!=="only"&&(c.environment=s),n&&(c.background=s),Xu(c,i),()=>{n!=="only"&&(c.environment=d),n&&(c.background=h),Xu(c,p)}}function QO({scene:n,background:e=!1,map:t,...s}){const i=sa(a=>a.scene);return pe.useLayoutEffect(()=>{if(t)return ZO(e,n,i,t,s)}),null}function jV({background:n=!1,scene:e,blur:t,backgroundBlurriness:s,backgroundIntensity:i,backgroundRotation:a,environmentIntensity:r,environmentRotation:o,...l}){const c=B2(l),h=sa(d=>d.scene);return pe.useLayoutEffect(()=>ZO(n,e,h,c,{backgroundBlurriness:t??s,backgroundIntensity:i,backgroundRotation:a,environmentIntensity:r,environmentRotation:o})),pe.useEffect(()=>()=>{c.dispose()},[c]),null}function nre({children:n,near:e=.1,far:t=1e3,resolution:s=256,frames:i=1,map:a,background:r=!1,blur:o,backgroundBlurriness:l,backgroundIntensity:c,backgroundRotation:h,environmentIntensity:d,environmentRotation:p,scene:g,files:v,path:_,preset:S=void 0,extensions:b}){const w=sa(U=>U.gl),T=sa(U=>U.scene),E=pe.useRef(null),[R]=pe.useState(()=>new dy),D=pe.useMemo(()=>{const U=new lO(s);return U.texture.type=Wi,U},[s]);pe.useEffect(()=>()=>{D.dispose()},[D]),pe.useLayoutEffect(()=>{if(i===1){const U=w.autoClear;w.autoClear=!0,E.current.update(w,R),w.autoClear=U}return ZO(r,g,T,D.texture,{backgroundBlurriness:o??l,backgroundIntensity:c,backgroundRotation:h,environmentIntensity:d,environmentRotation:p})},[n,R,D.texture,g,T,r,i,w]);let F=1;return D2(()=>{if(i===1/0||F<i){const U=w.autoClear;w.autoClear=!0,E.current.update(w,R),w.autoClear=U,F++}}),pe.createElement(pe.Fragment,null,hie(pe.createElement(pe.Fragment,null,n,pe.createElement("cubeCamera",{ref:E,args:[e,t,D]}),v||S?pe.createElement(jV,{background:!0,files:v,preset:S,path:_,extensions:b}):a?pe.createElement(QO,{background:!0,map:a,extensions:b}):null),R))}function sre(n){var e,t,s,i;const a=B2(n),r=n.map||a;pe.useMemo(()=>VO({GroundProjectedEnvImpl:Uie}),[]),pe.useEffect(()=>()=>{a.dispose()},[a]);const o=pe.useMemo(()=>[r],[r]),l=(e=n.ground)==null?void 0:e.height,c=(t=n.ground)==null?void 0:t.radius,h=(s=(i=n.ground)==null?void 0:i.scale)!==null&&s!==void 0?s:1e3;return pe.createElement(pe.Fragment,null,pe.createElement(QO,Hx({},n,{map:r})),pe.createElement("groundProjectedEnvImpl",{args:o,scale:h,height:l,radius:c}))}function ire(n){return n.ground?pe.createElement(sre,n):n.map?pe.createElement(QO,n):n.children?pe.createElement(nre,n):pe.createElement(jV,n)}function are(){return V.jsxs("mesh",{rotation:[-Math.PI/2,0,0],position:[0,-1.5,0],receiveShadow:!0,children:[V.jsx("planeGeometry",{args:[10,10]}),V.jsx($ae,{blur:[300,100],resolution:2048,mixBlur:1,mixStrength:50,depthScale:1.2,minDepthThreshold:.4,maxDepthThreshold:1.4,color:"#1a1a2e",metalness:.8,roughness:1})]})}function rre(){return V.jsx("mesh",{rotation:[Math.PI/2,0,0],position:[-2,-1.45,-3],children:V.jsx("gridHelper",{args:[10,10,"#4cc9f0","#1a1a2e"]})})}function ore({modelScale:n,modelRotation:e,modelPosition:t}){const s="/Robotics_Portfolio/models/Sonny.glb",{scene:i}=$S(s);return V.jsx("primitive",{object:i,scale:n,rotation:[e.x,e.y,e.z],position:[t.x,t.y,t.z]})}function lre({viewerSettings:n,modelScale:e,modelRotation:t,modelPosition:s}){return V.jsxs(Aie,{shadows:n.showShadows,children:[V.jsx("color",{attach:"background",args:[n.backgroundColor]}),V.jsx(Lae,{makeDefault:!0,position:[5,3,5],fov:60}),V.jsx(Fae,{enablePan:!0,enableZoom:!0,enableRotate:!0,maxDistance:20,minDistance:2}),V.jsx("ambientLight",{intensity:n.ambientLightIntensity}),V.jsx("directionalLight",{castShadow:n.showShadows,position:[5,5,5],intensity:n.directionalLightIntensity}),n.showReflections&&V.jsx(ire,{preset:"city"}),V.jsx(are,{}),n.showGrid&&V.jsx(rre,{}),V.jsx(pe.Suspense,{fallback:null,children:V.jsx(ore,{modelScale:e,modelRotation:t,modelPosition:s})}),n.showAxes&&V.jsx("axesHelper",{args:[3]})]})}$S.preload("/Robotics_Portfolio/models/Sonny.glb");function XV(){const n=ly();return V.jsx("button",{className:"back-btn-top",onClick:()=>n("/control-hub"),children:" Control Hub"})}function qV(){const n=pe.useRef(null),[e,t]=pe.useState("Sonny.glb"),[s,i]=pe.useState({showGrid:!0,showShadows:!0,showAxes:!1,showReflections:!1,wireframe:!1,ambientLightIntensity:.4,directionalLightIntensity:1,backgroundColor:"#000000"}),[a,r]=pe.useState(3),[o,l]=pe.useState({x:0,y:25,z:0}),[c,h]=pe.useState({x:0,y:-1.4,z:0}),[d,p]=pe.useState("transform"),g=S=>{t(S.name),console.log("Importing model:",S.name)},v=S=>{i(b=>({...b,[S]:!b[S]}))},_=()=>{r(3),l({x:0,y:25,z:0}),h({x:0,y:-1.4,z:0}),i(S=>({...S,backgroundColor:"#000000"}))};return V.jsxs("div",{className:"virtual-model-top",children:[V.jsxs("div",{className:"vm-header-top",children:[V.jsx(XV,{}),V.jsxs("div",{className:"header-center-top",children:[V.jsx("h1",{children:"VIRTUAL MODEL"}),V.jsx("p",{className:"model-name-display-top",children:e})]}),V.jsx("button",{className:"reset-btn-top",onClick:_,children:"Reset All"})]}),V.jsxs("div",{className:"main-viewer-section",children:[V.jsx("div",{className:"viewer-container-top",children:V.jsx(lre,{viewerSettings:s,modelScale:a,modelRotation:o,modelPosition:c})}),V.jsx("div",{className:"viewer-stats-top",children:V.jsxs("div",{className:"stats-grid",children:[V.jsxs("div",{className:"stat-card",children:[V.jsx("span",{className:"stat-label-top",children:"SCALE"}),V.jsx("span",{className:"stat-value-top",children:a.toFixed(2)})]}),V.jsxs("div",{className:"stat-card",children:[V.jsx("span",{className:"stat-label-top",children:"ROTATION"}),V.jsxs("span",{className:"stat-value-top",children:["X: ",o.x," | Y: ",o.y," | Z: ",o.z,""]})]}),V.jsxs("div",{className:"stat-card",children:[V.jsx("span",{className:"stat-label-top",children:"POSITION"}),V.jsxs("span",{className:"stat-value-top",children:["X: ",c.x.toFixed(2)," | Y: ",c.y.toFixed(2)," | Z: ",c.z.toFixed(2)]})]})]})})]}),V.jsxs("div",{className:"vm-layout-top",children:[V.jsxs("div",{className:"vm-controls-top",children:[V.jsxs("div",{className:"control-tabs-top",children:[V.jsxs("button",{className:`tab-btn-top ${d==="transform"?"active":""}`,onClick:()=>p("transform"),children:[V.jsx("span",{className:"tab-icon",children:""}),V.jsx("span",{children:"Transform"})]}),V.jsxs("button",{className:`tab-btn-top ${d==="display"?"active":""}`,onClick:()=>p("display"),children:[V.jsx("span",{className:"tab-icon",children:""}),V.jsx("span",{children:"Display"})]}),V.jsxs("button",{className:`tab-btn-top ${d==="lighting"?"active":""}`,onClick:()=>p("lighting"),children:[V.jsx("span",{className:"tab-icon",children:""}),V.jsx("span",{children:"Lighting"})]})]}),V.jsxs("div",{className:"tab-content-top",children:[d==="transform"&&V.jsx("div",{className:"tab-panel-top",children:V.jsxs("div",{className:"control-section",children:[V.jsx("h4",{children:"Model Transform"}),V.jsx("div",{className:"control-group-top",children:V.jsxs("div",{className:"slider-control",children:[V.jsxs("div",{className:"slider-header",children:[V.jsx("label",{children:"Scale"}),V.jsx("span",{className:"slider-value",children:a.toFixed(1)})]}),V.jsx("input",{type:"range",min:"0.1",max:"10",step:"0.1",value:a,onChange:S=>r(parseFloat(S.target.value))})]})}),V.jsxs("div",{className:"control-group-top",children:[V.jsx("h5",{children:"Position"}),V.jsxs("div",{className:"vector-controls-top",children:[V.jsxs("div",{className:"axis-control",children:[V.jsx("span",{className:"axis-label",children:"X"}),V.jsx("input",{type:"range",min:"-5",max:"5",step:"0.1",value:c.x,onChange:S=>h(b=>({...b,x:parseFloat(S.target.value)}))}),V.jsx("span",{className:"axis-value",children:c.x.toFixed(1)})]}),V.jsxs("div",{className:"axis-control",children:[V.jsx("span",{className:"axis-label",children:"Y"}),V.jsx("input",{type:"range",min:"-3",max:"3",step:"0.1",value:c.y,onChange:S=>h(b=>({...b,y:parseFloat(S.target.value)}))}),V.jsx("span",{className:"axis-value",children:c.y.toFixed(1)})]}),V.jsxs("div",{className:"axis-control",children:[V.jsx("span",{className:"axis-label",children:"Z"}),V.jsx("input",{type:"range",min:"-5",max:"5",step:"0.1",value:c.z,onChange:S=>h(b=>({...b,z:parseFloat(S.target.value)}))}),V.jsx("span",{className:"axis-value",children:c.z.toFixed(1)})]})]})]}),V.jsxs("div",{className:"control-group-top",children:[V.jsx("h5",{children:"Rotation"}),V.jsxs("div",{className:"vector-controls-top",children:[V.jsxs("div",{className:"axis-control",children:[V.jsx("span",{className:"axis-label",children:"X"}),V.jsx("input",{type:"range",min:"-180",max:"180",step:"1",value:o.x,onChange:S=>l(b=>({...b,x:parseInt(S.target.value)}))}),V.jsxs("span",{className:"axis-value",children:[o.x,""]})]}),V.jsxs("div",{className:"axis-control",children:[V.jsx("span",{className:"axis-label",children:"Y"}),V.jsx("input",{type:"range",min:"-180",max:"180",step:"1",value:o.y,onChange:S=>l(b=>({...b,y:parseInt(S.target.value)}))}),V.jsxs("span",{className:"axis-value",children:[o.y,""]})]}),V.jsxs("div",{className:"axis-control",children:[V.jsx("span",{className:"axis-label",children:"Z"}),V.jsx("input",{type:"range",min:"-180",max:"180",step:"1",value:o.z,onChange:S=>l(b=>({...b,z:parseInt(S.target.value)}))}),V.jsxs("span",{className:"axis-value",children:[o.z,""]})]})]})]}),V.jsxs("div",{className:"model-import-section",children:[V.jsx("button",{className:"import-btn-top",onClick:()=>n.current?.click(),children:"Import 3D Model"}),V.jsx("input",{ref:n,type:"file",onChange:S=>{const b=S.target.files?.[0];b&&g(b)},accept:".glb,.gltf,.obj,.fbx,.stl",style:{display:"none"}}),V.jsx("p",{className:"file-hint",children:"Supports: .glb, .gltf, .obj, .fbx, .stl"})]})]})}),d==="display"&&V.jsx("div",{className:"tab-panel-top",children:V.jsxs("div",{className:"control-section",children:[V.jsx("h4",{children:"Visual Settings"}),V.jsxs("div",{className:"toggle-grid-top",children:[V.jsxs("label",{className:"toggle-item-top",children:[V.jsx("input",{type:"checkbox",checked:s.showGrid,onChange:()=>v("showGrid")}),V.jsx("span",{children:"Show Grid"})]}),V.jsxs("label",{className:"toggle-item-top",children:[V.jsx("input",{type:"checkbox",checked:s.showShadows,onChange:()=>v("showShadows")}),V.jsx("span",{children:"Show Shadows"})]}),V.jsxs("label",{className:"toggle-item-top",children:[V.jsx("input",{type:"checkbox",checked:s.showAxes,onChange:()=>v("showAxes")}),V.jsx("span",{children:"Show Axes"})]}),V.jsxs("label",{className:"toggle-item-top",children:[V.jsx("input",{type:"checkbox",checked:s.showReflections,onChange:()=>v("showReflections")}),V.jsx("span",{children:"Show Reflections"})]}),V.jsxs("label",{className:"toggle-item-top",children:[V.jsx("input",{type:"checkbox",checked:s.wireframe,onChange:()=>v("wireframe")}),V.jsx("span",{children:"Wireframe Mode"})]})]})]})}),d==="lighting"&&V.jsx("div",{className:"tab-panel-top",children:V.jsxs("div",{className:"control-section",children:[V.jsx("h4",{children:"Lighting & Environment"}),V.jsx("div",{className:"control-group-top",children:V.jsxs("div",{className:"slider-control",children:[V.jsxs("div",{className:"slider-header",children:[V.jsx("label",{children:"Ambient Light"}),V.jsx("span",{className:"slider-value",children:s.ambientLightIntensity.toFixed(1)})]}),V.jsx("input",{type:"range",min:"0",max:"2",step:"0.1",value:s.ambientLightIntensity,onChange:S=>i(b=>({...b,ambientLightIntensity:parseFloat(S.target.value)}))})]})}),V.jsx("div",{className:"control-group-top",children:V.jsxs("div",{className:"slider-control",children:[V.jsxs("div",{className:"slider-header",children:[V.jsx("label",{children:"Directional Light"}),V.jsx("span",{className:"slider-value",children:s.directionalLightIntensity.toFixed(1)})]}),V.jsx("input",{type:"range",min:"0",max:"5",step:"0.1",value:s.directionalLightIntensity,onChange:S=>i(b=>({...b,directionalLightIntensity:parseFloat(S.target.value)}))})]})}),V.jsxs("div",{className:"color-picker-top",children:[V.jsx("label",{children:"Background Color"}),V.jsxs("div",{className:"color-picker-row-top",children:[V.jsx("input",{type:"color",value:s.backgroundColor,onChange:S=>i(b=>({...b,backgroundColor:S.target.value})),className:"color-input-top"}),V.jsx("span",{className:"color-value-top",children:s.backgroundColor})]})]})]})})]})]}),V.jsxs("div",{className:"vm-guide-top",children:[V.jsxs("div",{className:"guide-section",children:[V.jsx("h3",{children:"Controls Guide"}),V.jsxs("div",{className:"guide-content",children:[V.jsxs("div",{className:"guide-item",children:[V.jsx("span",{className:"guide-icon",children:""}),V.jsxs("div",{children:[V.jsx("strong",{children:"Orbit:"})," Left-click + drag to rotate view"]})]}),V.jsxs("div",{className:"guide-item",children:[V.jsx("span",{className:"guide-icon",children:""}),V.jsxs("div",{children:[V.jsx("strong",{children:"Zoom:"})," Scroll wheel or pinch gesture"]})]}),V.jsxs("div",{className:"guide-item",children:[V.jsx("span",{className:"guide-icon",children:""}),V.jsxs("div",{children:[V.jsx("strong",{children:"Pan:"})," Right-click + drag or middle-click + drag"]})]}),V.jsxs("div",{className:"guide-item",children:[V.jsx("span",{className:"guide-icon",children:""}),V.jsxs("div",{children:[V.jsx("strong",{children:"Reset View:"}),' Double-click the "Reset All" button']})]})]})]}),V.jsxs("div",{className:"guide-section",children:[V.jsx("h3",{children:"Quick Tips"}),V.jsxs("ul",{className:"tips-list",children:[V.jsxs("li",{children:["Use the ",V.jsx("strong",{children:"Transform tab"})," to position and rotate your model"]}),V.jsxs("li",{children:["Toggle ",V.jsx("strong",{children:"Wireframe mode"})," to see the model's structure"]}),V.jsxs("li",{children:["Adjust ",V.jsx("strong",{children:"lighting"})," to highlight different details"]}),V.jsx("li",{children:"Import your own 3D models using the import button"})]})]}),V.jsxs("div",{className:"current-settings",children:[V.jsx("h3",{children:"Current Settings"}),V.jsxs("div",{className:"settings-list",children:[V.jsxs("div",{className:"setting-item",children:[V.jsx("span",{children:"Model:"}),V.jsx("span",{children:e})]}),V.jsxs("div",{className:"setting-item",children:[V.jsx("span",{children:"Background:"}),V.jsx("span",{style:{color:s.backgroundColor},children:s.backgroundColor})]}),V.jsxs("div",{className:"setting-item",children:[V.jsx("span",{children:"Grid:"}),V.jsx("span",{children:s.showGrid?"Visible":"Hidden"})]}),V.jsxs("div",{className:"setting-item",children:[V.jsx("span",{children:"Shadows:"}),V.jsx("span",{children:s.showShadows?"Enabled":"Disabled"})]})]})]})]})]})]})}const QI={headTurn:0,headTilt:0,leftShoulder:10,leftElbow:60,rightShoulder:10,rightElbow:60,leftHand:0,rightHand:0};function KV(){const[n,e]=pe.useState({...QI}),[t,s]=pe.useState("head"),i={rest:{headTurn:0,headTilt:0,leftShoulder:5,leftElbow:20,rightShoulder:5,rightElbow:20,leftHand:0,rightHand:0},wave:{headTurn:10,headTilt:0,leftShoulder:40,leftElbow:20,rightShoulder:5,rightElbow:20,leftHand:30},salute:{headTurn:0,headTilt:-10,rightShoulder:60,rightElbow:10,leftShoulder:5,leftElbow:20},point:{headTurn:15,headTilt:0,rightShoulder:30,rightElbow:10,rightHand:10},tpose:{headTurn:0,headTilt:0,leftShoulder:90,rightShoulder:-90,leftElbow:0,rightElbow:0}},a=l=>{const c=i[l];c&&(e(h=>({...h,...c})),r(c,{preset:l}))},r=(l=n,c={})=>{const h={source:"MovementModule",pose:l,meta:c,timestamp:Date.now()};window.dispatchEvent(new CustomEvent("robot:pose",{detail:h}))},o=(l,c)=>{e(h=>({...h,[l]:c}))};return V.jsxs("div",{className:"movement-module",children:[V.jsx("h2",{className:"mm-title",children:"Advanced Robotics Panel"}),V.jsxs("div",{className:"mm-topbar",children:[V.jsxs("div",{className:"tabs",children:[V.jsx("button",{className:t==="head"?"active":"",onClick:()=>s("head"),children:"Head"}),V.jsx("button",{className:t==="left"?"active":"",onClick:()=>s("left"),children:"Left Arm"}),V.jsx("button",{className:t==="right"?"active":"",onClick:()=>s("right"),children:"Right Arm"}),V.jsx("button",{className:t==="hands"?"active":"",onClick:()=>s("hands"),children:"Hands"}),V.jsx("button",{className:t==="presets"?"active":"",onClick:()=>s("presets"),children:"Presets"})]}),V.jsxs("div",{className:"mm-actions",children:[V.jsx("button",{className:"btn",onClick:()=>r(),children:"Send Pose"}),V.jsx("button",{className:"btn ghost",onClick:()=>{e({...QI}),r(QI,{preset:"reset"})},children:"Reset"})]})]}),V.jsxs("div",{className:"mm-body",children:[t==="head"&&V.jsxs("div",{className:"panel",children:[V.jsxs("label",{children:["Head Turn (Y) ",Math.round(n.headTurn??0),""]}),V.jsx("input",{type:"range",min:-90,max:90,value:n.headTurn??0,onChange:l=>o("headTurn",parseInt(l.target.value))}),V.jsxs("label",{children:["Head Tilt (X) ",Math.round(n.headTilt??0),""]}),V.jsx("input",{type:"range",min:-45,max:45,value:n.headTilt??0,onChange:l=>o("headTilt",parseInt(l.target.value))}),V.jsxs("div",{className:"quick-actions",children:[V.jsx("button",{onClick:()=>r({headTurn:0,headTilt:0},{action:"center_head"}),children:"Center"}),V.jsx("button",{onClick:()=>r({headTurn:30},{action:"look_right"}),children:"Look Right"}),V.jsx("button",{onClick:()=>r({headTurn:-30},{action:"look_left"}),children:"Look Left"})]})]}),t==="left"&&V.jsxs("div",{className:"panel",children:[V.jsxs("label",{children:["Left Shoulder ",Math.round(n.leftShoulder??0),""]}),V.jsx("input",{type:"range",min:-10,max:180,value:n.leftShoulder??0,onChange:l=>o("leftShoulder",parseInt(l.target.value))}),V.jsxs("label",{children:["Left Elbow ",Math.round(n.leftElbow??0),""]}),V.jsx("input",{type:"range",min:0,max:180,value:n.leftElbow??0,onChange:l=>o("leftElbow",parseInt(l.target.value))}),V.jsx("div",{className:"quick-actions",children:V.jsx("button",{onClick:()=>r({leftShoulder:40,leftElbow:20},{action:"left_wave"}),children:"Wave Prep"})})]}),t==="right"&&V.jsxs("div",{className:"panel",children:[V.jsxs("label",{children:["Right Shoulder ",Math.round(n.rightShoulder??0),""]}),V.jsx("input",{type:"range",min:-10,max:180,value:n.rightShoulder??0,onChange:l=>o("rightShoulder",parseInt(l.target.value))}),V.jsxs("label",{children:["Right Elbow ",Math.round(n.rightElbow??0),""]}),V.jsx("input",{type:"range",min:0,max:180,value:n.rightElbow??0,onChange:l=>o("rightElbow",parseInt(l.target.value))}),V.jsx("div",{className:"quick-actions",children:V.jsx("button",{onClick:()=>r({rightShoulder:60,rightElbow:10},{action:"salute"}),children:"Salute"})})]}),t==="hands"&&V.jsxs("div",{className:"panel",children:[V.jsxs("label",{children:["Left Hand Grip ",Math.round(n.leftHand??0),"%"]}),V.jsx("input",{type:"range",min:0,max:100,value:n.leftHand??0,onChange:l=>o("leftHand",parseInt(l.target.value))}),V.jsxs("label",{children:["Right Hand Grip ",Math.round(n.rightHand??0),"%"]}),V.jsx("input",{type:"range",min:0,max:100,value:n.rightHand??0,onChange:l=>o("rightHand",parseInt(l.target.value))}),V.jsxs("div",{className:"quick-actions",children:[V.jsx("button",{onClick:()=>r({leftHand:100,rightHand:100},{action:"grip"}),children:"Grip"}),V.jsx("button",{onClick:()=>r({leftHand:0,rightHand:0},{action:"release"}),children:"Release"})]})]}),t==="presets"&&V.jsxs("div",{className:"panel presets",children:[V.jsx("h4",{children:"Presets"}),V.jsx("div",{className:"preset-grid",children:Object.keys(i).map(l=>V.jsxs("div",{className:"preset-card",children:[V.jsx("div",{className:"preset-name",children:l}),V.jsxs("div",{className:"preset-actions",children:[V.jsx("button",{onClick:()=>a(l),children:"Apply"}),V.jsx("button",{onClick:()=>r(i[l],{preset:l}),children:"Send"})]})]},l))})]})]}),V.jsx("div",{className:"mm-footer",children:V.jsx("small",{children:"Advanced Robotics Panel  Movement controls & presets"})})]})}function cre(){return V.jsxs("div",{className:"robotstudio-wrapper",children:[V.jsxs("div",{className:"robotstudio-header",children:[V.jsx("h1",{className:"robotstudio-title",children:"Robot Studio"}),V.jsx("p",{className:"robotstudio-subtitle",children:"Virtual InMoov Control Environment"})]}),V.jsxs("div",{className:"robotstudio-layout",children:[V.jsx("div",{className:"robotstudio-left",children:V.jsx(KV,{})}),V.jsx("div",{className:"robotstudio-container",children:V.jsx("div",{className:"robotstudio-right",children:V.jsx(qV,{})})})]})]})}function lz(n,e){const t=(n??"").trim();return t?e(t):"Say that again?"}function YV(n){const e=n.toLowerCase();return e.includes("hello")||e.includes("hi")?"Hello! I'm your AI assistant. How can I help today?":e.includes("skills")||e.includes("tech")?"I work with React, TypeScript, robotics, and AI systems.":e.includes("project")?"You're currently exploring a modular robotics control platform.":e.includes("help")?"You can ask me about projects, robotics, AI, or voice control.":"I'm not sure yet  but I'm learning more every day."}function ure(n){const e=n.toLowerCase();return e.includes("hello")?"Hey there!!  So good to hear from you!":e.includes("robot")?"Robots are AWESOME  especially when you build them yourself!":"That sounds interesting! Tell me more "}function hre(n){const e=n.toLowerCase();return e.includes("hello")?"Oh wow. A greeting. How original.":e.includes("help")?"Yes yes, I help. It's literally my job.":"Fascinating. Truly."}function dre(n){return`Certainly. I have logged your request: "${n}". How may I further assist?`}const fre={default:YV,friendly:ure,sarcastic:hre,butler:dre};function pre(){const n=ly(),[e,t]=pe.useState(["AI: Hello! I'm your AI assistant."]),[s,i]=pe.useState(""),[a,r]=pe.useState(!1),[o,l]=pe.useState(!1),[c,h]=pe.useState("default"),d=pe.useRef(null),p=S=>{if(!window.speechSynthesis)return;l(!0);const b=new SpeechSynthesisUtterance(S);b.onend=()=>l(!1),window.speechSynthesis.speak(b)},g=()=>fre[c]??YV,v=S=>{if(S.preventDefault(),!s.trim())return;const b=g(),w=lz(s,b);t(T=>[...T,`You: ${s}`,`AI: ${w}`]),p(w),i("")},_=()=>{const S=window.SpeechRecognition||window.webkitSpeechRecognition;if(!S){alert("Speech recognition not supported in this browser.");return}const b=new S;b.lang="en-US",r(!0),b.onresult=w=>{const T=w.results[0][0].transcript,E=g(),R=lz(T,E);t(D=>[...D,`You (voice): ${T}`,`AI: ${R}`]),p(R),r(!1)},b.onerror=()=>{r(!1)},b.start()};return pe.useEffect(()=>{d.current?.scrollIntoView({behavior:"smooth"})},[e]),V.jsxs("div",{className:"aiassistant-page",children:[V.jsx("button",{onClick:()=>n("/control-hub"),children:" Control Hub"}),V.jsx("h1",{children:"AI Assistant"}),V.jsxs("select",{value:c,onChange:S=>h(S.target.value),children:[V.jsx("option",{value:"default",children:"Default"}),V.jsx("option",{value:"friendly",children:"Friendly"}),V.jsx("option",{value:"sarcastic",children:"Sarcastic"}),V.jsx("option",{value:"butler",children:"Robot Butler"})]}),V.jsxs("div",{className:"messages",children:[e.map((S,b)=>V.jsx("div",{children:S},b)),V.jsx("div",{ref:d})]}),V.jsxs("form",{onSubmit:v,children:[V.jsx("input",{value:s,onChange:S=>i(S.target.value),placeholder:"Say something..."}),V.jsx("button",{type:"submit",children:V.jsx(Oq,{size:18})})]}),V.jsx("button",{onClick:_,disabled:a,children:V.jsx(m4,{size:20})}),o&&V.jsx(kq,{size:18})]})}var C1={exports:{}};const mre=1e-7,gre=1e-4;class eB{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class k2{refCount(e){return Ho("refCount")}incRef(e){return Ho("incRef")}timerAvailable(){return!0}time(e){return Ho("time")}read(e){return Ho("read")}readSync(e){return Ho("readSync")}readToGPU(e,t){return Ho("readToGPU")}numDataIds(){return Ho("numDataIds")}disposeData(e,t){return Ho("disposeData")}write(e,t,s){return Ho("write")}move(e,t,s,i,a){return Ho("move")}createTensorFromGPUData(e,t,s){return Ho("createTensorFromGPUData")}memory(){return Ho("memory")}floatPrecision(){return Ho("floatPrecision")}epsilon(){return this.floatPrecision()===32?mre:gre}dispose(){return Ho("dispose")}}function Ho(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function tB(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,rd(n,e,t)}function xre(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,rd(n,t,s),rd(e,t,s)}function Gf(n,e,t){return Math.max(n,Math.min(e,t))}function L2(n){return n%2===0?n:n+1}function rd(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function JV(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function yre(n,e){const t=Math.random();return e*t+(1-t)*n}function vre(n,e){let t=0;for(let s=0;s<n.length;s++){const i=Number(n[s])-Number(e[s]);t+=i*i}return t}function ee(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function nr(n,e,t=""){ee(as(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Eg(n){ee(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function qe(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function bre(n){return n.length===0}function ZV(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function as(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function lg(n){return n%1===0}function Sre(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function vE(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function _re(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return tB(e),e}function qm(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function K3(n,e=i=>0,t,s){return new Promise((i,a)=>{let r=0;const o=()=>{if(n()){i();return}r++;const l=e(r);if(t!=null&&r>=t){a();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function nB(n,e){let t=1,s=-1;for(let a=0;a<n.length;++a)if(n[a]>=0)t*=n[a];else if(n[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(n[a]<0)throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[s]=e/t,i}function es(n,e){const t=e.length;return n=n==null?e.map((s,i)=>i):[].concat(n),ee(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),ee(n.every(s=>lg(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function _d(n,e){const t=[],s=[],i=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||i?null:es(e,n).sort();let r=0;for(let o=0;o<n.length;++o){if(a!=null){if(a[r]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(a[r]==null||a[r]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),a[r]<=o&&r++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function ka(n,e){return Ui(n,e)}function Ui(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function QV(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function eH(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function sB(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function nS(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function tH(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ku(n){return typeof n=="string"||n instanceof String}function nH(n){return typeof n=="boolean"}function bE(n){return typeof n=="number"}function Mg(n){return Array.isArray(n)?Mg(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":bE(n)?"float32":Ku(n)?"string":nH(n)?"bool":"float32"}function Vf(n){return!!(n&&n.constructor&&n.call&&n.apply)}function SE(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function gn(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function sH(n,e,t,s=!1){const i=new Array;if(e.length===1){const a=e[0]*(s?2:1);for(let r=0;r<a;r++)i[r]=t[n+r]}else{const a=e[0],r=e.slice(1),o=r.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<a;l++)i[l]=sH(n+l*o,r,t,s)}return i}function _l(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((i,a)=>i*a)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return sH(0,n,e,t)}function iH(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function F2(n,e){const t=tr(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function tr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function iB(n,e){const t=n.reduce((s,i)=>s*i,1);if(e==null||e==="float32")return _l(n,new Float32Array(t));if(e==="int32")return _l(n,new Int32Array(t));if(e==="bool")return _l(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function tl(n){n.forEach(e=>{ee(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Kc(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=t[i]*n[i];return s}function Ng(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/t[i]),n-=s[i]*t[i];return s[s.length-1]=n,s}function Hf(n){return n&&n.then&&typeof n.then=="function"}const cz="tfjsflags";class aH{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Are,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const i=this.urlFlags[e];Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Hf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);cz in e&&e[cz].split(",").forEach(s=>{const[i,a]=s.split(":");this.urlFlags[i]=Cre(i,a)})}}function Are(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(wre(e,s[0],s[1]),s.join("="))),e}function wre(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Cre(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Pe(){return aB}let aB=null;function Tre(n){aB=n}let e3;function rH(){if(e3==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");e3=n}return e3}function Ere(){const n=rH();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function rB(n,e){const t=Ere();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const GS="Abs",yy="Acos",vy="Acosh",Rg="Add",VS="AddN",U2="All",P2="Any",HS="ArgMax",WS="ArgMin",by="Asin",Sy="Asinh",_y="Atan",Ay="Atanh",wy="Atan2",jS="AvgPool",z2="AvgPoolGrad",XS="AvgPool3D",$2="AvgPool3DGrad",qS="BatchMatMul",KS="BatchToSpaceND",G2="Bincount",YS="BitwiseAnd",oH="BroadcastTo",V2="BroadcastArgs",Cy="Cast",Ty="Ceil",Ey="ClipByValue",H2="Complex",JS="ComplexAbs",ZS="Concat",QS="Conv2D",W2="Conv2DBackpropFilter",e_="Conv2DBackpropInput",t_="Conv3D",j2="Conv3DBackpropFilterV2",X2="Conv3DBackpropInputV2",My="Cos",Ny="Cosh",q2="Cumprod",n_="Cumsum",K2="CropAndResize",Y2="DenseBincount",J2="DepthToSpace",s_="DepthwiseConv2dNative",Z2="DepthwiseConv2dNativeBackpropFilter",Q2="DepthwiseConv2dNativeBackpropInput",eM="Diag",i_="Dilation2D",_E="Dilation2DBackpropInput",AE="Dilation2DBackpropFilter",tM="Draw",Ry="RealDiv",nM="Einsum",Iy="Elu",sM="EluGrad",Dy="Erf",a_="Equal",Oy="Exp",r_="ExpandDims",By="Expm1",iM="FFT",aM="Fill",rM="FlipLeftRight",ky="Floor",Ly="FloorDiv",o_="FusedBatchNorm",l_="GatherV2",oM="GatherNd",c_="Greater",Fy="GreaterEqual",Uy="Identity",lM="IFFT",cM="Imag",Py="IsFinite",zy="IsInf",$y="IsNan",u_="LeakyRelu",h_="Less",d_="LessEqual",uM="LinSpace",Gy="Log",Vy="Log1p",f_="LogicalAnd",p_="LogicalNot",m_="LogicalOr",Mre="LogicalXor",lH="LogSoftmax",Nre="LowerBound",g_="LRN",hM="LRNGrad",Rre="MatrixBandPart",x_="Max",Hy="Maximum",y_="MaxPool",dM="MaxPoolGrad",v_="MaxPool3D",fM="MaxPool3DGrad",pM="MaxPoolWithArgmax",b_="Mean",S_="Min",Wy="Minimum",__="MirrorPad",jy="Mod",mM="Multinomial",Xy="Multiply",A_="Neg",w_="NotEqual",gM="NonMaxSuppressionV3",xM="NonMaxSuppressionV4",yM="NonMaxSuppressionV5",C_="OnesLike",T_="OneHot",E_="Pack",M_="PadV2",Ire="Pool",qy="Pow",N_="Prelu",R_="Prod",vM="RaggedGather",bM="RaggedRange",SM="RaggedTensorToTensor",_M="Range",AM="Real",Ky="Reciprocal",Yy="Relu",I_="Reshape",D_="ResizeNearestNeighbor",wM="ResizeNearestNeighborGrad",O_="ResizeBilinear",CM="ResizeBilinearGrad",Jy="Relu6",B_="Reverse",Zy="Round",Qy="Rsqrt",TM="ScatterNd",EM="TensorScatterUpdate",MM="SearchSorted",k_="Select",ev="Selu",L_="Slice",tv="Sin",nv="Sinh",sv="Sign",iv="Sigmoid",av="Softplus",rv="Sqrt",F_="Sum",U_="SpaceToBatchND",P_="SplitV",z_="Softmax",NM="SparseFillEmptyRows",RM="SparseReshape",IM="SparseSegmentMean",DM="SparseSegmentSum",OM="SparseToDense",ov="SquaredDifference",BM="Square",$_="StaticRegexReplace",kM="StridedSlice",LM="StringNGrams",FM="StringSplit",UM="StringToHashBucketFast",lv="Sub",cv="Tan",uv="Tanh",hv="Tile",PM="TopK",zM="Transform",Km="Transpose",$M="Unique",G_="Unpack",V_="UnsortedSegmentSum",Dre="UpperBound",H_="ZerosLike",dv="Step",wE="FromPixels",GM="RotateWithOffset",sS="_FusedMatMul",iS="FusedConv2D",aS="FusedDepthwiseConv2D";function gl(...n){Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(...n)}function Ore(...n){Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.log(...n)}const Wx=rB("kernelRegistry",()=>new Map),rS=rB("gradRegistry",()=>new Map);function oS(n,e){const t=oB(n,e);return Wx.get(t)}function Y3(n){return rS.get(n)}function CE(n){const e=Wx.entries(),t=[];for(;;){const{done:s,value:i}=e.next();if(s)break;const[a,r]=i,[o]=a.split("_");o===n&&t.push(r)}return t}function VM(n){const{kernelName:e,backendName:t}=n,s=oB(e,t);Wx.has(s)&&gl(`The kernel '${e}' for backend '${t}' is already registered`),Wx.set(s,n)}function cH(n){const{kernelName:e}=n;rS.has(e)&&Pe().getBool("DEBUG")&&gl(`Overriding the gradient for '${e}'`),rS.set(e,n)}function Bre(n,e){const t=oB(n,e);if(!Wx.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Wx.delete(t)}function kre(n){if(!rS.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);rS.delete(n)}function Lre(n,e){CE(n).forEach(s=>{const i=Object.assign({},s,{backendName:e});VM(i)})}function oB(n,e){return`${e}_${n}`}function uH(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var t3,uz;function Fre(){if(uz)return t3;uz=1,t3=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(B,L,H){this.low=B|0,this.high=L|0,this.unsigned=!!H}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(B){return(B&&B.__isLong__)===!0}e.isLong=t;var s={},i={};function a(B,L){var H,K,Z;return L?(B>>>=0,(Z=0<=B&&B<256)&&(K=i[B],K)?K:(H=o(B,(B|0)<0?-1:0,!0),Z&&(i[B]=H),H)):(B|=0,(Z=-128<=B&&B<128)&&(K=s[B],K)?K:(H=o(B,B<0?-1:0,!1),Z&&(s[B]=H),H))}e.fromInt=a;function r(B,L){if(isNaN(B))return L?w:b;if(L){if(B<0)return w;if(B>=v)return F}else{if(B<=-_)return U;if(B+1>=_)return D}return B<0?r(-B,L).neg():o(B%g|0,B/g|0,L)}e.fromNumber=r;function o(B,L,H){return new e(B,L,H)}e.fromBits=o;var l=Math.pow;function c(B,L,H){if(B.length===0)throw Error("empty string");if(B==="NaN"||B==="Infinity"||B==="+Infinity"||B==="-Infinity")return b;if(typeof L=="number"?(H=L,L=!1):L=!!L,H=H||10,H<2||36<H)throw RangeError("radix");var K;if((K=B.indexOf("-"))>0)throw Error("interior hyphen");if(K===0)return c(B.substring(1),L,H).neg();for(var Z=r(l(H,8)),Q=b,P=0;P<B.length;P+=8){var W=Math.min(8,B.length-P),q=parseInt(B.substring(P,P+W),H);if(W<8){var se=r(l(H,W));Q=Q.mul(se).add(r(q))}else Q=Q.mul(Z),Q=Q.add(r(q))}return Q.unsigned=L,Q}e.fromString=c;function h(B,L){return typeof B=="number"?r(B,L):typeof B=="string"?c(B,L):o(B.low,B.high,typeof L=="boolean"?L:B.unsigned)}e.fromValue=h;var d=65536,p=1<<24,g=d*d,v=g*g,_=v/2,S=a(p),b=a(0);e.ZERO=b;var w=a(0,!0);e.UZERO=w;var T=a(1);e.ONE=T;var E=a(1,!0);e.UONE=E;var R=a(-1);e.NEG_ONE=R;var D=o(-1,2147483647,!1);e.MAX_VALUE=D;var F=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=F;var U=o(0,-2147483648,!1);e.MIN_VALUE=U;var O=e.prototype;return O.toInt=function(){return this.unsigned?this.low>>>0:this.low},O.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},O.toString=function(L){if(L=L||10,L<2||36<L)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(U)){var H=r(L),K=this.div(H),Z=K.mul(H).sub(this);return K.toString(L)+Z.toInt().toString(L)}else return"-"+this.neg().toString(L);for(var Q=r(l(L,6),this.unsigned),P=this,W="";;){var q=P.div(Q),se=P.sub(q.mul(Q)).toInt()>>>0,le=se.toString(L);if(P=q,P.isZero())return le+W;for(;le.length<6;)le="0"+le;W=""+le+W}},O.getHighBits=function(){return this.high},O.getHighBitsUnsigned=function(){return this.high>>>0},O.getLowBits=function(){return this.low},O.getLowBitsUnsigned=function(){return this.low>>>0},O.getNumBitsAbs=function(){if(this.isNegative())return this.eq(U)?64:this.neg().getNumBitsAbs();for(var L=this.high!=0?this.high:this.low,H=31;H>0&&(L&1<<H)==0;H--);return this.high!=0?H+33:H+1},O.isZero=function(){return this.high===0&&this.low===0},O.eqz=O.isZero,O.isNegative=function(){return!this.unsigned&&this.high<0},O.isPositive=function(){return this.unsigned||this.high>=0},O.isOdd=function(){return(this.low&1)===1},O.isEven=function(){return(this.low&1)===0},O.equals=function(L){return t(L)||(L=h(L)),this.unsigned!==L.unsigned&&this.high>>>31===1&&L.high>>>31===1?!1:this.high===L.high&&this.low===L.low},O.eq=O.equals,O.notEquals=function(L){return!this.eq(L)},O.neq=O.notEquals,O.ne=O.notEquals,O.lessThan=function(L){return this.comp(L)<0},O.lt=O.lessThan,O.lessThanOrEqual=function(L){return this.comp(L)<=0},O.lte=O.lessThanOrEqual,O.le=O.lessThanOrEqual,O.greaterThan=function(L){return this.comp(L)>0},O.gt=O.greaterThan,O.greaterThanOrEqual=function(L){return this.comp(L)>=0},O.gte=O.greaterThanOrEqual,O.ge=O.greaterThanOrEqual,O.compare=function(L){if(t(L)||(L=h(L)),this.eq(L))return 0;var H=this.isNegative(),K=L.isNegative();return H&&!K?-1:!H&&K?1:this.unsigned?L.high>>>0>this.high>>>0||L.high===this.high&&L.low>>>0>this.low>>>0?-1:1:this.sub(L).isNegative()?-1:1},O.comp=O.compare,O.negate=function(){return!this.unsigned&&this.eq(U)?U:this.not().add(T)},O.neg=O.negate,O.add=function(L){t(L)||(L=h(L));var H=this.high>>>16,K=this.high&65535,Z=this.low>>>16,Q=this.low&65535,P=L.high>>>16,W=L.high&65535,q=L.low>>>16,se=L.low&65535,le=0,Y=0,re=0,he=0;return he+=Q+se,re+=he>>>16,he&=65535,re+=Z+q,Y+=re>>>16,re&=65535,Y+=K+W,le+=Y>>>16,Y&=65535,le+=H+P,le&=65535,o(re<<16|he,le<<16|Y,this.unsigned)},O.subtract=function(L){return t(L)||(L=h(L)),this.add(L.neg())},O.sub=O.subtract,O.multiply=function(L){if(this.isZero())return b;if(t(L)||(L=h(L)),n){var H=n.mul(this.low,this.high,L.low,L.high);return o(H,n.get_high(),this.unsigned)}if(L.isZero())return b;if(this.eq(U))return L.isOdd()?U:b;if(L.eq(U))return this.isOdd()?U:b;if(this.isNegative())return L.isNegative()?this.neg().mul(L.neg()):this.neg().mul(L).neg();if(L.isNegative())return this.mul(L.neg()).neg();if(this.lt(S)&&L.lt(S))return r(this.toNumber()*L.toNumber(),this.unsigned);var K=this.high>>>16,Z=this.high&65535,Q=this.low>>>16,P=this.low&65535,W=L.high>>>16,q=L.high&65535,se=L.low>>>16,le=L.low&65535,Y=0,re=0,he=0,me=0;return me+=P*le,he+=me>>>16,me&=65535,he+=Q*le,re+=he>>>16,he&=65535,he+=P*se,re+=he>>>16,he&=65535,re+=Z*le,Y+=re>>>16,re&=65535,re+=Q*se,Y+=re>>>16,re&=65535,re+=P*q,Y+=re>>>16,re&=65535,Y+=K*le+Z*se+Q*q+P*W,Y&=65535,o(he<<16|me,Y<<16|re,this.unsigned)},O.mul=O.multiply,O.divide=function(L){if(t(L)||(L=h(L)),L.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&L.low===-1&&L.high===-1)return this;var H=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,L.low,L.high);return o(H,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?w:b;var K,Z,Q;if(this.unsigned){if(L.unsigned||(L=L.toUnsigned()),L.gt(this))return w;if(L.gt(this.shru(1)))return E;Q=w}else{if(this.eq(U)){if(L.eq(T)||L.eq(R))return U;if(L.eq(U))return T;var P=this.shr(1);return K=P.div(L).shl(1),K.eq(b)?L.isNegative()?T:R:(Z=this.sub(L.mul(K)),Q=K.add(Z.div(L)),Q)}else if(L.eq(U))return this.unsigned?w:b;if(this.isNegative())return L.isNegative()?this.neg().div(L.neg()):this.neg().div(L).neg();if(L.isNegative())return this.div(L.neg()).neg();Q=b}for(Z=this;Z.gte(L);){K=Math.max(1,Math.floor(Z.toNumber()/L.toNumber()));for(var W=Math.ceil(Math.log(K)/Math.LN2),q=W<=48?1:l(2,W-48),se=r(K),le=se.mul(L);le.isNegative()||le.gt(Z);)K-=q,se=r(K,this.unsigned),le=se.mul(L);se.isZero()&&(se=T),Q=Q.add(se),Z=Z.sub(le)}return Q},O.div=O.divide,O.modulo=function(L){if(t(L)||(L=h(L)),n){var H=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,L.low,L.high);return o(H,n.get_high(),this.unsigned)}return this.sub(this.div(L).mul(L))},O.mod=O.modulo,O.rem=O.modulo,O.not=function(){return o(~this.low,~this.high,this.unsigned)},O.and=function(L){return t(L)||(L=h(L)),o(this.low&L.low,this.high&L.high,this.unsigned)},O.or=function(L){return t(L)||(L=h(L)),o(this.low|L.low,this.high|L.high,this.unsigned)},O.xor=function(L){return t(L)||(L=h(L)),o(this.low^L.low,this.high^L.high,this.unsigned)},O.shiftLeft=function(L){return t(L)&&(L=L.toInt()),(L&=63)===0?this:L<32?o(this.low<<L,this.high<<L|this.low>>>32-L,this.unsigned):o(0,this.low<<L-32,this.unsigned)},O.shl=O.shiftLeft,O.shiftRight=function(L){return t(L)&&(L=L.toInt()),(L&=63)===0?this:L<32?o(this.low>>>L|this.high<<32-L,this.high>>L,this.unsigned):o(this.high>>L-32,this.high>=0?0:-1,this.unsigned)},O.shr=O.shiftRight,O.shiftRightUnsigned=function(L){if(t(L)&&(L=L.toInt()),L&=63,L===0)return this;var H=this.high;if(L<32){var K=this.low;return o(K>>>L|H<<32-L,H>>>L,this.unsigned)}else return L===32?o(H,0,this.unsigned):o(H>>>L-32,0,this.unsigned)},O.shru=O.shiftRightUnsigned,O.shr_u=O.shiftRightUnsigned,O.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},O.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},O.toBytes=function(L){return L?this.toBytesLE():this.toBytesBE()},O.toBytesLE=function(){var L=this.high,H=this.low;return[H&255,H>>>8&255,H>>>16&255,H>>>24,L&255,L>>>8&255,L>>>16&255,L>>>24]},O.toBytesBE=function(){var L=this.high,H=this.low;return[L>>>24,L>>>16&255,L>>>8&255,L&255,H>>>24,H>>>16&255,H>>>8&255,H&255]},e.fromBytes=function(L,H,K){return K?e.fromBytesLE(L,H):e.fromBytesBE(L,H)},e.fromBytesLE=function(L,H){return new e(L[0]|L[1]<<8|L[2]<<16|L[3]<<24,L[4]|L[5]<<8|L[6]<<16|L[7]<<24,H)},e.fromBytesBE=function(L,H){return new e(L[4]<<24|L[5]<<16|L[6]<<8|L[7],L[0]<<24|L[1]<<16|L[2]<<8|L[3],H)},t3}var hH=Fre();const dH=KE(hH),Ure=z7({__proto__:null,default:dH},[hH]);const Im=dH||Ure;function W_(n){return Im.fromString(n,!0,16)}const fH=W_("c3a5c85c97cb3127"),Mm=W_("b492b66fbe98f273"),Gr=W_("9ae16a3b2f90404f");function J3(n){return n.xor(n.shru(47))}function pH(n,e,t){const s=n.slice(e,e+t);return Im.fromBytes(Array.from(s),!0,!0)}function ai(n,e){return pH(n,e,8)}function hz(n,e){return pH(n,e,4)}function Na(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Bf(n,e,t=W_("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let i=e.xor(s).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function Pre(n,e,t,s,i,a){i=i.add(n),a=Na(a.add(i).add(s),21);const r=i;return i=i.add(e),i=i.add(t),a=a.add(Na(i,44)),[i.add(s),a.add(r)]}function WC(n,e,t,s){return Pre(ai(n,e),ai(n,e+8),ai(n,e+16),ai(n,e+24),t,s)}function zre(n,e=n.length){if(e>=8){const t=Gr.add(e*2),s=ai(n,0).add(Gr),i=ai(n,e-8),a=Na(i,37).mul(t).add(s),r=Na(s,25).add(i).mul(t);return Bf(a,r,t)}if(e>=4){const t=Gr.add(e*2),s=hz(n,0);return Bf(s.shl(3).add(e),hz(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],i=n[e-1],a=t+(s<<8),r=e+(i<<2);return J3(Gr.mul(a).xor(fH.mul(r))).mul(Gr)}return Gr}function $re(n,e=n.length){const t=Gr.add(e*2),s=ai(n,0).mul(Mm),i=ai(n,8),a=ai(n,e-8).mul(t),r=ai(n,e-16).mul(Gr);return Bf(Na(s.add(i),43).add(Na(a,30)).add(r),s.add(Na(i.add(Gr),18)).add(a),t)}function Gre(n,e=n.length){const t=Gr.add(e*2),s=ai(n,0).mul(Gr),i=ai(n,8),a=ai(n,e-8).mul(t),r=ai(n,e-16).mul(Gr),o=Na(s.add(i),43).add(Na(a,30)).add(r),l=Bf(o,s.add(Na(i.add(Gr),18)).add(a),t),c=ai(n,16).mul(t),h=ai(n,24),d=o.add(ai(n,e-32)).mul(t),p=l.add(ai(n,e-24)).mul(t);return Bf(Na(c.add(h),43).add(Na(d,30)).add(p),c.add(Na(h.add(s),18)).add(d),t)}function mH(n,e=n.length){const t=Im.fromNumber(81,!0);if(e<=32)return e<=16?zre(n,e):$re(n,e);if(e<=64)return Gre(n,e);let s=t,i=t.mul(Mm).add(113),a=J3(i.mul(Gr).add(113)).mul(Gr),r=[Im.UZERO,Im.UZERO],o=[Im.UZERO,Im.UZERO];s=s.mul(Gr).add(ai(n,0));let l=0;const c=(e-1>>6)*64,h=c+(e-1&63)-63;do s=Na(s.add(i).add(r[0]).add(ai(n,l+8)),37).mul(Mm),i=Na(i.add(r[1]).add(ai(n,l+48)),42).mul(Mm),s=s.xor(o[1]),i=i.add(r[0]).add(ai(n,l+40)),a=Na(a.add(o[0]),33).mul(Mm),r=WC(n,l,r[1].mul(Mm),s.add(o[0])),o=WC(n,l+32,a.add(o[1]),i.add(ai(n,l+16))),[a,s]=[s,a],l+=64;while(l!==c);const d=Mm.add(a.and(255).shl(1));return l=h,o[0]=o[0].add(e-1&63),r[0]=r[0].add(o[0]),o[0]=o[0].add(r[0]),s=Na(s.add(i).add(r[0]).add(ai(n,l+8)),37).mul(d),i=Na(i.add(r[1]).add(ai(n,l+48)),42).mul(d),s=s.xor(o[1].mul(9)),i=i.add(r[0].mul(9).add(ai(n,l+40))),a=Na(a.add(o[0]),33).mul(d),r=WC(n,l,r[1].mul(d),s.add(o[0])),o=WC(n,l+32,a.add(o[1]),i.add(ai(n,l+16))),[a,s]=[s,a],Bf(Bf(r[0],o[0],d).add(J3(i).mul(fH)).add(a),Bf(r[1],o[1],d).add(s),d)}function Ad(n,e){return e==="string"?Qu(n):ap([n],e)}function Vre(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function ap(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=oh(n)),Pe().getBool("DEBUG")&&QV(n,e),Vre(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function zr(){return Pe().platform.now()}function Hre(n,e){return Pe().platform.fetch(n,e)}function Qu(n,e="utf-8"){return e=e||"utf-8",Pe().platform.encode(n,e)}function gd(n,e="utf-8"){return e=e||"utf-8",Pe().platform.decode(n,e)}function Ra(n){return Pe().platform.isTypedArray!=null?Pe().platform.isTypedArray(n):uH(n)}function oh(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Hf(n)||n==null||Ra(n)&&t)e.push(n);else if(Array.isArray(n)||Ra(n))for(let s=0;s<n.length;++s)oh(n[s],e,t);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)oh(n[i],e,t)}return e}const Wre=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:as,arraysEqualWithNull:ZV,assert:ee,assertNonNegativeIntegerDimensions:tl,assertNonNull:Eg,assertShapesMatch:nr,bytesFromStringArray:tH,bytesPerElement:nS,checkConversionForErrors:QV,clamp:Gf,computeStrides:gn,convertBackendValuesAndArrayBuffer:iH,createScalarValue:Ad,createShuffledIndices:_re,decodeString:gd,distSquared:vre,encodeString:Qu,fetch:Hre,fingerPrint64:mH,flatten:oh,getArrayFromDType:Ui,getTypedArrayFromDType:ka,hasEncodingLoss:sB,hexToLong:W_,indexToLoc:Ng,inferDtype:Mg,inferFromImplicitShape:nB,isBoolean:nH,isFunction:Vf,isInt:lg,isNumber:bE,isPromise:Hf,isScalarShape:bre,isString:Ku,isTypedArray:Ra,isValidDtype:eH,locToIndex:Kc,makeOnesTypedArray:F2,makeZerosNestedTypedArray:iB,makeZerosTypedArray:tr,nearestDivisor:SE,nearestLargerEven:L2,now:zr,parseAxisParam:es,randUniform:yre,repeatedTry:K3,rightPad:qm,shuffle:tB,shuffleCombo:xre,sizeFromShape:qe,sizeToSquarishShape:vE,squeezeShape:_d,sum:JV,swap:rd,tanh:Sre,toNestedArray:_l,toTypedArray:ap},Symbol.toStringTag,{value:"Module"}));class jre{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new qre)}profileKernel(e,t,s){let i;const a=()=>{i=s()};let r;const o=zr();if(this.backendTimer.timerAvailable())r=this.backendTimer.time(a);else{a();for(const c of i)c.dataSync();r=Promise.resolve({kernelMs:zr()-o})}if(Pe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const h=i[c];h.data().then(d=>{Xre(d,h.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:r.then(c=>c.kernelMs),extraInfo:r.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:i,inputs:a,extraInfo:r}=e;s.forEach(o=>{Promise.all([o.data(),i,r]).then(l=>{this.logger.logKernelProfile(t,o,l[0],l[1],a,l[2])})})}}function Xre(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class qre{logKernelProfile(e,t,s,i,a,r){const o=typeof i=="number"?qm(`${i}ms`,9):i.error,l=qm(e,25),c=t.rank,h=t.size,d=qm(t.shape.toString(),14);let p="";for(const g in a){const v=a[g];if(v!=null){const _=v.shape||t.shape,S=_.length;p+=`${g}: ${S}D ${S>0?_:""} `}}console.log(`%c${l}	%c${o}	%c${c}D ${d}	%c${h}	%c${p}	%c${r}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Kre(n,e,t){const s={},i={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],h=c.inputs;for(const d in h){const p=h[d];let g=!1;for(let v=0;v<e.length;v++)if(s[p.id]){c.outputs.forEach(_=>s[_.id]=!0),g=!0,i[c.id]=!0;break}if(g)break}}const a={};a[t.id]=!0;const r={};for(let l=n.length-1;l>=0;l--){const c=n[l],h=c.inputs;for(let d=0;d<c.outputs.length;d++)if(a[c.outputs[d].id]){for(const p in h)a[h[p].id]=!0,r[c.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&r[c.id]){const h={};for(const p in c.inputs){const g=c.inputs[p];s[g.id]&&(h[p]=g)}const d=Object.assign({},c);d.inputs=h,d.outputs=c.outputs,o.push(d)}}return o}function Yre(n,e,t,s){for(let i=e.length-1;i>=0;i--){const a=e[i],r=[];if(a.outputs.forEach(l=>{const c=n[l.id];c!=null?r.push(c):r.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(r);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const c=t(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const h=a.inputs[l];if(!as(c.shape,h.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=c;else{const d=n[h.id];n[h.id]=s(d,c),d.dispose()}}}}const dz=20,y1=3,n3=7;function Jre(n,e,t,s){const i=gn(e),a=Zre(n,e,t,i),r=e.length,o=fT(n,e,t,i,a),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${r}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function Zre(n,e,t,s){const i=qe(e),a=s[s.length-1],r=new Array(a).fill(0),o=e.length,l=t==="complex64"?E1(n):n;if(o>1)for(let c=0;c<i/a;c++){const h=c*a;for(let d=0;d<a;d++)r[d]=Math.max(r[d],T1(l[h+d],0,t).length)}return r}function T1(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(n3))} + ${parseFloat(n[1].toFixed(n3))}j`:Ku(n)?s=`'${n}'`:t==="bool"?s=gH(n):s=parseFloat(n.toFixed(n3)).toString(),qm(s,e)}function gH(n){return n===0?"false":"true"}function fT(n,e,t,s,i,a=!0){const r=t==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(t==="complex64"){const _=E1(n);return[T1(_[0],0,t)]}return t==="bool"?[gH(n[0])]:[n[0].toString()]}if(l===1){if(o>dz){const S=y1*r;let b=Array.from(n.slice(0,S)),w=Array.from(n.slice((o-y1)*r,o*r));return t==="complex64"&&(b=E1(b),w=E1(w)),["["+b.map((T,E)=>T1(T,i[E],t)).join(", ")+", ..., "+w.map((T,E)=>T1(T,i[o-y1+E],t)).join(", ")+"]"]}return["["+(t==="complex64"?E1(n):Array.from(n)).map((S,b)=>T1(S,i[b],t)).join(", ")+"]"]}const c=e.slice(1),h=s.slice(1),d=s[0]*r,p=[];if(o>dz){for(let _=0;_<y1;_++){const S=_*d,b=S+d;p.push(...fT(n.slice(S,b),c,t,h,i,!1))}p.push("...");for(let _=o-y1;_<o;_++){const S=_*d,b=S+d;p.push(...fT(n.slice(S,b),c,t,h,i,_===o-1))}}else for(let _=0;_<o;_++){const S=_*d,b=S+d;p.push(...fT(n.slice(S,b),c,t,h,i,_===o-1))}const g=l===2?",":"";p[0]="["+(o>0?p[0]+g:"");for(let _=1;_<p.length-1;_++)p[_]=" "+p[_]+g;let v=`,
`;for(let _=2;_<l;_++)v+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":v),p}function E1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class oa{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=qe(e),s!=null){const i=s.length;ee(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Ui(t,this.size),this.strides=gn(e)}set(e,...t){t.length===0&&(t=[0]),ee(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let s=e[e.length-1];for(let i=0;i<e.length-1;++i)s+=this.strides[i]*e[i];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Wc().makeTensor(this.values,this.shape,this.dtype)}}let Wc=null,yx=null;function Qre(n){Wc=n}function eoe(n){yx=n}class Us{constructor(e,t,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=qe(e),this.strides=gn(e),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return yx.buffer(this.shape,this.dtype,e)}bufferSync(){return yx.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return _l(this.shape,e,this.dtype==="complex64")}arraySync(){return _l(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Wc().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>gd(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Wc().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Wc().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>gd(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Wc().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Wc().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return yx.print(this,e)}clone(){return this.throwIfDisposed(),yx.clone(this)}toString(e=!1){const t=this.dataSync();return Jre(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),yx.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Wc().makeVariable(this,e,t,s)}}Object.defineProperty(Us,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function et(){return rB("Tensor",()=>Us)}et();class lS extends Us{constructor(e,t,s,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!as(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Wc().disposeTensor(this),this.dataId=e.dataId,Wc().incRef(this,null)}dispose(){Wc().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(lS,Symbol.hasInstance,{value:n=>n instanceof Us&&n.assign!=null&&n.assign instanceof Function});var Z3;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Z3||(Z3={}));var Q3;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Q3||(Q3={}));var eD;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(eD||(eD={}));var tD;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(tD||(tD={}));var nD;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(nD||(nD={}));const toe={float32:tD,int32:Q3,bool:eD,complex64:nD};function To(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return toe[n][e]}function HM(n){return To(n,"int32")}function xH(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function yH(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Ei(n,e){if(n.dtype===e.dtype)return[n,e];const t=To(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function vH(n,e){ee(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function noe(n,e){return e.some(t=>t.id===n.id)}function lB(n){const e=[];return bH(n,e,new Set),e}function bH(n,e,t){if(n==null)return;if(n instanceof Us){e.push(n);return}if(!soe(n))return;const s=n;for(const i in s){const a=s[i];t.has(a)||(t.add(a),bH(a,e,t))}}function soe(n){return Array.isArray(n)||typeof n=="object"}const ioe=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:vH,getTensorsInContainer:lB,isTensorInList:noe,makeTypesMatch:Ei},Symbol.toStringTag,{value:"Module"}));function s3(n){return n.kernelName!=null}class fz{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class jx{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fz}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(gl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new jre(this.backendInstance),!0}setupRegisteredKernels(){CE(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){CE(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof k2)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,a=s.then(r=>i<this.pendingBackendInitId?!1:(this.registry[e]=r,this.pendingBackendInit=null,!0)).catch(r=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,gl(`Initialization of backend ${e} failed`),gl(r.stack||r.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return gl(`Initialization of backend ${e} failed`),gl(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:i,asyncInit:a}=this.initializeBackend(s);if(a||i)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),i=s.backend,a=this.readSync(t),r=i.refCount(t);i.disposeData(t,!0),s.backend=e,e.move(t,a,s.shape,s.dtype,r),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,s){e();try{const i=s();return t(),i}catch(i){throw t(),i}}nextTensorId(){return jx.nextTensorId++}nextVariableId(){return jx.nextVariableId++}clone(e){const t=ve.runKernel(Uy,{x:e}),s={x:e},i=r=>({x:()=>{const o="float32",l={x:r},c={dtype:o};return ve.runKernel(Cy,l,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[t],i,a,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(oS(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const i=this.backend.numDataIds();let a=0;s.forEach(l=>{a+=l.dtype==="complex64"?3:1});const r=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-t-a-r;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const i=this.isTapeOn(),a=this.state.numBytes,r=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const c=s3(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(s3(e)){const{kernelName:v,inputs:_,attrs:S}=e;this.backendName==null&&this.backend;const b=oS(v,this.backendName);ee(b!=null,()=>`Cannot find registered kernel '${v}' for backend '${this.backendName}'`),o=()=>{const w=this.backend.numDataIds();l=b.kernelFunc({inputs:_,attrs:S,backend:this.backend});const T=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(v,w,T);const E=T.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(i){const R=this.getTensorsForGradient(v,_,E);s=this.saveTensorsForBackwardMode(R)}return E}}else{const{forwardFunc:v}=e,_=S=>{i&&(s=S.map(b=>this.keep(this.clone(b))))};o=()=>{const S=this.backend.numDataIds();l=this.tidy(()=>v(this.backend,_));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,S,b),b}}const{inputs:h,attrs:d}=e,p=s3(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(g=this.profiler.profileKernel(c,h,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),t=g.outputs)}),i&&this.addTapeNode(c,h,t,p,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-r,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(v=>h[v]!=null?h[v].shape:null),outputShapes:t.map(v=>v.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const i=Y3(e);if(i!=null){const a=i.inputsToSave||[],r=i.outputsToSave||[];let o;i.saveAllInputs?(ee(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(c=>t[c])):o=a.map(c=>t[c]);const l=s.filter((c,h)=>r[h]);return o.concat(l)}return[]}makeTensor(e,t,s,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let a=e;s==="string"&&Ku(e[0])&&(a=e.map(l=>Qu(l)));const r=i.write(a,t,s),o=new Us(t,s,r,this.nextTensorId());if(this.trackTensor(o,i),s==="string"){const l=this.state.tensorInfo.get(r),c=tH(a);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(e,t,s,i){s=s||"float32";const a={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(a,i)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:i,dtype:a}=e,r=new Us(i,a,s,this.nextTensorId());return this.trackTensor(r,t),r}makeVariable(e,t=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const a=new lS(e,t,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*nS(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof lS||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*nS(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,i,a,r){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:a},l=Y3(e);l!=null&&(i=l.gradFunc),i!=null&&(o.gradient=c=>(c=c.map((h,d)=>{if(h==null){const p=s[d],g=tr(p.size,p.dtype);return this.makeTensor(g,p.shape,p.dtype)}return h}),i(c.length>1?c:c[0],a,r))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=lB(e),s=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const r=this.state.activeScope.track[a];!r.kept&&!s.has(r.id)&&r.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===i.id&&this.track(a)})}gradients(e,t,s,i=!1){if(ee(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));ee(a instanceof Us,()=>"The result y returned by f() must be a tensor.");const r=Kre(this.state.activeTape,t,a);if(!i&&r.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=s??aoe(a.shape),Yre(o,r,c=>this.tidy(c),roe);const l=t.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(e){return ee(Vf(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{ee(t.every(o=>o instanceof Us),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};t.forEach((o,l)=>{i[l]=o});const a=(o,l)=>(s=e(...t,l),ee(s.value instanceof Us,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ee(Vf(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),r=(o,l)=>{const c=s.gradFunc(o,l),h=Array.isArray(c)?c:[c];ee(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ee(h.every(p=>p instanceof Us),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return h.forEach((p,g)=>{d[g]=()=>p}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:r,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=zr(),s=await this.backend.time(e);return s.wallMs=zr()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fz;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}jx.nextTensorId=0;jx.nextVariableId=0;function aoe(n){const e=F2(qe(n),"float32");return ve.makeTensor(e,n,"float32")}function SH(){const n=rH();if(n._tfengine==null){const e=new aH(n);n._tfengine=new jx(e)}return Tre(n._tfengine.ENV),Qre(()=>n._tfengine),n._tfengine}const ve=SH();function roe(n,e){const t={a:n,b:e};return ve.runKernel(Rg,t)}function ooe(){return typeof navigator<"u"&&navigator!=null}let sD;function loe(n){sD=n}function cB(n){if(sD!==void 0)return sD;if(n||ooe()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function uB(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const coe=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:uB,isMobile:cB,mockIsMobile:loe},Symbol.toStringTag,{value:"Module"}));const Eo=Pe();Eo.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Eo.registerFlag("IS_BROWSER",()=>uB());Eo.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Eo.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Eo.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Eo.registerFlag("PROD",()=>!1);Eo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Eo.getBool("DEBUG"));Eo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Eo.registerFlag("IS_TEST",()=>!1);Eo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Eo.getBool("DEBUG"));Eo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Eo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Eo.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function lh(n,e){let t=n;if(Ra(n))return e==="string"?[]:[n.length];if(xH(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(yH(n))return[n.buffer.size/(e==null?4:nS(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Ra(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&Pe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&_H(n,s,[]),s}function _H(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ra(n)){ee(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}ee(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),ee(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let i=0;i<n.length;++i)_H(n[i],s,t.concat(i))}function pz(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function te(n,e,t,s="numeric"){if(n instanceof et())return pz(s,n.dtype,e,t),n;let i=Mg(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),pz(s,i,e,t),n==null||!Ra(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const a=lh(n,i);!Ra(n)&&!Array.isArray(n)&&(n=[n]);const o=i!=="string"?ap(n,i):oh(n,[],!0);return ve.makeTensor(o,a,i)}function cS(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,r)=>te(a,`${e}[${r}]`,t,s))}const hB="__op";function be(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+hB;const i=(...a)=>{ve.startScope(t);try{const r=s(...a);return Hf(r)&&console.error("Cannot return a Promise inside of tidy."),ve.endScope(r),r}catch(r){throw ve.endScope(null),r}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}function uoe(n,e){const t=te(n,"real","complex"),s=te(e,"imag","complex");nr(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:t,imag:s};return ve.runKernel(H2,i)}const xd=be({complex_:uoe});function rp(n,e,t,s){if(s==null)s=Mg(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(yH(n)||xH(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return ve.backend.createTensorFromGPUData(n,e||t,s)}if(!Ra(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){tl(e);const i=qe(e),a=qe(t);ee(i===a,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${a}`);for(let r=0;r<t.length;++r){const o=t[r],l=r===t.length-1?o!==qe(e.slice(r)):!0;ee(t[r]===e[r]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ra(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?ap(n,s):oh(n,[],!0),ve.makeTensor(n,e,s)}function rc(n,e,t){const s=lh(n,t);return rp(n,e,s,t)}const cg={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ru{static join(e){return new ru(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Ra(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const i=e[s];s!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+i.byteLength;this.shards.push({buffer:i,start:t,end:a}),t=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,a=new ArrayBuffer(i),r=new Uint8Array(a);let o=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],d=e+o-c.start,p=o,v=Math.min(t,c.end)-c.start,_=new Uint8Array(c.buffer,d,v-d);if(r.set(_,p),o+=_.length,t<c.end)break}return a}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=hoe(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function hoe(n,e){let t=0,s=n.length;for(;t<=s;){const i=Math.floor((s-t)/2)+t,a=e(n[i]);if(a===0)return i;a<0?s=i:t=i+1}return-1}function doe(){Pe().set("PROD",!0)}function foe(){Pe().set("DEBUG",!0)}function poe(){Pe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function moe(n){Pe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function goe(){ve.disposeVariables()}function Vc(){return ve}function iD(){return ve.memory()}function xoe(n){return ve.profile(n)}function Le(n,e){return ve.tidy(n,e)}function Qn(n){lB(n).forEach(t=>t.dispose())}function ga(n){return ve.keep(n)}function yoe(n){return ve.time(n)}function voe(n){return ve.setBackend(n)}function boe(){return ve.ready()}function AH(){return ve.backendName}function Soe(n){ve.removeBackend(n)}function _oe(n){return ve.findBackend(n)}function Aoe(n){return ve.findBackendFactory(n)}function dB(n,e,t=1){return ve.registerBackend(n,e,t)}function fB(){return ve.backend}function woe(n,e){Pe().setPlatform(n,e)}const Wf=4;async function aD(n,e){const t=[],s=[],i=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);for(let r=0;r<i.length;++r){const o=i[r],l=Array.isArray(n)?n[r].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async d=>{const p=await l.bytes(),g=p.reduce((S,b)=>S+b.length,0)+Wf*p.length,v=new Uint8Array(g);let _=0;for(let S=0;S<p.length;S++){const b=p[S],w=new Uint8Array(new Uint32Array([b.length]).buffer);v.set(w,_),_+=Wf,v.set(b,_),_+=b.length}d(v)});s.push(h)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const a=await Promise.all(s);return{data:Eoe(a),specs:t}}function wH(n,e){const t=new ru(n),s={};let i=0;for(const a of e){const r=Coe(a,(o,l)=>t.slice(i+o,i+l));s[a.name]=CH(a,t.slice(i,i+r)),i+=r}return s}function Coe(n,e){const t=qe(n.shape);let s;if("quantization"in n){const i=n.quantization;s=cg[i.dtype]}else if(n.dtype==="string"){let i=0;for(let a=0;a<t;a++)i+=Wf+new Uint32Array(e(i,i+Wf))[0];return i}else s=cg[n.dtype];return t*s}async function Toe(n,e){const t=qe(n.shape);let s;if("quantization"in n){const i=n.quantization;s=cg[i.dtype]}else if(n.dtype==="string"){let i=0;for(let a=0;a<t;a++)i+=Wf+new Uint32Array(await e(i,i+Wf))[0];return i}else s=cg[n.dtype];return t*s}function CH(n,e){const t=n.name,s=n.dtype,i=n.shape,a=qe(i);let r,o=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=cg[l.dtype],h=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){r=new Float32Array(h.length);for(let d=0;d<h.length;d++){const p=h[d];r[d]=p*l.scale+l.min}}else if(l.dtype==="float16")r=Ooe()(h);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);r=new Int32Array(h.length);for(let d=0;d<h.length;d++){const p=h[d];r[d]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=a*c}else if(s==="string"){const l=qe(n.shape);r=[];for(let c=0;c<l;c++){const h=new Uint32Array(e.slice(o,o+Wf))[0];o+=Wf;const d=new Uint8Array(e.slice(o,o+h));r.push(d),o+=h}}else{const l=cg[s];if(s==="float32")r=new Float32Array(e);else if(s==="int32")r=new Int32Array(e);else if(s==="bool")r=new Uint8Array(e);else if(s==="complex64"){r=new Float32Array(e);const c=new Float32Array(r.length/2),h=new Float32Array(r.length/2);for(let v=0;v<c.length;v++)c[v]=r[v*2],h[v]=r[v*2+1];const d=rc(c,i,"float32"),p=rc(h,i,"float32"),g=xd(d,p);return d.dispose(),p.dispose(),g}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=a*l}return rc(r,i,s)}async function mz(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:i,value:a}=await n.read();if(i&&a==null){const o=t-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const r=new Uint8Array(s.length+a.byteLength);r.set(s,0),r.set(new Uint8Array(a),s.length),s=r}return s.buffer}async function TH(n,e){const t={},s=n.getReader();let i=new ArrayBuffer(0);for(const a of e){const r=await Toe(a,async(c,h)=>(i=await mz(s,i,h),i.slice(c,h)));i=await mz(s,i,r);const o=i.slice(0,r);i=i.slice(r);const l=CH(a,o);if(t[a.name]=l,AH()==="webgpu"){const c=fB();"uploadToGPU"in c&&qe(l.shape)>=Pe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return t}function Eoe(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(e);let i=0;return t.forEach(a=>{s.set(new Uint8Array(a.buffer),i),i+=a.byteLength}),s.buffer}const pB=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function gz(n){return pB?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Moe(n){if(pB)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function Noe(n){if(pB){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function EH(n){return ru.join(n)}function xz(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function MH(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function mB(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function gB(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),mB(n,t,s)}function j_(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:gz(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:gz(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new ru(n.weightData).byteLength}}function TE(n){const e=[];for(const t of n)e.push(...t.weights);return e}function Roe(){const n=t=>{let s=t<<13,i=0;for(;(s&8388608)===0;)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Ioe(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Doe(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Ooe(){const n=Roe(),e=Ioe(),t=Doe();return s=>{const i=new ArrayBuffer(4*s.length),a=new Uint32Array(i);for(let r=0;r<s.length;r++){const o=s[r],l=n[t[o>>10]+(o&1023)]+e[o>>10];a[r]=l}return new Float32Array(i)}}class _i{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return _i.instance==null&&(_i.instance=new _i),_i.instance}static registerSaveRouter(e){_i.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_i.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _i.getHandlers(e,"save")}static getLoadHandlers(e,t){return _i.getHandlers(e,"load",t)}static getHandlers(e,t,s){const i=[];return(t==="load"?_i.getInstance().loadRouters:_i.getInstance().saveRouters).forEach(r=>{const o=r(e,s);o!==null&&i.push(o)}),i}}const Boe=n=>_i.registerSaveRouter(n),koe=n=>_i.registerLoadRouter(n),NH=n=>_i.getSaveHandlers(n),Loe=(n,e)=>_i.getLoadHandlers(n,e);const rD="tensorflowjs",oD=1,Vm="models_store",Rf="model_info_store";function RH(){if(!Pe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function lD(n){const e=n.result;e.createObjectStore(Vm,{keyPath:"modelPath"}),e.createObjectStore(Rf,{keyPath:"modelPath"})}class ug{constructor(e){if(this.indexedDB=RH(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,i)=>{const a=this.indexedDB.open(rD,oD);a.onupgradeneeded=()=>lD(a),a.onsuccess=()=>{const r=a.result;if(t==null){const o=r.transaction(Vm,"readonly"),c=o.objectStore(Vm).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return r.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=h=>(r.close(),i(c.error)),o.oncomplete=()=>r.close()}else{t.weightData=ru.join(t.weightData);const o=j_(t),l=r.transaction(Rf,"readwrite");let c=l.objectStore(Rf),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(p){return i(p)}let d;h.onsuccess=()=>{d=r.transaction(Vm,"readwrite");const p=d.objectStore(Vm);let g;try{g=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(v){return i(v)}g.onsuccess=()=>s({modelArtifactsInfo:o}),g.onerror=v=>{c=l.objectStore(Rf);const _=c.delete(this.modelPath);_.onsuccess=()=>(r.close(),i(g.error)),_.onerror=S=>(r.close(),i(g.error))}},h.onerror=p=>(r.close(),i(h.error)),l.oncomplete=()=>{d==null?r.close():d.oncomplete=()=>r.close()}}},a.onerror=r=>i(a.error)})}}ug.URL_SCHEME="indexeddb://";const IH=n=>Pe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ug.URL_SCHEME)?Foe(n.slice(ug.URL_SCHEME.length)):null;_i.registerSaveRouter(IH);_i.registerLoadRouter(IH);function Foe(n){return new ug(n)}function Uoe(n){return n.startsWith(ug.URL_SCHEME)?n.slice(ug.URL_SCHEME.length):n}class Poe{constructor(){this.indexedDB=RH()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(rD,oD);s.onupgradeneeded=()=>lD(s),s.onsuccess=()=>{const i=s.result,a=i.transaction(Rf,"readonly"),o=a.objectStore(Rf).getAll();o.onsuccess=()=>{const l={};for(const c of o.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},o.onerror=l=>(i.close(),t(o.error)),a.oncomplete=()=>i.close()},s.onerror=i=>t(s.error)})}async removeModel(e){return e=Uoe(e),new Promise((t,s)=>{const i=this.indexedDB.open(rD,oD);i.onupgradeneeded=()=>lD(i),i.onsuccess=()=>{const a=i.result,r=a.transaction(Rf,"readwrite"),o=r.objectStore(Rf),l=o.get(e);let c;l.onsuccess=()=>{if(l.result==null)return a.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=o.delete(e),d=()=>{c=a.transaction(Vm,"readwrite");const g=c.objectStore(Vm).delete(e);g.onsuccess=()=>t(l.result.modelArtifactsInfo),g.onerror=v=>s(l.error)};h.onsuccess=d,h.onerror=p=>(d(),a.close(),s(l.error))}},l.onerror=h=>(a.close(),s(l.error)),r.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},i.onerror=a=>s(i.error)})}}const od="/",vx="tensorflowjs_models",DH="info",zoe="model_topology",$oe="weight_specs",Goe="weight_data",Voe="model_metadata";function OH(n){return{info:[vx,n,DH].join(od),topology:[vx,n,zoe].join(od),weightSpecs:[vx,n,$oe].join(od),weightData:[vx,n,Goe].join(od),modelMetadata:[vx,n,Voe].join(od)}}function BH(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Hoe(n){const e=n.split(od);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(od)}function Woe(n){return n.startsWith(hg.URL_SCHEME)?n.slice(hg.URL_SCHEME.length):n}class hg{constructor(e){if(!Pe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=OH(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),i=j_(e),a=ru.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Moe(a));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:i}}catch{throw BH(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const r=this.LS.getItem(this.keys.weightData);if(r==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Noe(r),t}}hg.URL_SCHEME="localstorage://";const kH=n=>Pe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(hg.URL_SCHEME)?joe(n.slice(hg.URL_SCHEME.length)):null;_i.registerSaveRouter(kH);_i.registerLoadRouter(kH);function joe(n){return new hg(n)}class Xoe{constructor(){ee(Pe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ee(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=vx+od,s=od+DH;for(let i=0;i<this.LS.length;++i){const a=this.LS.key(i);if(a.startsWith(t)&&a.endsWith(s)){const r=Hoe(a);e[r]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=Woe(e);const t=OH(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return BH(t),s}}const Cx="://";class $r{constructor(){this.managers={}}static getInstance(){return $r.instance==null&&($r.instance=new $r),$r.instance}static registerManager(e,t){ee(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Cx)&&(e=e.slice(0,e.indexOf(Cx))),ee(e.length>0,()=>"scheme must not be an empty string.");const s=$r.getInstance();ee(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=$r.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys($r.getInstance().managers)}}function pT(n){if(n.indexOf(Cx)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${$r.getSchemes().join(",")}`);return{scheme:n.split(Cx)[0],path:n.split(Cx)[1]}}async function LH(n,e,t=!1){ee(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=_i.getLoadHandlers(n);ee(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),ee(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const i=s[0],a=_i.getSaveHandlers(e);ee(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),ee(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const r=a[0],o=pT(n).scheme,l=pT(n).path,c=o===pT(n).scheme,h=await i.load();t&&c&&await $r.getManager(o).removeModel(l);const d=await r.save(h);return t&&!c&&await $r.getManager(o).removeModel(l),d.modelArtifactsInfo}async function qoe(){const n=$r.getSchemes(),e={};for(const t of n){const s=await $r.getManager(t).listModels();for(const i in s){const a=t+Cx+i;e[a]=s[i]}}return e}async function Koe(n){const e=pT(n);return $r.getManager(e.scheme).removeModel(e.path)}async function Yoe(n,e){return LH(n,e,!1)}async function Joe(n,e){return LH(n,e,!0)}class Zoe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Pe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return uH(e)}}if(Pe().get("IS_BROWSER")){Pe().setPlatform("browser",new Zoe);try{$r.registerManager(hg.URL_SCHEME,new Xoe)}catch{}try{$r.registerManager(ug.URL_SCHEME,new Poe)}catch{}}const Qoe={importFetch:()=>require("node-fetch")};let i3;class ele{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Pe().global.fetch!=null?Pe().global.fetch(e,t):(i3==null&&(i3=Qoe.importFetch()),i3(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Pe().get("IS_NODE")&&!Pe().get("IS_BROWSER")&&Pe().setPlatform("node",new ele);function Hn(n,e="float32",t){return e=e||"float32",tl(n),new oa(n,e,t)}function tle(n,e){const t=te(n,"x","cast");if(!eH(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},i={dtype:e};return ve.runKernel(Cy,s,i)}const Ft=be({cast_:tle});function nle(n){const t={x:te(n,"x","clone","string_or_numeric")};return ve.runKernel(Uy,t)}const eh=be({clone_:nle});function xB(n,e=!1){console.log(n.toString(e))}SH();const sle={buffer:Hn,cast:Ft,clone:eh,print:xB};eoe(sle);function ile(n,e){let t=te(n,"a","add"),s=te(e,"b","add");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(Rg,i)}const bt=be({add_:ile});function ale(n,e){let t=te(n,"a","floorDiv"),s=te(e,"b","floorDiv");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(Ly,i)}const WM=be({floorDiv_:ale});function rle(n,e){let t=te(n,"a","div"),s=te(e,"b","div");if([t,s]=Ei(t,s),t.dtype==="int32"&&s.dtype==="int32")return WM(t,s);const i={a:t,b:s},a={};return ve.runKernel(Ry,i,a)}const un=be({div_:rle});function ole(n,e){let t=te(n,"a","mul"),s=te(e,"b","mul");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(Xy,i)}const we=be({mul_:ole});function lle(n){const e=te(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ve.runKernel(JS,t)}else{const t={x:e};return ve.runKernel(GS,t)}}const ia=be({abs_:lle});function cle(n){const t={x:te(n,"x","acos")};return ve.runKernel(yy,t)}const yB=be({acos_:cle});function ule(n){const t={x:te(n,"x","acosh")};return ve.runKernel(vy,t)}const vB=be({acosh_:ule});function hle(n){ee(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),ee(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((i,a)=>te(i,`tensors${a}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!as(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return ve.runKernel(VS,s)}const FH=be({addN_:hle});function dle(n,e=null,t=!1){const i={x:te(n,"x","all","bool")},a={axis:e,keepDims:t};return ve.runKernel(U2,i,a)}const jM=be({all_:dle});function fle(n,e=null,t=!1){const i={x:te(n,"x","any","bool")},a={axis:e,keepDims:t};return ve.runKernel(P2,i,a)}const uS=be({any_:fle});function ple(n,e=0){const s={x:te(n,"x","argMax")},i={axis:e};return ve.runKernel(HS,s,i)}const dg=be({argMax_:ple});function mle(n,e=0){const s={x:te(n,"x","argMin")},i={axis:e};return ve.runKernel(WS,s,i)}const bB=be({argMin_:mle});function gle(n){const t={x:te(n,"x","asin")};return ve.runKernel(by,t)}const SB=be({asin_:gle});function xle(n){const t={x:te(n,"x","asinh")};return ve.runKernel(Sy,t)}const _B=be({asinh_:xle});function yle(n){const t={x:te(n,"x","atan")};return ve.runKernel(_y,t)}const AB=be({atan_:yle});function vle(n,e){let t=te(n,"a","atan2"),s=te(e,"b","atan2");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(wy,i)}const wB=be({atan2_:vle});function ble(n){const t={x:te(n,"x","atanh")};return ve.runKernel(Ay,t)}const CB=be({atanh_:ble});function X_(n,e,t,s,i="NHWC",a){const r=n[3],o=[...e,r],l=Cd(i);return Fa(n,o,t,a,s,null,null,l)}function uc(n,e,t,s,i,a,r="channelsLast"){const[o,l]=hS(e);let c;if(r==="channelsLast")c=[o,l,n[3],n[3]];else if(r==="channelsFirst")c=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${r}`);return Fa(n,c,t,s,i,a,!1,r)}function wd(n,e,t,s,i,a,r="NDHWC"){const[o,l,c]=cD(e);let h,d;if(r==="NDHWC")d="channelsLast",h=[o,l,c,n[4],n[4]];else if(r==="NCDHW")d="channelsFirst",h=[o,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${r}`);return op(n,h,t,s,i,!1,d,a)}function Fa(n,e,t,s,i,a,r=!1,o="channelsLast"){let[l,c,h,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,h,d]=n;else if(o==="channelsFirst")[l,d,c,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,,v]=e,[_,S]=hS(t),[b,w]=hS(s),T=Tx(p,b),E=Tx(g,w),{padInfo:R,outHeight:D,outWidth:F}=Ale(i,c,h,_,S,T,E,a,o),U=r?v*d:v;let O;return o==="channelsFirst"?O=[l,U,D,F]:o==="channelsLast"&&(O=[l,D,F,U]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:h,inChannels:d,outHeight:D,outWidth:F,outChannels:U,padInfo:R,strideHeight:_,strideWidth:S,filterHeight:p,filterWidth:g,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationHeight:b,dilationWidth:w,inShape:n,outShape:O,filterShape:e}}function op(n,e,t,s,i,a=!1,r="channelsLast",o){let[l,c,h,d,p]=[-1,-1,-1,-1,-1];if(r==="channelsLast")[l,c,h,d,p]=n;else if(r==="channelsFirst")[l,p,c,h,d]=n;else throw new Error(`Unknown dataFormat ${r}`);const[g,v,_,,S]=e,[b,w,T]=cD(t),[E,R,D]=cD(s),F=Tx(g,E),U=Tx(v,R),O=Tx(_,D),{padInfo:B,outDepth:L,outHeight:H,outWidth:K}=wle(i,c,h,d,b,w,T,F,U,O,o),Z=a?S*p:S;let Q;return r==="channelsFirst"?Q=[l,Z,L,H,K]:r==="channelsLast"&&(Q=[l,L,H,K,Z]),{batchSize:l,dataFormat:r,inDepth:c,inHeight:h,inWidth:d,inChannels:p,outDepth:L,outHeight:H,outWidth:K,outChannels:Z,padInfo:B,strideDepth:b,strideHeight:w,strideWidth:T,filterDepth:g,filterHeight:v,filterWidth:_,effectiveFilterDepth:F,effectiveFilterHeight:U,effectiveFilterWidth:O,dilationDepth:E,dilationHeight:R,dilationWidth:D,inShape:n,outShape:Q,filterShape:e}}function Sle(n,e,t,s,i){s==null&&(s=TB(n,e,t));const a=n[0],r=n[1],o=dS((a-e+2*s)/t+1,i),l=dS((r-e+2*s)/t+1,i);return[o,l]}function _le(n,e,t,s,i,a){i==null&&(i=TB(n,e[0],s[0]));const r=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*i>=e[o]&&(r[o]=dS((n[o]-e[o]+2*i)/s[o]+1,a));return r}function TB(n,e,t,s=1){const i=Tx(e,s);return Math.floor((n[0]*(t-1)-t+i)/2)}function hS(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function cD(n){return typeof n=="number"?[n,n,n]:n}function Tx(n,e){return e<=1?n:n+(n-1)*(e-1)}function Ale(n,e,t,s,i,a,r,o,l){let c,h,d;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const g=Sle([e,t],a,s,n,o);h=g[0],d=g[1]}else if(n==="same"){h=Math.ceil(e/s),d=Math.ceil(t/i);const p=Math.max(0,(h-1)*s+a-e),g=Math.max(0,(d-1)*i+r-t),v=Math.floor(p/2),_=p-v,S=Math.floor(g/2),b=g-S;c={top:v,bottom:_,left:S,right:b,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-a+1)/s),d=Math.ceil((t-r+1)/i);else if(typeof n=="object"){const p=l==="channelsLast"?n[1][0]:n[2][0],g=l==="channelsLast"?n[1][1]:n[2][1],v=l==="channelsLast"?n[2][0]:n[3][0],_=l==="channelsLast"?n[2][1]:n[3][1];c={top:p,bottom:g,left:v,right:_,type:p===0&&g===0&&v===0&&_===0?"VALID":"EXPLICIT"},h=dS((e-a+p+g)/s+1,o),d=dS((t-r+v+_)/i+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:h,outWidth:d}}function wle(n,e,t,s,i,a,r,o,l,c,h){let d,p,g,v;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const S=_le([e,t,s,1],[o,l,c],1,[i,a,r],n,h);p=S[0],g=S[1],v=S[2]}else if(n==="same"){p=Math.ceil(e/i),g=Math.ceil(t/a),v=Math.ceil(s/r);const _=(p-1)*i+o-e,S=(g-1)*a+l-t,b=(v-1)*r+c-s,w=Math.floor(_/2),T=_-w,E=Math.floor(S/2),R=S-E,D=Math.floor(b/2),F=b-D;d={top:E,bottom:R,left:D,right:F,front:w,back:T,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:p,outHeight:g,outWidth:v}}function dS(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function jf(n){const[e,t,s]=hS(n);return e===1&&t===1&&s===1}function sr(n,e){return jf(n)||jf(e)}function fg(n){return hS(n).every(e=>e>0)}function Cd(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Kr(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")ee(lg(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(i=>{ee(lg(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function Cle(n,e){const s={x:te(n,"x","reshape","string_or_numeric")},i={shape:e};return ve.runKernel(I_,s,i)}const Ee=be({reshape_:Cle});function Tle(n,e,t,s,i){const a=te(n,"x","avgPool","float32"),r=1;ee(sr(t,r),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ee(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Kr("avgPool",s,i);const c={x:o},h={filterSize:e,strides:t,pad:s,dimRoundingMode:i};let d=ve.runKernel(jS,c,h);return d=Ft(d,a.dtype),l?Ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const q_=be({avgPool_:Tle});function Ele(n,e,t,s,i,a="NDHWC"){const r=te(n,"x","avgPool3d","float32");let o=r,l=!1;r.rank===4&&(l=!0,o=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]])),ee(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),ee(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ee(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Kr("avgPool3d",s,i);const c={x:o},h={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:a};let d=ve.runKernel(XS,c,h);return d=Ft(d,o.dtype),l?Ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const EB=be({avgPool3d_:Ele});function Mle(n,e=0){ee(n.length>=1,()=>"Pass at least one tensor to concat");const t=cS(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return eh(t[0]);const s=t,i={axis:e};return ve.runKernel(ZS,s,i)}const ji=be({concat_:Mle});function Nle(n,e,t=!1,s=!1){let i=te(n,"a","matMul"),a=te(e,"b","matMul");[i,a]=Ei(i,a);const r={a:i,b:a},o={transposeA:t,transposeB:s};return ve.runKernel(qS,r,o)}const Zn=be({matMul_:Nle});function Rle(n){const t={x:te(n,"x","sigmoid","float32")};return ve.runKernel(iv,t)}const Yc=be({sigmoid_:Rle});function Ile(n,e,t){const s=te(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},a={begin:e,size:t};return ve.runKernel(L_,i,a)}const ds=be({slice_:Ile});function Dle(n){const t={x:te(n,"x","tanh","float32")};return ve.runKernel(uv,t)}const Xf=be({tanh_:Dle});function Ole(n,e,t,s,i,a){const r=te(n,"forgetBias","basicLSTMCell"),o=te(e,"lstmKernel","basicLSTMCell"),l=te(t,"lstmBias","basicLSTMCell"),c=te(s,"data","basicLSTMCell"),h=te(i,"c","basicLSTMCell"),d=te(a,"h","basicLSTMCell"),p=ji([c,d],1),g=Zn(p,o),v=bt(g,l),_=v.shape[0],S=v.shape[1]/4,b=[_,S],w=ds(v,[0,0],b),T=ds(v,[0,S],b),E=ds(v,[0,S*2],b),R=ds(v,[0,S*3],b),D=bt(we(Yc(w),Xf(T)),we(h,Yc(bt(r,E)))),F=we(Xf(D),Yc(R));return[D,F]}const UH=be({basicLSTMCell_:Ole});function Ble(n,e,t){const s=te(n,"x","batchToSpaceND"),i=e.reduce((o,l)=>o*l);ee(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),ee(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),ee(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const a={x:s},r={blockShape:e,crops:t};return ve.runKernel(KS,a,r)}const K_=be({batchToSpaceND_:Ble});function kle(n){let e;return n.rank===0||n.rank===1?e=Ee(n,[1,1,1,n.size]):n.rank===2?e=Ee(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=Ee(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function Lle(n,e,t,s,i,a){a==null&&(a=.001);const r=te(n,"x","batchNorm"),o=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let c;i!=null&&(c=te(i,"scale","batchNorm"));let h;s!=null&&(h=te(s,"offset","batchNorm")),ee(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ee(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ee(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:kle(r),scale:c,offset:h,mean:o,variance:l},g={varianceEpsilon:a},v=ve.runKernel(o_,p,g);return Ee(v,r.shape)}const fv=be({batchNorm_:Lle});function Fle(n,e,t,s,i,a){const r=te(n,"x","batchNorm"),o=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let c;i!=null&&(c=te(i,"scale","batchNorm"));let h;return s!=null&&(h=te(s,"offset","batchNorm")),ee(r.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${r.rank}.`),ee(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),ee(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&ee(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&ee(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),fv(r,o,l,h,c,a)}const MB=be({batchNorm2d_:Fle});function Ule(n,e,t,s,i,a){const r=te(n,"x","batchNorm"),o=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let c;i!=null&&(c=te(i,"scale","batchNorm"));let h;return s!=null&&(h=te(s,"offset","batchNorm")),ee(r.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${r.rank}.`),ee(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),ee(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&ee(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&ee(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),fv(r,o,l,h,c,a)}const NB=be({batchNorm3d_:Ule});function Ple(n,e,t,s,i,a){const r=te(n,"x","batchNorm"),o=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let c;i!=null&&(c=te(i,"scale","batchNorm"));let h;return s!=null&&(h=te(s,"offset","batchNorm")),ee(r.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${r.rank}.`),ee(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),ee(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&ee(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&ee(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),fv(r,o,l,h,c,a)}const RB=be({batchNorm4d_:Ple});function zle(n,e,t){const s=te(n,"x","bincount"),i=te(e,"weights","bincount");ee(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),ee(t>=0,()=>`size must be non-negative, but got ${t}.`),ee(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const a={x:s,weights:i},r={size:t};return ve.runKernel(G2,a,r)}const IB=be({bincount_:zle});function $le(n,e){const t=te(n,"x","bitwiseAnd"),s=te(e,"y","bitwiseAnd");if(!as(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const i={a:t,b:s};return ve.runKernel(YS,i)}const PH=be({bitwiseAnd_:$le});function Gle(n,e){const t=te(n,"s0","broadcastArgs","int32"),s=te(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const i={s0:t,s1:s};return ve.runKernel(V2,i)}const zH=be({broadcastArgs_:Gle});function Vle(n,e){let t=te(n,"broadcastTo","x");const s=t.shape;if(tl(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=Ee(t,c)}const i=t.shape,a=Array.from(e);for(let c=e.length-1;c>=0;c--)if(i[c]===e[c])a[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(a.map((c,h)=>c>1?h:-1).filter(c=>c>=0).length===0)return eh(t);const o={x:t},l={reps:a};return ve.runKernel(hv,o,l)}const Ym=be({broadcastTo_:Vle});function Hle(n){const t={x:te(n,"x","ceil","float32")};return ve.runKernel(Ty,t)}const DB=be({ceil_:Hle});function Ig(n,e,t){tl(n),t=t||Mg(e);const s={shape:n,value:e,dtype:t};return ve.runKernel(aM,{},s)}function Wle(n,e,t){const s=te(n,"x","clipByValue");if(ee(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Ig(s.shape,e,s.dtype);const i={x:s},a={clipValueMin:e,clipValueMax:t};return ve.runKernel(Ey,i,a)}const Mo=be({clipByValue_:Wle});function jle(n){return ji(n,0)}const OB=be({concat1d_:jle});function Xle(n,e){return ji(n,e)}const BB=be({concat2d_:Xle});function qle(n,e){return ji(n,e)}const kB=be({concat3d_:qle});function Kle(n,e){return ji(n,e)}const LB=be({concat4d_:Kle});function Yle(n,e,t,s,i="NHWC",a=[1,1],r){const o=te(n,"x","conv2d","float32"),l=te(e,"filter","conv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),ee(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Kr("conv2d",s,r);const d=i==="NHWC"?c.shape[3]:c.shape[1];ee(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),ee(sr(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ee(fg(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),ee(fg(t),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},g={strides:t,pad:s,dataFormat:i,dilations:a,dimRoundingMode:r},v=ve.runKernel(QS,p,g);return h?Ee(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const yd=be({conv2d_:Yle});function Jle(n,e,t,s,i="NWC",a=1,r){const o=te(n,"x","conv1d"),l=te(e,"filter","conv1d");let c=o,h=!1;o.rank===2&&(h=!0,c=Ee(o,[1,o.shape[0],o.shape[1]])),ee(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),ee(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Kr("conv1d",s,r),ee(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),ee(sr(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),ee(fg(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),ee(fg(t),()=>"Error in conv1D: Stride should be larger than 0."),ee(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const d=Ee(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=Ee(c,[c.shape[0],1,c.shape[1],c.shape[2]]),S=yd(p,d,[1,t],s,"NHWC",[1,a],r);return h?Ee(S,[S.shape[2],S.shape[3]]):Ee(S,[S.shape[0],S.shape[2],S.shape[3]])}const XM=be({conv1d_:Jle});function Zle(n,e,t,s,i,a="NHWC",r){ee(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,l=e,c=!1;e.rank===3&&(c=!0,l=Ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),ee(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),ee(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),ee(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const h=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];ee(h===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[2]}.`),ee(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),Kr("conv2dDerInput",i,r);const p={dy:l,filter:t},g={strides:s,pad:i,dataFormat:a,dimRoundingMode:r,inputShape:o},v=ve.runKernel(e_,p,g);return c?Ee(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const FB=be({conv2DBackpropInput_:Zle});function Qle(n,e,t,s,i,a){const r=te(n,"x","conv2dTranspose"),o=te(e,"filter","conv2dTranspose");return FB(t,r,o,s,i,"NHWC",a)}const qM=be({conv2dTranspose_:Qle});function ece(n,e,t,s,i="NDHWC",a=[1,1,1]){const r=te(n,"x","conv3d"),o=te(e,"filter","conv3d");let l=r,c=!1;r.rank===4&&(c=!0,l=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]])),ee(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),ee(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),ee(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),ee(sr(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ee(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),ee(fg(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),ee(fg(t),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:l,filter:o},d={strides:t,pad:s,dataFormat:i,dilations:a},p=ve.runKernel(t_,h,d);return c?Ee(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const UB=be({conv3d_:ece});function tce(n,e,t,s,i){ee(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,r=e,o=!1;e.rank===4&&(o=!0,r=Ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const l=a[4],c=r.shape[4];ee(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),ee(r.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${r.rank}`),ee(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),ee(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),ee(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const h={dy:r,filter:t},d={pad:i,strides:s,inputShape:a},p=ve.runKernel(X2,h,d);return o?Ee(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const $H=be({conv3DBackpropInput_:tce});function nce(n,e,t,s,i){const a=te(n,"x","conv3dTranspose"),r=te(e,"filter","conv3dTranspose");return $H(t,a,r,s,i)}const PB=be({conv3dTranspose_:nce});function sce(n){const t={x:te(n,"x","cos","float32")};return ve.runKernel(My,t)}const Y_=be({cos_:sce});function ice(n){const t={x:te(n,"x","cosh","float32")};return ve.runKernel(Ny,t)}const KM=be({cosh_:ice});function ace(n,e=0,t=!1,s=!1){const a={x:te(n,"x","cumprod")},r={axis:e,exclusive:t,reverse:s};return ve.runKernel(q2,a,r)}const fS=be({cumprod_:ace});function rce(n,e=0,t=!1,s=!1){const a={x:te(n,"x","cumsum")},r={axis:e,exclusive:t,reverse:s};return ve.runKernel(n_,a,r)}const YM=be({cumsum_:rce});function oce(n,e,t,s=!1){const i=te(n,"x","denseBincount"),a=te(e,"weights","denseBincount");ee(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),ee(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),ee(t>=0,()=>`size must be non-negative, but got ${t}.`),ee(a.size===i.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${a.shape}.`);const r={x:i,weights:a},o={size:t,binaryOutput:s};return ve.runKernel(Y2,r,o)}const EE=be({denseBincount_:oce});function lce(n,e,t="NHWC"){const s=te(n,"x","depthToSpace","float32"),i=t==="NHWC"?s.shape[1]:s.shape[2],a=t==="NHWC"?s.shape[2]:s.shape[3],r=t==="NHWC"?s.shape[3]:s.shape[1];ee(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),ee(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${s.shape}`),ee(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${s.shape}`),ee(r%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${r} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:e,dataFormat:t};return ve.runKernel(J2,o,l)}const zB=be({depthToSpace_:lce});function cce(n,e,t,s,i="NHWC",a=[1,1],r){const o=te(n,"x","depthwiseConv2d","float32"),l=te(e,"filter","depthwiseConv2d","float32");let c=o,h=!1;o.rank===3&&(h=!0,c=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),ee(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=i==="NHWC"?c.shape[3]:c.shape[1];ee(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Kr("depthwiseConv2d",s,r);const p={x:c,filter:l},g={strides:t,pad:s,dataFormat:i,dilations:a,dimRoundingMode:r},v=ve.runKernel(s_,p,g);return h?Ee(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const pv=be({depthwiseConv2d_:cce});function uce(n){const t={x:te(n,"x","diag")};return ve.runKernel(eM,t)}const GH=be({diag_:uce});function hce(n,e,t,s,i=[1,1],a="NHWC"){const r=te(n,"x","dilation2d"),o=te(e,"filter","dilation2d");ee(r.rank===3||r.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${r.rank}.`),ee(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),ee(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=r,c=!1;r.rank===3&&(l=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]),c=!0),ee(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const h={x:l,filter:o},d={strides:t,pad:s,dilations:i},p=ve.runKernel(i_,h,d);return c?Ee(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const $B=be({dilation2d_:hce});function pg(n,e){const t=n.length,s=[];for(let i=0;i<t;i++){const a=t-1-i,r=n[a]||1;(e[e.length-1-i]||1)>1&&r===1&&s.unshift(a)}return s}function la(n,e){const t=[];for(let s=0;s<e.length;s++){const i=n[n.length-s-1],a=e.length-s-1,r=e[a];(i==null||i===1&&r>1)&&t.unshift(a)}return t}function kn(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let i=0;i<t;i++){let a=n[n.length-i-1];a==null&&(a=1);let r=e[e.length-i-1];if(r==null&&(r=1),a===1)s[t-i-1]=r;else if(r===1)s[t-i-1]=a;else if(a!==r){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else s[t-i-1]=a}return s}const dce=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:kn,getBroadcastDims:pg,getReductionAxes:la},Symbol.toStringTag,{value:"Module"}));function fce(n,e){let t=te(n,"a","equal","string_or_numeric"),s=te(e,"b","equal","string_or_numeric");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(a_,i)}const oc=be({equal_:fce});function pce(n,e,t){const s=te(e,"a","where"),i=te(t,"b","where"),a=te(n,"condition","where","bool"),r=kn(kn(a.shape,s.shape),i.shape),o=Ym(a,r),l=Ym(s,r),c=Ym(i,r),h={condition:o,t:l,e:c};return ve.runKernel(k_,h)}const er=be({where_:pce});function mce(n){const t={x:te(n,"x","zerosLike")};return ve.runKernel(H_,t)}const ps=be({zerosLike_:mce});function gce(n,e){let t=te(n,"a","div"),s=te(e,"b","div");[t,s]=Ei(t,s);const i=un(t,s),a=ps(i),r=oc(s,a);return er(r,a,i)}const GB=be({divNoNan_:gce});function xce(n,e){const t=te(n,"t1","dot"),s=te(e,"t2","dot");ee((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const i=t.rank===1?t.size:t.shape[1],a=s.rank===1?s.size:s.shape[0];if(ee(i===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${a}.`),t.rank===1&&s.rank===1){const r=Ee(t,[1,-1]),o=Ee(s,[-1,1]),l=Zn(r,o);return Ee(l,[])}else if(t.rank===1&&s.rank===2){const r=Ee(t,[1,-1]),o=Ee(s,[s.shape[0],s.shape[1]]),l=Zn(r,o);return Ee(l,[l.size])}else if(t.rank===2&&s.rank===1){const r=Ee(s,[-1,1]),o=Zn(t,r);return Ee(o,[o.size])}else{const r=Ee(s,[s.shape[0],s.shape[1]]);return Zn(t,r)}}const VB=be({dot_:xce});function yce(n,...e){const t=e.map((i,a)=>te(i,`tensors${a}`,"einsum")),s={equation:n};return ve.runKernel(nM,t,s)}const Dm=be({einsum_:yce});function vce(n){const t={x:te(n,"x","elu","float32")};return ve.runKernel(Iy,t)}const mv=be({elu_:vce});function bce(n,e){const t=te(n,"x","ensureShape","string_or_numeric");if(!ZV(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const VH=be({ensureShape_:bce});function Sce(n){let e=te(n,"x","erf");ee(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ft(e,"float32"));const t={x:e};return ve.runKernel(Dy,t)}const JM=be({erf_:Sce});function HB(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function HH(n,e,t){const s=n.length+e.length,i=[];let a=0,r=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?i.push(n[a++]):i.push(e[r++]);return i}function Ua(n,e){const t=[],s=n.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&t.push(n[a]);const i=e.map(a=>n[a]);return[t,i]}function Xi(n,e){const t=e.map(s=>1);return HH(n,t,e)}function ir(n,e,t){ee(HB(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Mi(n,e){if(HB(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function lp(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function qi(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function _ce(n,e=null,t=!1){const i={x:te(n,"x","max")},a={reductionIndices:e,keepDims:t};return ve.runKernel(x_,i,a)}const Al=be({max_:_ce});function Ace(n,e=null,t=!1){const i={x:te(n,"x","min")},a={axis:e,keepDims:t};return ve.runKernel(S_,i,a)}const Xx=be({min_:Ace});function wce(n,e){let t=te(n,"base","pow"),s=te(e,"exp","pow");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(qy,i)}const ch=be({pow_:wce});function vn(n,e){if((Ra(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ra(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return rp(n,[],[],e)}function Cce(n){const t={x:te(n,"x","sqrt","float32")};return ve.runKernel(rv,t)}const La=be({sqrt_:Cce});function Tce(n){const e=te(n,"x","square"),t={};return ve.runKernel("Square",{x:e},t)}const Xs=be({square_:Tce});function Ece(n,e=null,t=!1){let s=te(n,"x","sum");s.dtype==="bool"&&(s=Ft(s,"int32"));const i={x:s},a={axis:e,keepDims:t};return ve.runKernel(F_,i,a)}const sn=be({sum_:Ece});function Mce(n,e="euclidean",t=null,s=!1){n=te(n,"x","norm");const i=WH(n,e,t);let a=i.shape;if(s){const r=es(t,n.shape);a=Xi(i.shape,r)}return Ee(i,a)}function WH(n,e,t=null){if(n.rank===0)return ia(n);if(n.rank!==1&&t===null)return WH(Ee(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return sn(ia(n),t);if(e===1/0)return Al(ia(n),t);if(e===-1/0)return Xx(ia(n),t);if(e==="euclidean"||e===2)return La(sn(ch(ia(n),vn(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Al(sn(ia(n),t[0]),t[1]-1);if(e===1/0)return Al(sn(ia(n),t[1]),t[0]);if(e===-1/0)return Xx(sn(ia(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return La(sn(Xs(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const gv=be({norm_:Mce});function Nce(n,e=null,t=!1){return gv(n,"euclidean",e,t)}const WB=be({euclideanNorm_:Nce});function Rce(n){const t={x:te(n,"x","exp")};return ve.runKernel(Oy,t)}const No=be({exp_:Rce});function Ice(n,e=0){const t=te(n,"x","expandDims","string_or_numeric");ee(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},i={dim:e};return ve.runKernel(r_,s,i)}const gr=be({expandDims_:Ice});function Dce(n){const t={x:te(n,"x","expm1")};return ve.runKernel(By,t)}const jB=be({expm1_:Dce});function Oce(n,e){const t=te(n,"x","tile","string_or_numeric");ee(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},i={reps:e};return ve.runKernel(hv,s,i)}const vl=be({tile_:Oce});function Bce(n,e,t,s="float32"){e==null&&(e=n);const i=Hn([n,e],s),a=n<=e?n:e;for(let o=0;o<a;++o)i.set(1,o,o);const r=Ee(i.toTensor(),[n,e]);if(t==null)return r;if(t.length===1)return vl(gr(r,0),[t[0],1,1]);if(t.length===2)return vl(gr(gr(r,0),0),[t[0],t[1],1,1]);if(t.length===3)return vl(gr(gr(gr(r,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const ZM=be({eye_:Bce});function kce(n){const t={x:te(n,"x","floor","float32")};return ve.runKernel(ky,t)}const xv=be({floor_:kce});function Lce(n,e,t=0,s=0){const i=te(n,"x","gather"),a=te(e,"indices","gather","int32"),r={x:i,indices:a},o={axis:t,batchDims:s};return ve.runKernel(l_,r,o)}const yv=be({gather_:Lce});function Fce(n,e){let t=te(n,"a","greater","string_or_numeric"),s=te(e,"b","greater","string_or_numeric");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(c_,i)}const Do=be({greater_:Fce});function Uce(n,e){let t=te(n,"a","greaterEqual","string_or_numeric"),s=te(e,"b","greaterEqual","string_or_numeric");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(Fy,i)}const Td=be({greaterEqual_:Uce});function Pce(n){const t={input:te(n,"input","imag")};return ve.runKernel(cM,t)}const J_=be({imag_:Pce});function zce(n){const t={x:te(n,"x","isFinite")};return ve.runKernel(Py,t)}const XB=be({isFinite_:zce});function $ce(n){const t={x:te(n,"x","isInf")};return ve.runKernel(zy,t)}const qB=be({isInf_:$ce});function Gce(n){const t={x:te(n,"x","isNaN")};return ve.runKernel($y,t)}const KB=be({isNaN_:Gce});function Vce(n,e=.2){const s={x:te(n,"x","leakyRelu")},i={alpha:e};return ve.runKernel(u_,s,i)}const Z_=be({leakyRelu_:Vce});function Hce(n,e){let t=te(n,"a","less","string_or_numeric"),s=te(e,"b","less","string_or_numeric");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(h_,i)}const qx=be({less_:Hce});function Wce(n,e){let t=te(n,"a","lessEqual","string_or_numeric"),s=te(e,"b","lessEqual","string_or_numeric");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(d_,i)}const cp=be({lessEqual_:Wce});function jH(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return ve.runKernel(uM,{},s)}function jce(n,e=5,t=1,s=1,i=.5){const a=te(n,"x","localResponseNormalization");ee(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),ee(lg(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let r=a,o=!1;a.rank===3&&(o=!0,r=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:r},c={depthRadius:e,bias:t,alpha:s,beta:i},h=ve.runKernel(g_,l,c);return o?Ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const YB=be({localResponseNormalization_:jce});function Xce(n){const t={x:te(n,"x","log","float32")};return ve.runKernel(Gy,t)}const Jo=be({log_:Xce});function qce(n){const t={x:te(n,"x","log1p")};return ve.runKernel(Vy,t)}const Q_=be({log1p_:qce});function Kce(n){return ee(Vf(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=te(e,"x","tf.grad","string_or_numeric"),i=t!=null?te(t,"dy","tf.grad"):null;return ve.tidy(()=>{const{value:a,grads:r}=ve.gradients(()=>n(s),[s],i);return i!=null&&nr(a.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),QM(r),r[0]})}}function Yce(n){return ee(Vf(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{ee(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=cS(e,"args","tf.grads","string_or_numeric"),i=t!=null?te(t,"dy","tf.grads"):null;return ve.tidy(()=>{const{value:a,grads:r}=ve.gradients(()=>n(...s),s,i);return i!=null&&nr(a.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),QM(r),r})}}function Jce(n){return ee(Vf(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{ee(e instanceof Us,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),ee(t==null||t instanceof Us,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:i}=ve.gradients(()=>n(e),[e],t);return QM(s),{grad:s[0],value:i}}}function Zce(n){return ee(Vf(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{ee(Array.isArray(e)&&e.every(i=>i instanceof Us),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),ee(t==null||t instanceof Us,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=ve.gradients(()=>n(...e),e,t);return t!=null&&nr(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),QM(s.grads),s}}function XH(n,e){ee(Vf(n),()=>"The f passed in variableGrads(f) must be a function"),ee(e==null||Array.isArray(e)&&e.every(c=>c instanceof lS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in ve.registeredVariables)e.push(ve.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,i=e.length;e=e.filter(c=>c.trainable),ee(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const a=!0,{value:r,grads:o}=ve.gradients(n,e,null,a);ee(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ee(r.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${r.rank} tensor`);const l={};return e.forEach((c,h)=>{o[h]!=null&&(l[c.name]=o[h])}),s?.forEach(c=>l[c.name]=null),{value:r,grads:l}}function uh(n){return ve.customGrad(n)}function QM(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Qce(n){const t={x:te(n,"x","neg")};return ve.runKernel(A_,t)}const ri=be({neg_:Qce});function eue(n){const t={x:te(n,"x","softplus")};return ve.runKernel(av,t)}const Dg=be({softplus_:eue});function tue(n){const e=te(n,"x","logSigmoid");return uh(s=>({value:ri(Dg(ri(s))),gradFunc:r=>we(r,Yc(ri(s)))}))(e)}const JB=be({logSigmoid_:tue});function nue(n,e){let t=te(n,"a","sub"),s=te(e,"b","sub");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(lv,i)}const en=be({sub_:nue});function sue(n,e=-1){const t=te(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return uh((i,a)=>{const o=Al(i,e,!0),l=en(i,o),c=en(Ft(l,"float32"),Jo(sn(No(l),e,!0)));return a([c]),{value:c,gradFunc:(d,p)=>{const[g]=p,v=!0,_=No(g);return en(d,we(sn(d,e,v),_))}}})(t)}const eN=be({logSoftmax_:sue});function iue(n,e=null,t=!1){const s=te(n,"x","logSumExp"),i=es(e,s.shape),a=Al(s,i,!0),r=en(s,a),o=No(r),l=sn(o,i),c=Jo(l),h=bt(Ee(a,c.shape),c);if(t){const d=Xi(h.shape,i);return Ee(h,d)}return h}const eA=be({logSumExp_:iue});function aue(n,e){const t=te(n,"a","logicalAnd","bool"),s=te(e,"b","logicalAnd","bool");kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(f_,i)}const eu=be({logicalAnd_:aue});function rue(n){const t={x:te(n,"x","logicalNot","bool")};return ve.runKernel(p_,t)}const tA=be({logicalNot_:rue});function oue(n,e){const t=te(n,"a","logicalOr","bool"),s=te(e,"b","logicalOr","bool");kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(m_,i)}const tN=be({logicalOr_:oue});function lue(n,e){const t=te(n,"a","logicalXor","bool"),s=te(e,"b","logicalXor","bool");return kn(t.shape,s.shape),eu(tN(n,e),tA(eu(n,e)))}const ZB=be({logicalXor_:lue});const jC=2147483648;function cue(n,e,t="left"){const s=te(n,"sortedSequence","searchSorted"),i=te(e,"values","searchSorted"),a=s.shape[s.shape.length-1],r=i.shape[i.shape.length-1],o=Ee(s,[-1,a]),l=Ee(i,[-1,r]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(qe(l.shape)>=jC)throw new Error(`values tensor size must less than ${jC}`);if(o.shape[1]>=jC)throw new Error(`trailing dim_size must less than ${jC} for int32 output type, was ${o.shape[1]}`);const c={sortedSequence:o,values:l},h={side:t};return ve.runKernel(MM,c,h)}const nN=be({searchSorted_:cue});function qH(n,e){return nN(n,e,"left")}function uue(n,e,t,s,i){const a=te(n,"x","maxPool"),r=1;let o=a,l=!1;a.rank===3&&(l=!0,o=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ee(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),ee(sr(t,r),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),Kr("maxPool",s,i);const c={x:o},h={filterSize:e,strides:t,pad:s,dimRoundingMode:i},d=ve.runKernel(y_,c,h);return l?Ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const nA=be({maxPool_:uue});function hue(n,e=[1,1,1],t,s,i,a="NDHWC"){const r=te(n,"x","maxPool3d");let o=r,l=!1;r.rank===4&&(l=!0,o=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]])),ee(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),ee(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Kr("maxPool3d",s,i);const c={x:o},h={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:a},d=ve.runKernel(v_,c,h);return l?Ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const QB=be({maxPool3d_:hue});function due(n,e,t,s,i=!1){const r={x:te(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:i},l=ve.runKernel(pM,r,o);return{result:l[0],indexes:l[1]}}const KH=be({maxPoolWithArgmax_:due});function fue(n,e){let t=te(n,"a","maximum"),s=te(e,"b","maximum");[t,s]=Ei(t,s),t.dtype==="bool"&&(t=Ft(t,"int32"),s=Ft(s,"int32")),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(Hy,i)}const mh=be({maximum_:fue});function pue(n,e=null,t=!1){const i={x:te(n,"x","mean")},a={axis:e,keepDims:t};return ve.runKernel(b_,i,a)}const Ai=be({mean_:pue});function aa(n,e="float32"){if(tl(n),e==="complex64"){const s=aa(n,"float32"),i=aa(n,"float32");return xd(s,i)}const t=tr(qe(n),e);return ve.makeTensor(t,n,e)}function _o(n,e="float32"){if(tl(n),e==="complex64"){const s=_o(n,"float32"),i=aa(n,"float32");return xd(s,i)}const t=F2(qe(n),e);return ve.makeTensor(t,n,e)}function YH(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=te(n,"x","meshgrid",n instanceof Us?n.dtype:"float32");if(e===void 0)return[s];let i=te(e,"y","meshgrid",e instanceof Us?e.dtype:"float32");const a=qe(s.shape),r=qe(i.shape);return t==="xy"?(s=Ee(s,[1,-1]),i=Ee(i,[-1,1]),[Zn(_o([r,1],s.dtype),s),Zn(i,_o([1,a],i.dtype))]):(s=Ee(s,[-1,1]),i=Ee(i,[1,-1]),[Zn(s,_o([1,r],s.dtype)),Zn(_o([a,1],i.dtype),i)])}function mue(n,e){let t=te(n,"a","minimum"),s=te(e,"b","minimum");[t,s]=Ei(t,s),t.dtype==="bool"&&(t=Ft(t,"int32"),s=Ft(s,"int32")),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(Wy,i)}const qf=be({minimum_:mue});function gue(n,e,t){ee(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=te(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ee(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)ee(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ee(e[o][0]>=0&&e[o][0]<=s.shape[o]-i&&e[o][1]>=0&&e[o][1]<=s.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-i} or less than 0 for input of shape ${s.shape}`);const a={paddings:e,mode:t},r={x:s};return ve.runKernel(__,r,a)}const ek=be({mirrorPad_:gue});function xue(n,e){let t=te(n,"a","mod"),s=te(e,"b","mod");[t,s]=Ei(t,s);const i={a:t,b:s};return ve.runKernel(jy,i)}const tk=be({mod_:xue});function yue(n,e=null,t=!1){n=te(n,"x","moments");const s=es(e,n.shape),i=Ai(n,s,t);let a=i.shape;t||(a=Xi(i.shape,s));const r=Xs(en(Ft(n,"float32"),Ee(i,a))),o=Ai(r,s,t);return{mean:i,variance:o}}const sA=be({moments_:yue});function vue(n,e,t,s){const i=te(e,"data","multiRNNCell"),a=cS(t,"c","multiRNNCell"),r=cS(s,"h","multiRNNCell");let o=i;const l=[];for(let d=0;d<n.length;d++){const p=n[d](o,a[d],r[d]);l.push(p[0]),l.push(p[1]),o=p[1]}const c=[],h=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),h.push(l[d+1]);return[c,h]}const JH=be({multiRNNCell_:vue});function bue(n,e,t,s=!1){const i=te(n,"logits","multinomial"),a=i.size,r=i.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(r>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${r}`);t=t||Math.random();const l={logits:r===1?Ee(i,[1,-1]):i},c={numSamples:e,seed:t,normalized:s},h=ve.runKernel(mM,l,c);return r===1?Ee(h,[h.size]):h}const ZH=be({multinomial_:bue});function Sue(n,e){let t=te(n,"a","notEqual","string_or_numeric"),s=te(e,"b","notEqual","string_or_numeric");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s};return ve.runKernel(w_,i)}const mg=be({notEqual_:Sue});function _ue(n,e,t=1,s=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r={indices:te(n,"indices","oneHot","int32")},o={dtype:i,depth:e,onValue:t,offValue:s};return ve.runKernel(T_,r,o)}const Kx=be({oneHot_:_ue});function Aue(n){const t={x:te(n,"x","onesLike")};return ve.runKernel(C_,t)}const Zo=be({onesLike_:Aue});function wue(n,e){const t=te(n,"v1","outerProduct"),s=te(e,"v2","outerProduct");ee(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const i=Ee(t,[-1,1]),a=Ee(s,[1,-1]);return Zn(i,a)}const QH=be({outerProduct_:wue});function Cue(n,e,t=0){const s=te(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},a={x:s};return ve.runKernel(M_,a,i)}const Ed=be({pad_:Cue});function Tue(n,e,t=0){return ee(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ed(n,[e],t)}const e5=be({pad1d_:Tue});function Eue(n,e,t=0){return ee(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ed(n,e,t)}const t5=be({pad2d_:Eue});function Mue(n,e,t=0){return ee(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ed(n,e,t)}const n5=be({pad3d_:Mue});function Nue(n,e,t=0){return ee(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ed(n,e,t)}const s5=be({pad4d_:Nue});function Rue(n,e,t){const s=te(n,"x","spaceToBatchND");ee(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),ee(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),ee(s.shape.reduce((r,o,l)=>l>0&&l<=e.length?r&&(o+t[l-1][0]+t[l-1][1])%e[l-1]===0:r,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:s},a={blockShape:e,paddings:t};return ve.runKernel(U_,i,a)}const iA=be({spaceToBatchND_:Rue});function Iue(n,e,t,s,i,a,r){i==null&&(i=[1,1]),a==null&&(a=1),s===0&&(s="valid");const o=te(n,"x","maxPool");let l=o,c=!1;o.rank===3&&(c=!0,l=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ee(sr(a,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);const h=uc(l.shape,e,a,i,s),d=[h.dilationHeight,h.dilationWidth];let p;s==="same"?p=Oue([h.filterHeight,h.filterWidth],d):p=[[0,0],[0,0]];const g=d[0]===1&&d[1]===1,[v,_]=Due([h.inHeight,h.inWidth],d,p),S=g?s:"valid",b=g?l:iA(l,d,v),T=(t==="avg"?()=>q_(b,e,a,S,r):()=>nA(b,e,a,S,r))(),E=g?T:K_(T,d,_);return c?Ee(E,[E.shape[1],E.shape[2],E.shape[3]]):E}function Due(n,e,t){const s=t.map(h=>h[0]),i=t.map(h=>h[1]),a=n.concat(s,i),r=e.map((h,d)=>(h-a[d]%h)%h),o=i.map((h,d)=>h+r[d]),l=e.map((h,d)=>[s[d],o[d]]),c=e.map((h,d)=>[0,r[d]]);return[l,c]}function Oue(n,e){const s=n.map((r,o)=>r+(r-1)*(e[o]-1)).map(r=>r-1),i=s.map(r=>Math.floor(r/2)),a=s.map((r,o)=>r-i[o]);return s.map((r,o)=>[i[o],a[o]])}const nk=be({pool_:Iue});function Bue(n,e){const t=te(n,"x","prelu"),s=te(e,"alpha","prelu"),i={x:t,alpha:s};return ve.runKernel(N_,i)}const aA=be({prelu_:Bue});function kue(n,e=null,t=!1){let s=te(n,"x","prod");s.dtype==="bool"&&(s=Ft(s,"int32"));const i={x:s},a={axis:e,keepDims:t};return ve.runKernel(R_,i,a)}const sk=be({prod_:kue});function Lue(n,e,t,s){const i=n.map((h,d)=>te(h,`tensors${d}`,"raggedGather","int32")),a=te(e,"paramsDenseValues","raggedGather"),r=te(t,"indices","raggedGather","int32"),o={paramsNestedSplits:i,paramsDenseValues:a,indices:r},l={outputRaggedRank:s},c=ve.runKernel(vM,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const i5=be({raggedGather_:Lue});function Fue(n,e,t){const s=te(n,"starts","raggedRange"),i=te(e,"limits","raggedRange",s.dtype),a=te(t,"deltas","raggedRange",s.dtype),r={starts:s,limits:i,deltas:a},o=ve.runKernel(bM,r);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const a5=be({raggedRange_:Fue});function Uue(n,e,t,s,i){const a=te(n,"shape","raggedTensorToTensor","int32"),r=te(e,"values","raggedTensorToTensor"),o=te(t,"defaultValue","raggedTensorToTensor",r.dtype),l=s.map((d,p)=>te(d,`tensors${p}`,"raggedTensorToTensor","int32")),c={shape:a,values:r,defaultValue:o,rowPartitionTensors:l},h={rowPartitionTypes:i};return ve.runKernel(SM,c,h)}const r5=be({raggedTensorToTensor_:Uue});function Pue(n,e,t){tl(n);const s=qe(n);let i=null;if(t==null||t==="float32")i=new Float32Array(s);else if(t==="int32")i=new Int32Array(s);else if(t==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let a=0;a<s;a++)i[a]=e();return ve.makeTensor(i,n,t)}const o5=be({rand_:Pue});var mT={exports:{}},zue=mT.exports,yz;function $ue(){return yz||(yz=1,(function(n){(function(e,t,s){function i(l){var c=this,h=o();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function a(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function r(l,c){var h=new i(l),d=c&&c.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&a(d,h),p.state=function(){return a(h,{})}),p}function o(){var l=4022871197,c=function(h){h=String(h);for(var d=0;d<h.length;d++){l+=h.charCodeAt(d);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=r:this.alea=r})(zue,n)})(mT)),mT.exports}var gT={exports:{}},Gue=gT.exports,vz;function Vue(){return vz||(vz=1,(function(n){(function(e,t,s){function i(o){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},o===(o|0)?l.x=o:c+=o;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function r(o,l){var c=new i(o),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}t&&t.exports?t.exports=r:this.xor128=r})(Gue,n)})(gT)),gT.exports}var xT={exports:{}},Hue=xT.exports,bz;function Wue(){return bz||(bz=1,(function(n){(function(e,t,s){function i(o){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:c+=o;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function r(o,l){var c=new i(o),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}t&&t.exports?t.exports=r:this.xorwow=r})(Hue,n)})(xT)),xT.exports}var yT={exports:{}},jue=yT.exports,Sz;function Xue(){return Sz||(Sz=1,(function(n){(function(e,t,s){function i(o){var l=this;l.next=function(){var h=l.x,d=l.i,p,g;return p=h[d],p^=p>>>7,g=p^p<<24,p=h[d+1&7],g^=p^p>>>10,p=h[d+3&7],g^=p^p>>>3,p=h[d+4&7],g^=p^p<<7,p=h[d+7&7],p=p^p<<13,g^=p^p<<9,h[d]=g,l.i=d+1&7,g};function c(h,d){var p,g=[];if(d===(d|0))g[0]=d;else for(d=""+d,p=0;p<d.length;++p)g[p&7]=g[p&7]<<15^d.charCodeAt(p)+g[p+1&7]<<13;for(;g.length<8;)g.push(0);for(p=0;p<8&&g[p]===0;++p);for(p==8?g[7]=-1:g[p],h.x=g,h.i=0,p=256;p>0;--p)h.next()}c(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function r(o,l){o==null&&(o=+new Date);var c=new i(o),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},d.int32=c.next,d.quick=d,h&&(h.x&&a(h,c),d.state=function(){return a(c,{})}),d}t&&t.exports?t.exports=r:this.xorshift7=r})(jue,n)})(yT)),yT.exports}var vT={exports:{}},que=vT.exports,_z;function Kue(){return _z||(_z=1,(function(n){(function(e,t,s){function i(o){var l=this;l.next=function(){var h=l.w,d=l.X,p=l.i,g,v;return l.w=h=h+1640531527|0,v=d[p+34&127],g=d[p=p+1&127],v^=v<<13,g^=g<<17,v^=v>>>15,g^=g>>>12,v=d[p]=v^g,l.i=p,v+(h^h>>>16)|0};function c(h,d){var p,g,v,_,S,b=[],w=128;for(d===(d|0)?(g=d,d=null):(d=d+"\0",g=0,w=Math.max(w,d.length)),v=0,_=-32;_<w;++_)d&&(g^=d.charCodeAt((_+32)%d.length)),_===0&&(S=g),g^=g<<10,g^=g>>>15,g^=g<<4,g^=g>>>13,_>=0&&(S=S+1640531527|0,p=b[_&127]^=g+S,v=p==0?v+1:0);for(v>=128&&(b[(d&&d.length||0)&127]=-1),v=127,_=512;_>0;--_)g=b[v+34&127],p=b[v=v+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,b[v]=g^p;h.w=S,h.X=b,h.i=v}c(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function r(o,l){o==null&&(o=+new Date);var c=new i(o),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},d.int32=c.next,d.quick=d,h&&(h.X&&a(h,c),d.state=function(){return a(c,{})}),d}t&&t.exports?t.exports=r:this.xor4096=r})(que,n)})(vT)),vT.exports}var bT={exports:{}},Yue=bT.exports,Az;function Jue(){return Az||(Az=1,(function(n){(function(e,t,s){function i(o){var l=this,c="";l.next=function(){var d=l.b,p=l.c,g=l.d,v=l.a;return d=d<<25^d>>>7^p,p=p-g|0,g=g<<24^g>>>8^v,v=v-d|0,l.b=d=d<<20^d>>>12^p,l.c=p=p-g|0,l.d=g<<16^p>>>16^v,l.a=v-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):c+=o;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function r(o,l){var c=new i(o),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,g=(c.next()>>>0)/4294967296,v=(p+g)/(1<<21);while(v===0);return v},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&a(h,c),d.state=function(){return a(c,{})}),d}t&&t.exports?t.exports=r:this.tychei=r})(Yue,n)})(bT)),bT.exports}var ST={exports:{}};const Zue={},Que=Object.freeze(Object.defineProperty({__proto__:null,default:Zue},Symbol.toStringTag,{value:"Module"})),ehe=VD(Que);var the=ST.exports,wz;function nhe(){return wz||(wz=1,(function(n){(function(e,t,s){var i=256,a=6,r=52,o="random",l=s.pow(i,a),c=s.pow(2,r),h=c*2,d=i-1,p;function g(E,R,D){var F=[];R=R==!0?{entropy:!0}:R||{};var U=b(S(R.entropy?[E,T(t)]:E??w(),3),F),O=new v(F),B=function(){for(var L=O.g(a),H=l,K=0;L<c;)L=(L+K)*i,H*=i,K=O.g(1);for(;L>=h;)L/=2,H/=2,K>>>=1;return(L+K)/H};return B.int32=function(){return O.g(4)|0},B.quick=function(){return O.g(4)/4294967296},B.double=B,b(T(O.S),t),(R.pass||D||function(L,H,K,Z){return Z&&(Z.S&&_(Z,O),L.state=function(){return _(O,{})}),K?(s[o]=L,H):L})(B,U,"global"in R?R.global:this==s,R.state)}function v(E){var R,D=E.length,F=this,U=0,O=F.i=F.j=0,B=F.S=[];for(D||(E=[D++]);U<i;)B[U]=U++;for(U=0;U<i;U++)B[U]=B[O=d&O+E[U%D]+(R=B[U])],B[O]=R;(F.g=function(L){for(var H,K=0,Z=F.i,Q=F.j,P=F.S;L--;)H=P[Z=d&Z+1],K=K*i+P[d&(P[Z]=P[Q=d&Q+H])+(P[Q]=H)];return F.i=Z,F.j=Q,K})(i)}function _(E,R){return R.i=E.i,R.j=E.j,R.S=E.S.slice(),R}function S(E,R){var D=[],F=typeof E,U;if(R&&F=="object")for(U in E)try{D.push(S(E[U],R-1))}catch{}return D.length?D:F=="string"?E:E+"\0"}function b(E,R){for(var D=E+"",F,U=0;U<D.length;)R[d&U]=d&(F^=R[d&U]*19)+D.charCodeAt(U++);return T(R)}function w(){try{var E;return p&&(E=p.randomBytes)?E=E(i):(E=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(E)),T(E)}catch{var R=e.navigator,D=R&&R.plugins;return[+new Date,e,D,e.screen,T(t)]}}function T(E){return String.fromCharCode.apply(0,E)}if(b(s.random(),t),n.exports){n.exports=g;try{p=ehe}catch{}}else s["seed"+o]=g})(typeof self<"u"?self:the,[],Math)})(ST)),ST.exports}var a3,Cz;function she(){if(Cz)return a3;Cz=1;var n=$ue(),e=Vue(),t=Wue(),s=Xue(),i=Kue(),a=Jue(),r=nhe();return r.alea=n,r.xor128=e,r.xorwow=t,r.xorshift7=s,r.xor4096=i,r.tychei=a,a3=r,a3}var sN=she();const ihe=.001,l5=.1;function ahe(n,e,t){return t==null&&(t=ik()),uD(n,e,(s,i)=>ak(s,i,t))}function ik(){return ve.backend.floatPrecision()===32?ihe:l5}function uD(n,e,t){let s=!0;if((Ra(n)||Ra(e))&&(s=!1),Ra(n)&&Ra(e)&&(s=!0),s){const r=n.constructor.name,o=e.constructor.name;if(r!==o)throw new Error(`Arrays are of different type. Actual: ${r}. Expected: ${o}`)}if(Array.isArray(n)&&Array.isArray(e)){const r=lh(n),o=lh(e);if(!as(r,o))throw new Error(`Arrays have different shapes. Actual: [${r}]. Expected: [${o}]`)}const i=Ra(n)?n:oh(n),a=Ra(e)?e:oh(e);if(i.length!==a.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${a.length}.
Actual:   ${i}.
Expected: ${a}.`);for(let r=0;r<a.length;++r){const o=i[r],l=a[r];if(!t(o,l))throw new Error(`Arrays differ: actual[${r}] = ${o}, expected[${r}] = ${l}.
Actual:   ${i}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function rhe(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function ohe(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Ku(n)||Ku(n[0])||Ku(e)||Ku(e[0])?uD(n,t,(s,i)=>s==i):uD(n,e,(s,i)=>ak(s,i,0))}function lhe(n,e,t){if(t==null&&(t=ik()),!ak(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function ak(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function che(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function uhe(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let i=0;i<s.length;i++)if(t[i]!==s[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${s[i]} but got ${t[i]} instead`)}function c5(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?c5(t):n[e]=Qu(t)}return n}function hhe(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function dhe(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const fhe=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:l5,createVideoElement:hhe,encodeStrings:c5,expectArrayBuffersEqual:uhe,expectArraysClose:ahe,expectArraysEqual:ohe,expectNumbersClose:lhe,expectPromiseToFail:rhe,expectValuesInRange:che,play:dhe,testEpsilon:ik},Symbol.toStringTag,{value:"Module"}));class rk{constructor(e,t,s,i,a){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const r=a||Math.random();this.random=sN.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,s=!1;for(;!s;){let i,a,r;do i=2*this.random()-1,a=2*this.random()-1,r=i*i+a*a;while(r>=1||r===0);const o=Math.sqrt(-2*Math.log(r)/r);e=this.mean+this.stdDev*i*o,t=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class phe{constructor(e,t,s,i){this.alpha=e,this.beta=1/t,this.dtype=s;const a=i||Math.random();this.randu=sN.alea(a.toString()),this.randn=new rk(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,i,a,r;for(;;){do i=this.randn.nextValue(),r=1+this.c*i;while(r<=0);if(r*=r*r,e=i*i,t=1-.331*e*e,s=.5*e+this.d*(1-r+Math.log(r)),a=this.randu(),a<t||Math.log(a)<s)break}return r=1/this.beta*this.d*r,this.alpha<1&&(r*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(r)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class mhe{constructor(e=0,t=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=sN.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function ghe(n,e,t=1,s="float32",i){if(tl(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new phe(e,t,s,i),r=Hn(n,s);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const u5=be({randomGamma_:ghe});function xhe(n,e=0,t=1,s,i){if(tl(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new rk(e,t,s,!1,i),r=Hn(n,s);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const iN=be({randomNormal_:xhe});function yhe(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return iN(n,0,1,e,t)}const h5=be({randomStandardNormal_:yhe});function vhe(n,e=0,t=1,s="float32",i){tl(n);const a=Hn(n,s),r=new mhe(e,t,null,i);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const up=be({randomUniform_:vhe});function bhe(n,e,t,s){return up(n,e,t,"int32",s)}const d5=be({randomUniformInt_:bhe});function gg(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:s};return ve.runKernel(_M,{},i)}function She(n){const t={input:te(n,"input","real")};return ve.runKernel(AM,t)}const Yx=be({real_:She});function _he(n){const t={x:te(n,"x","reciprocal")};return ve.runKernel(Ky,t)}const ok=be({reciprocal_:_he});function Ahe(n){const t={x:te(n,"x","relu")};return ve.runKernel(Yy,t)}const ou=be({relu_:Ahe});function whe(n){const t={x:te(n,"x","relu6")};return ve.runKernel(Jy,t)}const aN=be({relu6_:whe});function Che(n,e){const s={x:te(n,"x","reverse")},i={dims:e};return ve.runKernel(B_,s,i)}const Cl=be({reverse_:Che});function The(n){const e=te(n,"x","reverse");return ee(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Cl(e,0)}const f5=be({reverse1d_:The});function Ehe(n,e){const t=te(n,"x","reverse");return ee(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Cl(t,e)}const p5=be({reverse2d_:Ehe});function Mhe(n,e){const t=te(n,"x","reverse");return ee(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Cl(t,e)}const m5=be({reverse3d_:Mhe});function Nhe(n,e){const t=te(n,"x","reverse");return ee(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Cl(t,e)}const g5=be({reverse4d_:Nhe});function Rhe(n){const t={x:te(n,"x","round")};return ve.runKernel(Zy,t)}const rN=be({round_:Rhe});function Ihe(n){const t={x:te(n,"x","rsqrt","float32")};return ve.runKernel(Qy,t)}const oN=be({rsqrt_:Ihe});function Dhe(n){const t={x:te(n,"x","selu")};return ve.runKernel(ev,t)}const lN=be({selu_:Dhe});function Ohe(n,e,t,s,i,a=[1,1],r="NHWC"){const o=te(n,"x","separableConv2d"),l=te(e,"depthwiseFilter","separableConv2d"),c=te(t,"pointwiseFilter","separableConv2d");let h=o,d=!1;if(o.rank===3&&(d=!0,h=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),r==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ee(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),ee(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),ee(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),ee(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),ee(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const p=l.shape[2],g=l.shape[3];ee(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);const v=pv(h,l,s,i,r,a),S=yd(v,c,1,"valid",r);return d?Ee(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const cN=be({separableConv2d_:Ohe});async function Bhe(n,e){const t=te(n,"x","setdiff1d"),s=te(e,"y","setdiff1d");ee(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),ee(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),ee(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await t.data(),a=await s.data(),r=new Set(a);let o=0;for(let h=0;h<i.length;h++)r.has(i[h])||o++;const l=new oa([o],t.dtype),c=new oa([o],"int32");for(let h=0,d=0;h<i.length;h++)r.has(i[h])||(l.values[d]=i[h],c.values[d]=h,d++);return[l.toTensor(),c.toTensor()]}const x5=Bhe;function khe(n){const t={x:te(n,"x","sign")};return ve.runKernel(sv,t)}const lk=be({sign_:khe});function Lhe(n){const t={x:te(n,"x","sin","float32")};return ve.runKernel(tv,t)}const uN=be({sin_:Lhe});function Fhe(n){const t={x:te(n,"x","sinh")};return ve.runKernel(nv,t)}const hN=be({sinh_:Fhe});function Uhe(n,e,t){const s=te(n,"x","slice1d");return ee(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),ds(s,[e],[t])}const rA=be({slice1d_:Uhe});function Phe(n,e,t){const s=te(n,"x","slice2d");return ee(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),ds(s,e,t)}const dN=be({slice2d_:Phe});function zhe(n,e,t){const s=te(n,"x","slice3d");return ee(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),ds(s,e,t)}const oA=be({slice3d_:zhe});function $he(n,e,t){const s=te(n,"x","slice4d");return ee(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),ds(s,e,t)}const Jx=be({slice4d_:$he});function Ghe(n,e=-1){const t=te(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},i={dim:e};return ve.runKernel(z_,s,i)}const lA=be({softmax_:Ghe});function Vhe(n){ee(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ve.runKernel(iM,e)}const cA=be({fft_:Vhe});function Hhe(n){ee(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ve.runKernel(lM,e)}const Zx=be({ifft_:Hhe});function Whe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const i=Ee(n,[t,e]);s=Zx(i)}else{const i=[t,2*(e-1)],a=Ee(Yx(n),[t,e]),r=Ee(J_(n),[t,e]),o=Cl(ds(a,[0,1],[t,e-2]),1),l=we(Cl(ds(r,[0,1],[t,e-2]),1),vn(-1)),c=ji([a,o],1),h=ji([r,l],1),d=Ee(xd(c,h),[i[0],i[1]]);s=Zx(d)}if(s=Yx(s),n.rank===3&&n.shape[0]!==0){const i=s,a=n.shape[0];s=Ee(s,[a,s.shape[0]/a,s.shape[1]]),i.dispose()}return s}const fN=be({irfft_:Whe});function jhe(n,e,t=0){const i={x:te(n,"x","split")},a={numOrSizeSplits:e,axis:t};return ve.runKernel(P_,i,a)}const wo=be({split_:jhe});function Xhe(n,e){ee(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let i;if(e!=null&&e<t){const v=n.shape.map(S=>0),_=n.shape.map(S=>S);_[n.shape.length-1]=e,i=ds(n,v,_),t=e}else if(e!=null&&e>t){const v=n.shape.map(_=>_);v[n.shape.length-1]=e-t,i=ji([n,aa(v)],n.shape.length-1),t=e}else i=n;const a=ps(i),r=Ee(xd(i,a),[s,t]),o=cA(r),l=Math.floor(t/2)+1,c=Yx(o),h=J_(o),d=wo(c,[l,t-l],c.shape.length-1),p=wo(h,[l,t-l],h.shape.length-1),g=i.shape.slice();return g[i.shape.length-1]=l,Ee(xd(d[0],p[0]),g)}const uA=be({rfft_:Xhe});function qhe(n,e){let t=te(n,"a","squaredDifference"),s=te(e,"b","squaredDifference");[t,s]=Ei(t,s),kn(t.shape,s.shape);const i={a:t,b:s},a={};return ve.runKernel(ov,i,a)}const pN=be({squaredDifference_:qhe});function Khe(n,e){const t=te(n,"x","squeeze","string_or_numeric");return Ee(t,_d(t.shape,e).newShape)}const hp=be({squeeze_:Khe});function Yhe(n,e=0){const t=cS(n,"tensors","stack","string_or_numeric");ee(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&ee(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,i={axis:e};return ve.runKernel(E_,s,i)}const Ro=be({stack_:Yhe});function Jhe(n,e=0){const s={x:te(n,"x","step")},i={alpha:e};return ve.runKernel(dv,s,i)}const Og=be({step_:Jhe});function Zhe(n,e,t,s,i=0,a=0,r=0,o=0,l=0){const h={x:te(n,"x","stridedSlice","string_or_numeric")},d={begin:e,end:t,strides:s,beginMask:i,endMask:a,ellipsisMask:r,newAxisMask:o,shrinkAxisMask:l};return ve.runKernel(kM,h,d)}const ck=be({stridedSlice_:Zhe});function Qhe(n){const t={x:te(n,"x","tan","float32")};return ve.runKernel(cv,t)}const uk=be({tan_:Qhe});function xr(n,e){Eg(n);const t=lh(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return rp(n,null,t,e)}function Ex(n,e,t){if(Eg(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=lh(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return rp(n,e,s,t)}function hk(n,e,t){if(Eg(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=lh(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return rp(n,e,s,t)}function y5(n,e,t){if(Eg(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=lh(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return rp(n,e,s,t)}function v5(n,e,t){if(Eg(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=lh(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return rp(n,e,s,t)}function b5(n,e,t){if(Eg(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=lh(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,rp(n,e,s,t)}function dk(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(a+` update.rank < ${i}. `);if(n.length<s+(t.rank-i))throw new Error(a+` Output shape length < ${s+(t.rank-i)}`);if(t.rank!==i+n.length-s)throw new Error(a+` update.rank != ${i+n.length-s}`);for(let r=0;r<i;++r)if(t.shape[r]!==e.shape[r])throw new Error(a+` updates.shape[${r}] (${t.shape[r]}) != indices.shape[${r}] (${e.shape[r]}).`);for(let r=0;r<t.rank-i;++r)if(t.shape[r+i]!==n[r+s])throw new Error(a+` updates.shape[${r+i}] (${t.shape[r+i]}) != shape[${r+i}] (${n[r+i]})`)}function mN(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}dk(t,e,n)}function dp(n,e,t){const s=e.shape.length,i=s>1?e.shape[s-1]:1,a=t.length;let r=1;for(let d=i;d<a;++d)r*=t[d];const o=i<1?1:i,l=qe(e.shape)/o,c=[...gn(t.slice(0,i)),1],h=qe(t);return{sliceRank:i,numUpdates:l,sliceSize:r,strides:c,outputSize:h}}const ede=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:dp,validateInput:mN,validateUpdateShape:dk},Symbol.toStringTag,{value:"Module"}));function tde(n,e,t){const s=te(n,"tensor","tensorScatterupdate"),i=te(e,"indices","tensorScatterupdate","int32"),a=te(t,"updates","tensorScatterupdate");if(mN(a,i,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const r={tensor:s,indices:i,updates:a},o={};return ve.runKernel(EM,r,o)}const S5=be({tensorScatterUpdate_:tde});function nde(n,e=1,t=!0){const s=te(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const a={x:s},r={k:e,sorted:t},[o,l]=ve.runKernel(PM,a,r);return{values:o,indices:l}}const fk=be({topk_:nde});function sde(n,e=0,t=1,s,i){if(tl(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new rk(e,t,s,!0,i),r=Hn(n,s);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const gN=be({truncatedNormal_:sde});function ide(n,e=0){const t=te(n,"x","unique","string_or_numeric");ee(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},i={axis:e},[a,r]=ve.runKernel($M,s,i);return{values:a,indices:r}}const pk=be({unique_:ide});function ade(n,e,t){const s=te(n,"x","unsortedSegmentSum"),i=te(e,"segmentIds","unsortedSegmentSum","int32");ee(lg(t),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:i},r={numSegments:t};return ve.runKernel(V_,a,r)}const xN=be({unsortedSegmentSum_:ade});function rde(n,e=0){const t=te(n,"x","unstack","string_or_numeric");ee(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},i={axis:e};return ve.runKernel(G_,s,i)}const Tl=be({unstack_:rde});function _5(n,e){return nN(n,e,"right")}function mk(n,e=!0,t,s){return ve.makeVariable(n,e,t,s)}function yN(n,e){const t=[];for(let a=0;a<e.length;a++)e[a]&&t.push(a);const s=Hn(n,"int32"),i=Hn([t.length,n.length],"int32");for(let a=0;a<t.length;a++){const r=s.indexToLoc(t[a]),o=a*n.length;i.values.set(r,o)}return i.toTensor()}async function ode(n){const e=te(n,"condition","whereAsync","bool"),t=await e.data(),s=yN(e.shape,t);return n!==e&&e.dispose(),s}const gk=ode;async function lde(n,e,t){const s=te(n,"tensor","boolMask"),i=te(e,"mask","boolMask","bool"),a=t??0,r=i.rank,o=s.shape;ee(r>0,()=>"mask cannot be scalar"),nr(o.slice(a,a+r),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let _=a;_<a+r;_++)l*=o[_];const c=o.slice(0,a).concat([l],o.slice(a+r)),h=Ee(s,c),d=Ee(i,[-1]),p=await gk(d),g=hp(p,[1]),v=yv(h,g,a);return n!==s&&s.dispose(),e!==i&&i.dispose(),g.dispose(),h.dispose(),d.dispose(),p.dispose(),v}const A5=lde;function cde(n,e,t){const s=te(n,"x","transpose");if(e==null&&(e=s.shape.map((r,o)=>o).reverse()),ee(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(r=>{ee(r>=0&&r<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const i={x:s},a={perm:e};return s.dtype==="complex64"?Le(()=>{let r=Yx(s),o=J_(s);return r=ve.runKernel(Km,{x:r},a),o=ve.runKernel(Km,{x:o},a),t&&(o=ri(o)),xd(r,o)}):ve.runKernel(Km,i,a)}const ls=be({transpose_:cde});function ude(n,e,t,s,i=!0){const a=te(n,"v","movingAverage"),r=te(e,"x","movingAverage"),o=te(t,"decay","movingAverage");vH(a,r),ee(as(a.shape,r.shape),()=>"Shape mismatch in v and x");const l=vn(1),c=en(l,o);let h=we(en(r,a),c);if(i){ee(s!=null,()=>"When using zeroDebias: true, step is required.");const d=te(s,"step","movingAverage");h=un(h,en(l,ch(o,d)))}return bt(a,h)}const w5=be({movingAverage_:ude});function hde(n,e,t){tl(t);const s=te(n,"indices","scatterND","int32"),i=te(e,"updates","scatterND");mN(i,s,t);const a={indices:s,updates:i},r={shape:t};return ve.runKernel(TM,a,r)}const C5=be({scatterND_:hde});function dde(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,a=n.rank>1?n.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const r=e.size;if(!(e.rank===0||e.rank===1&&r===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function fde(n,e,t,s=0){tl(t);const i=te(n,"sparseIndices","sparseToDense","int32"),a=te(e,"sparseValues","sparseToDense","string_or_numeric"),r=te(s,"defaultValue","sparseToDense",a.dtype);dde(i,a,t,r);const o={sparseIndices:i,sparseValues:a,defaultValue:r},l={outputShape:t};return ve.runKernel(OM,o,l)}const T5=be({sparseToDense_:fde});function pde(n,e){const t=te(e,"indices","gatherND","int32"),i={params:te(n,"x","gatherND","string_or_numeric"),indices:t};return ve.runKernel(oM,i)}const E5=be({gatherND_:pde});function mde(n,e){if(e==null)return n.shape.slice();if(as(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function gde(n,e,t,s){const i=te(n,"x","dropout");if(ee(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),ee(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Us?i.clone():i;const a=mde(i,t),r=1-e,o=un(xv(bt(up(a,0,1,"float32",s),r)),r);return we(i,o)}const xk=be({dropout_:gde});function yk(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function vN(n,e,t){const s=1-n%2,i=new Float32Array(n);for(let a=0;a<n;++a){const r=2*Math.PI*a/(n+s-1);i[a]=e-t*Math.cos(r)}return xr(i,"float32")}async function xde(n,e,t=1){const s=te(n,"predictions","inTopK"),i=te(e,"targets","inTopK");ee(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),ee(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),nr(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];ee(t>0&&t<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${t}`);const r=await s.data(),o=await i.data(),[l,c]=[r.length/a,a],h=ka("bool",l);for(let d=0;d<l;d++){const p=d*c,g=r.subarray(p,p+c),v=[];for(let _=0;_<g.length;_++)v.push({value:g[_],index:_});v.sort((_,S)=>S.value-_.value),h[d]=0;for(let _=0;_<t;_++)if(v[_].index===o[d]){h[d]=1;break}}return n!==s&&s.dispose(),e!==i&&i.dispose(),rc(h,i.shape,"bool")}const M5=xde;function yde(n,e,t,s,i,a="NHWC",r){let o=n;n.rank===3&&(o=Ee(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=Ee(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ee(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),ee(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),ee(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=a==="NHWC"?o.shape[3]:o.shape[1],h=a==="NHWC"?l.shape[3]:l.shape[1];ee(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),ee(h===t[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${t[3]}).`),Kr("conv2dDerFilter",i,r);const d={x:o,dy:l},p={strides:s,pad:i,dataFormat:a,dimRoundingMode:r,filterShape:t};return ve.runKernel(W2,d,p)}const vk=be({conv2DBackpropFilter_:yde});function bN(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return we(n,Og(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function SN(n,e){let t=e;const s=la(n.shape,e.shape);return s.length>0&&(t=sn(t,s)),Ee(t,n.shape)}function _N(n,e,t,s){if(e==="linear")return n;if(e==="relu")return ou(n);if(e==="elu")return mv(n);if(e==="relu6")return aN(n);if(e==="prelu")return aA(n,t);if(e==="leakyrelu")return Z_(n,s);if(e==="sigmoid")return Yc(n);throw new Error(`Unknown fused activation ${e}.`)}const AN=(n,e)=>!(n>0)||e==="linear";function vde({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:r,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",AN(ve.state.gradientDepth,l)===!1){ee(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let D=yd(n,e,t,s,i,a,r);return o!=null&&(D=bt(D,o)),_N(D,l,c,h)}const d=te(n,"x","conv2d","float32"),p=te(e,"filter","conv2d","float32");let g=d,v=!1;d.rank===3&&(v=!0,g=Ee(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ee(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),ee(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Kr("fused conv2d",s,r);const _=i==="NHWC"?g.shape[3]:g.shape[1];ee(p.shape[2]===_,()=>`Error in conv2d: depth of input (${_}) must match input depth for filter ${p.shape[2]}.`),ee(sr(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const S=Fa(g.shape,p.shape,t,a,s,r);let b;o!=null&&(b=te(o,"bias","fused conv2d"),[b]=Ei(b,d),i==="NHWC"?kn(S.outShape,b.shape):(ee(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),ee(b.shape.length===0||b.shape[0]===S.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let w;if(c!=null){const D=c.shape;if(ee(D.length<=1||D.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${D.length}.`),D.length===1)ee(D[0]===1||D[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the number of output channels (${S.outChannels}).`);else if(D.length===3)try{kn(D,S.outShape)}catch{const U=`Error in fused conv2d: PReLU activation weights (${D}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(U)}w=te(c,"prelu weights","fused conv2d")}const T=(D,F)=>{ee(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[U,O,B,L]=F,H=bN(D,B,l);ee(jf(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const K=FB(O.shape,H,U,t,s),Z=vk(O,H,U.shape,t,s),Q=[K,Z];if(L!=null){const P=SN(L,H);Q.push(P)}return Q},E={x:g,filter:p,bias:b,preluActivationWeights:w},R={strides:t,pad:s,dataFormat:i,dilations:a,dimRoundingMode:r,activation:l,leakyreluAlpha:h};return o==null?uh((F,U,O)=>{let B=ve.runKernel(iS,E,R);return O([U,F,B]),v&&(B=Ee(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:T}})(g,p):uh((F,U,O,B)=>{let L=ve.runKernel(iS,E,R);return B([U,F,L,O]),v&&(L=Ee(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:T}})(g,p,b)}const N5=be({fusedConv2d_:vde});function bde(n,e,t,s,i,a=[1,1],r){let o=n;n.rank===3&&(o=Ee(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=Ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:o,dy:l},h={strides:s,pad:i,dimRoundingMode:r,dilations:a,filterShape:t};return ve.runKernel(Z2,c,h)}const R5=be({depthwiseConv2dNativeBackpropFilter_:bde});function Sde(n,e,t,s,i,a=[1,1],r){let o=e,l=!1;e.rank===3&&(l=!0,o=Ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:o,filter:t},h={strides:s,pad:i,dimRoundingMode:r,dilations:a,inputShape:n},d=ve.runKernel(Q2,c,h);return l?Ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const I5=be({depthwiseConv2dNativeBackpropInput_:Sde});function _de({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:r,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(AN(ve.state.gradientDepth,l)===!1){let R=pv(n,e,t,s,i,a,r);return o!=null&&(R=bt(R,o)),_N(R,l,c,h)}const d=te(n,"x","depthwiseConv2d","float32"),p=te(e,"filter","depthwiseConv2d","float32");let g=d,v=!1;d.rank===3&&(v=!0,g=Ee(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ee(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),ee(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),ee(g.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),ee(sr(t,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Kr("fused depthwiseConv2d",s,r);const _=Fa(g.shape,p.shape,t,a,s,r,!0);let S;o!=null&&(S=te(o,"bias","fused conv2d"),[S]=Ei(S,d),kn(_.outShape,S.shape));let b;c!=null&&(b=te(c,"prelu weights","fused depthwiseConv2d"));const w=(R,D)=>{ee(jf(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[F,U,O,B]=D,L=bN(R,O,l),H=I5(U.shape,L,F,t,s,a,r),K=R5(U,L,F.shape,t,s,a,r);if(B!=null){const Z=SN(S,L);return[H,K,Z]}return[H,K]},T={x:g,filter:p,bias:S,preluActivationWeights:b},E={strides:t,pad:s,dataFormat:i,dilations:a,dimRoundingMode:r,activation:l,leakyreluAlpha:h};return o==null?uh((D,F,U)=>{let O=ve.runKernel(aS,T,E);return U([F,D,O]),v&&(O=Ee(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:w}})(g,p):uh((D,F,U,O)=>{let B=ve.runKernel(aS,T,E);return O([F,D,B,U]),v&&(B=Ee(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:w}})(g,p,S)}const Ade=be({fusedDepthwiseConv2d_:_de});function wde({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:i,activation:a="linear",preluActivationWeights:r,leakyreluAlpha:o=.2}){if(AN(ve.state.gradientDepth,a)===!1){let L=Zn(n,e,t,s);return i!=null&&(L=bt(L,i)),_N(L,a,r,o)}let l=te(n,"a","fused matMul"),c=te(e,"b","fused matMul");[l,c]=Ei(l,c);const h=t?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=t?l.shape[l.rank-1]:l.shape[l.rank-2],g=s?c.shape[c.rank-2]:c.shape[c.rank-1],v=l.shape.slice(0,-2),_=c.shape.slice(0,-2),S=qe(v),b=qe(_);ee(h===d,()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const T=kn(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,g]),E=t?Ee(l,[S,h,p]):Ee(l,[S,p,h]),R=s?Ee(c,[b,g,d]):Ee(c,[b,d,g]);let D;i!=null&&(D=te(i,"bias","fused matMul"),[D]=Ei(D,l),kn(T,D.shape));let F;r!=null&&(F=te(r,"prelu weights","fused matMul"));const U=(L,H)=>{const[K,Z,Q,P]=H,W=bN(Ee(L,Q.shape),Q,a);let q,se;if(!t&&!s?(q=Zn(W,Z,!1,!0),se=Zn(K,W,!0,!1)):!t&&s?(q=Zn(W,Z,!1,!1),se=Zn(W,K,!0,!1)):t&&!s?(q=Zn(Z,W,!1,!0),se=Zn(K,W,!1,!1)):(q=Zn(Z,W,!0,!0),se=Zn(W,K,!0,!0)),i!=null){const le=SN(P,W);return[q,se,le]}else return[q,se]},O={a:E,b:R,bias:D,preluActivationWeights:F},B={transposeA:t,transposeB:s,activation:a,leakyreluAlpha:o};return i==null?uh((H,K,Z)=>{const Q=ve.runKernel(sS,O,B);return Z([H,K,Q]),{value:Ee(Q,T),gradFunc:U}})(E,R):uh((H,K,Z,Q)=>{const P=ve.runKernel(sS,O,B);return Q([H,K,P,Z]),{value:Ee(P,T),gradFunc:U}})(E,R,D)}const hD=be({fusedMatMul_:wde});const D5=Object.freeze(Object.defineProperty({__proto__:null,conv2d:N5,depthwiseConv2d:Ade,matMul:hD},Symbol.toStringTag,{value:"Module"}));function Cde(n){return vN(n,.54,.46)}const Tde=be({hammingWindow_:Cde});function Ede(n){return vN(n,.5,.5)}const O5=be({hannWindow_:Ede});function Mde(n,e,t,s=!1,i=0){let a=0;const r=[];for(;a+e<=n.size;)r.push(ds(n,a,e)),a+=t;if(s)for(;a<n.size;){const o=a+e-n.size,l=ji([ds(n,a,e-o),Ig([o],i)]);r.push(l),a+=t}return r.length===0?Ex([],[0,e]):Ee(ji(r),[r.length,e])}const B5=be({frame_:Mde});function Nde(n,e,t,s,i=O5){s==null&&(s=yk(e));const a=B5(n,e,t),r=we(a,i(e));return uA(r,s)}const Rde=be({stft_:Nde});function Ide(n,e,t,s,i="bilinear",a=0){const r=te(n,"image","cropAndResize"),o=te(e,"boxes","cropAndResize","float32"),l=te(t,"boxInd","cropAndResize","int32"),c=o.shape[0];ee(r.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${r.rank}.`),ee(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),ee(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),ee(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),ee(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),ee(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const h={image:r,boxes:o,boxInd:l},d={method:i,extrapolationValue:a,cropSize:s};return ve.runKernel(K2,h,d)}const Dde=be({cropAndResize_:Ide});function Ode(n){const e=te(n,"image","flipLeftRight","float32");ee(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ve.runKernel(rM,t,{})}const Bde=be({flipLeftRight_:Ode});function kde(n){const e=te(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];ee(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),ee(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,vl(e,i)}const Lde=be({grayscaleToRGB_:kde});function Fde(n){const e=te(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];ee(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),ee(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=e.dtype,a=Ft(e,"float32"),r=xr([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Dm("ij,j->i",a,r);break;case 3:o=Dm("ijk,k->ij",a,r);break;case 4:o=Dm("ijkl,l->ijk",a,r);break;case 5:o=Dm("ijklm,m->ijkl",a,r);break;case 6:o=Dm("ijklmn,n->ijklm",a,r);break;default:throw new Error("Not a valid tensor rank.")}return o=gr(o,-1),Ft(o,i)}const Ude=be({rgbToGrayscale_:Fde});function Pde(n,e,t=0,s=.5){const i=te(n,"image","rotateWithOffset","float32");ee(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const a={image:i},r={radians:e,fillValue:t,center:s};return ve.runKernel(GM,a,r)}const zde=be({rotateWithOffset_:Pde});function vv(n,e,t,s,i,a){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),a==null&&(a=0);const r=n.shape[0];return t=Math.min(t,r),ee(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),ee(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),ee(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),ee(e.rank===1,()=>"scores must be a 1D tensor"),ee(e.shape[0]===r,()=>`scores has incompatible shape with boxes. Expected ${r}, but was ${e.shape[0]}`),ee(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:a}}function $de(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const a=te(n,"boxes","nonMaxSuppression","float32"),r=te(e,"scores","nonMaxSuppression","float32"),o=vv(a,r,t,s,i);t=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:i};return ve.runKernel(gM,{boxes:a,scores:r},l)}const Gde=be({nonMaxSuppression_:$de});function Vde(n,e,t){const s=Hde(n,e,t),i=s<0?-(s+1):s;n.splice(i,0,e)}function Hde(n,e,t){return jde(n,e,t||Wde)}function Wde(n,e){return n>e?1:n<e?-1:0}function jde(n,e,t){let s=0,i=n.length,a=0,r=!1;for(;s<i;){a=s+(i-s>>>1);const o=t(e,n[a]);o>0?s=a+1:(i=a,r=!o)}return r?s:-s-1}function wN(n,e,t,s,i){return bk(n,e,t,s,i,0)}function CN(n,e,t,s,i,a){return bk(n,e,t,s,i,0,!1,a,!0)}function TN(n,e,t,s,i,a){return bk(n,e,t,s,i,a,!0)}function bk(n,e,t,s,i,a,r=!1,o=!1,l=!1){const c=[];for(let S=0;S<e.length;S++)e[S]>i&&c.push({score:e[S],boxIndex:S,suppressBeginIndex:0});c.sort(Tz);const h=a>0?-.5/a:0,d=[],p=[];for(;d.length<t&&c.length>0;){const S=c.pop(),{score:b,boxIndex:w,suppressBeginIndex:T}=S;if(b<i)break;let E=!1;for(let R=d.length-1;R>=T;--R){const D=Xde(n,w,d[R]);if(D>=s){E=!0;break}if(S.score=S.score*qde(s,h,D),S.score<=i)break}S.suppressBeginIndex=d.length,E||(S.score===b?(d.push(w),p.push(S.score)):S.score>i&&Vde(c,S,Tz))}const g=d.length,v=t-g;o&&v>0&&(d.push(...new Array(v).fill(0)),p.push(...new Array(v).fill(0)));const _={selectedIndices:d};return r&&(_.selectedScores=p),l&&(_.validOutputs=g),_}function Xde(n,e,t){const s=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),a=Math.min(s[0],s[2]),r=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),h=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),p=Math.max(i[1],i[3]),g=(o-a)*(l-r),v=(d-c)*(p-h);if(g<=0||v<=0)return 0;const _=Math.max(a,c),S=Math.max(r,h),b=Math.min(o,d),w=Math.min(l,p),T=Math.max(b-_,0)*Math.max(w-S,0);return T/(g+v-T)}function qde(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function Tz(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function Kde(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const a=te(n,"boxes","nonMaxSuppressionAsync"),r=te(e,"scores","nonMaxSuppressionAsync"),o=vv(a,r,t,s,i);t=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([a.data(),r.data()]),c=l[0],h=l[1],{selectedIndices:d}=wN(c,h,t,s,i);return a!==n&&a.dispose(),r!==e&&r.dispose(),xr(d,"int32")}const Yde=Kde;function Jde(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,a=0){const r=te(n,"boxes","nonMaxSuppression"),o=te(e,"scores","nonMaxSuppression"),l=vv(r,o,t,s,i,a);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,a=l.softNmsSigma;const c={boxes:r,scores:o},h={maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:a},d=ve.runKernel(yM,c,h);return{selectedIndices:d[0],selectedScores:d[1]}}const Zde=be({nonMaxSuppressionWithScore_:Jde});async function Qde(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,a=0){const r=te(n,"boxes","nonMaxSuppressionAsync"),o=te(e,"scores","nonMaxSuppressionAsync"),l=vv(r,o,t,s,i,a);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,a=l.softNmsSigma;const c=await Promise.all([r.data(),o.data()]),h=c[0],d=c[1],{selectedIndices:p,selectedScores:g}=TN(h,d,t,s,i,a);return r!==n&&r.dispose(),o!==e&&o.dispose(),{selectedIndices:xr(p,"int32"),selectedScores:xr(g)}}const efe=Qde;function tfe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,a=!1){const r=te(n,"boxes","nonMaxSuppression"),o=te(e,"scores","nonMaxSuppression"),l=vv(r,o,t,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,p={boxes:r,scores:o},g={maxOutputSize:c,iouThreshold:h,scoreThreshold:d,padToMaxOutputSize:a},v=ve.runKernel(xM,p,g);return{selectedIndices:v[0],validOutputs:v[1]}}const nfe=be({nonMaxSuppressionPadded_:tfe});async function sfe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,a=!1){const r=te(n,"boxes","nonMaxSuppressionAsync"),o=te(e,"scores","nonMaxSuppressionAsync"),l=vv(r,o,t,s,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,[p,g]=await Promise.all([r.data(),o.data()]),{selectedIndices:v,validOutputs:_}=CN(p,g,c,h,d,a);return r!==n&&r.dispose(),o!==e&&o.dispose(),{selectedIndices:xr(v,"int32"),validOutputs:vn(_,"int32")}}const ife=sfe;function afe(n,e,t=!1,s=!1){const i=te(n,"images","resizeBilinear");ee(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),ee(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),ee(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=i,r=!1;i.rank===3&&(r=!0,a=Ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:a},l={alignCorners:t,halfPixelCenters:s,size:e},c=ve.runKernel(O_,o,l);return r?Ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const k5=be({resizeBilinear_:afe});function rfe(n,e,t=!1,s=!1){const i=te(n,"images","resizeNearestNeighbor");ee(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),ee(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),ee(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ee(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=i,r=!1;i.rank===3&&(r=!0,a=Ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:a},l={alignCorners:t,halfPixelCenters:s,size:e},c=ve.runKernel(D_,o,l);return r?Ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const L5=be({resizeNearestNeighbor_:rfe});function ofe(n,e="binary",t=!1,s=.5){const i=te(n,"image","threshold"),a=.2989,r=.587,o=.114,l=i.shape[0]*i.shape[1];let c=we(xr([s]),255),h,d,p,g;if(ee(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),ee(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),ee(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),ee(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[h,d,p]=wo(i,[1,1,1],-1);const S=we(h,a),b=we(d,r),w=we(p,o);g=bt(bt(S,b),w)}else g=n;if(e==="otsu"){const S=IB(Ft(rN(g),"int32"),rc([]),256);c=lfe(S,l)}const v=t?cp(g,c):Do(g,c);return Ft(we(v,255),"int32")}function lfe(n,e){let t=xr([-1]),s=xr([0]),i=xr([0]),a,r,o,l,c,h;for(let d=0;d<n.size-1;d++){a=ds(n,0,d+1),r=ds(n,d+1),c=un(sn(a),e),h=un(sn(r),e);const p=sn(we(a,gg(0,a.size)));o=un(p,sn(a));const g=Ig(r.shape,a.size),v=bt(gg(0,r.size),g),_=we(r,v);l=un(sn(_),sn(r));const S=en(o,l),b=en(o,l),w=we(c,h);i=we(we(w,S),b);const T=Do(i,s);s=er(T,i,s),t=er(T,xr([d]),t)}return t}const cfe=be({threshold_:ofe});function ufe(n,e,t="nearest",s="constant",i=0,a){const r=te(n,"image","transform","float32"),o=te(e,"transforms","transform","float32");ee(r.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${r.rank}.`),ee(o.rank===2&&(o.shape[0]===r.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ee(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:r,transforms:o},c={interpolation:t,fillMode:s,fillValue:i,outputShape:a};return ve.runKernel(zM,l,c)}const hfe=be({transform_:ufe});function dfe(n,e,t){const s=te(n,"a","bandPart");ee(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[a,r]=s.shape.slice(-2);let o,l;typeof e=="number"?(ee(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),ee(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),o=te(e<0?a:e,"numLower","bandPart")):(ee(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=er(qx(e,0),a,qf(e,a))),typeof t=="number"?(ee(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),ee(t<=r,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${r}).`),l=te(t<0?r:t,"numUpper","bandPart")):(ee(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=er(qx(t,0),r,qf(t,r)));const c=Ee(gg(0,a,1,"int32"),[-1,1]),h=gg(0,r,1,"int32"),d=en(c,h),p=eu(cp(d,o),Td(d,ri(l))),g=aa([a,r],s.dtype);return Ee(Ro(Tl(Ee(s,[-1,a,r])).map(v=>er(p,v,g))),i)}const ffe=be({bandPart_:dfe});function pfe(n){let e;if(Array.isArray(n)){e=!1,ee(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let a=1;a<n.length;++a)ee(n[a].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${i})`)}else e=!0,n=wo(n,n.shape[0],0).map(i=>hp(i,[0]));ee(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let i=0;i<n.length;++i)t.push(ve.tidy(()=>{let a=s[i];if(i>0)for(let r=0;r<i;++r){const o=we(sn(we(t[r],a)),t[r]);a=en(a,o)}return un(a,gv(a,"euclidean"))}));return e?Ro(t,0):t}const mfe=be({gramSchmidt_:pfe});function gfe(n,e=!1){if(ee(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Ez(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=Tl(Ee(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],a=[];s.forEach(l=>{const[c,h]=Ez(l,e);i.push(c),a.push(h)});const r=Ee(Ro(i,0),n.shape),o=Ee(Ro(a,0),n.shape);return[r,o]}}function Ez(n,e=!1){return ve.tidy(()=>{ee(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let i=ZM(t),a=eh(n);const r=Ex([[1]],[1,1]);let o=eh(r);const l=t>=s?s:t;for(let c=0;c<l;++c){const h=a,d=o,p=i;[o,a,i]=ve.tidy(()=>{const g=ds(a,[c,c],[t-c,1]),v=gv(g),_=ds(a,[c,c],[1,1]),S=er(Do(_,0),Ex([[-1]]),Ex([[1]])),b=en(_,we(S,v)),w=un(g,b);w.shape[0]===1?o=eh(r):o=ji([r,ds(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const T=ri(un(Zn(S,b),v)),E=ds(a,[c,0],[t-c,s]),R=we(T,o),D=ls(o);if(c===0)a=en(E,Zn(R,Zn(D,E)));else{const O=en(E,Zn(R,Zn(D,E)));a=ji([ds(a,[0,0],[c,s]),O],0)}const F=ls(R),U=ds(i,[0,c],[t,i.shape[1]-c]);if(c===0)i=en(U,Zn(Zn(U,o),F));else{const O=en(U,Zn(Zn(U,o),F));i=ji([ds(i,[0,0],[t,c]),O],1)}return[o,a,i]}),Qn([h,d,p])}return!e&&t>s&&(i=ds(i,[0,0],[t,s]),a=ds(a,[0,0],[s,s])),[i,a]})}const xfe=be({qr_:gfe});var Vr;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Vr||(Vr={}));function yfe(n,e,t=Vr.SUM_BY_NONZERO_WEIGHTS){const s=te(n,"losses","computeWeightedLoss");let i=null;e!=null&&(i=te(e,"weights","computeWeightedLoss"));const a=i==null?s:we(s,i);if(t===Vr.NONE)return a;if(t===Vr.SUM)return sn(a);if(t===Vr.MEAN){if(i==null)return Ai(a);{const r=s.size/i.size,o=un(sn(a),sn(i));return r>1?un(o,vn(r)):o}}if(t===Vr.SUM_BY_NONZERO_WEIGHTS){if(i==null)return un(sn(a),vn(s.size));{const r=we(i,_o(s.shape)),o=Ft(sn(mg(r,vn(0))),"float32");return un(sn(a),o)}}throw Error(`Unknown reduction: ${t}`)}const Md=be({computeWeightedLoss_:yfe});function vfe(n,e,t,s=Vr.SUM_BY_NONZERO_WEIGHTS){const i=te(n,"labels","absoluteDifference"),a=te(e,"predictions","absoluteDifference");let r=null;t!=null&&(r=te(t,"weights","absoluteDifference")),nr(i.shape,a.shape,"Error in absoluteDifference: ");const o=ia(en(i,a));return Md(o,r,s)}const bfe=be({absoluteDifference_:vfe});function Sfe(n,e,t,s,i=Vr.SUM_BY_NONZERO_WEIGHTS){const a=te(n,"labels","cosineDistance"),r=te(e,"predictions","cosineDistance");let o=null;s!=null&&(o=te(s,"weights","cosineDistance")),nr(a.shape,r.shape,"Error in cosineDistance: ");const l=vn(1),c=en(l,sn(we(a,r),t,!0));return Md(c,o,i)}const _fe=be({cosineDistance_:Sfe});function Afe(n,e,t,s=Vr.SUM_BY_NONZERO_WEIGHTS){let i=te(n,"labels","hingeLoss");const a=te(e,"predictions","hingeLoss");let r=null;t!=null&&(r=te(t,"weights","hingeLoss")),nr(i.shape,a.shape,"Error in hingeLoss: ");const o=vn(1);i=en(we(vn(2),i),o);const l=ou(en(o,we(i,a)));return Md(l,r,s)}const wfe=be({hingeLoss_:Afe});function Cfe(n,e,t,s=1,i=Vr.SUM_BY_NONZERO_WEIGHTS){const a=te(n,"labels","huberLoss"),r=te(e,"predictions","huberLoss");let o=null;t!=null&&(o=te(t,"weights","huberLoss")),nr(a.shape,r.shape,"Error in huberLoss: ");const l=vn(s),c=ia(en(r,a)),h=qf(c,l),d=en(c,h),p=bt(we(vn(.5),Xs(h)),we(l,d));return Md(p,o,i)}const Tfe=be({huberLoss_:Cfe});function Efe(n,e,t,s=1e-7,i=Vr.SUM_BY_NONZERO_WEIGHTS){const a=te(n,"labels","logLoss"),r=te(e,"predictions","logLoss");let o=null;t!=null&&(o=te(t,"weights","logLoss")),nr(a.shape,r.shape,"Error in logLoss: ");const l=vn(1),c=vn(s),h=ri(we(a,Jo(bt(r,c)))),d=we(en(l,a),Jo(bt(en(l,r),c))),p=en(h,d);return Md(p,o,i)}const Mfe=be({logLoss_:Efe});function Nfe(n,e,t,s=Vr.SUM_BY_NONZERO_WEIGHTS){const i=te(n,"labels","meanSquaredError"),a=te(e,"predictions","meanSquaredError");let r=null;t!=null&&(r=te(t,"weights","meanSquaredError")),nr(i.shape,a.shape,"Error in meanSquaredError: ");const o=pN(i,a);return Md(o,r,s)}const Rfe=be({meanSquaredError_:Nfe});function Ife(n,e){const t=te(n,"labels","sigmoidCrossEntropyWithLogits"),s=te(e,"logits","sigmoidCrossEntropyWithLogits");nr(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=ou(s),a=we(s,t),r=Q_(No(ri(ia(s))));return bt(en(i,a),r)}function Dfe(n,e,t,s=0,i=Vr.SUM_BY_NONZERO_WEIGHTS){let a=te(n,"multiClassLabels","sigmoidCrossEntropy");const r=te(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=te(t,"weights","sigmoidCrossEntropy")),nr(a.shape,r.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=vn(s),h=vn(1),d=vn(.5);a=bt(we(a,en(h,c)),we(d,c))}const l=Ife(a,r);return Md(l,o,i)}const Ofe=be({sigmoidCrossEntropy_:Dfe});function Bfe(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return uh((i,a,r)=>{const l=eA(a,[t],!0),c=en(Ft(a,"float32"),l);r([i,c]);const h=ri(we(c,i));return{value:sn(h,[t]),gradFunc:(g,v)=>{const[_,S]=v,b=Xi(g.shape,[t]);return[we(Ee(g,b),en(Ft(_,"float32"),No(S))),we(Ee(g,b),en(No(S),Ft(_,"float32")))]}}})(n,e)}function kfe(n,e,t,s=0,i=Vr.SUM_BY_NONZERO_WEIGHTS){let a=te(n,"onehotLabels","softmaxCrossEntropy");const r=te(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=te(t,"weights","softmaxCrossEntropy")),nr(a.shape,r.shape,"Error in softmaxCrossEntropy: "),s>0){const c=vn(s),h=vn(1),d=vn(a.shape[1]);a=bt(we(a,en(h,c)),un(c,d))}const l=Bfe(a,r);return Md(l,o,i)}const Lfe=be({softmaxCrossEntropy_:kfe});function Ffe(n,e,t,s){const i=te(n,"indices","sparseFillEmptyRows","int32"),a=te(e,"values","sparseFillEmptyRows"),r=te(t,"denseShape","sparseFillEmptyRows","int32"),o=te(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(r.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:i,values:a,denseShape:r,defaultValue:o},c=ve.runKernel(NM,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const Ufe=be({sparseFillEmptyRows_:Ffe});function Pfe(n,e,t){const s=te(n,"inputIndices","sparseReshape","int32"),i=te(e,"inputShape","sparseReshape","int32"),a=te(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const r={inputIndices:s,inputShape:i,newShape:a},o=ve.runKernel(RM,r);return{outputIndices:o[0],outputShape:o[1]}}const zfe=be({sparseReshape_:Pfe});function $fe(n,e,t){const s=te(n,"data","sparseSegmentMean"),i=te(e,"indices","sparseSegmentMean","int32"),a=te(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const r={data:s,indices:i,segmentIds:a};return ve.runKernel(IM,r)}const Gfe=be({sparseSegmentMean_:$fe});function Vfe(n,e,t){const s=te(n,"data","sparseSegmentSum"),i=te(e,"indices","sparseSegmentSum","int32"),a=te(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const r={data:s,indices:i,segmentIds:a};return ve.runKernel(DM,r)}const Hfe=be({sparseSegmentSum_:Vfe});function Wfe(n,e,t,s,i,a,r,o){const l=te(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=te(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:t,nGramWidths:s,leftPad:i,rightPad:a,padWidth:r,preserveShortSequences:o},d={data:l,dataSplits:c},p=ve.runKernel(LM,d,h);return{nGrams:p[0],nGramsSplits:p[1]}}const jfe=be({stringNGrams_:Wfe});function Xfe(n,e,t=!0){const s=te(n,"input","stringSplit","string"),i=te(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const a={skipEmpty:t},r={input:s,delimiter:i},o=ve.runKernel(FM,r,a);return{indices:o[0],values:o[1],shape:o[2]}}const qfe=be({stringSplit_:Xfe});function Kfe(n,e){const t=te(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return ve.runKernel(UM,i,s)}const Yfe=be({stringToHashBucketFast_:Kfe});function Jfe(n,e,t,s=!0){const i=te(n,"input","staticRegexReplace","string"),a={pattern:e,rewrite:t,replaceGlobal:s};return ve.runKernel($_,{x:i},a)}const Zfe=be({staticRegexReplace_:Jfe});const F5={fft:cA,ifft:Zx,rfft:uA,irfft:fN},U5={hammingWindow:Tde,hannWindow:O5,frame:B5,stft:Rde},qc={flipLeftRight:Bde,grayscaleToRGB:Lde,resizeNearestNeighbor:L5,resizeBilinear:k5,rgbToGrayscale:Ude,rotateWithOffset:zde,cropAndResize:Dde,nonMaxSuppression:Gde,nonMaxSuppressionAsync:Yde,nonMaxSuppressionWithScore:Zde,nonMaxSuppressionWithScoreAsync:efe,nonMaxSuppressionPadded:nfe,nonMaxSuppressionPaddedAsync:ife,threshold:cfe,transform:hfe},Sk={bandPart:ffe,gramSchmidt:mfe,qr:xfe},P5={absoluteDifference:bfe,computeWeightedLoss:Md,cosineDistance:_fe,hingeLoss:wfe,huberLoss:Tfe,logLoss:Mfe,meanSquaredError:Rfe,sigmoidCrossEntropy:Ofe,softmaxCrossEntropy:Lfe},z5={sparseFillEmptyRows:Ufe,sparseReshape:zfe,sparseSegmentMean:Gfe,sparseSegmentSum:Hfe},$5={stringNGrams:jfe,stringSplit:qfe,stringToHashBucketFast:Yfe,staticRegexReplace:Zfe};const Qfe=new Map,dD=new Map;class Bg{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class xl{constructor(){this.classNameMap={}}static getMap(){return xl.instance==null&&(xl.instance=new xl),xl.instance}static register(e){xl.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function _t(n,e,t){ee(n.className!=null,()=>"Class being registered does not have the static className property defined."),ee(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),ee(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,i=e+">"+s;return xl.register(n),Qfe.set(i,n),dD.set(n,i),n}function epe(n){return dD.has(n)?dD.get(n):n.className}const tpe=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Bg,SerializationMap:xl,getRegisteredName:epe,registerClass:_t},Symbol.toStringTag,{value:"Module"}));class Nd extends Bg{minimize(e,t=!1,s){const{value:i,grads:a}=this.computeGradients(e,s);if(s!=null){const r=s.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(r)}else this.applyGradients(a);return Qn(a),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return XH(e,t)}dispose(){this.iterations_!=null&&Qn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:vn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Nd,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class _k extends Nd{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ve.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const a=ve.registeredVariables[s],r=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:Le(()=>ps(a).variable(r))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:Le(()=>ps(a).variable(r))});const o=Array.isArray(e)?e[i].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;Le(()=>{const h=bt(we(l,this.rho),we(Xs(o),1-this.rho)),d=we(un(La(bt(c,this.epsilon)),La(bt(l,this.epsilon))),o),p=bt(we(c,this.rho),we(Xs(d),1-this.rho));l.assign(h),c.assign(p);const g=bt(we(d,-this.learningRate),a);a.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Qn(this.accumulatedGrads.map(e=>e.variable)),Qn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class Ak extends Nd{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const a=ve.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:Le(()=>Ig(a.shape,this.initialAccumulatorValue).variable(!1))});const r=Array.isArray(e)?e[i].tensor:e[s];if(r==null)return;const o=this.accumulatedGrads[i].variable;Le(()=>{const l=bt(o,Xs(r));o.assign(l);const c=bt(we(un(r,La(bt(l,ve.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Qn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class wk extends Nd{static get className(){return"Adam"}constructor(e,t,s,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Le(()=>{this.accBeta1=vn(t).variable(),this.accBeta2=vn(s).variable()}),i==null&&(this.epsilon=ve.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Le(()=>{const s=en(1,this.accBeta1),i=en(1,this.accBeta2);t.forEach((a,r)=>{const o=ve.registeredVariables[a],l=!1;this.accumulatedFirstMoment[r]==null&&(this.accumulatedFirstMoment[r]={originalName:`${a}/m`,variable:Le(()=>ps(o).variable(l))}),this.accumulatedSecondMoment[r]==null&&(this.accumulatedSecondMoment[r]={originalName:`${a}/v`,variable:Le(()=>ps(o).variable(l))});const c=Array.isArray(e)?e[r].tensor:e[a];if(c==null)return;const h=this.accumulatedFirstMoment[r].variable,d=this.accumulatedSecondMoment[r].variable,p=bt(we(h,this.beta1),we(c,1-this.beta1)),g=bt(we(d,this.beta2),we(Xs(c),1-this.beta2)),v=un(p,s),_=un(g,i);h.assign(p),d.assign(g);const S=bt(we(un(v,bt(La(_),this.epsilon)),-this.learningRate),o);o.assign(S)}),this.accBeta1.assign(we(this.accBeta1,this.beta1)),this.accBeta2.assign(we(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Qn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Qn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Le(()=>{this.accBeta1.assign(ch(this.beta1,this.iterations_+1)),this.accBeta2.assign(ch(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class Ck extends Nd{static get className(){return"Adamax"}constructor(e,t,s,i=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Le(()=>{this.iteration=vn(0).variable(),this.accBeta1=vn(t).variable()}),i==null&&(this.epsilon=ve.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);Le(()=>{const s=en(1,this.accBeta1),i=un(-this.learningRate,bt(we(this.iteration,this.decay),1));t.forEach((a,r)=>{const o=ve.registeredVariables[a],l=!1;this.accumulatedFirstMoment[r]==null&&(this.accumulatedFirstMoment[r]={originalName:`${a}/m`,variable:ps(o).variable(l)}),this.accumulatedWeightedInfNorm[r]==null&&(this.accumulatedWeightedInfNorm[r]={originalName:`${a}/v`,variable:ps(o).variable(l)});const c=Array.isArray(e)?e[r].tensor:e[a];if(c==null)return;const h=this.accumulatedFirstMoment[r].variable,d=this.accumulatedWeightedInfNorm[r].variable,p=bt(we(h,this.beta1),we(c,1-this.beta1)),g=we(d,this.beta2),v=ia(c),_=mh(g,v);h.assign(p),d.assign(_);const S=bt(we(un(i,s),un(p,bt(_,this.epsilon))),o);o.assign(S)}),this.iteration.assign(bt(this.iteration,1)),this.accBeta1.assign(we(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Qn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Qn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class EN extends Nd{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const r=ve.registeredVariables[s];Le(()=>{const o=bt(we(this.c,a),r);r.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=ga(vn(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Tk extends EN{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=vn(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const a=ve.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:Le(()=>ps(a).variable(!1))});const r=this.accumulations[i].variable,o=Array.isArray(e)?e[i].tensor:e[s];o!=null&&Le(()=>{let l;const c=bt(we(this.m,r),o);this.useNesterov?l=bt(we(this.c,bt(o,we(c,this.m))),a):l=bt(we(this.c,c),a),r.assign(c),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Qn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Ek extends Nd{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,i=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,i==null&&(this.epsilon=ve.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const a=ve.registeredVariables[s],r=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:Le(()=>ps(a).variable(r))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:Le(()=>ps(a).variable(r))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:Le(()=>ps(a).variable(r))});const o=Array.isArray(e)?e[i].tensor:e[s];if(o==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;Le(()=>{const h=bt(we(l,this.decay),we(Xs(o),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[i].variable,p=bt(we(d,this.decay),we(o,1-this.decay)),g=un(we(o,this.learningRate),La(en(h,bt(Xs(p),this.epsilon)))),v=bt(we(c,this.momentum),g);l.assign(h),d.assign(p),c.assign(v);const _=en(a,v);a.assign(_)}else{const d=bt(we(l,this.decay),we(Xs(o),1-this.decay)),p=bt(we(c,this.momentum),un(we(o,this.learningRate),La(bt(d,this.epsilon))));l.assign(d),c.assign(p);const g=en(a,p);a.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Qn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Qn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Qn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const npe=[_k,Ak,wk,Ck,Tk,Ek,EN];function spe(){for(const n of npe)_t(n)}const ipe="model",ape=".json",rpe=".weights.bin";function Mz(n){return new Promise(e=>setTimeout(e)).then(n)}class xg{constructor(e){if(!Pe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(xg.URL_SCHEME)&&(e=e.slice(xg.URL_SCHEME.length)),(e==null||e.length===0)&&(e=ipe),this.modelJsonFileName=e+ape,this.weightDataFileName=e+rpe}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ru.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=MH(e,i),r=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=r,await Mz(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await Mz(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:j_(e)}}}}xg.URL_SCHEME="downloads://";class ope{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=i=>{const a=JSON.parse(i.target.result),r=a.modelTopology;if(r==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:r});return}const l=gB(a,c=>this.loadWeights(c));e(l)},s.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const r of e)t.push(...r.weights),s.push(...r.paths);const i=this.checkManifestAndWeightFiles(e),a=s.map(r=>this.loadWeightsFile(r,i[r]));return Promise.all(a).then(r=>[t,r])}loadWeightsFile(e,t){return new Promise((s,i)=>{const a=new FileReader;a.onload=r=>{const o=r.target.result;s(o)},a.onerror=r=>i(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(a=>xz(a.name)),i={};for(const a of e)a.paths.forEach(r=>{const o=xz(r);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);i[r]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const lpe=n=>Pe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(xg.URL_SCHEME)?cpe(n.slice(xg.URL_SCHEME.length)):null;_i.registerSaveRouter(lpe);function cpe(n="model"){return new xg(n)}function upe(n){return new ope(n)}function Nz(n,e,t,s){r(n),t=t??0,s=s??1,o(t,s);let i=0;const a=l=>(l.then(c=>{const h=t+ ++i/n.length*(s-t);return e(h),c}),l);function r(l){ee(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){ee(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),ee(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),ee(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(a))}async function G5(n,e){e==null&&(e={});const t=e.fetchFunc==null?Pe().platform.fetch:e.fetchFunc,s=n.map(d=>t(d,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await Nz(s,e.onProgress,0,.5)).map(d=>d.arrayBuffer());return e.onProgress==null?await Promise.all(o):await Nz(o,e.onProgress,.5,1)}function hpe(n,e){var t;const s=e.fetchFunc==null?Pe().platform.fetch:e.fetchFunc;let i=0,a;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async r=>{for(var o;i<n.length;){a||(a=(await s(n[i],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await a.read();if(l){i++,a=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,i/n.length);continue}r.enqueue(c);return}r.close()}})}async function dpe(n,e="",t,s){return V5(r=>G5(r,{requestInit:s}))(n,e,t)}function V5(n){return async(e,t="",s)=>{const i=e.map(()=>!1),a={},r=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((g,v)=>{let _=0;g.weights.forEach(S=>{const b="quantization"in S?S.quantization.dtype:S.dtype,w=cg[b]*qe(S.shape),T=()=>{i[v]=!0,a[v]==null&&(a[v]=[]),a[v].push({manifestEntry:S,groupOffset:_,sizeBytes:w})};s!=null?s.forEach((E,R)=>{E===S.name&&(T(),r[R]=!0)}):T(),o.push(S.name),_+=w})}),!r.every(g=>g)){const g=s.filter((v,_)=>!r[_]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=i.reduce((g,v,_)=>(v&&g.push(_),g),[]),c=[];l.forEach(g=>{e[g].paths.forEach(v=>{const _=t+(t.endsWith("/")?"":"/")+v;c.push(_)})});const h=await n(c),d={};let p=0;return l.forEach(g=>{const v=e[g].paths.length,_=new ru(h.slice(p,p+v));a[g].forEach(b=>{const w=_.slice(b.groupOffset,b.groupOffset+b.sizeBytes),T=wH(w,[b.manifestEntry]);for(const E in T)d[E]=T[E]}),p+=v}),d}}const fpe="application/octet-stream",ppe="application/json";class Mk{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(ee(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Pe().platform.fetch,ee(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&ee(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=MH(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(i)],{type:ppe}),"model.json"),e.weightData!=null){const r=ru.join(e.weightData);t.body.append("model.weights.bin",new Blob([r],{type:fpe}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:j_(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let r=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?r+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":r+=" Please make sure the server is serving valid JSON for this request.",new Error(r)}const s=t.modelTopology,i=t.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return gB(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=TE(e.weightsManifest),i=()=>hpe(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:i})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=mpe(t),a=this.weightPathPrefix||s,r=[],o=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(c)):r.push(a+c+i);return this.weightUrlConverter&&r.push(...await Promise.all(o)),r}async loadWeights(e){const t=await this.getWeightUrls(e),s=TE(e),i=await G5(t,this.loadOptions);return[s,i]}}Mk.URL_SCHEME_REGEX=/^https?:\/\//;function mpe(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),i=t>e?n.substring(t):"";return[s+"/",i]}function fD(n){return n.match(Mk.URL_SCHEME_REGEX)!=null}const H5=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>fD(s)):t=fD(n),t)return Nk(n,e)}return null};_i.registerSaveRouter(H5);_i.registerLoadRouter(H5);function Nk(n,e){return new Mk(n,e)}function gpe(n,e){return Nk(n,e)}class r3{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class W5{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class xpe{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function ype(n,e,t,s){const i=arguments;return new xpe(ME(...i))}function ME(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new r3(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new r3({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new r3({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function vpe(n){return new W5(n)}function bpe(n){return new W5(n)}const Rk=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:ru,browserFiles:upe,browserHTTPRequest:gpe,concatenateArrayBuffers:EH,copyModel:Yoe,decodeWeights:wH,decodeWeightsStream:TH,encodeWeights:aD,fromMemory:ype,fromMemorySync:ME,getLoadHandlers:Loe,getModelArtifactsForJSON:gB,getModelArtifactsForJSONSync:mB,getModelArtifactsInfoForJSON:j_,getSaveHandlers:NH,getWeightSpecs:TE,http:Nk,isHTTPScheme:fD,listModels:qoe,loadWeights:dpe,moveModel:Joe,registerLoadRouter:koe,registerSaveRouter:Boe,removeModel:Koe,weightsLoaderFactory:V5,withSaveHandler:vpe,withSaveHandlerSync:bpe},Symbol.toStringTag,{value:"Module"}));function Spe(n,e,t){const s=te(n,"labels","confusionMatrix"),i=te(e,"predictions","confusionMatrix");ee(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),ee(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),ee(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),ee(s.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),ee(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const a=Kx(Ft(s,"int32"),t),r=Kx(Ft(i,"int32"),t),o=ls(a),l=Zn(o,r);return Ft(l,"int32")}const _pe=be({confusionMatrix_:Spe});const Ape=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:_pe},Symbol.toStringTag,{value:"Module"}));let _m,Rz=!1;function j5(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,i=!1,a=!1,r=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)a=!0;else if(n.getContext!=null)r=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(oS(wE,ve.backendName)!=null){const v={pixels:n},_={numChannels:e};return ve.runKernel(wE,v,_)}const[c,h]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d;if(r)d=n.getContext("2d").getImageData(0,0,c,h).data;else if(s||t)d=n.data;else if(a||i||o){if(_m==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")_m=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else _m=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});_m.canvas.width=c,_m.canvas.height=h,_m.drawImage(n,0,0,c,h),d=_m.getImageData(0,0,c,h).data}let p;if(e===4)p=new Int32Array(d);else{const v=c*h;p=new Int32Array(v*e);for(let _=0;_<v;_++)for(let S=0;S<e;++S)p[_*e+S]=d[_*4+S]}return hk(p,[h,c,e],"int32")}function wpe(n){return n!=null&&n.data instanceof Uint8Array}function Cpe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Tpe(n){return n!=null&&n.width!==0&&n.height!==0}function Epe(n){return Cpe()&&!(n instanceof ImageBitmap)&&Tpe(n)&&!wpe(n)}async function Mpe(n,e=3){let t=null;if(Pe().getBool("WRAP_TO_IMAGEBITMAP")&&Epe(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return j5(t,e)}function X5(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function Npe(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function Rpe(n,e){let t=te(n,"img","toPixels");if(!(n instanceof Us)){const c=t;t=Ft(c,"int32"),c.dispose()}X5(t);const[s,i]=t.shape.slice(0,2),a=t.rank===2?1:t.shape[2],r=await t.data(),o=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*s*4);for(let c=0;c<s*i;++c){const h=[0,0,0,255];for(let p=0;p<a;p++){const g=r[c*a+p];if(t.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(t.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);a===1?(h[0]=g*o,h[1]=g*o,h[2]=g*o):h[p]=g*o}const d=c*4;l[d+0]=Math.round(h[0]),l[d+1]=Math.round(h[1]),l[d+2]=Math.round(h[2]),l[d+3]=Math.round(h[3])}if(e!=null){Rz||oS(tM,ve.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Rz=!0),e.width=i,e.height=s;const c=e.getContext("2d"),h=new ImageData(l,i,s);c.putImageData(h,0,0)}return t!==n&&t.dispose(),l}function Ipe(n,e,t){let s=te(n,"img","draw");if(!(n instanceof Us)){const r=s;s=Ft(r,"int32"),r.dispose()}X5(s),Npe(t?.imageOptions);const i={image:s},a={canvas:e,options:t};ve.runKernel(tM,i,a)}const Dpe=be({fromPixels_:j5}),Ope=Object.freeze(Object.defineProperty({__proto__:null,draw:Ipe,fromPixels:Dpe,fromPixelsAsync:Mpe,toPixels:Rpe},Symbol.toStringTag,{value:"Module"}));function MN(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(qe(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,a=i[i.length-1];let r=1;for(let d=0;d<i.length-1;++d)r*=i[d];const o=n.shape,l=i.slice();l.pop();let c=1;for(let d=a;d<t;++d)c*=o[d],l.push(o[d]);const h=[...gn(n.shape).map(d=>d/c),1].slice(0,a);return[l,r,c,h]}const Bpe=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:MN},Symbol.toStringTag,{value:"Module"}));const pD=-2,kpe=-1;function Ik(n,e,t){const s=n.shape.length;ee(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),ee(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)ee(e[i]+t[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function Lpe(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Dk(n,e,t){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((e[i]-n[i])/t[i]);return s}function q5(n,e,t,s){const i=[...n];for(let a=i.length;a<s.length;a++)i.push(1);for(let a=0;a<t;a++)a===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function K5(n,e,t){return t<=n?t:t-(e-1)}function Y5(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function Fpe(n,e,t,s,i,a,r,o,l){const c=n.length;let h=new Array(c),d=new Array(c),p=new Array(c);if(e.length&&t>0){const g=e[0],v=t+1;h=J5(r,g,v,s,n),d=Z5(o,g,v,i,n),p=q5(a,g,v,n)}else for(let g=0;g<c;g++)h[g]=e8(r,s,a,n,g,l),d[g]=t8(o,i,a,n,g,l),p[g]=Q5(a,g,l);return{begin:h,end:d,strides:p}}function J5(n,e,t,s,i){const a=[...i],r=Y5(t,e);for(let o=0;o<a.length;o++)if(r.indexOf(o)>-1)a[o]=0;else{const l=K5(e,t,o);let c=s[l];n&1<<l&&(c=0),a[o]=c}return a}function Z5(n,e,t,s,i){const a=[...i],r=Y5(t,e);for(let o=0;o<a.length;o++)if(r.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=K5(e,t,o);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),a[o]=c}for(let o=0;o<a.length;o++){const l=i[o];a[o]<0&&(a[o]+=l),a[o]=Gf(0,a[o],i[o])}return a}function Q5(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function e8(n,e,t,s,i,a){let r=e[i];const o=t[i]||1;(n&1<<i||a&1<<i||r==null)&&(o>0?r=Number.MIN_SAFE_INTEGER:r=Number.MAX_SAFE_INTEGER);const l=s[i];return r<0&&(r+=l),r=Gf(0,r,l-1),r}function t8(n,e,t,s,i,a){let r=e[i];const o=t[i]||1;(n&1<<i||a&1<<i||r==null)&&(o>0?r=Number.MAX_SAFE_INTEGER:r=Number.MIN_SAFE_INTEGER);const l=s[i];return r<0&&(r+=l),o>0?r=Gf(0,r,l):r=Gf(-1,r,l-1),r}function Ok(n,e,t){let s=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){s=i;break}for(let i=s+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function Bk(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function NN(n,e,t){let s;const i=n.shape.length;typeof e=="number"?s=[e,...new Array(i-1).fill(0)]:e.length<i?s=e.concat(new Array(i-e.length).fill(0)):s=e.slice(),s.forEach(r=>{ee(r!==-1,()=>"slice() does not support negative begin indexing.")});let a;return t==null?a=new Array(i).fill(-1):typeof t=="number"?a=[t,...new Array(i-1).fill(-1)]:t.length<i?a=t.concat(new Array(i-t.length).fill(-1)):a=t,a=a.map((r,o)=>r>=0?r:(ee(r===-1,()=>`Negative size values should be exactly -1 but got ${r} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,a]}function kk(n,e,t,s,i,a,r,o,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,r!=null&&(r&r-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:a,ellipsisMask:r,newAxisMask:o,shrinkAxisMask:l};for(let T=0;T<d.dims;T++)h&&(1<<T&o)!==0&&d.numAddAxisAfterEllipsis++,1<<T&r&&(h=!0);h||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Upe(d,p);let g=!0,v=!0,_=!0;const S=[],b=[];for(let T=0;T<n.length;++T){if(p.strides[T]===0)throw Error(`strides[${T}] must be non-zero`);const E=!!(p.shrinkAxisMask&1<<T),R=n[T];if(R===-1){S.push(E?1:-1);continue}const D=[p.beginMask&1<<T,p.endMask&1<<T],F=[p.strides[T]>0?0:-1,p.strides[T]>0?R:R-1];if(E&&p.strides[T]<=0)throw Error("only stride 1 allowed on non-range indexing.");_=_&&p.strides[T]===1;const U=!!(p.beginMask&1<<T&&p.endMask&1<<T);if(p.beginValid&&p.endValid){if(E){const H=p.begin[T]<0?R+p.begin[T]:p.begin[T];if(p.begin[T]=H,p.end[T]=p.begin[T]+1,H<0||H>=R)throw Error(`slice index ${p.begin[T]} of dimension ${T} out of bounds.`)}else p.begin[T]=Iz(p.begin[T],0,p.strides[T],R,D,F),p.end[T]=Iz(p.end[T],1,p.strides[T],R,D,F);const L=p.strides[T]===1&&p.begin[T]===0&&p.end[T]===R;g=g&&L,v=v&&(T===0&&p.strides[T]===1||L)}else g=g&&p.strides[T]===1&&U,v=v&&(T===0&&p.strides[T]===1||U);let O,B=!1;if(p.beginValid&&p.endValid?(O=p.end[T]-p.begin[T],B=!0):E?(O=1,B=!0):U&&R>=0&&(p.strides[T]<0?O=-R:O=R,B=!0),B){let L;O===0||O<0!=p.strides[T]<0?L=0:L=Math.trunc(O/p.strides[T])+(O%p.strides[T]!==0?1:0),S.push(L)}else S.push(-1)}for(let T=0;T<p.finalShapeGatherIndices.length;++T){const E=p.finalShapeGatherIndices[T];E>=0?b.push(S[E]):E===pD&&b.push(1)}return{finalShapeSparse:b.filter((T,E)=>p.finalShapeGatherIndices[E]!==pD),finalShape:b,isIdentity:g,sliceDim0:v,isSimpleSlice:_,begin:p.begin,end:p.end,strides:p.strides}}function Upe(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(pD),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(kpe),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function Iz(n,e,t,s,i,a){if(i[e])return t>0?a[e]:a[e+1&1];{const r=n<0?s+n:n;return r<a[0]?a[0]:r>a[1]?a[1]:r}}const n8=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Ik,computeFlatOffset:Bk,computeOutShape:Dk,getNormalizedAxes:Fpe,isSliceContinous:Ok,maskToAxes:Lpe,parseSliceParams:NN,sliceInfo:kk,startForAxis:e8,startIndicesWithElidedDims:J5,stopForAxis:t8,stopIndicesWithElidedDims:Z5,stridesForAxis:Q5,stridesWithElidedDims:q5},Symbol.toStringTag,{value:"Module"}));const Ppe="4.22.0";class s8{static sgd(e){return new EN(e)}static momentum(e,t,s=!1){return new Tk(e,t,s)}static rmsprop(e,t=.9,s=0,i=null,a=!1){return new Ek(e,t,s,i,a)}static adam(e=.001,t=.9,s=.999,i=null){return new wk(e,t,s,i)}static adadelta(e=.001,t=.95,s=null){return new _k(e,t,s)}static adamax(e=.002,t=.9,s=.999,i=null,a=0){return new Ck(e,t,s,i,a)}static adagrad(e,t=.1){return new Ak(e,t)}}const Nm=s8;const zpe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function Lk(){return new Promise(n=>zpe(()=>n()))}function Fk(n,e){const t=n[0].length;n.forEach((i,a)=>{ee(i.length===t,()=>`Error in concat${t}D: rank of tensors[${a}] must be the same as the rank of the rest (${t})`)}),ee(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((i,a)=>{for(let r=0;r<t;r++)ee(r===e||i[r]===s[r],()=>`Error in concat${t}D: Shape of tensors[${a}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function th(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var jc;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(jc||(jc={}));function i8(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let i=1;i<t.length;++i){const a=t[i],r=s[s.length-t.length+i],o=s[r];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${a} but shape[${i+n}] = ${o}`)}else s[r]=a}return s}function a8(n){const e={FIRST_DIM_SIZE:jc.FIRST_DIM_SIZE,VALUE_ROWIDS:jc.VALUE_ROWIDS,ROW_LENGTHS:jc.ROW_LENGTHS,ROW_SPLITS:jc.ROW_SPLITS,ROW_LIMITS:jc.ROW_LIMITS,ROW_STARTS:jc.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function r8(n){return n.length===0?0:n[0]===jc.FIRST_DIM_SIZE?n.length-1:n.length}function o8(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(t,s-1);++i){const a=n[i],r=e[i+1];if(a>=0&&r>=0&&a!==1&&a!==r)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${a} but ragged tensor input.flatValues.shape[${i-n.length}] = ${r}`)}}const Uk=30;function RN(n){return n<=Uk?n:SE(n,Math.floor(Math.sqrt(n)))}function Pk(n,e,t){const s=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[s,i]}function hA(n,e,t,s=!0){let i=[];if(s)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const a=e.length;for(let r=0;r<a;++r)i=i.concat([n[r+1]/e[r],e[r]]);i=i.concat(n.slice(a+1))}return i}function dA(n,e,t=!0){const s=[];if(t){s.push(e);for(let i=e+1;i<n;++i)i<=2*e?(s.push(i),s.push(i-(e+1))):s.push(i)}else{const i=[],a=[];for(let r=1;r<n;++r)r>=e*2+1||r%2===1?a.push(r):i.push(r);s.push(...i),s.push(0),s.push(...a)}return s}function fA(n,e,t,s=!0){const i=[];s?i.push(n[0]/t):i.push(n[0]*t);for(let a=1;a<n.length;++a)a<=e.length?s?i.push(e[a-1]*n[a]):i.push(n[a]/e[a-1]):i.push(n[a]);return i}function zk(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function $k(n,e,t){const s=n.slice(0,1);for(let i=0;i<t;++i)s.push(n[i+1]-e[i][0]-e[i][1]);return s}const IN=1.7580993408473768,DN=1.0507009873554805;const Gk=.3275911,Vk=.254829592,Hk=-.284496736,Wk=1.421413741,jk=-1.453152027,Xk=1.061405429;function vd(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function l8(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function c8(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function u8(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function qk(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function h8(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function d8(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const a=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(a),s[i]=Math.sin(a)}return{real:t,imag:s}}function f8(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),i=Math.cos(s),a=Math.sin(s);return{real:i,imag:a}}const o3="->",$pe=/->/g,Dz=",",Oz="...";function Kk(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace($pe,"").length)/o3.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${o3}").`);const[s,i]=n.split(o3);ee(s.indexOf(Oz)===-1,()=>`The ellipsis notation ("${Oz}") is not supported yet.`);const a=s.split(Dz),r=a.length;if(e!==r)throw new Error(`Expected ${r} input tensors, received ${e}`);if(r>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let p=0;p<i.length;++p){const g=i[p];if(!a.some(v=>v.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let p=0;p<s.length;++p){const g=s[p];o.indexOf(g)===-1&&g!==Dz&&o.push(g)}const l=new Array(a.length);for(let p=0;p<r;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let g=0;g<a[p].length;++g)l[p].push(o.indexOf(a[p][g]))}const c=o.length,h=i.length,d=[];for(let p=h;p<c;++p)d.push(p);return{allDims:o,summedDims:d,idDims:l}}function Yk(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const s=[];for(let i=0;i<n;++i)t[i]===-1&&s.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:s}}function Jk(n,e,t){const s=new Array(n);for(let i=0;i<t.length;++i){const a=t[i].shape;for(let r=0;r<e[i].length;++r)s[e[i][r]]===void 0?s[e[i][r]]=a[r]:ee(s[e[i][r]]===a[r],()=>`Expected dimension ${s[e[i][r]]} at axis ${r} of input shaped ${JSON.stringify(a)}, but got dimension ${a[r]}`)}}function Zk(n,e){const t=n,s=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let r=0;r<i;++r)s.push([]);const a=[];for(let r=0;r<t.length;++r){const o=t[r],l=Gpe(e,o);for(const c of l)a.indexOf(c)===-1&&(s[r].push(c),a.push(c))}return{path:t,steps:s}}function Qk(n){return n.every((e,t)=>e===t)}function Gpe(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function eL(n,e,t=0){let s=[];if(typeof e=="number")ee(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((r,o)=>(o===-1&&(r+=1),r),0);ee(i<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const r=e.reduce((o,l)=>l>0?o+l:o);e[a]=n.shape[t]-r}ee(n.shape[t]===e.reduce((r,o)=>r+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function p8(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function m8(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function g8(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function x8(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function y8(n,e){return`size ${n} must be non-negative, not ${e}`}function v8(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function b8(n,e){const t=qe(n),s=qe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function S8(n,e){const t=qe(n),s=qe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function mD(){return"segment ids must be >= 0"}function _8(){return"segment ids are not increasing"}function A8(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function w8(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function C8(n,e){let t=!1,s;for(n<=Uk?(s=n,t=!0):s=SE(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=SE(n,s+1);return s}function T8(n,e,t){const s=[],i=n.length;for(let a=0;a<i;a++)a!==e?s.push(n[a]):s.push(t);return s}function tL(n,e,t,s){const i=e.shape.length,a=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let d=0;d<s;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const r=n.shape[t],o=[];let l=1,c=1,h=1;for(let d=0;d<s;++d)o.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<t;d++)o.push(n.shape[d]),c*=n.shape[d];for(let d=s;d<i;d++)o.push(e.shape[d]);for(let d=t+1;d<a;d++)o.push(n.shape[d]),h*=n.shape[d];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:r,outputShape:o}}const Vpe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:tL,computeOutShape:T8,segOpComputeOptimalWindowSize:C8},Symbol.toStringTag,{value:"Module"}));function bd(n){try{return n.map(e=>gd(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function E8(n){return n.map(e=>Qu(e))}const M8=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Vk,ERF_A2:Hk,ERF_A3:Wk,ERF_A4:jk,ERF_A5:Xk,ERF_P:Gk,PARALLELIZE_THRESHOLD:Uk,get RowPartitionType(){return jc},SELU_SCALE:DN,SELU_SCALEALPHA:IN,applyActivation:_N,assertAndGetBroadcastShape:kn,assertAxesAreInnerMostDims:ir,assertParamsConsistent:Fk,assignToTypedArray:h8,axesAreInnerMostDims:HB,calculateShapes:dp,checkEinsumDimSizes:Jk,checkPadOnDimRoundingMode:Kr,combineLocations:HH,combineRaggedTensorToTensorShapes:i8,complexWithEvenIndex:c8,complexWithOddIndex:u8,computeConv2DInfo:Fa,computeConv3DInfo:op,computeDefaultPad:TB,computeDilation2DInfo:X_,computeOptimalWindowSize:RN,computeOutAndReduceShapes:Ua,computeOutShape:th,computePool2DInfo:uc,computePool3DInfo:wd,convertConv2DDataFormat:Cd,decodeEinsumEquation:Kk,eitherStridesOrDilationsAreOne:sr,expandShapeToKeepDim:Xi,exponent:f8,exponents:d8,fromStringArrayToUint8:E8,fromUint8ToStringArray:bd,getAxesPermutation:Mi,getBroadcastDims:pg,getComplexWithIndex:qk,getEinsumComputePath:Zk,getEinsumPermutation:Yk,getFusedBiasGradient:SN,getFusedDyActivation:bN,getImageCenter:Pk,getInnerMostAxes:qi,getPermuted:dA,getRaggedRank:r8,getReductionAxes:la,getReshaped:hA,getReshapedPermuted:fA,getRowPartitionTypesHelper:a8,getSliceBeginCoords:zk,getSliceSize:$k,getSparseFillEmptyRowsIndicesDenseShapeMismatch:p8,getSparseFillEmptyRowsNegativeIndexErrorMessage:m8,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:g8,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:v8,getSparseReshapeInputOutputMismatchErrorMessage:S8,getSparseReshapeInputOutputMultipleErrorMessage:b8,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:x8,getSparseReshapeNegativeOutputDimErrorMessage:y8,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:w8,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:mD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:_8,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:A8,getUndoAxesPermutation:lp,isIdentityPermutation:Qk,log:Ore,mergeRealAndImagArrays:vd,prepareAndValidate:MN,prepareSplitSize:eL,segment_util:Vpe,shouldFuse:AN,slice_util:n8,splitRealAndImagArrays:l8,stridesOrDilationsArePositive:fg,tupleValuesAreOne:jf,upcastType:To,validateDefaultValueShape:o8,validateInput:mN,validateUpdateShape:dk,warn:gl},Symbol.toStringTag,{value:"Module"}));const Hpe=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:wN,nonMaxSuppressionV4Impl:CN,nonMaxSuppressionV5Impl:TN,whereImpl:yN},Symbol.toStringTag,{value:"Module"}));spe();const Wpe=Object.freeze(Object.defineProperty({__proto__:null,Abs:GS,Acos:yy,Acosh:vy,AdadeltaOptimizer:_k,AdagradOptimizer:Ak,AdamOptimizer:wk,AdamaxOptimizer:Ck,Add:Rg,AddN:VS,All:U2,Any:P2,ArgMax:HS,ArgMin:WS,Asin:by,Asinh:Sy,Atan:_y,Atan2:wy,Atanh:Ay,AvgPool:jS,AvgPool3D:XS,AvgPool3DGrad:$2,AvgPoolGrad:z2,BatchMatMul:qS,BatchToSpaceND:KS,Bincount:G2,BitwiseAnd:YS,BroadcastArgs:V2,BroadcastTo:oH,Cast:Cy,Ceil:Ty,ClipByValue:Ey,Complex:H2,ComplexAbs:JS,Concat:ZS,Conv2D:QS,Conv2DBackpropFilter:W2,Conv2DBackpropInput:e_,Conv3D:t_,Conv3DBackpropFilterV2:j2,Conv3DBackpropInputV2:X2,Cos:My,Cosh:Ny,CropAndResize:K2,Cumprod:q2,Cumsum:n_,DataStorage:eB,DenseBincount:Y2,DepthToSpace:J2,DepthwiseConv2dNative:s_,DepthwiseConv2dNativeBackpropFilter:Z2,DepthwiseConv2dNativeBackpropInput:Q2,Diag:eM,Dilation2D:i_,Dilation2DBackpropFilter:AE,Dilation2DBackpropInput:_E,Draw:tM,get ENV(){return aB},Einsum:nM,Elu:Iy,EluGrad:sM,Environment:aH,Equal:a_,Erf:Dy,Exp:Oy,ExpandDims:r_,Expm1:By,FFT:iM,Fill:aM,FlipLeftRight:rM,Floor:ky,FloorDiv:Ly,FromPixels:wE,FusedBatchNorm:o_,FusedConv2D:iS,FusedDepthwiseConv2D:aS,GatherNd:oM,GatherV2:l_,Greater:c_,GreaterEqual:Fy,IFFT:lM,Identity:Uy,Imag:cM,IsFinite:Py,IsInf:zy,IsNan:$y,KernelBackend:k2,LRN:g_,LRNGrad:hM,LeakyRelu:u_,Less:h_,LessEqual:d_,LinSpace:uM,Log:Gy,Log1p:Vy,LogSoftmax:lH,LogicalAnd:f_,LogicalNot:p_,LogicalOr:m_,LogicalXor:Mre,LowerBound:Nre,MatrixBandPart:Rre,Max:x_,MaxPool:y_,MaxPool3D:v_,MaxPool3DGrad:fM,MaxPoolGrad:dM,MaxPoolWithArgmax:pM,Maximum:Hy,Mean:b_,Min:S_,Minimum:Wy,MirrorPad:__,Mod:jy,MomentumOptimizer:Tk,Multinomial:mM,Multiply:Xy,Neg:A_,NonMaxSuppressionV3:gM,NonMaxSuppressionV4:xM,NonMaxSuppressionV5:yM,NotEqual:w_,OP_SCOPE_SUFFIX:hB,OneHot:T_,OnesLike:C_,Optimizer:Nd,OptimizerConstructors:s8,Pack:E_,PadV2:M_,Pool:Ire,Pow:qy,Prelu:N_,Prod:R_,RMSPropOptimizer:Ek,RaggedGather:vM,RaggedRange:bM,RaggedTensorToTensor:SM,Range:_M,get Rank(){return Z3},Real:AM,RealDiv:Ry,Reciprocal:Ky,get Reduction(){return Vr},Relu:Yy,Relu6:Jy,Reshape:I_,ResizeBilinear:O_,ResizeBilinearGrad:CM,ResizeNearestNeighbor:D_,ResizeNearestNeighborGrad:wM,Reverse:B_,RotateWithOffset:GM,Round:Zy,Rsqrt:Qy,SGDOptimizer:EN,ScatterNd:TM,SearchSorted:MM,Select:k_,Selu:ev,Sigmoid:iv,Sign:sv,Sin:tv,Sinh:nv,Slice:L_,Softmax:z_,Softplus:av,SpaceToBatchND:U_,SparseFillEmptyRows:NM,SparseReshape:RM,SparseSegmentMean:IM,SparseSegmentSum:DM,SparseToDense:OM,SplitV:P_,Sqrt:rv,Square:BM,SquaredDifference:ov,StaticRegexReplace:$_,Step:dv,StridedSlice:kM,StringNGrams:LM,StringSplit:FM,StringToHashBucketFast:UM,Sub:lv,Sum:F_,Tan:cv,Tanh:uv,Tensor:Us,TensorBuffer:oa,TensorScatterUpdate:EM,Tile:hv,TopK:PM,Transform:zM,Transpose:Km,Unique:$M,Unpack:G_,UnsortedSegmentSum:V_,UpperBound:Dre,Variable:lS,ZerosLike:H_,_FusedMatMul:sS,abs:ia,acos:yB,acosh:vB,add:bt,addN:FH,all:jM,any:uS,argMax:dg,argMin:bB,asin:SB,asinh:_B,atan:AB,atan2:wB,atanh:CB,avgPool:q_,avgPool3d:EB,backend:fB,backend_util:M8,basicLSTMCell:UH,batchNorm:fv,batchNorm2d:MB,batchNorm3d:NB,batchNorm4d:RB,batchToSpaceND:K_,bincount:IB,bitwiseAnd:PH,booleanMaskAsync:A5,broadcastArgs:zH,broadcastTo:Ym,broadcast_util:dce,browser:Ope,buffer:Hn,cast:Ft,ceil:DB,clipByValue:Mo,clone:eh,complex:xd,concat:ji,concat1d:OB,concat2d:BB,concat3d:kB,concat4d:LB,conv1d:XM,conv2d:yd,conv2dTranspose:qM,conv3d:UB,conv3dTranspose:PB,copyRegisteredKernels:Lre,cos:Y_,cosh:KM,cosineWindow:vN,cumprod:fS,cumsum:YM,customGrad:uh,denseBincount:EE,deprecationWarn:moe,depthToSpace:zB,depthwiseConv2d:pv,device_util:coe,diag:GH,dilation2d:$B,disableDeprecationWarnings:poe,dispose:Qn,disposeVariables:goe,div:un,divNoNan:GB,dot:VB,dropout:xk,einsum:Dm,elu:mv,enableDebugMode:foe,enableProdMode:doe,enclosingPowerOfTwo:yk,engine:Vc,ensureShape:VH,env:Pe,equal:oc,erf:JM,euclideanNorm:WB,exp:No,expandDims:gr,expm1:jB,eye:ZM,fft:cA,fill:Ig,findBackend:_oe,findBackendFactory:Aoe,floor:xv,floorDiv:WM,fused:D5,gather:yv,gatherND:E5,gather_util:Bpe,getBackend:AH,getGradient:Y3,getKernel:oS,getKernelsForBackend:CE,grad:Kce,grads:Yce,greater:Do,greaterEqual:Td,ifft:Zx,imag:J_,image:qc,inTopKAsync:M5,io:Rk,irfft:fN,isFinite:XB,isInf:qB,isNaN:KB,keep:ga,kernel_impls:Hpe,leakyRelu:Z_,less:qx,lessEqual:cp,linalg:Sk,linspace:jH,localResponseNormalization:YB,log:Jo,log1p:Q_,logSigmoid:JB,logSoftmax:eN,logSumExp:eA,logicalAnd:eu,logicalNot:tA,logicalOr:tN,logicalXor:ZB,losses:P5,lowerBound:qH,matMul:Zn,math:Ape,max:Al,maxPool:nA,maxPool3d:QB,maxPoolWithArgmax:KH,maximum:mh,mean:Ai,memory:iD,meshgrid:YH,min:Xx,minimum:qf,mirrorPad:ek,mod:tk,moments:sA,movingAverage:w5,mul:we,multiRNNCell:JH,multinomial:ZH,neg:ri,nextFrame:Lk,norm:gv,notEqual:mg,oneHot:Kx,ones:_o,onesLike:Zo,op:be,outerProduct:QH,pad:Ed,pad1d:e5,pad2d:t5,pad3d:n5,pad4d:s5,pool:nk,pow:ch,prelu:aA,print:xB,prod:sk,profile:xoe,raggedGather:i5,raggedRange:a5,raggedTensorToTensor:r5,rand:o5,randomGamma:u5,randomNormal:iN,randomStandardNormal:h5,randomUniform:up,randomUniformInt:d5,range:gg,ready:boe,real:Yx,reciprocal:ok,registerBackend:dB,registerGradient:cH,registerKernel:VM,relu:ou,relu6:aN,removeBackend:Soe,reshape:Ee,reverse:Cl,reverse1d:f5,reverse2d:p5,reverse3d:m5,reverse4d:g5,rfft:uA,round:rN,rsqrt:oN,scalar:vn,scatterND:C5,scatter_util:ede,searchSorted:nN,selu:lN,separableConv2d:cN,serialization:tpe,setBackend:voe,setPlatform:woe,setdiff1dAsync:x5,sigmoid:Yc,sign:lk,signal:U5,sin:uN,sinh:hN,slice:ds,slice1d:rA,slice2d:dN,slice3d:oA,slice4d:Jx,slice_util:n8,softmax:lA,softplus:Dg,spaceToBatchND:iA,sparse:z5,sparseToDense:T5,spectral:F5,split:wo,sqrt:La,square:Xs,squaredDifference:pN,squeeze:hp,stack:Ro,step:Og,stridedSlice:ck,string:$5,sub:en,sum:sn,sumOutType:HM,tan:uk,tanh:Xf,tensor:rc,tensor1d:xr,tensor2d:Ex,tensor3d:hk,tensor4d:y5,tensor5d:v5,tensor6d:b5,tensorScatterUpdate:S5,tensor_util:ioe,test_util:fhe,tidy:Le,tile:vl,time:yoe,topk:fk,train:Nm,transpose:ls,truncatedNormal:gN,unique:pk,unregisterGradient:kre,unregisterKernel:Bre,unsortedSegmentSum:xN,unstack:Tl,upcastType:To,upperBound:_5,util:Wre,valueAndGrad:Jce,valueAndGrads:Zce,variable:mk,variableGrads:XH,version_core:Ppe,where:er,whereAsync:gk,zeros:aa,zerosLike:ps},Symbol.toStringTag,{value:"Module"}));const jpe=Pe();jpe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var jo;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(jo||(jo={}));var Bz;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(Bz||(Bz={}));const nL={};function Xpe(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};nL[n]=t}function N8(n){return nL[n]}function qpe(n){delete nL[n]}function $(n,e,t,s,i){const a=e.inputParams[n];if(a&&a.inputIndexStart!==void 0){const o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,c=o<0?e.inputNames.length+o:o;if(a.type==="tensor")return Ka(e.inputNames[c],t,s,i);if(a.type==="tensors"){const p=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((v,_)=>{var S;return((S=p[_])===null||S===void 0?void 0:S.op)!=="NoOp"}).map(v=>Ka(v,t,s,i))}const h=Ka(e.inputNames[c],t,s,i),d=h.dataSync();return a.type==="number"?d[0]:_l(h.shape,d)}const r=e.attrParams[n];return r&&r.value}function Ka(n,e,t,s){const[i,a]=Xo(n,t);if(s!=null){const o=s.getHashTableHandleByName(i);if(o!=null)return o}const r=t.currentContextIds.find(o=>!!e[NE(i,o)]);return r!==void 0?e[NE(i,r)][a]:void 0}function kz(n,e,t){return e[NE(n,t.currentContextId)]}function td(n,e){const[t,s,i]=Xo(n,e);return[NE(t,e&&e.currentContextId),s,i]}function NE(n,e){return e?`${n}-${e}`:n}function Xo(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const a=e.parseNodeNameCache.get(n);if(a!=null)return a}const s=n.split(":");let i;if(s.length===1)i=[n,0,void 0];else{const a=s[0],r=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);i=[a,o,r]}return t&&e.parseNodeNameCache.set(n,i),i}function _T(n,e,t){let s=$("pad",n,e,t);if(s==="explicit"){s=$("explicitPaddings",n,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)i[a][0]=s[a*2],i[a][1]=s[a*2+1];return i}return s}function nd(n){return n.kept?n:eh(n)}const Kpe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ype=Object.freeze(Object.defineProperty({__proto__:null,json:Kpe},Symbol.toStringTag,{value:"Module"}));const Jpe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Zpe=Object.freeze(Object.defineProperty({__proto__:null,json:Jpe},Symbol.toStringTag,{value:"Module"}));const Qpe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],eme=Object.freeze(Object.defineProperty({__proto__:null,json:Qpe},Symbol.toStringTag,{value:"Module"}));const tme=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],nme=Object.freeze(Object.defineProperty({__proto__:null,json:tme},Symbol.toStringTag,{value:"Module"}));const sme=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],ime=Object.freeze(Object.defineProperty({__proto__:null,json:sme},Symbol.toStringTag,{value:"Module"}));const ame=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],rme=Object.freeze(Object.defineProperty({__proto__:null,json:ame},Symbol.toStringTag,{value:"Module"}));const ome=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],lme=Object.freeze(Object.defineProperty({__proto__:null,json:ome},Symbol.toStringTag,{value:"Module"}));const cme=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ume=Object.freeze(Object.defineProperty({__proto__:null,json:cme},Symbol.toStringTag,{value:"Module"}));const hme=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],dme=Object.freeze(Object.defineProperty({__proto__:null,json:hme},Symbol.toStringTag,{value:"Module"}));const fme=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],pme=Object.freeze(Object.defineProperty({__proto__:null,json:fme},Symbol.toStringTag,{value:"Module"}));const mme=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],gme=Object.freeze(Object.defineProperty({__proto__:null,json:mme},Symbol.toStringTag,{value:"Module"}));const xme=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],yme=Object.freeze(Object.defineProperty({__proto__:null,json:xme},Symbol.toStringTag,{value:"Module"}));const vme=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],bme=Object.freeze(Object.defineProperty({__proto__:null,json:vme},Symbol.toStringTag,{value:"Module"}));const Sme=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],_me=Object.freeze(Object.defineProperty({__proto__:null,json:Sme},Symbol.toStringTag,{value:"Module"}));const Ame=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],wme=Object.freeze(Object.defineProperty({__proto__:null,json:Ame},Symbol.toStringTag,{value:"Module"}));const Cme=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Tme=Object.freeze(Object.defineProperty({__proto__:null,json:Cme},Symbol.toStringTag,{value:"Module"}));const Eme=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Mme=Object.freeze(Object.defineProperty({__proto__:null,json:Eme},Symbol.toStringTag,{value:"Module"}));const Nme=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Rme=Object.freeze(Object.defineProperty({__proto__:null,json:Nme},Symbol.toStringTag,{value:"Module"}));const Ime=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Dme=Object.freeze(Object.defineProperty({__proto__:null,json:Ime},Symbol.toStringTag,{value:"Module"}));class Lz{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Ype,Zpe,eme,nme,ime,rme,lme,ume,dme,pme,gme,yme,bme,_me,wme,Tme,Mme,Rme,Dme],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}transformGraph(e,t={}){const s=e.node,i=[],a=[],r=[],o=s.reduce((_,S)=>(_[S.name]=this.mapNode(S),S.op.startsWith("Placeholder")?i.push(_[S.name]):S.op==="Const"?a.push(_[S.name]):(S.input==null||S.input.length===0)&&r.push(_[S.name]),_),{});let l=[];const c=[];let h={},d={};t!=null&&(h=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const p=Object.keys(o);p.forEach(_=>{const S=o[_];S.inputNames.forEach((b,w)=>{const[T,,E]=td(b),R=o[T];if(R.outputs!=null){const D=R.outputs.indexOf(E);if(D!==-1){const F=`${T}:${D}`;S.inputNames[w]=F}}S.inputs.push(R),R.children.push(S)})}),Object.keys(d).length===0?p.forEach(_=>{const S=o[_];S.children.length===0&&c.push(S)}):Object.keys(d).forEach(_=>{const[S]=td(_),b=o[S];b!=null&&(b.signatureKey=d[_],c.push(b))}),Object.keys(h).length>0?Object.keys(h).forEach(_=>{const[S]=td(_),b=o[S];b&&(b.signatureKey=h[_],l.push(b))}):l=i;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((_,S)=>(_[S.signature.name]=this.mapFunction(S),_),{}));const v={nodes:o,inputs:l,outputs:c,weights:a,placeholders:i,signature:t,functions:g};return r.length>0&&(v.initNodes=r),v}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=N8(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((i,a)=>(i[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},i),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((i,a)=>{const r=a.type;let o;switch(a.type){case"string":o=gD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=gD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=AD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=AD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=yD(e.attr,a.tfName,a.defaultValue||0),o===void 0&&a.tfDeprecatedName&&(o=yD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=_D(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=_D(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=xD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=xD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=CD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=CD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=SD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=SD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=wD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=wD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=vD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=vD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=bD(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=bD(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=Fz(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=Fz(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return i[a.name]={value:o,type:r},i},{})),s}mapFunction(e){const t=e.nodeDef,s=[],i=[];let a={};t!=null&&(a=t.reduce((d,p)=>(d[p.name]=this.mapNode(p),p.op==="Const"&&i.push(d[p.name]),d),{}));const r=[],o=[];e.signature.inputArg.forEach(d=>{const[p]=td(d.name),g={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:sL(d.type),type:"dtype"}},children:[]};g.signatureKey=d.name,r.push(g),a[p]=g}),Object.keys(a).forEach(d=>{const p=a[d];p.inputNames.forEach((g,v)=>{const[_,,S]=td(g),b=a[_];if(b.outputs!=null){const w=b.outputs.indexOf(S);if(w!==-1){const T=`${_}:${w}`;p.inputNames[v]=T}}p.inputs.push(b),b.children.push(p)})});const c=e.ret;e.signature.outputArg.forEach(d=>{const[p,g]=td(c[d.name]),v=a[p];v!=null&&(v.defaultOutput=g,o.push(v))});const h=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:o,weights:i,placeholders:s,signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Ome(n){const e=Pe().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function R8(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):Ome(n);return e?t:t.toLowerCase()}function gD(n,e,t,s=!1){const i=n[e];return i!=null?R8(i.s,s):t}function xD(n,e,t){const s=n[e];return s?s.b:t}function yD(n,e,t){const s=n[e]||{},i=s.i!=null?s.i:s.f!=null?s.f:t;return typeof i=="number"?i:parseInt(i,10)}function sL(n){switch(typeof n=="string"&&(n=jo[n]),n){case jo.DT_FLOAT:case jo.DT_HALF:return"float32";case jo.DT_INT32:case jo.DT_INT64:case jo.DT_INT8:case jo.DT_UINT8:return"int32";case jo.DT_BOOL:return"bool";case jo.DT_DOUBLE:return"float32";case jo.DT_STRING:return"string";case jo.DT_COMPLEX64:case jo.DT_COMPLEX128:return"complex64";default:return null}}function Fz(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function vD(n,e,t){const s=n[e];return s&&s.type?sL(s.type):t}function bD(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(i=>sL(i)):t}function I8(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function SD(n,e,t){const s=n[e];return s&&s.shape?I8(s.shape):t}function _D(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function AD(n,e,t,s=!1){const i=n[e];return i&&i.list&&i.list.s?i.list.s.map(a=>R8(a,s)):t}function wD(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(i=>I8(i)):t}function CD(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class Bme{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,a)=>(i[a]=this.getAttr(a),i),{}))}getInput(e){return Ka(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Ka(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return yD(this.node.rawAttrs,e,t);if(s.s!=null)return gD(this.node.rawAttrs,e,t);if(s.b!=null)return xD(this.node.rawAttrs,e,t);if(s.shape!=null)return SD(this.node.rawAttrs,e,t);if(s.type!=null)return vD(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return _D(this.node.rawAttrs,e,t);if(s.list.s!=null)return AD(this.node.rawAttrs,e,t);if(s.list.shape!=null)return wD(this.node.rawAttrs,e,t);if(s.list.b!=null)return CD(this.node.rawAttrs,e,t);if(s.list.type!=null)return bD(this.node.rawAttrs,e,t)}return t}}const ar=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:hB,abs:ia,acos:yB,acosh:vB,add:bt,addN:FH,all:jM,any:uS,argMax:dg,argMin:bB,asin:SB,asinh:_B,atan:AB,atan2:wB,atanh:CB,avgPool:q_,avgPool3d:EB,basicLSTMCell:UH,batchNorm:fv,batchNorm2d:MB,batchNorm3d:NB,batchNorm4d:RB,batchToSpaceND:K_,bincount:IB,bitwiseAnd:PH,booleanMaskAsync:A5,broadcastArgs:zH,broadcastTo:Ym,buffer:Hn,cast:Ft,ceil:DB,clipByValue:Mo,clone:eh,complex:xd,concat:ji,concat1d:OB,concat2d:BB,concat3d:kB,concat4d:LB,conv1d:XM,conv2d:yd,conv2dTranspose:qM,conv3d:UB,conv3dTranspose:PB,cos:Y_,cosh:KM,cosineWindow:vN,cumprod:fS,cumsum:YM,denseBincount:EE,depthToSpace:zB,depthwiseConv2d:pv,diag:GH,dilation2d:$B,div:un,divNoNan:GB,dot:VB,dropout:xk,einsum:Dm,elu:mv,enclosingPowerOfTwo:yk,ensureShape:VH,equal:oc,erf:JM,euclideanNorm:WB,exp:No,expandDims:gr,expm1:jB,eye:ZM,fft:cA,fill:Ig,floor:xv,floorDiv:WM,fused:D5,gather:yv,gatherND:E5,greater:Do,greaterEqual:Td,ifft:Zx,imag:J_,image:qc,inTopKAsync:M5,irfft:fN,isFinite:XB,isInf:qB,isNaN:KB,leakyRelu:Z_,less:qx,lessEqual:cp,linalg:Sk,linspace:jH,localResponseNormalization:YB,log:Jo,log1p:Q_,logSigmoid:JB,logSoftmax:eN,logSumExp:eA,logicalAnd:eu,logicalNot:tA,logicalOr:tN,logicalXor:ZB,losses:P5,lowerBound:qH,matMul:Zn,max:Al,maxPool:nA,maxPool3d:QB,maxPoolWithArgmax:KH,maximum:mh,mean:Ai,meshgrid:YH,min:Xx,minimum:qf,mirrorPad:ek,mod:tk,moments:sA,movingAverage:w5,mul:we,multiRNNCell:JH,multinomial:ZH,neg:ri,norm:gv,notEqual:mg,oneHot:Kx,ones:_o,onesLike:Zo,op:be,outerProduct:QH,pad:Ed,pad1d:e5,pad2d:t5,pad3d:n5,pad4d:s5,pool:nk,pow:ch,prelu:aA,print:xB,prod:sk,raggedGather:i5,raggedRange:a5,raggedTensorToTensor:r5,rand:o5,randomGamma:u5,randomNormal:iN,randomStandardNormal:h5,randomUniform:up,randomUniformInt:d5,range:gg,real:Yx,reciprocal:ok,relu:ou,relu6:aN,reshape:Ee,reverse:Cl,reverse1d:f5,reverse2d:p5,reverse3d:m5,reverse4d:g5,rfft:uA,round:rN,rsqrt:oN,scalar:vn,scatterND:C5,searchSorted:nN,selu:lN,separableConv2d:cN,setdiff1dAsync:x5,sigmoid:Yc,sign:lk,signal:U5,sin:uN,sinh:hN,slice:ds,slice1d:rA,slice2d:dN,slice3d:oA,slice4d:Jx,softmax:lA,softplus:Dg,spaceToBatchND:iA,sparse:z5,sparseToDense:T5,spectral:F5,split:wo,sqrt:La,square:Xs,squaredDifference:pN,squeeze:hp,stack:Ro,step:Og,stridedSlice:ck,string:$5,sub:en,sum:sn,tan:uk,tanh:Xf,tensor:rc,tensor1d:xr,tensor2d:Ex,tensor3d:hk,tensor4d:y5,tensor5d:v5,tensor6d:b5,tensorScatterUpdate:S5,tile:vl,topk:fk,transpose:ls,truncatedNormal:gN,unique:pk,unsortedSegmentSum:xN,unstack:Tl,upperBound:_5,variable:mk,where:er,whereAsync:gk,zeros:aa,zerosLike:ps},Symbol.toStringTag,{value:"Module"}));const kme=(n,e,t,s=ar)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add($("a",n,e,t),$("b",n,e,t))];case"AddN":return[s.addN($("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod($("a",n,e,t),$("b",n,e,t))];case"Mul":return[s.mul($("a",n,e,t),$("b",n,e,t))];case"RealDiv":case"Div":return[s.div($("a",n,e,t),$("b",n,e,t))];case"DivNoNan":return[s.divNoNan($("a",n,e,t),$("b",n,e,t))];case"FloorDiv":return[s.floorDiv($("a",n,e,t),$("b",n,e,t))];case"Sub":return[s.sub($("a",n,e,t),$("b",n,e,t))];case"Minimum":return[s.minimum($("a",n,e,t),$("b",n,e,t))];case"Maximum":return[s.maximum($("a",n,e,t),$("b",n,e,t))];case"Pow":return[s.pow($("a",n,e,t),$("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference($("a",n,e,t),$("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Lme=(n,e,t,s=ar)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs($("x",n,e,t))];case"Acos":return[s.acos($("x",n,e,t))];case"Acosh":return[s.acosh($("x",n,e,t))];case"Asin":return[s.asin($("x",n,e,t))];case"Asinh":return[s.asinh($("x",n,e,t))];case"Atan":return[s.atan($("x",n,e,t))];case"Atan2":return[s.atan2($("x",n,e,t),$("y",n,e,t))];case"Atanh":return[s.atanh($("x",n,e,t))];case"Ceil":return[s.ceil($("x",n,e,t))];case"Complex":return[s.complex($("real",n,e,t),$("imag",n,e,t))];case"Cos":return[s.cos($("x",n,e,t))];case"Cosh":return[s.cosh($("x",n,e,t))];case"Elu":return[s.elu($("x",n,e,t))];case"Erf":return[s.erf($("x",n,e,t))];case"Exp":return[s.exp($("x",n,e,t))];case"Expm1":return[s.expm1($("x",n,e,t))];case"Floor":return[s.floor($("x",n,e,t))];case"Log":return[s.log($("x",n,e,t))];case"Log1p":return[s.log1p($("x",n,e,t))];case"Imag":return[s.imag($("x",n,e,t))];case"Neg":return[s.neg($("x",n,e,t))];case"Reciprocal":return[s.reciprocal($("x",n,e,t))];case"Real":return[s.real($("x",n,e,t))];case"Relu":return[s.relu($("x",n,e,t))];case"Round":return[s.round($("x",n,e,t))];case"Selu":return[s.selu($("x",n,e,t))];case"Sigmoid":return[s.sigmoid($("x",n,e,t))];case"Sin":return[s.sin($("x",n,e,t))];case"Sign":return[s.sign($("x",n,e,t))];case"Sinh":return[s.sinh($("x",n,e,t))];case"Softplus":return[s.softplus($("x",n,e,t))];case"Sqrt":return[s.sqrt($("x",n,e,t))];case"Square":return[s.square($("x",n,e,t))];case"Tanh":return[s.tanh($("x",n,e,t))];case"Tan":return[s.tan($("x",n,e,t))];case"ClipByValue":return[s.clipByValue($("x",n,e,t),$("clipValueMin",n,e,t),$("clipValueMax",n,e,t))];case"Relu6":return[s.relu6($("x",n,e,t))];case"Rsqrt":return[s.rsqrt(Ka(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu($("x",n,e,t),$("alpha",n,e,t))];case"Prelu":return[s.prelu($("x",n,e,t),$("alpha",n,e,t))];case"IsNan":return[s.isNaN(Ka(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(Ka(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(Ka(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Zl(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){ee(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const i=n[s],a=e[s];ee(i<0||a<0||i===a,()=>t+` Shapes ${n} and ${e} must match`)}}}function Uz(n){return!(typeof n=="number"||n.some(e=>e<0))}function v1(n,e,t){let s=TD(n,t);const i=!Uz(s);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&e.forEach(a=>{s=TD(a.shape,s)}),!Uz(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function TD(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const i=n[s],a=e[s];if(i>=0&&a>=0&&i!==a)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=i>=0?i:a}return t}class Fme{constructor(e,t,s,i,a,r,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=a,this.dynamicSize=r,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=vn(0),ga(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Zl(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,ga(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,i)=>this.write(s,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return rc([],[0].concat(this.elementShape));const s=this.readMany(e);return Zl(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Ro(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return rc([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const s=this.readMany(t);return Zl(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ji(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Tl(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const i=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:t.size/s,r=[];Le(()=>{t=Ee(t,[1,s,a]);for(let l=0;l<e.length;++l){const h=[0,l===0?0:i[l-1],0],d=[1,e[l],a];r[l]=Ee(ds(t,h,d),this.elementShape)}return r});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,r)}}class yg{get id(){return this.idTensor.id}constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);Zl(t,a.shape,"TensorList shape mismatch: "),ga(a)}),this.idTensor=vn(0),this.maxNumElements=i,ga(this.idTensor)}copy(){return new yg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Zl(e,this.elementShape,"TensorList shape mismatch: ");const i=v1(this.elementShape,this.tensors,e);return Le(()=>{const a=this.tensors.map(r=>Ee(r,i));return Ro(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=v1(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,Zl(i.shape,e,"TensorList shape mismatch: "),Ee(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Zl(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ga(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new yg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Zl(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=v1(this.elementShape,this.tensors,t);return Ee(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Zl(this.elementShape,t.shape,"TensorList shape mismatch: "),ga(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Zl(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=v1(this.elementShape,this.tensors,s);return e.length===0?rc([],[0].concat(i)):Le(()=>{const a=e.map(r=>Ee(this.tensors[r],i));return Ro(a,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Zl(this.elementShape,t,"TensorList shape mismatch: ");const s=v1(this.elementShape,this.tensors,t);return this.size()===0?rc([],[0].concat(s)):Le(()=>{const i=this.tensors.map(a=>Ee(a,s));return ji(i,0)})}}function Ume(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const i=n.shape.slice(1);Zl(i,e,"TensorList shape mismatch: ");const a=Tl(n);return new yg(a,e,s)}function Pme(n,e,t,s){return new yg([],n,e,s)}function zme(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const i=Math.max(...e);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const a=new yg([],t,n.dtype,s),r=Tl(n,0);return e.forEach((o,l)=>{a.setItem(o,r[l])}),a}function $me(n,e,t){let s=0;const i=e.map(h=>(s+=h,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const a=n.shape.slice(1),r=TD(a,t),o=s===0?0:n.size/s,l=Le(()=>{const h=[];n=Ee(n,[1,s,o]);for(let d=0;d<e.length;++d){const g=[0,d===0?0:i[d-1],0],v=[1,e[d],o];h[d]=Ee(ds(n,g,v),r)}return n.dispose(),h}),c=new yg([],t,n.dtype,e.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}const Gme=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=$("thenBranch",n,e,t),i=$("elseBranch",n,e,t),a=$("cond",n,e,t),r=$("args",n,e,t);return(await a.data())[0]?t.functionMap[s].executeFunctionAsync(r,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(r,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=$("body",n,e,t),i=$("cond",n,e,t),a=$("args",n,e,t),r=await t.functionMap[i].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap),o=a.map(h=>h.id);let l=await r[0].data();r.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&h.dispose()});let c=a;for(;l[0];){const h=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const d=c.map(g=>g.id);h.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&d.indexOf(g.id)===-1&&g.dispose()});const p=await t.functionMap[i].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await p[0].data(),p.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&d.indexOf(g.id)===-1&&g.dispose()})}return c}case"LoopCond":{const s=$("pred",n,e,t);return[nd(s)]}case"Switch":{const s=$("pred",n,e,t);let i=$("data",n,e,t);return i.kept||(i=nd(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=n.inputNames.find(i=>Ka(i,e,t)!==void 0);if(s){const i=Ka(s,e,t);return[nd(i)]}return}case"Enter":{const s=$("frameName",n,e,t),i=$("tensor",n,e,t);return t.enterFrame(s),[nd(i)]}case"Exit":{const s=$("tensor",n,e,t);return t.exitFrame(),[nd(s)]}case"NextIteration":{const s=$("tensor",n,e,t);return t.nextIteration(),[nd(s)]}case"TensorArrayV3":{const s=$("size",n,e,t),i=$("dtype",n,e,t),a=$("elementShape",n,e,t),r=$("dynamicSize",n,e,t),o=$("clearAfterRead",n,e,t),l=$("identicalElementShapes",n,e,t),c=$("name",n,e,t),h=new Fme(c,i,s,a,l,r,o);return t.addTensorArray(h),[h.idTensor,vn(1)]}case"TensorArrayWriteV3":{const s=$("tensorArrayId",n,e,t),i=$("index",n,e,t),a=$("tensor",n,e,t),r=t.getTensorArray(s.id);return r.write(i,a),[r.idTensor]}case"TensorArrayReadV3":{const s=$("tensorArrayId",n,e,t),i=$("index",n,e,t);return[t.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=$("tensorArrayId",n,e,t),i=$("indices",n,e,t),a=$("dtype",n,e,t);return[t.getTensorArray(s.id).gather(i,a)]}case"TensorArrayScatterV3":{const s=$("tensorArrayId",n,e,t),i=$("indices",n,e,t),a=$("tensor",n,e,t),r=t.getTensorArray(s.id);return r.scatter(i,a),[r.idTensor]}case"TensorArrayConcatV3":{const s=$("tensorArrayId",n,e,t),i=t.getTensorArray(s.id),a=$("dtype",n,e,t);return[i.concat(a)]}case"TensorArraySplitV3":{const s=$("tensorArrayId",n,e,t),i=$("tensor",n,e,t),a=$("lengths",n,e,t),r=t.getTensorArray(s.id);return r.split(a,i),[r.idTensor]}case"TensorArraySizeV3":{const s=$("tensorArrayId",n,e,t),i=t.getTensorArray(s.id);return[vn(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=$("tensorArrayId",n,e,t),i=t.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=$("tensorListId",n,e,t),i=$("index",n,e,t),a=$("tensor",n,e,t),r=t.getTensorList(s.id);return r.setItem(i,a),[r.idTensor]}case"TensorListGetItem":{const s=$("tensorListId",n,e,t),i=$("index",n,e,t),a=$("elementShape",n,e,t),r=$("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(i,a,r)]}case"TensorListScatterV2":case"TensorListScatter":{const s=$("indices",n,e,t),i=$("tensor",n,e,t),a=$("elementShape",n,e,t),r=$("numElements",n,e,t),o=zme(i,s,a,r);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=$("elementShape",n,e,t),i=$("elementDType",n,e,t);let a;n.op==="TensorListReserve"?a="numElements":a="maxNumElements";const r=$(a,n,e,t),o=n.op==="TensorListReserve"?-1:r,l=Pme(s,i,r,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=$("tensorListId",n,e,t),i=$("indices",n,e,t),a=$("elementShape",n,e,t),r=$("elementDType",n,e,t);return[t.getTensorList(s.id).gather(i,r,a)]}case"TensorListStack":{const s=$("tensorListId",n,e,t),i=$("elementShape",n,e,t),a=$("elementDType",n,e,t),r=$("numElements",n,e,t);return[t.getTensorList(s.id).stack(i,a,r)]}case"TensorListFromTensor":{const s=$("tensor",n,e,t),i=$("elementShape",n,e,t),a=$("elementDType",n,e,t),r=Ume(s,i,a);return t.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=$("tensorListId",n,e,t),i=t.getTensorList(s.id),a=$("dtype",n,e,t),r=$("elementShape",n,e,t);return[i.concat(a,r)]}case"TensorListPushBack":{const s=$("tensorListId",n,e,t),i=$("tensor",n,e,t),a=t.getTensorList(s.id);return a.pushBack(i),[a.idTensor]}case"TensorListPopBack":{const s=$("tensorListId",n,e,t),i=$("elementShape",n,e,t),a=$("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(i,a)]}case"TensorListSplit":{const s=$("tensor",n,e,t),i=$("elementShape",n,e,t),a=$("lengths",n,e,t),r=$me(s,a,i);return t.addTensorList(r),[r.idTensor]}case"TensorListLength":{const s=$("tensorListId",n,e,t),i=t.getTensorList(s.id);return[vn(i.size(),"int32")]}case"TensorListResize":{const s=$("tensorListId",n,e,t),i=$("size",n,e,t),r=t.getTensorList(s.id).resize(i);return t.addTensorList(r),[r.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Pz(n,e,t){const[s,i]=$("fusedOps",n,e,t),a=s==="biasadd",r=!a,o=i==="prelu",l=s==="fusedbatchnorm",c=$("numArgs",n,e,t);if(a){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=$("strides",n,e,t),d=_T(n,e,t),p=$("dataFormat",n,e,t).toUpperCase(),g=$("dilations",n,e,t);let[v,_]=$("args",n,e,t);r&&(_=v,v=void 0);const S=$("leakyreluAlpha",n,e,t);return{stride:h,pad:d,dataFormat:p,dilations:g,biasArg:v,preluArg:_,activationFunc:i,leakyreluAlpha:S}}const Vme=(n,e,t,s=ar)=>{switch(n.op){case"Conv1D":{const i=$("stride",n,e,t),a=$("pad",n,e,t),r=$("dataFormat",n,e,t).toUpperCase(),o=$("dilation",n,e,t);return[s.conv1d($("x",n,e,t),$("filter",n,e,t),i,a,r,o)]}case"Conv2D":{const i=$("strides",n,e,t),a=_T(n,e,t),r=$("dataFormat",n,e,t).toUpperCase(),o=$("dilations",n,e,t);return[s.conv2d($("x",n,e,t),$("filter",n,e,t),[i[1],i[2]],a,r,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:a,dataFormat:r,dilations:o,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=Pz(n,e,t);return[s.fused.conv2d({x:$("x",n,e,t),filter:$("filter",n,e,t),strides:[i[1],i[2]],pad:a,dataFormat:r,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:a,dataFormat:r,dilations:o,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=Pz(n,e,t);return[s.fused.depthwiseConv2d({x:$("x",n,e,t),filter:$("filter",n,e,t),strides:[i[1],i[2]],pad:a,dataFormat:r,dilations:[o[1],o[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=$("outputShape",n,e,t),a=$("strides",n,e,t),r=_T(n,e,t);return[s.conv2dTranspose($("x",n,e,t),$("filter",n,e,t),i,[a[1],a[2]],r)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=$("strides",n,e,t),a=_T(n,e,t),r=$("dilations",n,e,t),o=$("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d($("input",n,e,t),$("filter",n,e,t),[i[1],i[2]],a,o,[r[1],r[2]])]}case"Conv3D":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("dataFormat",n,e,t).toUpperCase(),o=$("dilations",n,e,t);return[s.conv3d($("x",n,e,t),$("filter",n,e,t),[i[1],i[2],i[3]],a,r,[o[1],o[2],o[3]])]}case"AvgPool":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("kernelSize",n,e,t);return[s.avgPool($("x",n,e,t),[r[1],r[2]],[i[1],i[2]],a)]}case"MaxPool":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("kernelSize",n,e,t);return[s.maxPool($("x",n,e,t),[r[1],r[2]],[i[1],i[2]],a)]}case"MaxPoolWithArgmax":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("kernelSize",n,e,t),o=$("includeBatchInIndex",n,e,t),{result:l,indexes:c}=s.maxPoolWithArgmax($("x",n,e,t),[r[1],r[2]],[i[1],i[2]],a,o);return[l,c]}case"AvgPool3D":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("kernelSize",n,e,t);return[s.avgPool3d($("x",n,e,t),[r[1],r[2],r[3]],[i[1],i[2],i[3]],a)]}case"MaxPool3D":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("kernelSize",n,e,t);return[s.maxPool3d($("x",n,e,t),[r[1],r[2],r[3]],[i[1],i[2],i[3]],a)]}case"Dilation2D":{const i=$("strides",n,e,t),a=$("pad",n,e,t),r=$("dilations",n,e,t),o=i[1],l=i[2],c=r[1],h=r[2];return[s.dilation2d($("x",n,e,t),$("filter",n,e,t),[o,l],a,[c,h],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Hme=(n,e,t,s=ar)=>{switch(n.op){case"Fill":{const i=$("shape",n,e,t),a=$("dtype",n,e,t),r=$("value",n,e,t);return[s.fill(i,r,a)]}case"LinSpace":{const i=$("start",n,e,t),a=$("stop",n,e,t),r=$("num",n,e,t);return[s.linspace(i,a,r)]}case"Multinomial":{const i=$("logits",n,e,t),a=$("numSamples",n,e,t),r=$("seed",n,e,t);return[s.multinomial(i,a,r)]}case"OneHot":{const i=$("indices",n,e,t),a=$("depth",n,e,t),r=$("onValue",n,e,t),o=$("offValue",n,e,t),l=$("dtype",n,e,t);return[s.oneHot(i,a,r,o,l)]}case"Ones":return[s.ones($("shape",n,e,t),$("dtype",n,e,t))];case"OnesLike":return[s.onesLike($("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal($("shape",n,e,t),$("dtype",n,e,t),$("seed",n,e,t))];case"RandomUniform":return[s.randomUniform($("shape",n,e,t),$("minval",n,e,t),$("maxval",n,e,t),$("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt($("shape",n,e,t),$("minval",n,e,t),$("maxval",n,e,t),$("seed",n,e,t))];case"Range":{const i=$("start",n,e,t),a=$("stop",n,e,t),r=$("step",n,e,t);return[s.range(i,a,r,$("dtype",n,e,t))]}case"TruncatedNormal":{const i=$("shape",n,e,t),a=$("mean",n,e,t),r=$("stdDev",n,e,t),o=$("seed",n,e,t);return[s.truncatedNormal(i,a,r,$("dtype",n,e,t),o)]}case"Zeros":return[s.zeros($("shape",n,e,t),$("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function l3(n,e,t){const s=$("boxes",n,e,t),i=$("scores",n,e,t),a=$("maxOutputSize",n,e,t),r=$("iouThreshold",n,e,t),o=$("scoreThreshold",n,e,t),l=$("softNmsSigma",n,e,t);return{boxes:s,scores:i,maxOutputSize:a,iouThreshold:r,scoreThreshold:o,softNmsSigma:l}}const Wme=async(n,e,t,s,i=ar)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:r,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=l3(n,e,t),d=await i.image.nonMaxSuppressionWithScoreAsync(a,r,o,l,c,h);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:r,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=l3(n,e,t),h=$("padToMaxOutputSize",n,e,t),d=await i.image.nonMaxSuppressionPaddedAsync(a,r,o,l,c,h);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:r,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=l3(n,e,t);return[await i.image.nonMaxSuppressionAsync(a,r,o,l,c)]}case"Where":{const a=i.cast($("condition",n,e,t),"bool"),r=[await i.whereAsync(a)];return a.dispose(),r}case"ListDiff":return i.setdiff1dAsync($("x",n,e,t),$("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const jme=(n,e,t,s=ar)=>{switch(n.op){case"LowerBound":{const i=$("sortedSequence",n,e,t),a=$("values",n,e,t);return[s.lowerBound(i,a)]}case"TopKV2":{const i=$("x",n,e,t),a=$("k",n,e,t),r=$("sorted",n,e,t),o=s.topk(i,a,r);return[o.values,o.indices]}case"UpperBound":{const i=$("sortedSequence",n,e,t),a=$("values",n,e,t);return[s.upperBound(i,a)]}case"Unique":{const i=$("x",n,e,t),a=s.unique(i);return[a.values,a.indices]}case"UniqueV2":{const i=$("x",n,e,t),a=$("axis",n,e,t),r=s.unique(i,a);return[r.values,r.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Xme=(n,e,t,s=ar)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const i=$("default",n,e,t);return[Ka(n.name,e,t)||i];case"Placeholder":return[Ka(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=$("x",n,e,t);return[nd(h)]}case"IdentityN":return $("x",n,e,t).map(h=>nd(h));case"Snapshot":const a=$("x",n,e,t);return[nd(a)];case"Shape":return[s.tensor1d($("x",n,e,t).shape,"int32")];case"ShapeN":return $("x",n,e,t).map(h=>s.tensor1d(h.shape));case"Size":return[s.scalar($("x",n,e,t).size,"int32")];case"Rank":return[s.scalar($("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const r=$("x",n,e,t),o=$("data",n,e,t),l=$("message",n,e,t),c=$("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<o.length;h++)console.log(Array.prototype.slice.call(o[h].dataSync()).slice(0,c));return[r];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class qme{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=vn(0),this.tensorMap=new Map,ga(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return vn(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),Le(()=>{const i=Tl(t),a=s.length,r=i.length;ee(a===r,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${r} elements.`);for(let o=0;o<a;o++){const l=s[o],c=i[o];ga(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return Le(()=>{const i=[];for(let a=0;a<s.length;a++){const r=s[a],o=this.findWithDefault(r,t);i.push(o)}return Ro(i)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const Kme=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(n.name);if(i!=null)return[i];{const a=$("keyDType",n,e,t),r=$("valueDType",n,e,t),o=new qme(a,r);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=$("tableHandle",n,e,t,s),a=$("keys",n,e,t),r=$("values",n,e,t);return[await s.getHashTableById(i.id).import(a,r)]}case"LookupTableFind":case"LookupTableFindV2":{const i=$("tableHandle",n,e,t,s),a=$("keys",n,e,t),r=$("defaultValue",n,e,t);return[await s.getHashTableById(i.id).find(a,r)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=$("tableHandle",n,e,t,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Yme=(n,e,t,s=ar)=>{switch(n.op){case"ResizeBilinear":{const i=$("images",n,e,t),a=$("size",n,e,t),r=$("alignCorners",n,e,t),o=$("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(i,[a[0],a[1]],r,o)]}case"ResizeNearestNeighbor":{const i=$("images",n,e,t),a=$("size",n,e,t),r=$("alignCorners",n,e,t),o=$("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(i,[a[0],a[1]],r,o)]}case"CropAndResize":{const i=$("image",n,e,t),a=$("boxes",n,e,t),r=$("boxInd",n,e,t),o=$("cropSize",n,e,t),l=$("method",n,e,t),c=$("extrapolationValue",n,e,t);return[s.image.cropAndResize(i,a,r,o,l,c)]}case"ImageProjectiveTransformV3":{const i=$("images",n,e,t),a=$("transforms",n,e,t),r=$("outputShape",n,e,t),o=$("fillValue",n,e,t),l=$("interpolation",n,e,t),c=$("fillMode",n,e,t);return[s.image.transform(i,a,l.toLowerCase(),c.toLowerCase(),o,r)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Jme=(n,e,t,s=ar)=>{switch(n.op){case"Equal":return[s.equal($("a",n,e,t),$("b",n,e,t))];case"NotEqual":return[s.notEqual($("a",n,e,t),$("b",n,e,t))];case"Greater":return[s.greater($("a",n,e,t),$("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual($("a",n,e,t),$("b",n,e,t))];case"Less":return[s.less($("a",n,e,t),$("b",n,e,t))];case"LessEqual":return[s.lessEqual($("a",n,e,t),$("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd($("a",n,e,t),$("b",n,e,t))];case"LogicalNot":return[s.logicalNot($("a",n,e,t))];case"LogicalOr":return[s.logicalOr($("a",n,e,t),$("b",n,e,t))];case"Select":case"SelectV2":return[s.where($("condition",n,e,t),$("a",n,e,t),$("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd($("a",n,e,t),$("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Zme=(n,e,t,s=ar)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul($("a",n,e,t),$("b",n,e,t),$("transposeA",n,e,t),$("transposeB",n,e,t))];case"Einsum":return[s.einsum($("equation",n,e,t),...$("tensors",n,e,t))];case"Transpose":return[s.transpose($("x",n,e,t),$("perm",n,e,t))];case"_FusedMatMul":const[i,a]=$("fusedOps",n,e,t),r=i==="biasadd",o=a==="prelu",l=$("numArgs",n,e,t),c=$("leakyreluAlpha",n,e,t);if(r){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,d]=$("args",n,e,t);return[s.fused.matMul({a:$("a",n,e,t),b:$("b",n,e,t),transposeA:$("transposeA",n,e,t),transposeB:$("transposeB",n,e,t),bias:h,activation:a,preluActivationWeights:d,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart($("a",n,e,t),$("numLower",n,e,t),$("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Qme=(n,e,t,s=ar)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm($("x",n,e,t),$("axis",n,e,t),$("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm($("x",n,e,t),$("mean",n,e,t),$("variance",n,e,t),$("offset",n,e,t),$("scale",n,e,t),$("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm($("x",n,e,t),$("mean",n,e,t),$("variance",n,e,t),$("offset",n,e,t),$("scale",n,e,t),$("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization($("x",n,e,t),$("radius",n,e,t),$("bias",n,e,t),$("alpha",n,e,t),$("beta",n,e,t))];case"Softmax":return[s.softmax($("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const ege=(n,e,t,s=ar)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:a}=s.raggedGather($("paramsNestedSplits",n,e,t),$("paramsDenseValues",n,e,t),$("indices",n,e,t),$("outputRaggedRank",n,e,t));return i.concat(a)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:a}=s.raggedRange($("starts",n,e,t),$("limits",n,e,t),$("splits",n,e,t));return[i,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor($("shape",n,e,t),$("values",n,e,t),$("defaultValue",n,e,t),$("rowPartitionTensors",n,e,t),$("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const tge=(n,e,t,s=ar)=>{switch(n.op){case"Max":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.max($("x",n,e,t),o,l)]}case"Mean":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.mean($("x",n,e,t),o,l)]}case"Min":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.min($("x",n,e,t),o,l)]}case"Sum":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.sum($("x",n,e,t),o,l)]}case"All":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.all($("x",n,e,t),o,l)]}case"Any":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.any($("x",n,e,t),o,l)]}case"ArgMax":{const o=$("axis",n,e,t);return[s.argMax($("x",n,e,t),o)]}case"ArgMin":{const o=$("axis",n,e,t);return[s.argMin($("x",n,e,t),o)]}case"Prod":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.prod($("x",n,e,t),o,l)]}case"Cumprod":{const o=$("axis",n,e,t),l=$("exclusive",n,e,t),c=$("reverse",n,e,t);return[s.cumprod($("x",n,e,t),o,l,c)]}case"Cumsum":{const o=$("axis",n,e,t),l=$("exclusive",n,e,t),c=$("reverse",n,e,t);return[s.cumsum($("x",n,e,t),o,l,c)]}case"Bincount":const i=$("x",n,e,t),a=$("weights",n,e,t),r=$("size",n,e,t);return[s.bincount(i,a,r)];case"DenseBincount":{const o=$("x",n,e,t),l=$("weights",n,e,t),c=$("size",n,e,t),h=$("binaryOutput",n,e,t);return[s.denseBincount(o,l,c,h)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const nge=(n,e,t,s=ar)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=$("n",n,e,t),a=$("axis",n,e,t);let r=$("tensors",n,e,t);return r=r.slice(0,i),[s.concat(r,a)]}case"Gather":{const i=$("x",n,e,t),a=$("indices",n,e,t);return[s.gather(i,s.cast(a,"int32"),0)]}case"GatherV2":{const i=$("axis",n,e,t),a=$("batchDims",n,e,t),r=$("x",n,e,t),o=$("indices",n,e,t);return[s.gather(r,s.cast(o,"int32"),i,a)]}case"Reverse":{const i=$("dims",n,e,t),a=[];for(let o=0;o<i.length;o++)i[o]&&a.push(o);const r=$("x",n,e,t);return[s.reverse(r,a)]}case"ReverseV2":{const i=$("axis",n,e,t),a=$("x",n,e,t);return[s.reverse(a,i)]}case"Slice":{const i=$("begin",n,e,t),a=$("size",n,e,t);return[s.slice($("x",n,e,t),i,a)]}case"StridedSlice":{const i=$("begin",n,e,t),a=$("end",n,e,t),r=$("strides",n,e,t),o=$("beginMask",n,e,t),l=$("endMask",n,e,t),c=$("ellipsisMask",n,e,t),h=$("newAxisMask",n,e,t),d=$("shrinkAxisMask",n,e,t),p=$("x",n,e,t);return[s.stridedSlice(p,i,a,r,o,l,c,h,d)]}case"Pack":return Le(()=>{const i=$("axis",n,e,t),a=$("tensors",n,e,t),r=a[0].shape,o=s.squeeze(a[0]).shape,l=a.map(c=>{const h=as(c.shape,r);if(!h&&!as(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return h?c:s.reshape(c,r)});return[s.stack(l,i)]});case"Unpack":{const i=$("axis",n,e,t),a=$("tensor",n,e,t);return s.unstack(a,i)}case"Tile":{const i=$("reps",n,e,t);return[s.tile($("x",n,e,t),i)]}case"Split":case"SplitV":{const i=$("axis",n,e,t),a=$("numOrSizeSplits",n,e,t),r=$("x",n,e,t);return s.split(r,a,i)}case"ScatterNd":{const i=$("indices",n,e,t),a=$("values",n,e,t),r=$("shape",n,e,t);return[s.scatterND(i,a,r)]}case"GatherNd":{const i=$("x",n,e,t),a=$("indices",n,e,t);return[s.gatherND(i,a)]}case"SparseToDense":{const i=$("sparseIndices",n,e,t),a=$("outputShape",n,e,t),r=$("sparseValues",n,e,t),o=$("defaultValue",n,e,t);return[s.sparseToDense(i,r,a,r.dtype===o.dtype?o:s.cast(o,r.dtype))]}case"TensorScatterUpdate":{const i=$("indices",n,e,t),a=$("values",n,e,t),r=$("tensor",n,e,t);return[s.tensorScatterUpdate(r,i,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const sge=(n,e,t,s=ar)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:a,emptyRowIndicator:r,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows($("indices",n,e,t),$("values",n,e,t),$("denseShape",n,e,t),$("defaultValue",n,e,t));return[i,a,r,o]}case"SparseReshape":{const{outputIndices:i,outputShape:a}=s.sparse.sparseReshape($("inputIndices",n,e,t),$("inputShape",n,e,t),$("newShape",n,e,t));return[i,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean($("data",n,e,t),$("indices",n,e,t),$("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum($("data",n,e,t),$("indices",n,e,t),$("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const ige=(n,e,t,s=ar)=>{switch(n.op){case"FFT":return[s.fft($("x",n,e,t))];case"IFFT":return[s.ifft($("x",n,e,t))];case"RFFT":return[s.rfft($("x",n,e,t))];case"IRFFT":return[s.irfft($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const age=(n,e,t,s=ar)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace($("input",n,e,t),$("pattern",n,e,t),$("rewrite",n,e,t),$("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:i,nGramsSplits:a}=s.string.stringNGrams($("data",n,e,t),$("dataSplits",n,e,t),$("separator",n,e,t),$("nGramWidths",n,e,t),$("leftPad",n,e,t),$("rightPad",n,e,t),$("padWidth",n,e,t),$("preserveShortSequences",n,e,t));return[i,a]}case"StringSplit":{const{indices:i,values:a,shape:r}=s.string.stringSplit($("input",n,e,t),$("delimiter",n,e,t),$("skipEmpty",n,e,t));return[i,a,r]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast($("input",n,e,t),$("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const rge=(n,e,t,s=ar)=>{switch(n.op){case"Cast":return[s.cast($("x",n,e,t),$("dtype",n,e,t))];case"ExpandDims":{const i=$("axis",n,e,t);return[s.expandDims($("x",n,e,t),i)]}case"Squeeze":{const i=$("axis",n,e,t);return[s.squeeze($("x",n,e,t),i)]}case"Reshape":return[s.reshape($("x",n,e,t),$("shape",n,e,t))];case"EnsureShape":return[s.ensureShape($("x",n,e,t),$("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad($("x",n,e,t),$("padding",n,e,t),$("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad($("x",n,e,t),$("padding",n,e,t),$("constantValue",n,e,t))];case"SpaceToBatchND":{const i=$("blockShape",n,e,t),a=$("paddings",n,e,t);return[s.spaceToBatchND($("x",n,e,t),i,a)]}case"BatchToSpaceND":{const i=$("blockShape",n,e,t),a=$("crops",n,e,t);return[s.batchToSpaceND($("x",n,e,t),i,a)]}case"DepthToSpace":{const i=$("blockSize",n,e,t),a=$("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace($("x",n,e,t),i,a)]}case"BroadcastTo":return[s.broadcastTo($("x",n,e,t),$("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs($("s0",n,e,t),$("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function zz(n,e,t,s,i=Le){const a=((r,o,l)=>{switch(r.category){case"arithmetic":return i(()=>kme(r,o,l));case"basic_math":return i(()=>Lme(r,o,l));case"control":return Gme(r,o,l);case"convolution":return i(()=>Vme(r,o,l));case"creation":return i(()=>Hme(r,o,l));case"dynamic":return Wme(r,o,l);case"evaluation":return i(()=>jme(r,o,l));case"image":return i(()=>Yme(r,o,l));case"graph":return i(()=>Xme(r,o,l));case"logical":return i(()=>Jme(r,o,l));case"matrices":return i(()=>Zme(r,o,l));case"normalization":return i(()=>Qme(r,o,l));case"ragged":return i(()=>ege(r,o,l));case"reduction":return i(()=>tge(r,o,l));case"slice_join":return i(()=>nge(r,o,l));case"sparse":return i(()=>sge(r,o,l));case"spectral":return i(()=>ige(r,o,l));case"string":return i(()=>age(r,o,l));case"transformation":return i(()=>rge(r,o,l));case"hash_table":return Kme(r,o,l,s);case"custom":const c=N8(r.op);if(c&&c.customExecutor)return c.customExecutor(new Bme(r,o,l));throw TypeError(`Custom op ${r.op} is not registered.`);default:throw TypeError(`Unknown op '${r.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Hf(a)?a.then(r=>[].concat(r)):[].concat(a)}class $z{constructor(e={},t={},s={},i={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=i,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Gz(n,e,t,s){const i=new Set,a=[];let r=null,o=null;const l=new Set,c=new Set(Object.keys(n).map(p=>Xo(p)[0]));s=s||[];const h=new Set(s.map(p=>Xo(p.name)[0])),d=[...e];for(;d.length>0;){const p=d.pop();if((Om(p)||pge(p)||mge(p))&&r==null&&(r=p,o=r.children.map(g=>g.name).filter(g=>i.has(g))),i.add(p.name),t[p.name]==null&&!c.has(p.name)&&!h.has(p.name)){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(g=>{l.has(g.name)||(l.add(g.name),d.push(g))})}}return{inputs:n,outputs:e,usedNodes:i,missingInputs:a,dynamicNode:r,syncInputs:o}}function oge(n,e){const{usedNodes:t,inputs:s}=e,i=Object.keys(s).map(S=>Xo(S)[0]).map(S=>n.nodes[S]),a=n.initNodes||[],r=S=>t.has(typeof S=="string"?S:S.name);function o(S){return[...new Map(S.map(b=>[b.name,b])).values()]}const l=o([...i,...n.weights,...a]).filter(r),c=o([...l,...Object.values(n.nodes)]).filter(r),h=new Map(c.map(S=>[S.name,S])),d={};for(const S of c){d[S.name]=d[S.name]||0;for(const b of S.children)r(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}const p=Object.entries(d).filter(([,S])=>S===0).map(([S])=>S),g=[...p];for(;p.length>0;){const S=p.pop(),b=h.get(S);for(const w of b.children.filter(r))--d[w.name]===0&&(g.push(w.name),p.push(w.name))}const v=g.map(S=>h.get(S)),_=lge(v,l);return cge(_,l),_}function lge(n,e){const t=new Map(n.map(r=>[r.name,r])),s=e.map(r=>r.name),i=new Set(s);for(;s.length>0;){const r=s.pop(),o=t.get(r);for(const l of o.children)!t.has(l.name)||i.has(l.name)||(i.add(l.name),s.push(l.name))}return n.filter(r=>i.has(r.name))}class XC extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function cge(n,e){const t=new Map(n.map((o,l)=>[o.name,l])),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name),a=new Set(n.map(o=>o.name)),r=o=>a.has(typeof o=="string"?o:o.name);for(const o of n){for(const l of o.children.filter(r)){if(!t.has(l.name))throw new XC(`Child ${l.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(l.name))throw new XC(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!i(o))for(const l of o.inputs){if(!t.has(l.name))throw new XC(`Input ${l.name} of node ${o.name} is unreachable.`);if(t.get(l.name)>t.get(o.name))throw new XC(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function uge(n){const e=new Map(n.map((o,l)=>[o.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((o,l)=>Om(o)?t:l),i=o=>{const l=s[e.get(o.name)];return l??-1},a=n.map((o,l)=>o.children.map(i).reduce((c,h)=>Math.max(c,h),s[l])),r=new Map;for(let o=0;o<n.length;++o){const l=a[o];if(l===t)continue;const c=n[o],h=n[l];r.has(h.name)||r.set(h.name,[]),r.get(h.name).push(c)}return r}const hge=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),dge=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),fge=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Om(n){return hge.has(n.op)}function pge(n){return dge.has(n.op)}function mge(n){return fge.has(n.op)}class RE{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new RE(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(a=>a.name).sort(),i=t.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,t){const s=Gz(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:a,syncInputs:r}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(i.length>0){const c=t.map(d=>d.name),h=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${h}]. Missing the following inputs: [${i}]`)}const o=oge(this.graph,s),l=uge(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return ga(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=s.map(p=>this.graph.nodes[Xo(p)[0]]),a=t.map(p=>Xo(p)[0]),r=new Set(a);let o=a.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(i,o);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,o),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const h={},d={};return Le(()=>{const p=new $z(this.weightMap,h,d,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(b=>{const[w,T]=Xo(b,p),E=[];E[T]=e[b],g[w]=E,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(E))});const v=this.getFrozenTensorIds(g),{orderedNodes:_,nodeLiveUntilMap:S}=c;for(const b of _){if(g[b.name])continue;const w=zz(b,g,p,this._resourceManager);if(Hf(w))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);g[b.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,g,p,v,r,S.get(b.name))}return this.parent==null&&p.dispose(v),t.map(b=>Ka(b,g,p))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,s,i,a,r,o){if(!(Om(t)||r.has(e))){for(const l of s[e])l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length);for(const l of t.inputs){if(Om(l))continue;const c=kz(l.name,s,i);if(c!=null)for(const h of c){if(!h||h.kept||a.has(h.id))continue;const d=o[h.id];d===1?(h.dispose(),delete o[h.id]):d!=null&&o[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,i,a,r){function o(l){return Om(l)||a.has(l.name)}if(!(Om(e)||r==null))for(const l of r){if(o(l))continue;const c=kz(l.name,t,s);for(const h of c)!h||h.kept||i.has(h.id)||h.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,i={},a={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const r=new $z(this.weightMap,i,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,r,t,s),l=t.map(p=>Ka(p,o,r)),c=l.map(p=>p.id),h=Object.keys(e).map(p=>e[p].id),d=new Set([...c,...h,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(g=>{g&&!g.isDisposed&&!d.has(g.id)&&g.dispose()})}),this.parent==null&&r.dispose(d),l}async executeFunctionAsync(e,t,s){const i=e.reduce((a,r,o)=>(a[this.inputs[o].name]=r,a),{});return this._executeAsync(i,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,i){const a=Object.keys(e),r=a.map(E=>this.graph.nodes[Xo(E)[0]]),o=s.map(E=>Xo(E)[0]),l=new Set(o);let c=o.map(E=>this.graph.nodes[E]);c.length===0&&(c=this._outputs);const{usedNodes:h,missingInputs:d,dynamicNode:p,syncInputs:g}=Gz(e,c,this.weightMap,this._initNodes),v=[...r,...this.graph.weights,...this._initNodes||[]].map(E=>({node:E,contexts:t.currentContext})),_=Object.assign({},this.weightMap);Object.keys(e).forEach(E=>{const[R,D]=Xo(E),F=[];F[D]=e[E],_[R]=F});const S={},b=this.getFrozenTensorIds(_),w={};for(;v.length>0;){const E=this.processStack(r,v,t,_,w,b,l,S,h);await Promise.all(E)}p==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const T=c.filter(E=>!Om(E)&&!Ka(E.name,_,t)).map(E=>E.name);if(T.length>0){let E="";throw p!=null&&(E=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${E}`)}return _}processStack(e,t,s,i,a,r,o,l,c){const h=[];for(;t.length>0;){const d=t.pop();s.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&$("isConstant",d.node,i,s)&&([p]=td(d.node.name,s)),i[d.node.name]==null){const g=zz(d.node,i,s,this._resourceManager);p||([p]=td(d.node.name,s));const v=s.currentContext;Hf(g)?h.push(g.then(_=>(i[p]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(_)),s.currentContext=v,this.checkTensorForDisposal(p,d.node,i,s,r,o,l),this.processChildNodes(d.node,t,s,i,a,c),_))):(i[p]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(g)),this.checkTensorForDisposal(p,d.node,i,s,r,o,l),this.processChildNodes(d.node,t,s,i,a,c))}else this.processChildNodes(d.node,t,s,i,a,c)}return h}processChildNodes(e,t,s,i,a,r){e.children.forEach(o=>{const[l]=td(o.name,s);a[l]||!r.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!Ka(c,i,s))&&(a[l]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!Ka(c,i,s))&&(a[l]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[i]=Xo(t),a=this.graph.nodes[i];if(a.attrParams.shape&&a.attrParams.shape.value){const r=a.attrParams.shape.value,o=r.length===s.shape.length&&s.shape.every((l,c)=>r[c]===-1||r[c]===l);ee(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${r}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&ee(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const i={};for(const a in e){const r=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[a];r!=null?i[r.name]=e[a]:i[a]=e[a]}return i}checkInputs(e){const t=Object.keys(e).filter(s=>{const[i]=Xo(s);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,i;const a=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[t];return a!=null?a.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Xo(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class gge{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const xge="?tfjs-format=file",yge="model.json";class iL{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=Rk){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new gge}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Hf(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await TH(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(i=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=i,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new RE(Lz.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=Lz.Instance.transformGraph(e.modelInitializer);this.initializer=new RE(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Us?[e]:e,s={};return t.forEach((i,a)=>s[this.structuredOutputKeys[a]]=i),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Us)&&!Array.isArray(e)){const a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(const r in a){const o=a[r];o.resourceId!=null&&(e[r]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((a,r)=>{var o,l,c;const h=(c=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[r])===null||c===void 0?void 0:c.resourceId;return h!=null?a[r]=this.resourceIdToCapturedInput[h]:a[r]=e[i++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let i=0;i<s.length;i++){const a=s[i],r=t[a];this.resourceIdToCapturedInput[r.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Qn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function vge(n,e={},t=Rk){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=Sge(n));const s=new iL(n,e,t);return await s.load(),s}function bge(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,i]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const a=TE(s.weightsManifest),r=mB(s,a,i);e=ME(r)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=ME(n);else throw new Error("Unknown model format");const t=new iL(e);return t.load(),t}function Sge(n){return n.endsWith("/")||(n=n+"/"),`${n}${yge}${xge}`}const _ge="4.22.0";const Age=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:iL,deregisterOp:qpe,loadGraphModel:vge,loadGraphModelSync:bge,registerOp:Xpe,version_converter:_ge},Symbol.toStringTag,{value:"Module"})),wge=VD(Age),Cge=VD(Wpe);var Tge=C1.exports,Vz;function Ege(){return Vz||(Vz=1,(function(n,e){(function(t,s){s(e,wge,Cge)})(Tge,(function(t,s,i){const a={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class r{constructor(l,c){this.modelPath=c||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await s.loadGraphModel(this.modelPath);const l=i.zeros([1,300,300,3],"int32"),c=await this.model.executeAsync(l);await Promise.all(c.map((h=>h.data()))),c.map((h=>h.dispose())),l.dispose()}async infer(l,c,h){const d=i.tidy((()=>(l instanceof i.Tensor||(l=i.browser.fromPixels(l)),i.expandDims(l)))),p=d.shape[1],g=d.shape[2],v=await this.model.executeAsync(d),_=v[0].dataSync(),S=v[1].dataSync();d.dispose(),i.dispose(v);const[b,w]=this.calculateMaxScores(_,v[0].shape[1],v[0].shape[2]),T=i.getBackend();i.getBackend()==="webgl"&&i.setBackend("cpu");const E=i.tidy((()=>{const D=i.tensor2d(S,[v[1].shape[1],v[1].shape[3]]);return i.image.nonMaxSuppression(D,b,c,h,h)})),R=E.dataSync();return E.dispose(),T!==i.getBackend()&&i.setBackend(T),this.buildDetectedObjects(g,p,S,b,R,w)}buildDetectedObjects(l,c,h,d,p,g){const v=p.length,_=[];for(let S=0;S<v;S++){const b=[];for(let D=0;D<4;D++)b[D]=h[4*p[S]+D];const w=b[0]*c,T=b[1]*l,E=b[2]*c,R=b[3]*l;b[0]=T,b[1]=w,b[2]=R-T,b[3]=E-w,_.push({bbox:b,class:a[g[p[S]]+1].displayName,score:d[p[S]]})}return _}calculateMaxScores(l,c,h){const d=[],p=[];for(let g=0;g<c;g++){let v=Number.MIN_VALUE,_=-1;for(let S=0;S<h;S++)l[g*h+S]>v&&(v=l[g*h+S],_=S);d[g]=v,p[g]=_}return[d,p]}async detect(l,c=20,h=.5){return this.infer(l,c,h)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=r,t.load=async function(o={}){if(i==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=o.base||"lite_mobilenet_v2",c=o.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const h=new r(l,c);return await h.load(),h},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})}))})(C1,C1.exports)),C1.exports}var Mge=Ege();const D8={kernelName:GS,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,Og(Ft(t,"float32"),-1))}}};const Nge={kernelName:yy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Xs(Ft(t,"float32")),i=La(en(vn(1),s));return ri(un(n,i))}}}};const Rge={kernelName:vy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=La(en(Xs(Ft(t,"float32")),1));return un(n,s)}}}};const Ige={kernelName:Rg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{let o=n;const l=la(t.shape,i);return l.length>0&&(o=sn(o,l)),Ee(o,t.shape)},b:()=>{let o=n;const l=la(s.shape,i);return l.length>0&&(o=sn(o,l)),Ee(o,s.shape)}}}};const Dge={kernelName:VS,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,i)=>{t[i]=()=>n.clone()}),t}};const Oge={kernelName:HS,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ps(t)}}};const Bge={kernelName:WS,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ps(t)}}};const kge={kernelName:by,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,La(en(vn(1),Xs(Ft(t,"float32")))))}}};const Lge={kernelName:Sy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=La(bt(vn(1),Xs(Ft(t,"float32"))));return un(n,s)}}}};const Fge={kernelName:wy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{const o=bt(Xs(t),Xs(s));let l=we(n,un(s,o));const c=la(t.shape,i);return c.length>0&&(l=sn(l,c)),Ee(l,t.shape)},b:()=>{const o=bt(Xs(t),Xs(s));let l=ri(we(n,un(t,o)));const c=la(s.shape,i);return c.length>0&&(l=sn(l,c)),Ee(l,s.shape)}}}};const Uge={kernelName:_y,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,bt(Xs(Ft(t,"float32")),1))}}};const Pge={kernelName:Ay,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,en(vn(1),Xs(Ft(t,"float32"))))}}};function zge(n,e,t,s,i,a){const r=te(n,"dy","avgPool3dGrad"),o=te(e,"input","avgPool3dGrad");let l=r,c=o,h=!1;o.rank===4&&(h=!0,l=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]),c=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ee(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),ee(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Kr("avgPool3dGrad",i,a);const d={dy:l,input:c},p={filterSize:t,strides:s,pad:i,dimRoundingMode:a},g=ve.runKernel($2,d,p);return h?Ee(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const $ge=be({avgPool3dGrad_:zge});const Gge={kernelName:XS,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:a,pad:r,dimRoundingMode:o}=t;return{x:()=>$ge(n,s,i,a,r,o)}}};function Vge(n,e,t,s,i){const a=te(n,"dy","avgPoolGrad"),r=te(e,"input","avgPoolGrad");ee(r.rank===a.rank,()=>`Rank of input (${r.rank}) does not match rank of dy (${a.rank})`);let o=r,l=a,c=!1;r.rank===3&&(c=!0,o=Ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]),l=Ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ee(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),ee(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const h={dy:l,input:o},d={filterSize:t,strides:s,pad:i},p=ve.runKernel(z2,h,d);return c?Ee(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Hge=be({avgPoolGrad_:Vge});const Wge={kernelName:jS,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:a,pad:r}=t;return{x:()=>Hge(n,s,i,a,r)}}};const jge={kernelName:qS,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,i]=e,{transposeA:a,transposeB:r}=t;return!a&&!r?{a:()=>Zn(n,i,!1,!0),b:()=>Zn(s,n,!0,!1)}:!a&&r?{a:()=>Zn(n,i,!1,!1),b:()=>Zn(n,s,!0,!1)}:a&&!r?{a:()=>Zn(i,n,!1,!0),b:()=>Zn(s,n,!1,!1)}:{a:()=>Zn(i,n,!0,!0),b:()=>Zn(n,s,!0,!0)}}};const Xge={kernelName:KS,gradFunc:(n,e,t)=>{const{blockShape:s,crops:i}=t;return{x:()=>iA(n,s,i)}}};const qge={kernelName:oH,gradFunc:(n,e,t)=>{const s=t,i=s.inputShape,a=s.shape,r=Array.from(a);for(let l=i.length-1;l>=0;l--)if(i[l]===a[l])r[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<r.length;l++)r[l]>1&&o.push(l);return{x:()=>sn(n,o,!0)}}};const Kge={kernelName:Cy,gradFunc:n=>({x:()=>n.clone()})};const Yge={kernelName:Ty,gradFunc:n=>({x:()=>ps(n)})};const Jge={kernelName:Ey,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:i,clipValueMax:a}=t;return{x:()=>er(eu(Td(s,i),cp(s,a)),n,ps(n))}}};const Zge={kernelName:JS,inputsToSave:["x"],gradFunc:D8.gradFunc};const Qge={kernelName:ZS,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:i}=t,a=es(i,e[0].shape)[0],r=s.map(l=>l[a]);return wo(n,r,a).map(l=>()=>l)}};const e0e={kernelName:QS,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{dilations:a,strides:r,pad:o,dataFormat:l}=t;return ee(jf(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>FB(s.shape,n,i,r,o,l),filter:()=>vk(s,n,i.shape,r,o,l)}}};const t0e={kernelName:e_,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{strides:a,pad:r,dataFormat:o,dimRoundingMode:l}=t;return{dy:()=>yd(n,i,a,r,o,1,l),filter:()=>vk(n,s,i.shape,a,r,o,l)}}};function n0e(n,e,t,s,i){let a=n;n.rank===4&&(a=Ee(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let r=e;r.rank===4&&(r=Ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ee(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),ee(r.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${r.shape}.`),ee(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),ee(a.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${t[3]}.`),ee(r.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${r.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:a,dy:r},l={strides:s,pad:i,filterShape:t};return ve.runKernel(j2,o,l)}const s0e=be({conv3DBackpropFilter_:n0e});const i0e={kernelName:t_,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:a}=t;ee(jf(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[r,o]=e;return{x:()=>$H(r.shape,n,o,i,a),filter:()=>s0e(r,n,o.shape,i,a)}}};const a0e={kernelName:My,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(ri(uN(Ft(t,"float32"))),n)}}};const r0e={kernelName:Ny,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(hN(Ft(t,"float32")),n)}}};const o0e={kernelName:n_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i,exclusive:a,reverse:r}=t;return{x:()=>{const o=Mi([i],s.rank);let l=YM(n,i,a,!r);return o!=null&&(l=ls(l,o)),l}}}};const l0e={kernelName:s_,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:a,dimRoundingMode:r}=t,o=s??[1,1];ee(jf(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,c]=e;return ee(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),ee(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),ee(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),ee(sr(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),Kr("depthwiseConv2d",a,r),{x:()=>I5(l.shape,n,c,i,a,o,r),filter:()=>R5(l,n,c.shape,i,a,o,r)}}};const c0e={kernelName:i_,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,a={x:s,filter:i,dy:n},r={x:s,filter:i,dy:n};return{x:()=>ve.runKernel(_E,a,t),filter:()=>ve.runKernel(AE,r,t)}}};const u0e={kernelName:Iy,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>ve.runKernel(sM,s)}}};const h0e={kernelName:Dy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=we(No(ri(Xs(t))),2/Math.sqrt(Math.PI));return{x:()=>we(n,s)}}};const d0e={kernelName:Oy,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,t)}}};const f0e={kernelName:r_,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>Ee(n,t.shape)}}};const p0e={kernelName:By,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,No(t))}}};const m0e={kernelName:ky,gradFunc:n=>({x:()=>ps(n)})};const g0e={kernelName:Ly,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{const o=un(n,Ft(s,"float32")),l=la(t.shape,i);return l.length>0?Ee(sn(o,l),t.shape):o},b:()=>{let o=we(n,Ft(t,"float32"));const l=la(s.shape,i);l.length>0&&(o=Ee(sn(o,l),s.shape));const c=Xs(s);return ri(un(o,Ft(c,"float32")))}}}};const x0e={kernelName:o_,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[i,a,r,o]=e,l=o??vn(1),c=la(a.shape,i.shape),h=[];if(a.rank===1){for(let E=0;E<i.shape.length-1;++E)h.push(i.shape[E]);h.push(1)}const d=en(i,a),p=we(n,l),g=oN(bt(r,vn(s))),v=we(we(we(g,g),g),vn(-.5));return{x:()=>a.rank===1?Ee(we(we(n,vl(Ee(g,[1,1,1,a.shape[0]]),h)),l),i.shape):Ee(we(we(n,g),l),i.shape),mean:()=>{let E=we(we(g,vn(-1)),p);return a.rank===1&&(E=sn(E,c)),Ee(E,a.shape)},variance:()=>{let E=we(we(v,d),p);return a.rank===1&&(E=sn(E,c)),Ee(E,a.shape)},scale:()=>{const E=we(d,g);let R=we(n,E);return a.rank===1&&(R=sn(R,c)),Ee(R,a.shape)},offset:()=>{let E=n;return a.rank===1&&(E=sn(E,c)),Ee(E,a.shape)}}}};const y0e={kernelName:l_,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,i]=e,{axis:a,batchDims:r}=t,o=es(a,s.shape)[0],l=(c,h,d)=>()=>{const p=c.shape,g=h.size,v=p.slice(0,o),_=v.length,S=p.slice(a,p.length).slice(1),b=S.length,w=Hz(0,_),T=Hz(_+1,_+1+b),E=Wz([v,[g],S]),R=Ee(d,E),D=Ee(h,[g]),F=Wz([[_],w,T]),U=ls(R,F);let O=xN(U,D,c.shape[o]);const B=lp(F);return O=ls(O,B),O};if(r===1){const c=s.shape[0],h=s.split(c,0);return{x:()=>Ro(h.map((g,v)=>l(g,i.slice(v,1),n.slice(v,1))())).reshape(s.shape),indices:()=>i}}else return{x:l(s,i,n),indices:()=>i}}};function Hz(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function Wz(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const v0e={kernelName:Fy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ps(t),b:()=>ps(s)}}};const b0e={kernelName:Uy,gradFunc:n=>({x:()=>Ft(n,"float32")})};const S0e={kernelName:Py,gradFunc:n=>({x:()=>ps(n)})};const _0e={kernelName:zy,gradFunc:n=>({x:()=>ps(n)})};const A0e={kernelName:$y,gradFunc:n=>({x:()=>ps(n)})};const w0e={kernelName:u_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:i}=t,a=Do(s,0);return{x:()=>er(a,n,we(n,i))}}};const C0e={kernelName:Vy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,bt(t,1))}}};const T0e={kernelName:Gy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,Ft(t,"float32"))}}};const E0e={kernelName:lH,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;return{logits:()=>{const r=No(s);return en(n,we(sn(n,i,!0),r))}}}};function M0e(n,e,t,s=5,i=1,a=1,r=.5){const o={x:n,y:e,dy:t},l={depthRadius:s,bias:i,alpha:a,beta:r};return ve.runKernel(hM,o,l)}const N0e=be({localResponseNormalizationBackprop_:M0e});const R0e={kernelName:g_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{depthRadius:a,bias:r,alpha:o,beta:l}=t;return{x:()=>N0e(s,i,n,a,r,o,l)}}};function O8(n,e,t,s){return e.rank<t.rank&&(e=Ee(e,Xi(e.shape,s))),n.rank<t.rank&&(n=Ee(n,Xi(n.shape,s))),{x:()=>we(n,Ft(oc(t,e),n.dtype))}}const jz={kernelName:x_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:i}=s,a=e[0],r=e[1],o=es(i,a.shape),l=O8(n,r,a,o);return{x:()=>l.x()}}};const I0e={kernelName:Hy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>we(n,Ft(Td(t,s),"float32")),b:()=>we(n,Ft(qx(t,s),"float32"))}}};function D0e(n,e,t,s,i,a,r){const o=te(n,"dy","maxPool3dGrad"),l=te(e,"input","maxPool3dGrad"),c=te(t,"output","maxPool3dGrad");let h=o,d=l,p=c,g=!1;l.rank===4&&(g=!0,h=Ee(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Ee(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=Ee(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),ee(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),ee(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),ee(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),Kr("maxPool3dGrad",a,r);const v={dy:h,input:d,output:p},_={filterSize:s,strides:i,pad:a,dimRoundingMode:r},S=ve.runKernel(fM,v,_);return g?Ee(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}const O0e=be({maxPool3dGrad_:D0e});const B0e={kernelName:v_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:a,strides:r,pad:o,dimRoundingMode:l}=t;return{x:()=>O0e(n,s,i,a,r,o,l)}}};function k0e(n,e,t,s,i,a,r){const o=te(n,"dy","maxPoolGrad"),l=te(e,"input","maxPoolGrad"),c=te(t,"output","maxPoolGrad");ee(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),ee(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),ee(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Kr("maxPoolGrad",a,r);const h={dy:o,input:l,output:c},d={filterSize:s,strides:i,pad:a,dimRoundingMode:r};return ve.runKernel(dM,h,d)}const L0e=be({maxPoolGrad_:k0e});const F0e={kernelName:y_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:a,strides:r,pad:o}=t;return{x:()=>L0e(n,s,i,a,r,o)}}};const U0e={kernelName:b_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t,a=es(i,s.shape),o=Ua(s.shape,a)[1],l=qe(o);return{x:()=>{const h=s.shape.slice();a.forEach(g=>{h[g]=1});const d=Ee(n,h);return un(we(d,_o(s.shape,"float32")),l)}}}};const P0e={kernelName:S_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:i}=s,[a,r]=e,o=es(i,a.shape),l=O8(n,r,a,o);return{x:()=>l.x()}}};const z0e={kernelName:Wy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>we(n,Ft(cp(t,s),"float32")),b:()=>we(n,Ft(Do(t,s),"float32"))}}};const $0e={kernelName:__,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,a=i.map(r=>r[0]);return{x:()=>ds(n,a,s.shape)}}};const G0e={kernelName:jy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{const o=la(t.shape,i);return o.length>0?Ee(sn(n,o),t.shape):n},b:()=>{const o=we(n,ri(xv(un(t,s)))),l=la(s.shape,i);return l.length>0?Ee(sn(o,l),s.shape):o}}}};const V0e={kernelName:Xy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{const o=we(n,Ft(s,"float32")),l=la(t.shape,i);return l.length>0?Ee(sn(o,l),t.shape):o},b:()=>{const o=we(n,Ft(t,"float32")),l=la(s.shape,i);return l.length>0?Ee(sn(o,l),s.shape):o}}}};const H0e={kernelName:A_,gradFunc:n=>({x:()=>ri(n)})};const W0e={kernelName:T_,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>aa(t.shape,"float32")}}};const j0e={kernelName:C_,gradFunc:n=>({x:()=>ps(n)})};const X0e={kernelName:E_,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Tl(n,s).map(a=>()=>a)}};const Xz={kernelName:M_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,a=i.map(r=>r[0]);return{x:()=>ds(n,a,s.shape)}}};const q0e={kernelName:qy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,i]=e,a=t,r=s,o=kn(a.shape,r.shape);return{a:()=>{const h=Ft(r,"float32");let d=we(n,we(h,ch(a,en(h,vn(1)))));const p=la(a.shape,o);return p.length>0&&(d=sn(d,p)),Ee(d,a.shape)},b:()=>{const h=Do(a,0),d=er(h,Jo(a),ps(a));let p=we(n,we(i,d));const g=la(r.shape,o);return g.length>0&&(p=sn(p,g)),Ee(p,r.shape)}}}};const K0e={kernelName:N_,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,i=Do(t,0);return{x:()=>er(i,n,we(n,s)),alpha:()=>{let a=er(i,ps(n),we(n,t));const r=la(s.shape,n.shape);return r.length>0&&(a=sn(a,r)),Ee(a,s.shape)}}}};function Y0e(n,e,t){const s=n.shape.slice();s[t]=1;const i=Ee(e,s),a=fS(n,t,!0,!1),r=fS(n,t,!0,!0),o=we(a,r);return we(i,o)}function J0e(n,e,t){const s=n.shape.length,i=s-t.length,a=Mi(t,s);let r=n;a!=null&&(r=ls(n,a));const o=r.shape.slice(),c=o.splice(s-t.length,t.length).reduce((p,g)=>p*g,1);o.push(c);const h=r.reshape(o);let d=Y0e(h,e,i);if(d=d.reshape(r.shape),a!=null){const p=lp(a);d=ls(d,p)}return d}const Z0e={kernelName:R_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;let a=[];return i==null?a=s.shape.map((r,o)=>o):typeof i=="number"?a=[i]:a=i,{x:()=>J0e(s,n,a)}}};const Q0e={kernelName:Ry,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{const o=un(n,Ft(s,"float32")),l=la(t.shape,i);return l.length>0?Ee(sn(o,l),t.shape):o},b:()=>{let o=we(n,Ft(t,"float32"));const l=la(s.shape,i);l.length>0&&(o=Ee(sn(o,l),s.shape));const c=Xs(s);return ri(un(o,Ft(c,"float32")))}}}};const exe={kernelName:Ky,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,ri(Xs(t)))}}};const txe={kernelName:Jy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=we(cp(t,6),Og(t));return{x:()=>we(n,Ft(s,"float32"))}}};const nxe={kernelName:Yy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,Ft(Og(t),"float32"))}}};const sxe={kernelName:I_,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ee(n,t.shape)}}};const ixe={kernelName:O_,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>ve.runKernel(CM,i,t)}}};const axe={kernelName:D_,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>ve.runKernel(wM,i,t)}}};const rxe={kernelName:B_,gradFunc:(n,e,t)=>{const{dims:s}=t,i=es(s,n.shape);return{x:()=>Cl(n,i)}}};const oxe={kernelName:Zy,gradFunc:n=>({x:()=>ps(n)})};const lxe={kernelName:Qy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ri(un(n,we(ch(t,1.5),2)))}}};const cxe={kernelName:k_,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ft(ps(t),"float32"),t:()=>we(n,Ft(t,n.dtype)),e:()=>we(n,Ft(tA(t),n.dtype))}}};const uxe={kernelName:ev,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Do(t,vn(0)),i=vn(IN),a=vn(DN),r=we(n,a),o=we(we(n,i),No(Ft(t,"float32")));return er(s,r,o)}}}};const hxe={kernelName:iv,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,we(t,en(vn(1),t)))}}};const dxe={kernelName:sv,gradFunc:n=>({x:()=>ps(n)})};const fxe={kernelName:tv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(Y_(Ft(t,"float32")),n)}}};const pxe={kernelName:nv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(KM(Ft(t,"float32")),n)}}};const mxe={kernelName:L_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:i,size:a}=t,r=s.shape,[o,l]=NN(s,i,a),c=[];for(let h=0;h<n.rank;h++)c.push([o[h],r[h]-o[h]-l[h]]);return{x:()=>Ed(n,c)}}};const gxe={kernelName:z_,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:i}=t,a=!0,r=we(n,s);return{logits:()=>en(r,we(sn(r,[i],a),s))}}};const xxe={kernelName:av,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,Yc(t))}}};const qz={kernelName:U_,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:i}=t;return{x:()=>K_(n,s,i)}}};const Kz={kernelName:P_,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>ji(n,s)}}};const yxe={kernelName:rv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,we(La(Ft(t,"float32")),2))}}};const vxe={kernelName:BM,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(n,we(Ft(t,"float32"),2))}}};const bxe={kernelName:ov,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=vn(2);return{a:()=>we(n,we(i,en(t,s))),b:()=>we(n,we(i,en(s,t)))}}};const Sxe={kernelName:dv,gradFunc:n=>({x:()=>ps(n)})};const _xe={kernelName:lv,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=kn(t.shape,s.shape);return{a:()=>{let o=n;const l=la(t.shape,i);return l.length>0&&(o=sn(o,l)),Ee(o,t.shape)},b:()=>{let o=n;const l=la(s.shape,i);return l.length>0&&(o=sn(o,l)),Ee(ri(o),s.shape)}}}};const Axe={kernelName:F_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,i=s.shape.slice(),{axis:a}=t;es(a,s.shape).forEach(c=>{i[c]=1});const o=Ee(n,i),l=we(o,_o(s.shape,"float32"));return{x:()=>l}}};const wxe={kernelName:cv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>un(n,Xs(Y_(t)))}}};const Cxe={kernelName:uv,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>we(en(vn(1),Xs(t)),n)}}};const Txe={kernelName:hv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:i}=t;return{x:()=>{let r=ps(s);if(s.rank===1)for(let o=0;o<i[0];++o)r=bt(r,ds(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)r=bt(r,ds(n,[o*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)r=bt(r,ds(n,[o*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<i[0];++o)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)for(let h=0;h<i[3];++h)r=bt(r,ds(n,[o*s.shape[0],l*s.shape[1],c*s.shape[2],h*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return r}}}};const Exe={kernelName:Km,gradFunc:(n,e,t)=>{const s=t,{perm:i}=s,a=lp(i);return{x:()=>ls(n,a)}}};const Mxe={kernelName:G_,gradFunc:(n,e,t)=>{const s=t,{axis:i}=s;return{value:()=>Ro(n,i)}}};const Nxe={kernelName:V_,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rxe(n,t)}}};function Rxe(n,e){const t=mh(e,ps(e)),s=yv(n,t);let i=Td(e,vn(0,"int32"));const a=s.rank-i.rank;for(let o=0;o<a;++o)i=gr(i,o+1);i=eu(i,_o(s.shape,"bool"));const r=ps(s);return er(i,s,r)}const Ixe={kernelName:H_,gradFunc:n=>({x:()=>ps(n)})};const Dxe=[D8,Nge,Rge,Ige,Dge,Oge,Bge,kge,Lge,Fge,Uge,Pge,Gge,Wge,jge,Xge,qge,Kge,Yge,Jge,Zge,Qge,t0e,e0e,i0e,a0e,r0e,o0e,l0e,c0e,Q0e,u0e,h0e,d0e,f0e,p0e,g0e,m0e,x0e,y0e,v0e,b0e,S0e,_0e,A0e,w0e,C0e,T0e,E0e,R0e,jz,jz,I0e,B0e,F0e,U0e,P0e,z0e,$0e,G0e,V0e,H0e,W0e,j0e,X0e,Xz,Xz,q0e,K0e,Z0e,exe,txe,nxe,sxe,ixe,axe,rxe,oxe,lxe,cxe,uxe,hxe,dxe,fxe,pxe,mxe,gxe,xxe,qz,qz,Kz,Kz,yxe,bxe,vxe,Sxe,_xe,Axe,wxe,Cxe,Txe,Exe,Mxe,Nxe,Ixe];for(const n of Dxe)cH(n);et().prototype.abs=function(){return this.throwIfDisposed(),ia(this)};et().prototype.acos=function(){return this.throwIfDisposed(),yB(this)};et().prototype.acosh=function(){return this.throwIfDisposed(),vB(this)};et().prototype.add=function(n){return this.throwIfDisposed(),bt(this,n)};et().prototype.all=function(n,e){return this.throwIfDisposed(),jM(this,n,e)};et().prototype.any=function(n,e){return this.throwIfDisposed(),uS(this,n,e)};et().prototype.argMax=function(n){return this.throwIfDisposed(),dg(this,n)};et().prototype.argMin=function(n){return this.throwIfDisposed(),bB(this,n)};et().prototype.asScalar=function(){return this.throwIfDisposed(),ee(this.size===1,()=>"The array must have only 1 element."),Ee(this,[])};et().prototype.asType=function(n){return this.throwIfDisposed(),Ft(this,n)};et().prototype.as1D=function(){return this.throwIfDisposed(),Ee(this,[this.size])};et().prototype.as2D=function(n,e){return this.throwIfDisposed(),Ee(this,[n,e])};et().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),Ee(this,[n,e,t])};et().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),Ee(this,[n,e,t,s])};et().prototype.as5D=function(n,e,t,s,i){return this.throwIfDisposed(),Ee(this,[n,e,t,s,i])};et().prototype.asin=function(){return this.throwIfDisposed(),SB(this)};et().prototype.asinh=function(){return this.throwIfDisposed(),_B(this)};et().prototype.atan=function(){return this.throwIfDisposed(),AB(this)};et().prototype.atan2=function(n){return this.throwIfDisposed(),wB(this,n)};et().prototype.atanh=function(){return this.throwIfDisposed(),CB(this)};et().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),q_(this,n,e,t,s)};et().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),K_(this,n,e)};et().prototype.batchNorm=function(n,e,t,s,i){return this.throwIfDisposed(),fv(this,n,e,t,s,i)};et().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Ym(this,n)};et().prototype.cast=function(n){return this.throwIfDisposed(),Ft(this,n)};et().prototype.ceil=function(){return this.throwIfDisposed(),DB(this)};et().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Mo(this,n,e)};et().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Us&&(n=[n]),ji([this,...n],e)};et().prototype.conv1d=function(n,e,t,s,i,a){return this.throwIfDisposed(),XM(this,n,e,t,s,i,a)};et().prototype.conv2dTranspose=function(n,e,t,s,i){return this.throwIfDisposed(),qM(this,n,e,t,s,i)};et().prototype.conv2d=function(n,e,t,s,i,a){return this.throwIfDisposed(),yd(this,n,e,t,s,i,a)};et().prototype.cos=function(){return this.throwIfDisposed(),Y_(this)};et().prototype.cosh=function(){return this.throwIfDisposed(),KM(this)};et().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),fS(this,n,e,t)};et().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),YM(this,n,e,t)};et().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),zB(this,n,e)};et().prototype.depthwiseConv2d=function(n,e,t,s,i,a){return this.throwIfDisposed(),pv(this,n,e,t,s,i,a)};et().prototype.dilation2d=function(n,e,t,s,i){return this.throwIfDisposed(),$B(this,n,e,t,s,i)};et().prototype.divNoNan=function(n){return this.throwIfDisposed(),GB(this,n)};et().prototype.div=function(n){return this.throwIfDisposed(),un(this,n)};et().prototype.dot=function(n){return this.throwIfDisposed(),VB(this,n)};et().prototype.elu=function(){return this.throwIfDisposed(),mv(this)};et().prototype.equal=function(n){return this.throwIfDisposed(),oc(this,n)};et().prototype.erf=function(){return this.throwIfDisposed(),JM(this)};et().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),WB(this,n,e)};et().prototype.exp=function(){return this.throwIfDisposed(),No(this)};et().prototype.expandDims=function(n){return this.throwIfDisposed(),gr(this,n)};et().prototype.expm1=function(){return this.throwIfDisposed(),jB(this)};et().prototype.fft=function(){return this.throwIfDisposed(),cA(this)};et().prototype.flatten=function(){return this.throwIfDisposed(),Ee(this,[this.size])};et().prototype.floor=function(){return this.throwIfDisposed(),xv(this)};et().prototype.floorDiv=function(n){return this.throwIfDisposed(),WM(this,n)};et().prototype.gather=function(n,e,t){return this.throwIfDisposed(),yv(this,n,e,t)};et().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Td(this,n)};et().prototype.greater=function(n){return this.throwIfDisposed(),Do(this,n)};et().prototype.ifft=function(){return this.throwIfDisposed(),Zx(this)};et().prototype.irfft=function(){return this.throwIfDisposed(),fN(this)};et().prototype.isFinite=function(){return this.throwIfDisposed(),XB(this)};et().prototype.isInf=function(){return this.throwIfDisposed(),qB(this)};et().prototype.isNaN=function(){return this.throwIfDisposed(),KB(this)};et().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Z_(this,n)};et().prototype.lessEqual=function(n){return this.throwIfDisposed(),cp(this,n)};et().prototype.less=function(n){return this.throwIfDisposed(),qx(this,n)};et().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),YB(this,n,e,t,s)};et().prototype.logSigmoid=function(){return this.throwIfDisposed(),JB(this)};et().prototype.logSoftmax=function(n){return this.throwIfDisposed(),eN(this,n)};et().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),eA(this,n,e)};et().prototype.log=function(){return this.throwIfDisposed(),Jo(this)};et().prototype.log1p=function(){return this.throwIfDisposed(),Q_(this)};et().prototype.logicalAnd=function(n){return this.throwIfDisposed(),eu(this,n)};et().prototype.logicalNot=function(){return this.throwIfDisposed(),tA(this)};et().prototype.logicalOr=function(n){return this.throwIfDisposed(),tN(this,n)};et().prototype.logicalXor=function(n){return this.throwIfDisposed(),ZB(this,n)};et().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Zn(this,n,e,t)};et().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),nA(this,n,e,t,s)};et().prototype.max=function(n,e){return this.throwIfDisposed(),Al(this,n,e)};et().prototype.maximum=function(n){return this.throwIfDisposed(),mh(this,n)};et().prototype.mean=function(n,e){return this.throwIfDisposed(),Ai(this,n,e)};et().prototype.min=function(n,e){return this.throwIfDisposed(),Xx(this,n,e)};et().prototype.minimum=function(n){return this.throwIfDisposed(),qf(this,n)};et().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),ek(this,n,e)};et().prototype.mod=function(n){return this.throwIfDisposed(),tk(this,n)};et().prototype.mul=function(n){return this.throwIfDisposed(),we(this,n)};et().prototype.neg=function(){return this.throwIfDisposed(),ri(this)};et().prototype.norm=function(n,e,t){return this.throwIfDisposed(),gv(this,n,e,t)};et().prototype.notEqual=function(n){return this.throwIfDisposed(),mg(this,n)};et().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Kx(this,n,e,t)};et().prototype.onesLike=function(){return this.throwIfDisposed(),Zo(this)};et().prototype.pad=function(n,e){return this.throwIfDisposed(),Ed(this,n,e)};et().prototype.pool=function(n,e,t,s,i,a){return this.throwIfDisposed(),nk(this,n,e,t,s,i,a)};et().prototype.pow=function(n){return this.throwIfDisposed(),ch(this,n)};et().prototype.prelu=function(n){return this.throwIfDisposed(),aA(this,n)};et().prototype.prod=function(n,e){return this.throwIfDisposed(),sk(this,n,e)};et().prototype.reciprocal=function(){return this.throwIfDisposed(),ok(this)};et().prototype.relu=function(){return this.throwIfDisposed(),ou(this)};et().prototype.relu6=function(){return this.throwIfDisposed(),aN(this)};et().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Ee(this,n.shape)};et().prototype.reshape=function(n){return this.throwIfDisposed(),Ee(this,n)};et().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),k5(this,n,e,t)};et().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),L5(this,n,e,t)};et().prototype.reverse=function(n){return this.throwIfDisposed(),Cl(this,n)};et().prototype.rfft=function(){return this.throwIfDisposed(),uA(this)};et().prototype.round=function(){return this.throwIfDisposed(),rN(this)};et().prototype.rsqrt=function(){return this.throwIfDisposed(),oN(this)};et().prototype.selu=function(){return this.throwIfDisposed(),lN(this)};et().prototype.separableConv2d=function(n,e,t,s,i,a){return this.throwIfDisposed(),cN(this,n,e,t,s,i,a)};et().prototype.sigmoid=function(){return this.throwIfDisposed(),Yc(this)};et().prototype.sign=function(){return this.throwIfDisposed(),lk(this)};et().prototype.sin=function(){return this.throwIfDisposed(),uN(this)};et().prototype.sinh=function(){return this.throwIfDisposed(),hN(this)};et().prototype.slice=function(n,e){return this.throwIfDisposed(),ds(this,n,e)};et().prototype.softmax=function(n){return this.throwIfDisposed(),lA(this,n)};et().prototype.softplus=function(){return this.throwIfDisposed(),Dg(this)};et().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),iA(this,n,e)};et().prototype.split=function(n,e){return this.throwIfDisposed(),wo(this,n,e)};et().prototype.sqrt=function(){return this.throwIfDisposed(),La(this)};et().prototype.square=function(){return this.throwIfDisposed(),Xs(this)};et().prototype.squaredDifference=function(n){return this.throwIfDisposed(),pN(this,n)};et().prototype.squeeze=function(n){return this.throwIfDisposed(),hp(this,n)};et().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Us?[this,n]:[this,...n];return Ro(t,e)};et().prototype.step=function(n){return this.throwIfDisposed(),Og(this,n)};et().prototype.stridedSlice=function(n,e,t,s,i,a,r,o){return this.throwIfDisposed(),ck(this,n,e,t,s,i,a,r,o)};et().prototype.sub=function(n){return this.throwIfDisposed(),en(this,n)};et().prototype.sum=function(n,e){return this.throwIfDisposed(),sn(this,n,e)};et().prototype.tan=function(){return this.throwIfDisposed(),uk(this)};et().prototype.tanh=function(){return this.throwIfDisposed(),Xf(this)};et().prototype.tile=function(n){return this.throwIfDisposed(),vl(this,n)};et().prototype.toBool=function(){return this.throwIfDisposed(),Ft(this,"bool")};et().prototype.toFloat=function(){return this.throwIfDisposed(),Ft(this,"float32")};et().prototype.toInt=function(){return this.throwIfDisposed(),Ft(this,"int32")};et().prototype.topk=function(n,e){return this.throwIfDisposed(),fk(this,n,e)};et().prototype.transpose=function(n){return this.throwIfDisposed(),ls(this,n)};et().prototype.unique=function(n){return this.throwIfDisposed(),pk(this,n)};et().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),xN(this,n,e)};et().prototype.unstack=function(n){return this.throwIfDisposed(),Tl(this,n)};et().prototype.where=function(n,e){return this.throwIfDisposed(),er(n,this,e)};et().prototype.zerosLike=function(){return this.throwIfDisposed(),ps(this)};class Hu extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Hu.prototype)}}class nc extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nc.prototype)}}class Me extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Me.prototype)}}class qn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,qn.prototype)}}class aL extends Error{constructor(e){super(e),Object.setPrototypeOf(this,aL.prototype)}}class B8{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function vg(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function Wu(n,e){if(!n)throw new aL(e)}function Yz(n,e){let t=0;for(const s of n)s===e&&t++;return t}function vo(n){return n.length===1?n[0]:n}function Gs(n){return Array.isArray(n)?n:[n]}function sd(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Bm(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let ql={};function rL(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function ED(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>ED(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:ED(s))}}}function pA(n,e={},t={},s="object",i=!1){if(typeof n=="string"){const a=n;let r;if(a in t)r=t[a];else if(a in ql)r=ql[a];else if(r=e[a],r==null)throw new Me(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return r}else{const a=n;if(a.className==null||a.config==null)throw new Me(`${s}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const r=a.className;let o,l;if(r in t?[o,l]=t[r]:r in ql?[o,l]=ql.className:r in e&&([o,l]=e[r]),o==null)throw new Me(`Unknown ${s}: ${r}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const g of Object.keys(ql))c[g]=ql[g];for(const g of Object.keys(t))c[g]=t[g];const h=a.config;h.customObjects=c;const d=Object.assign({},ql);for(const g of Object.keys(t))ql[g]=t[g];ED(a.config);const p=l(o,a.config,t,i);return ql=Object.assign({},d),p}else{const c=Object.assign({},ql);for(const d of Object.keys(t))ql[d]=t[d];const h=new o(a.config);return ql=Object.assign({},c),h}}}function Oxe(n,e){return n<e?-1:n>e?1:0}function qC(n,e){return-1*Oxe(n,e)}function kf(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function Bxe(n){if(n==null)throw new Me(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function kg(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new Me(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function oL(n,e,t=0,s=1/0){return Wu(t>=0),Wu(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(i=>typeof i===e)}function Ia(n,e){Array.isArray(n)?(ee(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Ia(t,`element ${s+1} of ${e}`))):ee(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${k8(n)}.`)}function k8(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>k8(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function kxe(n,e,t){let s=t!=null?t():zr(),i;return(...r)=>{const o=t!=null?t():zr();return o-s<e||(s=o,i=n(...r)),i}}function L8(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let Lxe=0;function F8(){return Lxe++}const KC={};function ON(n=""){return n in KC||(KC[n]=0),KC[n]+=1,n+KC[n].toString()}const Fxe=["channelsFirst","channelsLast"],Uxe=["nearest","bilinear"],Pxe=["valid","same","causal"],zxe=["max","avg"],$xe=["sum","mul","concat","ave"];const gx=new Map;function Ki(n){kg(Fxe,"DataFormat",n)}function Gxe(n){kg(Uxe,"InterpolationFormat",n)}function El(n){kg(Pxe,"PaddingMode",n)}function U8(n){kg(zxe,"PoolMode",n)}const G1=[],Jz="/";function Jm(n,e){G1.push(n);try{const t=e();return G1.pop(),t}catch(t){throw G1.pop(),t}}function Vxe(){return G1.length===0?"":G1.join(Jz)+Jz}function P8(n){if(!$8(n))throw new Error("Not a valid tensor name: '"+n+"'");return Vxe()+n}function z8(n){if(!$8(n))throw new Error("Not a valid tensor name: '"+n+"'");gx.has(n)||gx.set(n,0);const e=gx.get(n);if(gx.set(n,gx.get(n)+1),e>0){const t=`${n}_${e}`;return gx.set(t,1),t}else return n}const Hxe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function $8(n){return!!n.match(Hxe)}function Wxe(n){return n===parseInt(n.toString(),10)}function Lf(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let i=e;i<t;++i)s*=n[i];return s}function Qx(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Kf(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function tu(n,e){if(e<n)throw new Me(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let c3;function xa(){return c3==null&&(c3=fB().epsilon()),c3}function nu(){return"channelsLast"}function nh(n,e){return Ft(n,e)}function mA(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),Ee(n,t)}function jxe(n,e){return Le(()=>{if(n.shape.length!==2)throw new Me(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=mA(n,1);return MD(t,[1,e,1])})}function Xxe(n){const e=[Lf(n.shape)];return Ee(n,e)}function qxe(n){if(n.rank<=1)throw new Me(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Lf(n.shape,1)];return Ee(n,e)}function Zm(n,e,t){return Le(()=>{switch(n.rank){case 1:return rA(n,e,t);case 2:return dN(n,[e,0],[t,n.shape[1]]);case 3:return oA(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Jx(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ds(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ds(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Me(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function u3(n,e,t){return Le(()=>{switch(n.rank){case 1:return rA(n,e,t);case 2:return dN(n,[0,e],[n.shape[0],t]);case 3:return oA(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Jx(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new Me(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function YC(n,e,t,s){return Le(()=>{switch(n.rank){case 1:return rA(n,e,t);case 2:switch(s){case 1:return Zm(n,e,t);case 2:return u3(n,e,t);default:throw new Me(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Zm(n,e,t);case 2:return oA(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return u3(n,e,t);default:throw new Me(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Zm(n,e,t);case 2:return Jx(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Jx(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return u3(n,e,t);default:throw new Me(`The axis is not within the rank of the tensor ${s}`)}default:throw new Me(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function lL(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),ji(n,e)}function Zz(n,e){switch(n.rank){case 1:return OB([n,e]);case 2:return BB([n,e],0);case 3:return kB([n,e],0);case 4:return LB([n,e],0);default:throw new Me(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function MD(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new Me(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return vl(n,e)}function BN(n,e=0,t=1,s,i){return iN(n,e,t,s,i)}function sh(n,e,t,s){if(n.rank<2||e.rank<2)throw new qn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(i!==a)throw new qn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return hD({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?ND(n.rank,s,nu()):null,activation:t});{const i=n.shape.slice(),a=i.pop();n=Ee(n,[-1,a]);const r=e.shape.slice(),o=r.pop(),l=r.pop(),c=[...r,o],h=Array.from({length:e.rank},(v,_)=>_===0?e.rank-2:_<=e.rank-2?_-1:_);e=Ee(ls(e,h),[l,-1]);const d=[...i,...c];return Ee(hD({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?ND(n.rank,s,nu()):null,activation:t}),d)}}function G8(n,e,t){return Le(()=>(Array.isArray(e)?e=xr(e,"int32"):e=Ft(e,"int32"),yv(n,e,t)))}function gA(n){return we(n,n)}function ND(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new Me(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?Ee(e,[1,s[0],1,1,1]):Ee(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?Ee(e,[1,1,1,1,s[0]]):Ee(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?Ee(e,[1,s[0],1,1]):Ee(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?Ee(e,[1,1,1,s[0]]):Ee(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?Ee(e,[1,s[0],1]):Ee(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?Ee(e,[1,1,s[0]]):Ee(e,[1].concat(s))}else if(n<3)return e;throw new Me(`Unsupported input rank by biasAdd: ${e.rank}`)}function lu(n,e,t){return Le(()=>(t==null&&(t=nu()),Ki(t),bt(n,ND(n.rank,e,t))))}function Kxe(n,e=1){if(e!==1)throw new qn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return mv(n)}function Yxe(n){return Le(()=>un(n,bt(ia(n),1)))}function V8(n,e,t,s){return Le(()=>xk(n,e,t,s))}function Jxe(n){return Le(()=>{const e=bt(.5,we(.2,n));return Mo(e,0,1)})}function xA(n,e,t=!1){return t?n():e()}const Zxe=["fanIn","fanOut","fanAvg"],Qxe=["normal","uniform","truncatedNormal"];function eye(n){kg(Zxe,"FanMode",n)}function tye(n){kg(Qxe,"Distribution",n)}class hc extends Bg{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class H8 extends hc{apply(e,t){return aa(e,t)}}H8.className="Zeros";_t(H8);class cL extends hc{apply(e,t){return _o(e,t)}}cL.className="Ones";_t(cL);class W8 extends hc{constructor(e){if(super(),typeof e!="object")throw new Me(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Me(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Le(()=>we(vn(this.value),_o(e,t)))}getConfig(){return{value:this.value}}}W8.className="Constant";_t(W8);class j8 extends hc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return up(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}j8.className="RandomUniform";_t(j8);class X8 extends hc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new qn(`randomNormal does not support dType ${t}.`);return BN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}X8.className="RandomNormal";_t(X8);class q8 extends hc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new qn(`truncatedNormal does not support dType ${t}.`);return gN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}q8.className="TruncatedNormal";_t(q8);class K8 extends hc{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return Le(()=>{if(e.length!==2||e[0]!==e[1])throw new Me("Identity matrix initializer can only be used for 2D square matrices.");return we(this.gain,ZM(e[0]))})}getConfig(){return{gain:this.gain}}}K8.className="Identity";_t(K8);function nye(n,e="channelsLast"){let t,s;if(Ki(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=Lf(n,2);t=n[1]*i,s=n[0]*i}else if(e==="channelsLast"){const i=Lf(n,0,n.length-2);t=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=Lf(n);t=Math.sqrt(i),s=Math.sqrt(i)}return[t,s]}class Qo extends hc{constructor(e){if(super(),e.scale<0)throw new Me(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,eye(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,tye(this.distribution),this.seed=e.seed}apply(e,t){const s=nye(e),i=s[0],a=s[1];let r=this.scale;if(this.mode==="fanIn"?r/=Math.max(1,i):this.mode==="fanOut"?r/=Math.max(1,a):r/=Math.max(1,(i+a)/2),this.distribution==="normal"){const o=Math.sqrt(r);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new qn(`${this.getClassName()} does not support dType ${t}.`);return gN(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*r);return up(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Qo.className="VarianceScaling";_t(Qo);class uL extends Qo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qo.className}}uL.className="GlorotUniform";_t(uL);class hL extends Qo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qo.className}}hL.className="GlorotNormal";_t(hL);class dL extends Qo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qo.className}}dL.className="HeNormal";_t(dL);class fL extends Qo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qo.className}}fL.className="HeUniform";_t(fL);class pL extends Qo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qo.className}}pL.className="LeCunNormal";_t(pL);class mL extends Qo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qo.className}}mL.className="LeCunUniform";_t(mL);class Y8 extends hc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Le(()=>{if(e.length<2)throw new qn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=qe(e.slice(0,-1)),i=e[e.length-1],a=s*i;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const r=[Math.max(i,s),Math.min(i,s)],o=BN(r,0,1,t,this.seed),l=Sk.qr(o,!1);let c=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return c=we(c,d.sign()),s<i&&(c=c.transpose()),we(vn(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Y8.className="Orthogonal";_t(Y8);const Qz={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function e$(n,e={}){return pA(n,xl.getMap().classNameMap,e,"initializer")}function Ci(n){return rL(n)}function di(n){if(typeof n=="string"){const e=n in Qz?Qz[n]:n;if(e==="GlorotNormal")return new hL;if(e==="GlorotUniform")return new uL;if(e==="HeNormal")return new dL;if(e==="HeUniform")return new fL;if(e==="LeCunNormal")return new pL;if(e==="LeCunUniform")return new mL;{const t={};return t.className=e,t.config={},e$(t)}}else return n instanceof hc?n:e$(n)}function RD(n){return Array.isArray(n)&&Array.isArray(n[0])}function IE(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Nn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new Me(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Rs(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new Me(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function DE(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,i)=>s*i);return e}const t$="Variable";class sye{constructor(e,t="float32",s=t$,i=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=F8(),s=s??t$,this.originalName=P8(s),this.name=z8(this.originalName),this.trainable_=i,this.constraint=a,this.val=mk(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),iye(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function iye(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function ID(n){return n.map(e=>e.read())}function gL(n){n.forEach(e=>{e[0].write(e[1])})}class ya{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class hh{constructor(e,t,s,i,a,r,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=i,this.callArgs=a,this.outputTensorIndex=o,this.id=F8(),r!=null&&(this.originalName=P8(r),this.name=z8(this.originalName)),this.rank=t.length}}let aye=0;class kN{constructor(e,t){this.callArgs=t,this.id=aye++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let rye=0;class ns extends Bg{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=rye++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=sd(s)+"_"+ON(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),s=[a].concat(e.inputShape)}this.batchInputShape=s;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new nc(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Me(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return vo(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return vo(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Hu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Hu(`Layer ${this.name} is not connected, no input to return.`);return vo(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Hu(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Hu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return vo(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Gs(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Gs(this.inputSpec);if(t.length!==s.length)throw new Me(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let i=0;i<t.length;i++){const a=t[i],r=s[i];if(r==null)continue;const o=a.rank;if(r.ndim!=null&&o!==r.ndim)throw new Me(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${o}`);if(r.maxNDim!=null&&o>r.maxNDim)throw new Me(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${o}`);if(r.minNDim!=null&&o<r.minNDim)throw new Me(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${o}.`);if(r.dtype!=null&&a.dtype!==r.dtype)throw new Me(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${a.dtype}.`);if(r.axes){const l=a.shape;for(const c in r.axes){const h=Number(c),d=r.axes[c],p=h>=0?l[h]:l[l.length+h];if(d!=null&&[d,null].indexOf(p)===-1)throw new Me(`Input ${i} is incompatible with layer ${this.name}: expected axis ${h} of input shape to have value ${d} but got shape ${l}.`)}}if(r.shape!=null)for(let l=0;l<r.shape.length;++l){const c=r.shape[l],h=a.shape[l];if(c!=null&&h!=null&&c!==h)throw new Me(`Input ${i} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Gs(e),i=cye(e),a=uye(e);if(i===a)throw new Me("Arguments to apply() must be all SymbolicTensors or all Tensors");return Jm(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const r=[];for(const o of Gs(e))r.push(o.shape);this.build(vo(r)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const o=Gs(r),l=[];for(let c of o)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(r=vo(l),this.activityRegularizer!=null)throw new qn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}else{const r=oye(e),o=this.computeOutputShape(r);let l;const c=lye(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((h,d)=>new hh(c,h,this,Gs(e),t,this.name,d)):l=new hh(c,o,this,Gs(e),t,this.name),this.addInboundNode(e,l,null,null,r,o,t),this._refCount++,this.activityRegularizer!=null)throw new qn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&e[i]!=null&&e[i]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Hu(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Hu(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new nc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return DE(this.weights)}build(e){this.built=!0}getWeights(e=!1){return ID(e?this.trainableWeights:this.weights)}setWeights(e){Le(()=>{const t=this.weights;if(t.length!==e.length)throw new Me(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],i=ID(t);for(let a=0;a<i.length;++a){const r=i[a],o=t[a],l=e[a];if(!as(r.shape,l.shape))throw new Me(`Layer weight shape ${r.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}gL(s)})}addWeight(e,t,s,i,a,r,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new Me(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():di("zeros"));const c=i.apply(t,s),h=new sye(c,s,e,r,o);return c.dispose(),a!=null&&this.addLoss(()=>a.apply(h.read())),r==null&&(r=!0),r?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Gs(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const i=this.computeMask(e,s),a=Gs(t),r=Gs(i);if(a.length!==r.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=r[o]}addInboundNode(e,t,s,i,a,r,o=null){const l=Gs(e);t=Gs(t),s=Gs(s),i=Gs(i),a=IE(a),r=IE(r);const c=[],h=[],d=[];for(const p of l)c.push(p.sourceLayer),h.push(p.nodeIndex),d.push(p.tensorIndex);new kN({outboundLayer:this,inboundLayers:c,nodeIndices:h,tensorIndices:d,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:i,inputShapes:a,outputShapes:r},o);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function oye(n){n=Gs(n);const e=[];for(const t of n)e.push(t.shape);return vo(e)}function lye(n){return"float32"}function J8(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let a=0;a<s.inboundLayers.length;a++){const r=s.inputTensors[a],o=s.inboundLayers[a],l=s.nodeIndices[a],c=J8(r,o,l);for(const h of c)i.indexOf(h)===-1&&i.push(h)}return i}}}function cye(n){let e=!0;for(const t of Gs(n))if(!(t instanceof hh)){e=!1;break}return e}function uye(n){let e=!0;for(const t of Gs(n))if(t instanceof hh){e=!1;break}return e}class yA extends ns{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:ON("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Me("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Me("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Me("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const i=new hh(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new kN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Me(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}yA.className="InputLayer";_t(yA);function hye(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new Me("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new yA({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function dye(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ft(e,n.dtype)}catch{throw new Me(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class If{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof If)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=dye(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new Me(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof hh){if(this.id2Value[e.id]==null)throw new Me(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Me(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof hh){if(this.id2Value[e.id]==null)throw new Me(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Me(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Qn(this.id2Mask)}}const OE=new B8,BE=new B8;function fye(n){OE?.setMaxEntries(n),BE?.setMaxEntries(n)}function M1(n,e,t,s){const i=t==null?!1:t.training,a=Array.isArray(n),r=a?n:[n],o=r.map(v=>v.name),l=[],c=e.names();for(const v of o)c.indexOf(v)!==-1?l.push(e.getValue(v)):l.push(null);const h=o.join(",")+"|"+e.names().sort().join(",");let d=OE.get(h),p;if(d==null){const v=pye(r,e);d=v.sorted,p=v.recipientCounts,OE.put(h,d),BE.put(h,p)}p={},i||Object.assign(p,BE.get(h));const g=new If(e);for(let v=0;v<d.length;++v){const _=d[v],S=_.sourceLayer;if(S instanceof yA)continue;const b=[],w=[],T=[];let E=!1;for(const O of _.inputs){const B=g.getValue(O),L=g.getMask(O);b.push(B),w.push(L),L!=null&&(E=!0),i||(p[O.name]--,p[O.name]===0&&!e.hasKey(O)&&o.indexOf(O.name)===-1&&!B.isDisposed&&O.sourceLayer.stateful!==!0&&T.push(B))}E&&(t=t||{},t.mask=w[0]);const R=Gs(S.apply(b,t));let D=null;S.supportsMasking&&(D=S.computeMask(b,w));const F=gye(_),U=Array.isArray(F)?F:[F];for(let O=0;O<U.length;++O){g.hasKey(U[O])||g.add(U[O],R[O],Array.isArray(D)?D[0]:D);const B=o.indexOf(U[O].name);B!==-1&&(l[B]=R[O])}i||Qn(T)}return g.disposeMasks(),a?l:l[0]}function pye(n,e){ee(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const i=n$(n[0],e);t=i.sorted,s=i.recipientMap}else{const i=new Set;for(const a of n){const{sorted:r,recipientMap:o}=n$(a,e);for(const l of r)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:mye(s)}}function mye(n){const e={};for(const t in n)e[t]=n[t].size;return e}function n$(n,e){const t=new Set,s=[],i={};for(const o of e.names())t.add(o);const a=[],r=[];for(a.push(n);a.length>0;){const o=a[a.length-1];if(t.has(o.name)){a.pop();continue}const l=r[r.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),s.push(o),t.add(o.name),l&&r.pop();else{r.push(a.length-1);for(const c of o.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(o.name),!t.has(c.name)&&a.push(c)}}return{sorted:s,recipientMap:i}}function gye(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const xye=Pe();xye.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,fye);function xL(n,e){return Le(()=>La(sn(we(n,n),e,!0)))}class vA extends Bg{getConfig(){return{}}}class Z8 extends vA{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Le(()=>{const t=xL(e,this.axis),s=Mo(t,0,this.maxValue);return we(e,un(s,bt(xa(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Z8.className="MaxNorm";_t(Z8);class Q8 extends vA{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Le(()=>un(e,bt(xa(),xL(e,this.axis))))}getConfig(){return{axis:this.axis}}}Q8.className="UnitNorm";_t(Q8);class e6 extends vA{apply(e){return ou(e)}}e6.className="NonNeg";_t(e6);class t6 extends vA{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Le(()=>{const t=xL(e,this.axis),s=bt(we(this.rate,Mo(t,this.minValue,this.maxValue)),we(1-this.rate,t));return we(e,un(s,bt(xa(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}t6.className="MinMaxNorm";_t(t6);const s$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function va(n){return rL(n)}function i$(n,e={}){return pA(n,xl.getMap().classNameMap,e,"constraint")}function ba(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in s$?s$[n]:n,config:{}};return i$(t)}else return n instanceof vA?n:i$(n)}async function Am(n){if(n==null)return;const e=[],t=[],s=[];for(const i in n){const a=n[i];if(typeof a!="number"){const r=a;e.push(r.data()),t.push(i),s.push(r)}}if(e.length>0){const i=await Promise.all(e);for(let a=0;a<i.length;++a)n[t[a]]=i[a][0];Qn(s)}}function n6(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var a$;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(a$||(a$={}));const yye=125;class pS{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class vye{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class bye extends pS{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const i in t){const a=t[i];if(typeof a=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+a*s;else{let r;i in this.totals?r=this.totals[i]:this.totals[i]=0;const o=Le(()=>bt(this.totals[i],we(a,s)));this.totals[i]=o,r?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:Le(()=>{const i=we(un(1,this.seen),this.totals[s]);t[s]=i,this.totals[s].dispose(),ga(t[s])}))}}class Sye extends pS{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const a in this.history){const r=this.history[a];for(let o=0;o<r.length;++o)if(typeof r[o]!="number"){const l=r[o];e.push(l.data()),t.push(a),s.push(o)}}const i=await Promise.all(e);for(let a=0;a<i.length;++a)this.history[t[a]][s[a]].dispose(),this.history[t[a]][s[a]]=i[a][0]}}class _ye extends pS{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Lk,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=yye),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");bE(this.yieldEvery)&&(this.maybeWait=kxe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const i=[];this.yield!=null&&(await Am(s),i.push(this.yield(e,t,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Am(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Am(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Am(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Am(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):bE(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Am(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Am(e),await this.trainEnd(e))}}function s6(n,e){return n==null&&(n={}),n instanceof pS?[n]:Array.isArray(n)&&n[0]instanceof pS?n:Gs(n).map(s=>new _ye(s,e))}class Jl{constructor(){}static registerCallbackConstructor(e,t){ee(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Jl.checkForDuplicate(t),Jl.constructors[e]==null&&(Jl.constructors[e]=[]),Jl.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Jl.constructors)Jl.constructors[+t].forEach(i=>{if(i===e)throw new Me("Duplicate callback constructor.")})}static clear(){Jl.constructors={}}static createCallbacks(e){const t=[];for(const s in Jl.constructors){const i=+s;e>=i&&t.push(...Jl.constructors[i])}return t.map(s=>new s)}}Jl.constructors={};function i6(n,e,t,s,i,a,r,o,l){const c=new Sye,h=[new bye,...Jl.createCallbacks(e)];n!=null&&h.push(...n),h.push(c);const d=new vye(h);return d.setParams({epochs:t,initialEpoch:s,samples:i,steps:a,batchSize:r,verbose:e,doValidation:o,metrics:l}),{callbackList:d,history:c}}function dd(n,e={},t=!1){return pA(n,xl.getMap().classNameMap,e,"layer",t)}function kE(n,e){return Le(()=>{n.dtype!=="float32"&&(n=Ft(n,"float32"));const t=sn(gA(n),e,!0),s=Ig(t.shape,xa()),i=La(mh(t,s));return un(n,i)})}function LN(n,e){return Le(()=>Ai(gA(en(e,n)),-1))}function yL(n,e){return Le(()=>Ai(ia(en(e,n)),-1))}function vL(n,e){return Le(()=>{const t=en(n,e),s=Mo(ia(n),xa(),Number.MAX_VALUE),i=ia(un(t,s));return we(100,Ai(i,-1))})}function Aye(n,e){return Le(()=>{const t=Mo(e,xa(),Number.MAX_VALUE),s=Jo(bt(1,t)),i=Mo(n,xa(),Number.MAX_VALUE),a=Jo(bt(1,i));return Ai(gA(en(s,a)),-1)})}function wye(n,e){return Le(()=>{const t=mh(0,en(1,we(n,e)));return Ai(gA(t),-1)})}function Cye(n,e){return Le(()=>{const t=mh(0,en(1,we(n,e)));return Ai(t,-1)})}function Tye(n,e){return Le(()=>{const t=sn(we(n,e),-1),s=Al(we(en(1,n),e),-1);return mh(0,bt(1,en(s,t)))})}function Eye(n,e){return Le(()=>{const t=Math.log(2),s=en(e,n),i=en(bt(s,Dg(we(-2,s))),t);return Ai(i,-1)})}function mS(n,e,t=!1){return Le(()=>{if(t)e=lA(e);else{const s=sn(e,e.shape.length-1,!0);e=un(e,s)}return e=Mo(e,xa(),1-xa()),ri(sn(we(Ft(n,"float32"),Jo(e)),e.shape.length-1))})}function LE(n,e,t=!1){return Le(()=>{const s=Ft(xv(Xxe(n)),"int32");e=Mo(e,xa(),1-xa());const i=e.shape,a=Ee(Kx(s,i[i.length-1]),i);return mS(a,e,t)})}function Mye(n,e){if(!as(n.shape,e.shape))throw new Me(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return Le(()=>{const t=ou(e),s=ri(ia(e));return bt(en(t,we(e,n)),Q_(No(s)))})}function FN(n,e){return Le(()=>{let t;return t=Mo(e,xa(),1-xa()),t=Jo(un(t,en(1,t))),Ai(Mye(n,t),-1)})}function Nye(n,e){return Le(()=>{const t=Mo(n,xa(),1),s=Mo(e,xa(),1);return sn(we(n,Jo(un(t,s))),-1)})}function Rye(n,e){return Le(()=>{const t=Jo(bt(xa(),e));return Ai(en(e,we(n,t)),-1)})}function a6(n,e){return Le(()=>{const t=kE(n,-1),s=kE(e,-1),i=we(t,s);return ri(sn(i,-1))})}const FE={meanSquaredError:LN,meanAbsoluteError:yL,meanAbsolutePercentageError:vL,meanSquaredLogarithmicError:Aye,squaredHinge:wye,hinge:Cye,categoricalHinge:Tye,logcosh:Eye,categoricalCrossentropy:mS,sparseCategoricalCrossentropy:LE,binaryCrossentropy:FN,kullbackLeiblerDivergence:Nye,poisson:Rye,cosineProximity:a6};function h3(n){if(typeof n=="string"){if(n in FE)return FE[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Me(e)}else return n}function r6(n,e){return Le(()=>{const t=we(.5,Zo(e)),s=nh(Do(e,t),n.dtype);return Ai(oc(n,s),-1)})}function o6(n,e){return Le(()=>nh(oc(dg(n,-1),dg(e,-1)),"float32"))}function Iye(n,e){return Le(()=>Ft(sn(eu(oc(n,1),oc(e,1))),"float32"))}function Dye(n,e){return Le(()=>Ft(sn(eu(oc(n,0),oc(e,1))),"float32"))}function Oye(n,e){return Le(()=>{const t=Iye(n,e),s=Dye(n,e),i=bt(t,s);return Ft(er(Do(i,0),un(t,i),0),"float32")})}function Bye(n,e){return FN(n,e)}function kye(n,e){return n.rank===e.rank&&(n=hp(n,[n.rank-1])),e=dg(e,-1),e.dtype!==n.dtype&&(e=Ft(e,n.dtype)),Ft(oc(n,e),"float32")}const Lye=LN,Fye=LN,Uye=yL,Pye=yL,zye=vL,$ye=vL,l6=mS,Gye=a6,c6=LE,UE={binaryAccuracy:r6,categoricalAccuracy:o6,precision:Oye,categoricalCrossentropy:l6,sparseCategoricalCrossentropy:c6,mse:Lye,MSE:Fye,mae:Uye,MAE:Pye,mape:zye,MAPE:$ye,cosine:Gye};function Vye(n){if(typeof n=="string"&&n in UE)return UE[n];if(typeof n!="string"&&n!=null)return n;throw new Me(`Unknown metric ${n}`)}function JC(n){if(Wu(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(FE))if(FE[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(UE))if(UE[t]===n){e=t;break}return e!==void 0?e:n.name}}function Hye(n){const e={Adagrad:()=>Nm.adagrad(.01),Adadelta:()=>Nm.adadelta(1,.95,xa()),Adam:()=>Nm.adam(.001,.9,.999,xa()),Adamax:()=>Nm.adamax(.002,.9,.999,xa(),0),RMSProp:()=>Nm.rmsprop(.001,.9,0,xa()),SGD:()=>Nm.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new Me(`Unknown Optimizer ${n}`)}const r$=1*1024*1024;function o$(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!DD(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>r$&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${r$}.`)}}function DD(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!DD(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!DD(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function Wye(n,e,t,s=console.log){const i=Xye(n),a=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(h=>Math.floor(e*h)));let r;if(!i){a.push("Receives inputs"),r=[];for(const h in n.nodesByDepth)r.push(...n.nodesByDepth[h])}s("_".repeat(e)),PE(a,t,s),s("=".repeat(e));const o=n.layers;for(let h=0;h<o.length;++h)i?qye(o[h],t,s):Kye(o[h],t,r,s),s((h===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=jye(n),c=DE(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function jye(n){let e;return n.collectedTrainableWeights!=null?e=DE(n.collectedTrainableWeights):e=DE(n.trainableWeights),e}function Xye(n){let e=!0;const t=[],s=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}s.push(...i)}if(e)for(const i of n.layers){let a=!1;for(const r of i.inboundNodes)if(s.indexOf(r)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function PE(n,e,t=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,e[i]),s+=" ".repeat(e[i]-s.length);t(s)}function qye(n,e,t){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const a=n.name,r=n.getClassName(),o=[`${a} (${r})`,i,s,n.countParams().toString()];PE(o,e,t)}function Kye(n,e,t,s){let i,a;try{a=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const r=[];for(const d of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(d)===-1))for(let p=0;p<d.inboundLayers.length;++p){const g=d.inboundLayers[p].name,v=d.nodeIndices[p],_=d.tensorIndices[p];r.push(`${g}[${v}][${_}]`)}const o=n.name,l=n.getClassName(),c=r.length===0?"":r[0],h=[`${o} (${l})`,a,i,n.countParams().toString(),c];PE(h,e,s);for(let d=1;d<r.length;++d)PE(["","","","",r[d]],e,s)}function u6(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function OD(n,e){if(n===null)return null;if(typeof n=="string")return Bm(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const a=n[i];u6(e,i,a)?t.push(a):t.push(OD(a,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")t[s]=i;else{const a=Bm(s);t[a]=OD(i,a)}}return t}}function BD(n,e){if(n==null)return null;if(typeof n=="string")return sd(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const a=n[i];u6(e,i,a)?t.push(a):t.push(BD(a,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s],a=sd(s);(s==="name"||s==="className")&&typeof i=="string"?t[a]=i:t[a]=BD(i,s)}return t}}const h6="4.22.0";const Yye=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class $c extends ns{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=ON(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],kf(this.inputs).length!==this.inputs.length)throw new Me(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);kf(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const T=w.sourceLayer,E=w.nodeIndex,R=w.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(E),this.outputLayersTensorIndices.push(R)}for(const w of this.inputs){const T=w.sourceLayer,E=w.nodeIndex,R=w.tensorIndex;Wu(E===0,"input layer has >1 nodes"),Wu(R===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(E),this.inputLayersTensorIndices.push(R)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const T=this.inputLayers[w];if(!(T instanceof yA))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${w} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const t={},s={},i={},a={},r={},o=[],l=(w,T,E,R,D,F)=>{(R==null||D==null||F==null)&&(R=w.sourceLayer,D=w.nodeIndex,F=w.tensorIndex);const U=R.inboundNodes[D];if(E.indexOf(U)!==-1)throw new nc(`The tensor ${w.name} at layer "${R.name}" is part of a cycle.`);if(T.indexOf(U)!==-1)return;this.containerNodes.add($c.nodeKey(R,D)),R.id in r||(r[R.id]=Object.keys(r).length),E.indexOf(U)===-1&&E.push(U);const O=U.inboundLayers.length;for(let B=0;B<O;B++){const L=U.inputTensors[B],H=U.inboundLayers[B],K=U.nodeIndices[B],Z=U.tensorIndices[B];l(L,T,E,H,K,Z)}for(T.push(U);E.indexOf(U)>=0;)E.splice(E.indexOf(U),1);o.push(U)},c=[],h=[];for(const w of this.outputs)l(w,c,h);const d=o.slice().reverse();for(const w of d){s[w.id]=w,w.id in t||(t[w.id]=0);let T=t[w.id];const E=i[w.outboundLayer.id]==null?0:i[w.outboundLayer.id];T=Math.max(T,E),i[w.outboundLayer.id]=T,a[w.outboundLayer.id]=w.outboundLayer,t[w.id]=T;for(let R=0;R<w.inboundLayers.length;R++){const D=w.inboundLayers[R],F=w.nodeIndices[R],U=D.inboundNodes[F],O=t[U.id]==null?0:t[U.id];t[U.id]=Math.max(T+1,O),s[U.id]=U}}const p={};for(const w in t){const T=t[w];T in p||(p[T]=[]),p[T].push(s[w])}const g={};for(const w in i){const T=i[w];T in g||(g[T]=[]),g[T].push(a[w])}let v=Object.keys(g).map(w=>parseInt(w,10)).sort(qC);this.layers=[];for(const w of v){const T=g[w];T.sort((E,R)=>{const D=r[E.id],F=r[R.id];return D<F?-1:D>F?1:0});for(const E of T)E instanceof $c&&this.internalContainerRefs.push(E),this.layers.push(E)}this.layersByDepth=g,v=Object.keys(p).map(w=>parseInt(w,10)).sort(qC);const _=this.inputs.slice(),S=[];for(const w of v)for(const T of p[w]){const E=T.outboundLayer;if(E!=null){for(const R of T.inputTensors)if(_.indexOf(R)===-1)throw new nc(`Graph disconnected: cannot obtain value for tensor ${R} at layer "${E.name}". The following previous layers were accessed without issue: ${S}`);for(const R of T.outputTensors)_.push(R);S.push(E.name)}}this.nodesByDepth=p;const b=this.layers.map(w=>w.name);for(const w of b){const T=b.filter(E=>E===w).length;if(T!==1)throw new nc(`The name "${w}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new kN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Me("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let i=0;const a=Yye(e);a&&this.parseWeights(e);for(const o of this.layers)for(const[l,c]of o.weights.entries()){const h=a?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[h]!=null)throw new Me(`Duplicate weight name: ${h}`);s[h]=c,i++}const r=[];for(const o in e){let l=o;if(s[o]==null){const c=o.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)r.push([s[l],e[o]]);else if(t)throw new Me(`Provided weight data has no target variable: ${o}`);delete s[l]}if(t){const o=[];for(const l in s)o.push(l);if(o.length>0)throw new Me(`${o.length} of ${i} weights are not set: ${o}`)}gL(r)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),i=["vars","layer_checkpoint_dependencies"],a=s.map(r=>r.startsWith("_")?r.slice(1):r).filter(r=>!i.includes(r)).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${h6}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=BD(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return Le(()=>{e=Gs(e);const s=new If;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],e[i]);return M1(this.outputs,s,t)})}computeMask(e,t){return Le(()=>{e=Gs(e);let s;return t==null?s=vg(null,e.length):s=Gs(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=IE(e);if(t.length!==this.inputLayers.length)throw new Me(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const l=this.inputLayers[o],c=t[o],h=l.name+"_0_0";s[h]=c}const i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(qC);if(i.length>1)for(const o of i){const l=this.nodesByDepth[o];for(const c of l){const h=c.outboundLayer;if(this.inputLayers.map(_=>_.id).indexOf(h.id)!==-1)continue;const d=[];for(let _=0;_<c.inboundLayers.length;_++){const S=c.inboundLayers[_],b=c.nodeIndices[_],w=c.tensorIndices[_],T=`${S.name}_${b}_${w}`,E=s[T];d.push(E)}const p=h.computeOutputShape(vo(d)),g=IE(p),v=h.inboundNodes.indexOf(c);for(let _=0;_<g.length;_++){const S=`${h.name}_${v}_${_}`;s[S]=g[_]}}}const a=[],r=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=this.outputLayersTensorIndices[o],d=`${l.name}_${c}_${h}`;r.push(d)}for(let o=0;o<r.length;o++){const l=r[o];Wu(l in s),a.push(s[l])}return vo(a)}runInternalGraph(e,t){t==null&&(t=vg(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],h=e[l],d=t[l];s[c.id]=[h,d]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(qC);for(const l of i){const c=this.nodesByDepth[l];for(const h of c){const d=h.outboundLayer,p=h.inputTensors,g=h.outputTensors,v=new Array;for(const _ of p)_.id in s&&v.push(s[_.id]);if(v.length===p.length){let _={},S,b,w,T;if(h.callArgs!=null&&(_=h.callArgs),v.length===1){const[E,R]=v[0];_.mask==null&&(_.mask=R),w=Gs(d.call(E,_)),T=Gs(d.computeMask(E,R)),S=[E],b=[R]}else S=v.map(E=>E[0]),b=v.map(E=>E[1]),_.mask==null&&(_.mask=b),w=Gs(d.call(S,_)),T=Gs(d.computeMask(S,b));if(d.activityRegularizer)throw new qn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let E=0;E<g.length;++E){const R=g[E],D=w[E],F=T[E];s[R.id]=[D,F]}}}}const a=[],r=[],o=[];for(const l of this.outputs){Wu(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,h]=s[l.id];o.push(c.shape),a.push(c),r.push(h)}return[a,r,o]}buildNodeConversionMap(e){const t={};let s;for(const i of this.layers){s=i instanceof $c?1:0;for(let a=0;a<i.inboundNodes.length;a++){const r=$c.nodeKey(i,a);this.containerNodes.has(r)&&(t[r]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new Me("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new Me(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Me(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Le(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const i=$c.nodeKey(t,s);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const r of this.layers){const o=r.getClassName(),l=r.getConfig(),c=[];for(let d=0;d<r.inboundNodes.length;d++){const p=r.inboundNodes[d],g=$c.nodeKey(r,d);let v={};if(this.containerNodes.has(g)){if(p.callArgs)try{JSON.stringify(p.callArgs),v=p.callArgs}catch{console.warn(`Layer ${r.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),v={}}if(p.inboundLayers.length>0){const _=[];for(let S=0;S<p.inboundLayers.length;S++){const b=p.inboundLayers[S],w=p.nodeIndices[S],T=p.tensorIndices[S],E=$c.nodeKey(b,w);let R=t[E];R==null&&(R=0),_.push([b.name,R,T,v])}c.push(_)}}}const h={};h.name=r.name,h.className=o,h.config=l,h.inboundNodes=c,s.push(h)}e.layers=s;const i=[];for(let r=0;r<this.inputLayers.length;r++){const o=this.inputLayers[r],l=this.inputLayersNodeIndices[r],c=$c.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let h=t[c];h==null&&(h=0);const d=this.inputLayersTensorIndices[r];i.push([o.name,h,d])}e.inputLayers=i;const a=[];for(let r=0;r<this.outputLayers.length;r++){const o=this.outputLayers[r],l=this.outputLayersNodeIndices[r],c=$c.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let h=t[c];h==null&&(h=0);const d=this.outputLayersTensorIndices[r];a.push([o.name,h,d])}return e.outputLayers=a,e}static fromConfig(e,t,s={},i=!1){const a={},r={};function o(S,b){S.name in r?r[S.name].push(b):r[S.name]=[b]}function l(S,b){const w=[];let T;for(const E of b){const R=E[0],D=E[1],F=E[2];if(T=E[3]==null?{}:E[3],!(R in a)){o(S,b);return}const U=a[R];if(U.inboundNodes.length<=D){o(S,b);return}const O=U.inboundNodes[D];w.push(O.outputTensors[F])}w.length>0&&S.apply(vo(w),T)}function c(S){const b=S.name,w=dd(S,t.customObjects!=null?t.customObjects:{});w.setFastWeightInitDuringBuild(i),a[b]=w,S.inboundNodes.forEach(E=>{if(!(E instanceof Array))throw new Me(`Corrupted configuration, expected array for nodeData: ${E}`);o(w,E)})}const h=t.name,d=t.layers;for(const S of d)c(S);for(;!Bxe(r);)for(const S of d){const b=a[S.name];if(b.name in r){const w=r[b.name];delete r[b.name];for(const T of w)l(b,T)}}const p=[],g=[],v=t.inputLayers;for(const S of v){const b=S[0],w=S[1],T=S[2];Wu(b in a);const R=a[b].inboundNodes[w].outputTensors;p.push(R[T])}const _=t.outputLayers;for(const S of _){const b=S[0],w=S[1],T=S[2];Wu(b in a);const R=a[b].inboundNodes[w].outputTensors;g.push(R[T])}return new e({inputs:p,outputs:g,name:h})}get stateful(){if(this._stateful)throw new Me("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Le(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function Jye(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(a=>{a in n?i.push(n[a]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function d6(n,e){return Jye(n,e,"classWeight")}async function f6(n,e,t,s){if(t!=null){const i=Le(()=>{if(n.shape.length===1)return eh(n);if(n.shape.length===2){if(n.shape[1]>1)return dg(n,1);if(n.shape[1]===1)return Ee(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await i.data());Qn(i);const r=[];return a.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);r.push(t[o])}),xr(r,"float32")}else return null}function Zye(n,e){return we(n,e)}const Qye=32;function p6(n,e){let t,s;const i=e;t=i.xs,s=i.ys,ee(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=l$("input",n.inputNames,t),r=l$("output",n.outputNames,s),o=a[0].shape[0];ee(a.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),ee(r.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${r.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<a.length;l++)ee(a[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<r.length;l++)ee(r[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${r[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:a,ys:r}}function l$(n,e,t){if(t instanceof Us)return[t];if(Array.isArray(t))return ee(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const i of e){if(t[i]==null)throw new Me(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(t[i])}return s}}function eve(n){if(n.length===3)throw new qn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function tve(n,e,t){const s=t.batchesPerEpoch!=null;if(ee(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),ee(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),ee(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),ee(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),ee(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let a,r;if(i)if(c$(t.validationData))ee(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const S=eve(t.validationData);a=S.xs,r=S.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(S=>"val_"+S)):c=l.slice();const h=s6(t.callbacks,t.yieldEvery),d=t.verbose==null?1:t.verbose,{callbackList:p,history:g}=i6(h,d,t.epochs,null,null,nve(e,t),null,i,c);p.setModel(n),n.history=g,await p.onTrainBegin(),n.stopTraining_=!1;let v=t.initialEpoch==null?0:t.initialEpoch,_=await e.iterator();for(;v<t.epochs;){const S={};await p.onEpochBegin(v);let b=0,w=0;for(s||(_=await e.iterator());!s||b<t.batchesPerEpoch;){const T=await _.next();if(s&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){const{xs:E,ys:R}=p6(n,T.value),D={};D.batch=w,D.size=E[0].shape[0],await p.onBatchBegin(w,D);const F=[];if(t.classWeight!=null){const B=d6(t.classWeight,n.outputNames);for(let L=0;L<B.length;++L)F.push(await f6(R[L],null,B[L]))}const U=E.concat(R).concat(F),O=o(U);Qn(U);for(let B=0;B<l.length;++B){const L=l[B],H=O[B];D[L]=H,ga(H)}await p.onBatchEnd(w,D),n6(D),w++,b++}if(s?b>=t.batchesPerEpoch:T.done){if(i){let E;c$(t.validationData)?E=Gs(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):E=Gs(n.evaluate(a,r,{batchSize:t.validationBatchSize==null?Qye:t.validationBatchSize,verbose:0}));for(let R=0;R<n.metricsNames.length;++R)S[`val_${n.metricsNames[R]}`]=E[R]}break}if(n.stopTraining_)break}if(await p.onEpochEnd(v,S),v++,n.stopTraining_)break}return await p.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function nve(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function c$(n){return typeof n.iterator=="function"}function sve(n){return typeof n.next=="function"}async function ive(n,e,t){t=t||{};const s=t.batches!=null,i=n.testFunction;let a=[];if(t.verbose>0)throw new qn("Verbose mode is not implemented yet.");ee(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const r=sve(e)?e:await e.iterator();let o=0,l=0;for(;!s||l<t.batches;){const c=await r.next();if(a=Le(()=>{if(c.value){const{xs:h,ys:d}=p6(n,c.value),p=h.concat(d),g=Le(()=>i(p));if(Qn(p),l===0)for(let _=0;_<g.length;++_)a.push(vn(0));const v=p[0].shape[0];for(let _=0;_<g.length;++_){const S=g[_],b=a[_];a[_]=Le(()=>bt(a[_],we(v,S))),l>0&&Qn(b)}Qn(g),o+=v,++l}return a}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){const h=a[c];a[c]=un(a[c],o),Qn(h)}return vo(a)}function d3(n){ee(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function b1(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Zm(s,e,t-e)):Zm(n,e,t-e)}function kD(n,e){return Le(()=>n==null?null:Array.isArray(n)?n.map(t=>kD(t,e)):G8(n,e.dtype==="int32"?e:Ft(e,"int32")))}function f3(n,e){const t=[];let s=0,i=null;for(;s<n;)i=s+e,i>=n&&(i=n),t.push([s,i]),s=i;return t}function m6(n){const e=[];n instanceof Us&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(mA(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function zc(n,e){if(n==null)return;const t=[];if(e instanceof Us)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const a=e[i];t.push(a.id)}const s=[];if(n instanceof Us)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const a=n[i];t.indexOf(a.id)===-1&&s.push(a)}s.forEach(i=>{i.isDisposed||i.dispose()})}function ave(n){return n instanceof Us}function LD(n){return Array.isArray(n)}function u$(n){return!ave(n)&&!LD(n)}function h$(n,e,t,s=!0,i=""){if(e==null||e.length===0){if(n!=null){let r=!1;if(LD(n)&&n.length>0)r=!0;else if(u$(n)){for(const o in n)if(n.hasOwnProperty(o)){r=!0;break}}else r=!0;if(r)throw new Me(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(r=>null);let a;if(u$(n)){n=n,a=[];for(const r of e){if(n[r]==null)throw new Me(`No data provided for "${r}". Need data for each key in: ${e}`);a.push(n[r])}}else if(LD(n)){if(n=n,n.length!==e.length)throw new Me(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);a=n}else{if(n=n,e.length>1)throw new Me(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);a=[n]}if(a=m6(a),t!=null)for(let r=0;r<e.length;++r){if(t[r]==null)continue;const o=a[r];if(o.shape.length!==t[r].length)throw new Me(`Error when checking ${i}: expected ${e[r]} to have ${t[r].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<t[r].length;++l){if(l===0&&!s)continue;const c=o.shape[l],h=t[r][l];if(h!=null&&h>=0&&c!==h)throw new Me(`${i} expected a batch of elements where each example has shape [${t[r].slice(1,t[r].length)}] (i.e.,tensor shape [*,${t[r].slice(1,t[r].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function rve(n,e,t){const s=kf(n.map(a=>a.shape[0]));s.sort();const i=kf(e.map(a=>a.shape[0]));if(i.sort(),s.length>1)throw new Me(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(a=>a.shape))}`);if(i.length>1)throw new Me(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>0&&i.length>0&&!as(s,i))throw new Me(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function ove(n,e,t){const s=[LN,FN,mS];for(let i=0;i<n.length;++i){const a=n[i],r=e[i],o=t[i];if(r!=null){if(r===mS&&a.shape[a.shape.length-1]===1)throw new Me(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(r)!==-1){const l=a.shape.slice(1),c=o.slice(1);for(let h=0;h<l.length;++h){const d=l[h],p=c[h];if(p!=null&&d!==p)throw new Me(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function d$(n,e,t,s=!0,i=""){let a;if(Array.isArray(n)){if(n.length!==e.length)throw new Me(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);a=n}else{if(e.length>1)throw new Me(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);a=[n]}if(t!=null)for(let r=0;r<e.length;++r){if(t[r]==null)continue;const o=a[r];if(o.shape.length!==t[r].length)throw new Me(`Error when checking ${i}: expected ${e[r]} to have ${t[r].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<t[r].length;++l){if(l===0&&!s)continue;const c=o.shape[l],h=t[r][l];if(h!=null&&h!==c)throw new Me(`Error when checking ${i}: expected ${e[r]} to have shape ${JSON.stringify(t[r])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function lve(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const i of e){let a=t.hasOwnProperty(i)?t[i]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}const cve="layers-model";class Mx extends $c{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new Me("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Wye(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Hye(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Nd))throw new Me("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const r in e.loss)if(this.outputNames.indexOf(r)===-1)throw new Me(`Unknown entry in loss dictionary: "${r}". Only expected the following keys: ${this.outputNames}`);for(const r of this.outputNames)e.loss[r]==null&&console.warn(`Output "${r}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${r} during training`),t.push(h3(e.loss[r]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Me(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>h3(o))}else{const r=h3(e.loss);this.outputs.forEach(o=>{t.push(r)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let r=0;r<this.outputs.length;++r){const o=this.internalOutputShapes[r],l=this.outputNames[r];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[r])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Jm("loss",()=>{for(let r=0;r<this.outputs.length;++r){if(s.indexOf(r)!==-1)continue;const o=this.lossFunctions[r];this.outputs.length>1&&(this.metricsTensors.push([o,r]),this.metricsNames.push(this.outputNames[r]+"_loss"))}});const i=lve(e.metrics,this.outputNames),a=(r,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[r]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,r])};Jm("metric",()=>{for(let r=0;r<this.outputs.length;++r){if(s.indexOf(r)!==-1)continue;const o=i[r];(c=>{let d,p,g;for(const v of c){if(typeof v=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(v)!==-1){const S=this.internalOutputShapes[r];S[S.length-1]===1||this.lossFunctions[r]===FN?["accuracy","acc"].indexOf(v)!==-1?p=r6:["crossentropy","ce"].indexOf(v)!==-1&&(p=Bye):this.lossFunctions[r]===LE?["accuracy","acc"].indexOf(v)!==-1?p=kye:["crossentropy","ce"].indexOf(v)!==-1&&(p=c6):["accuracy","acc"].indexOf(v)!==-1?p=o6:["crossentropy","ce"].indexOf(v)!==-1&&(p=l6);let b;["accuracy","acc"].indexOf(v)!==-1?b="acc":["crossentropy","ce"].indexOf(v)!==-1&&(b="ce"),g=p,d=""+b}else g=Vye(v),d=""+JC(v);let _;Jm(d,()=>{_=g}),a(r,d,_)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const i=s.batchSize==null?32:s.batchSize;d3(i);const r=this.standardizeUserDataXY(e,t,!0,i);try{const o=r[0].concat(r[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,o,i,s.verbose,s.steps);return vo(c)}finally{zc(r[0],e),zc(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ive(this,e,t)}checkNumSamples(e,t,s,i="steps"){let a;if(s!=null){if(a=null,t!=null)throw new Me(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new Me(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Me("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),i=s?t:[t],a=this.retrieveSymbolicTensors(i),r=new If;if(e instanceof Us&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Me(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)r.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new Me(`No value is provided for the model's input ${l.name}`);r.add(l,c)}const o=M1(a,r);return s?o:o[0]}retrieveSymbolicTensors(e){const t=vg(null,e.length);let s=e.length;for(const i of this.layers){const a=Array.isArray(i.output)?i.output:[i.output],r=a.map(o=>o.name);for(let o=0;o<e.length;++o){const l=r.indexOf(e[o]);if(l!==-1&&(t[o]=a[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw t.forEach((a,r)=>{a==null&&i.push(e[r])}),new Me(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,s=!1){return Le(()=>{const i=this.checkNumSamples(e);if(s)throw new qn("Verbose predictLoop() is not implemented yet.");const a=f3(i,t),r=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)Le(()=>{const c=a[o][0],h=a[o][1],d=b1(e,c,h),p=[];if(Array.isArray(d))for(let v=0;v<d.length;++v)p.push({key:this.inputs[v],value:d[v]});else p.push({key:this.inputs[0],value:d});const g=new If(p);return M1(this.outputs,g)}).forEach((c,h)=>r[h].push(c));return vo(r.map(o=>ji(o,0)))})}predict(e,t={}){const s=m6(e);d$(s,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return d3(i),this.predictLoop(s,i)}finally{zc(s,e)}}predictOnBatch(e){d$(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,i){if(this.optimizer_==null)throw new nc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const o=this.feedOutputShapes[r];this.feedLossFns[r]===LE?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(e=h$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=h$(t,this.feedOutputNames,a,!1,"target"),rve(e,t),ove(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new Me(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,i,a=!0,r){const[o,l]=this.standardizeUserDataXY(e,t,a,r);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const h=d6(i,this.outputNames);c=[];for(let d=0;d<h.length;++d)c.push(await f6(l[d],null,h[d]))}return[o,l,c]}testLoop(e,t,s,i=0,a){return Le(()=>{const r=this.checkNumSamples(t,s,a,"steps"),o=[];if(i>0)throw new qn("Verbose mode is not implemented yet.");if(a!=null)throw new qn("steps mode in testLoop() is not implemented yet");{const l=f3(r,s),c=xr(tu(0,r));for(let h=0;h<l.length;++h){const d=l[h][0],p=l[h][1],g=Zm(c,d,p-d),v=kD(t,g),_=e(v);if(h===0)for(let S=0;S<_.length;++S)o.push(vn(0));for(let S=0;S<_.length;++S){const b=_[S];o[S]=bt(o[S],we(p-d,b))}}for(let h=0;h<o.length;++h)o[h]=un(o[h],r)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const i=e[s];let a=i;if(Yz(e,i)>1){const r=Yz(e.slice(0,s),i);a+=`_${r}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),r=[],o=()=>{const d=[];for(let _=0;_<this.inputs.length;++_)d.push({key:this.inputs[_],value:s[_]});const p=new If(d),g=M1(this.outputs,p,{training:!0});let v;for(let _=0;_<this.lossFunctions.length;++_){const S=this.lossFunctions[_];let b=S(i[_],g[_]);a[_]!=null&&(b=Zye(b,a[_]));const w=Ai(b);t.push(w),_===0?v=b:v=bt(v,b)}for(let _=0;_<this.metricsTensors.length;++_){let S;if(this.outputs.length>1&&_<this.outputs.length)S=t[_];else{const b=this.metricsTensors[_][0],w=this.metricsTensors[_][1];S=Ai(b(i[w],g[w]))}ga(S),r.push(S)}return v=Ai(v),this.calculateLosses().forEach(_=>{v=bt(v,_)}),v},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(o,!0,l)].concat(r)}}makeTestFunction(){this.testFunction=e=>Le(()=>{const t=[];let s;const i=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=[];for(let c=0;c<this.inputs.length;++c)r.push({key:this.inputs[c],value:i[c]});const o=new If(r),l=M1(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const h=this.lossFunctions[c],d=Ai(h(a[c],l[c]));c===0?s=d:s=bt(s,d),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][0],d=this.metricsTensors[c][1],p=Ai(h(a[d],l[d]));t.push(p)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,a,r,o,l,c,h,d,p;try{const g=s.batchSize==null?32:s.batchSize;d3(g);const _=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,g);i=_[0],a=_[1],p=_[2];let S=!1,b;if(s.validationData!=null&&s.validationData.length>0){if(S=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new qn("validationData including sample weights is not supported yet."):new Me(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const B=await this.standardizeUserData(l,c,null,null,!0,g);h=B[0],d=B[1],b=h.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){S=!0;const O=Math.floor(i[0].shape[0]*(1-s.validationSplit)),B=i[0].shape[0];h=b1(i,O,B),r=i,i=b1(i,0,O),d=b1(a,O,B),o=a,a=b1(a,0,O),b=h.concat(d)}else s.validationSteps!=null&&(S=!0);const w=i.concat(a).concat(p);this.checkTrainableWeightsConsistency();const T=this.makeTrainFunction(),E=this.getDedupedMetricsNames();let R,D;S?(this.makeTestFunction(),R=this.testFunction,D=E.slice().concat(E.map(O=>"val_"+O))):(R=null,b=[],D=E.slice());const F=s6(s.callbacks,s.yieldEvery);return await this.fitLoop(T,w,E,g,s.epochs,s.verbose,F,R,b,s.shuffle,D,s.initialEpoch,null,null)}finally{this.isTraining=!1,zc(i,e),zc(a,t),zc(r,e),zc(o,t),zc(h,l),zc(d,c),p!=null&&Qn(p)}}async fitLoop(e,t,s,i,a,r,o,l,c,h,d,p,g,v){i==null&&(i=32),a==null&&(a=1),h==null&&(h=!0),p==null&&(p=0);let _=!1;if(l!=null&&c!=null&&(_=!0),v!=null&&(_=!0,g==null))throw new Me("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const S=this.checkNumSamples(t,i,g,"steps_per_epoch");let b;S!=null&&(b=tu(0,S)),r==null&&(r=1);const{callbackList:w,history:T}=i6(o,r,a,p,S,g,i,_,d);w.setModel(this),this.history=T,await w.onTrainBegin(),this.stopTraining_=!1;for(let E=p;E<a;++E){await w.onEpochBegin(E);const R={};if(g!=null)throw new qn("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new qn("batch shuffling is not implemneted yet");h&&tB(b);const D=xr(b),F=f3(S,i);for(let U=0;U<F.length;++U){const O={};if(await w.onBatchBegin(U,O),Le(()=>{const B=F[U][0],L=F[U][1],H=Zm(D,B,L-B);O.batch=U,O.size=L-B;const K=kD(t,H),Z=e(K);for(let Q=0;Q<s.length;++Q){const P=s[Q],W=Z[Q];O[P]=W,ga(W)}if(U===F.length-1&&_){const Q=this.testLoop(l,c,i);for(let P=0;P<s.length;++P){const W=s[P],q=Q[P];ga(q),R["val_"+W]=q}}}),await w.onBatchEnd(U,O),n6(O),this.stopTraining_)break}D.dispose()}if(await w.onEpochEnd(E,R),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return tve(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),i=s[0],a=s[1],o=this.makeTrainFunction()(i.concat(a)),l=[];for(const c of o){const h=await c.data();l.push(h[0])}return Qn(o),zc(s[0],e),zc(s[1],t),vo(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,i=s?this.trainableWeights:this.weights,a=this.getWeights(s);for(let r=0;r<i.length;++r)s&&!i[r].trainable||t.push({name:i[r].originalName,tensor:a[r]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=iD().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-iD().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=sd(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>sd(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const i of t)if(typeof s[i]=="string")e[i]=sd(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[sd(JC(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>sd(JC(e)));{const e={};for(const t in this.metrics)e[t]=sd(JC(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=OD(e.optimizer_config),s=dd(t);let i;if(typeof e.loss=="string")i=Bm(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(r=>Bm(r));else if(e.loss!=null){i={};for(const r in e.loss)i[r]=Bm(e.loss[r])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(r=>Bm(r));else if(e.metrics!=null){a={};for(const r in e.metrics)a[r]=Bm(e.metrics[r])}this.compile({loss:i,metrics:a,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=NH(e);if(c.length===0)throw new Me(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new Me(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new Me("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await aD(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:cve,generatedBy:`TensorFlow.js tfjs-layers v${h6}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:h,specs:d}=await aD(await this.optimizer.getWeights(),c);s.specs.push(...d),s.data=EH([s.data,h])}return this.userDefinedMetadata!=null&&(o$(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){o$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Mx.className="Model";_t(Mx);class g6 extends Mx{}g6.className="Functional";_t(g6);class gS extends Mx{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:ON("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new Me(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof gS||e instanceof Mx;let s;if(t){if(s=e,s.outputs.length!==1)throw new Me("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new Me("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Me("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=hye({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new Me(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Me("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=J8(this.outputs[0])}this.inboundNodes=[],new kN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:vg(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Rs(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Mx({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new nc("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new nc("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new nc("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new nc("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},i=!1){let a,r={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Me("Legacy serialization format not supported yet.");a=t}else ee(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,r=t;const o=new e(r);if(!(o instanceof gS))throw new qn(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const h=dd(l,void 0,i);i&&h.setFastWeightInitDuringBuild(!0),o.add(h)}return o}set stopTraining(e){if(this.model==null)throw new Me("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Me("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}gS.className="Sequential";_t(gS);let Sr=class extends Bg{getConfig(){return{}}};class x6 extends Sr{apply(e,t=1){return Kxe(e,t)}}x6.className="elu";_t(x6);class y6 extends Sr{apply(e){return lN(e)}}y6.className="selu";_t(y6);class v6 extends Sr{apply(e){return ou(e)}}v6.className="relu";_t(v6);class b6 extends Sr{apply(e){return Le(()=>qf(6,ou(e)))}}b6.className="relu6";_t(b6);class S6 extends Sr{apply(e){return e}}S6.className="linear";_t(S6);class _6 extends Sr{apply(e){return Yc(e)}}_6.className="sigmoid";_t(_6);class A6 extends Sr{apply(e){return Jxe(e)}}A6.className="hardSigmoid";_t(A6);class w6 extends Sr{apply(e){return Dg(e)}}w6.className="softplus";_t(w6);class C6 extends Sr{apply(e){return Yxe(e)}}C6.className="softsign";_t(C6);class T6 extends Sr{apply(e){return Xf(e)}}T6.className="tanh";_t(T6);let bL=class extends Sr{apply(e,t=-1){return lA(e,t)}};bL.className="softmax";_t(bL);class E6 extends Sr{apply(e,t=-1){return eN(e,t)}}E6.className="logSoftmax";_t(E6);class M6 extends Sr{apply(e){return Le(()=>Le(()=>{const t=Math.sqrt(2),s=we(.5,bt(1,JM(un(e,t))));return we(e,s)}))}}M6.className="gelu";_t(M6);class N6 extends Sr{apply(e){return Le(()=>we(.5,we(e,bt(1,Xf(we(La(un(2,Math.PI)),bt(e,we(.044715,ch(e,3)))))))))}}N6.className="gelu_new";_t(N6);class R6 extends Sr{apply(e){return Le(()=>we(e,Xf(Dg(e))))}}R6.className="mish";_t(R6);class I6 extends Sr{apply(e,t=1){return Le(()=>we(Yc(we(e,t)),e))}}I6.className="swish";_t(I6);function Yf(n){return n.getClassName()}function p3(n,e={}){return pA(n,xl.getMap().classNameMap,e,"activation")}function Jf(n){if(n==null){const e={};return e.className="linear",e.config={},p3(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},p3(e)}else return n instanceof Sr?n:p3(n)}function uve(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class D6 extends Bg{}class O6 extends D6{constructor(e){super(),uve(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Le(()=>{let t=aa([1]);return this.hasL1&&(t=bt(t,sn(we(this.l1,ia(e))))),this.hasL2&&(t=bt(t,sn(we(this.l2,gA(e))))),Ee(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}O6.className="L1L2";_t(O6);const f$={l1l2:"L1L2"};function Qs(n){return rL(n)}function p$(n,e={}){return pA(n,xl.getMap().classNameMap,e,"regularizer")}function fi(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in f$?f$[n]:n,config:{}};return p$(t)}else return n instanceof D6?n:p$(n)}class B6 extends ns{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Nn(e);let s=ou(e);return this.maxValue!=null&&(s=Mo(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}B6.className="ReLU";_t(B6);class k6 extends ns{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Nn(e);return Z_(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}k6.className="LeakyReLU";_t(k6);class L6 extends ns{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=di(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fi(e.alphaRegularizer),this.alphaConstraint=ba(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Me(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Rs(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new ya({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Nn(e),aA(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ci(this.alphaInitializer),alphaRegularizer:Qs(this.alphaRegularizer),alphaConstraint:va(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}L6.className="PReLU";_t(L6);let F6=class extends ns{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new qn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Nn(e);return mv(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};F6.className="ELU";_t(F6);class U6 extends ns{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Nn(e);return we(s,Ft(Do(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}U6.className="ThresholdedReLU";_t(U6);class P6 extends ns{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new bL().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return Le(()=>{let s=Nn(e);const i=t.mask;if(i!=null){const a=we(en(_o(s.shape),Ft(i,s.dtype)),vn(-1e9));s=bt(s,a)}return this.axis instanceof Array?this.axis.length>1?No(en(s,eA(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}P6.className="Softmax";_t(P6);function Nx(n,e,t){if(typeof n=="number")return vg(n,e);if(n.length!==e)throw new Me(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const i=n[s];if(!Wxe(i))throw new Me(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Jc(n,e,t,s,i=1){if(n==null)return n;const a=e+(e-1)*(i-1);let r;return t==="same"?r=n:r=n-a+1,Math.floor((r+s-1)/s)}function ju(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Kf([t-e,0]);else if(s==="same")n=n*e;else throw new Me(`Unsupport padding mode: ${s}.`);return n}function SL(n,e){return Le(()=>(Ki(e),e==="channelsFirst"?ls(n,[0,2,3,1]):n))}function z6(n,e){return Le(()=>(Ki(e),e==="channelsFirst"?ls(n,[0,2,3,4,1]):n))}function hve(n,e,t,s=1,i="valid",a,r=1){return Le(()=>{if(a==null&&(a=nu()),Ki(a),n.shape.length!==3)throw new Me(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new Me(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new Me(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(n=ls(n,[0,2,1])),i==="causal")throw new qn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=XM(n,e,s,i==="same"?"same":"valid","NWC",r);return t!=null&&(o=lu(o,t)),o})}function m$(n,e,t,s=[1,1],i="valid",a,r,o=null){return Le(()=>{if(a==null&&(a=nu()),Ki(a),n.rank!==3&&n.rank!==4)throw new Me(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Me(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=SL(n,a);if(i==="causal")throw new qn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=N5({x:l,filter:e,strides:s,pad:i==="same"?"same":"valid",dilations:r,dataFormat:"NHWC",bias:t,activation:o}),a==="channelsFirst"&&(l=ls(l,[0,3,1,2])),l})}function dve(n,e,t,s=[1,1,1],i="valid",a,r){return Le(()=>{if(a==null&&(a=nu()),Ki(a),n.rank!==4&&n.rank!==5)throw new Me(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Me(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=z6(n,a);if(i==="causal")throw new qn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=UB(o,e,s,i==="same"?"same":"valid","NDHWC",r),t!=null&&(o=lu(o,t)),a==="channelsFirst"&&(o=ls(o,[0,4,1,2,3])),o})}class UN extends ns{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",UN.verifyArgs(t),this.rank=e,Ia(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new qn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Nx(t.kernelSize,e,"kernelSize"),this.strides=Nx(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,El(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Ki(this.dataFormat),this.activation=Jf(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=di(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ba(t.biasConstraint),this.biasRegularizer=fi(t.biasRegularizer),this.activityRegularizer=fi(t.activityRegularizer),this.dilationRate=Nx(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Me(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Me(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Me(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Wu("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!oL(e.kernelSize,"number",1,3))throw new Me(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Yf(this.activation),useBias:this.useBias,biasInitializer:Ci(this.biasInitializer),biasRegularizer:Qs(this.biasRegularizer),activityRegularizer:Qs(this.activityRegularizer),biasConstraint:va(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class bv extends UN{constructor(e,t){super(e,t),this.kernel=null,bv.verifyArgs(t),this.filters=t.filters,Ia(this.filters,"filters"),this.kernelInitializer=di(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ba(t.kernelConstraint),this.kernelRegularizer=fi(t.kernelRegularizer)}build(e){e=Rs(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Me(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return Le(()=>{e=Nn(e);let s;const i=this.bias==null?null:this.bias.read(),a=L8(this.activation.getClassName());if(a!=null&&this.rank===2)s=m$(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)s=hve(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=m$(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=dve(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new qn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Rs(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<s.length;++a){const r=Jc(s[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);t.push(r)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:Ci(this.kernelInitializer),kernelRegularizer:Qs(this.kernelRegularizer),kernelConstraint:va(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Me(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class bA extends bv{constructor(e){super(2,e),bA.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!oL(e.kernelSize,"number",1,2))throw new Me(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}bA.className="Conv2D";_t(bA);class SA extends bv{constructor(e){super(3,e),SA.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Me(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}SA.className="Conv3D";_t(SA);class $6 extends bA{constructor(e){if(super(e),this.inputSpec=[new ya({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Me(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Rs(e),e.length!==4)throw new Me("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Me("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ya({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return Le(()=>{let s=Nn(e);if(s.shape.length!==4)throw new Me(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,a=i[0];let r,o;this.dataFormat==="channelsFirst"?(r=2,o=3):(r=1,o=2);const l=i[r],c=i[o],h=this.kernelSize[0],d=this.kernelSize[1],p=this.strides[0],g=this.strides[1],v=ju(l,p,h,this.padding),_=ju(c,g,d,this.padding),S=[a,v,_,this.filters];this.dataFormat!=="channelsLast"&&(s=ls(s,[0,2,3,1]));let b=qM(s,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=ls(b,[0,3,1,2])),this.bias!=null&&(b=lu(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=Rs(e);const t=e.slice();let s,i,a;this.dataFormat==="channelsFirst"?(s=1,i=2,a=3):(s=3,i=1,a=2);const r=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[i]=ju(t[i],l,r,this.padding),t[a]=ju(t[a],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}$6.className="Conv2DTranspose";_t($6);class G6 extends SA{constructor(e){if(super(e),this.inputSpec=[new ya({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Me(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Rs(e),e.length!==5)throw new Me("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Me("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ya({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return Le(()=>{let s=Nn(e);if(s.shape.length!==5)throw new Me(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,a=i[0];let r,o,l;this.dataFormat==="channelsFirst"?(l=2,r=3,o=4):(l=1,r=2,o=3);const c=i[l],h=i[r],d=i[o],p=this.kernelSize[0],g=this.kernelSize[1],v=this.kernelSize[2],_=this.strides[0],S=this.strides[1],b=this.strides[2],w=ju(c,_,p,this.padding),T=ju(h,S,g,this.padding),E=ju(d,b,v,this.padding),R=[a,w,T,E,this.filters];this.dataFormat!=="channelsLast"&&(s=ls(s,[0,2,3,4,1]));let D=PB(s,this.kernel.read(),R,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(D=ls(D,[0,4,1,2,3])),this.bias!==null&&(D=lu(D,this.bias.read(),this.dataFormat)),this.activation!==null&&(D=this.activation.apply(D)),D})}computeOutputShape(e){e=Rs(e);const t=e.slice();let s,i,a,r;this.dataFormat==="channelsFirst"?(s=1,i=2,a=3,r=4):(s=4,i=1,a=2,r=3);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],h=this.strides[0],d=this.strides[1],p=this.strides[2];return t[s]=this.filters,t[i]=ju(t[i],h,o,this.padding),t[a]=ju(t[a],d,l,this.padding),t[r]=ju(t[r],p,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}G6.className="Conv3DTranspose";_t(G6);class V6 extends bv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Me("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Me("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Me(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=di(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fi(t.depthwiseRegularizer),this.depthwiseConstraint=ba(t.depthwiseConstraint),this.pointwiseInitializer=di(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fi(t.pointwiseRegularizer),this.pointwiseConstraint=ba(t.pointwiseConstraint)}build(e){if(e=Rs(e),e.length<this.rank+2)throw new Me(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Me(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],i=this.kernelSize.concat([s,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(s*this.depthMultiplier,this.filters);const r=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,r,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,r,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,r,this.biasConstraint):this.bias=null,this.inputSpec=[new ya({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return Le(()=>{e=Nn(e);let s;if(this.rank===1)throw new qn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ls(e,[0,2,3,1])),s=cN(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=lu(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=ls(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ci(this.depthwiseInitializer),e.pointwiseInitializer=Ci(this.pointwiseInitializer),e.depthwiseRegularizer=Qs(this.depthwiseRegularizer),e.pointwiseRegularizer=Qs(this.pointwiseRegularizer),e.depthwiseConstraint=va(this.depthwiseConstraint),e.pointwiseConstraint=va(this.pointwiseConstraint),e}}V6.className="SeparableConv";class H6 extends V6{constructor(e){super(2,e)}}H6.className="SeparableConv2D";_t(H6);class PN extends bv{constructor(e){super(1,e),PN.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!oL(e.kernelSize,"number",1,1))throw new Me(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}PN.className="Conv1D";_t(PN);class W6 extends ns{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Le(()=>{if(e=Nn(e),this.dataFormat==="channelsLast"){const s=YC(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return YC(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=YC(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return YC(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}W6.className="Cropping2D";_t(W6);class j6 extends ns{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ki(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Gxe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return Le(()=>{let s=Nn(e);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=ls(s,[0,2,3,1]);const a=this.size[0]*i[2],r=this.size[1]*i[3],o=this.interpolation==="nearest"?qc.resizeNearestNeighbor(s,[a,r]):qc.resizeBilinear(s,[a,r]);return ls(o,[0,3,1,2])}else{const a=this.size[0]*i[1],r=this.size[1]*i[2];return this.interpolation==="nearest"?qc.resizeNearestNeighbor(s,[a,r]):qc.resizeBilinear(s,[a,r])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}j6.className="UpSampling2D";_t(j6);function fve(n,e,t=[1,1],s="valid",i,a){return Le(()=>{i==null&&(i=nu()),Ki(i);let r=SL(n,i);if(n.rank!==4)throw new Me(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new Me(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return r=pv(r,e,t,s==="same"?"same":"valid","NHWC",a),i==="channelsFirst"&&(r=ls(r,[0,3,1,2])),r})}class X6 extends UN{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=di(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ba(e.depthwiseConstraint),this.depthwiseRegularizer=fi(e.depthwiseRegularizer)}build(e){if(e=Rs(e),e.length<4)throw new Me(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Me(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Le(()=>{e=Nn(e);let s=fve(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=lu(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Rs(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Jc(t,this.kernelSize[0],this.padding,this.strides[0]),r=Jc(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,a,r]:[e[0],a,r,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ci(this.depthwiseInitializer),e.depthwiseRegularizer=Qs(this.depthwiseRegularizer),e.depthwiseConstraint=va(this.depthwiseRegularizer),e}}X6.className="DepthwiseConv2D";_t(X6);function q6(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new Me("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(a){return a==null||Array.isArray(a)?a:[a]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function K6(n,e,t,s=!1,i,a,r=!1,o=!1){return Le(()=>{const l=e.shape.length;if(l<3)throw new Me(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(tu(2,l));e=ls(e,c),r&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=Ft(Ft(i,"bool"),"float32"),i.rank===l-1&&(i=gr(i,-1)),i=ls(i,c)),s&&(e=Cl(e,0),i!=null&&(i=Cl(i,0)));const h=[];let d,p=t;const g=e.shape[0],v=Tl(e);let _;i!=null&&(_=Tl(i));for(let b=0;b<g;++b){const w=v[b],T=Le(()=>n(w,p));if(i==null)d=T[0],p=T[1];else{const E=Le(()=>{const R=_[b],D=en(Zo(R),R),F=bt(we(T[0],R),we(p[0],D)),U=p.map((O,B)=>bt(we(T[1][B],R),we(O,D)));return{output:F,newStates:U}});d=E.output,p=E.newStates}o&&h.push(d)}let S;return o&&(S=Ro(h,1)),[d,S,p]})}class fp extends ns{constructor(e){super(e);let t;if(e.cell==null)throw new Me("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new wL({cells:e.cell}):t=e.cell,t.stateSize==null)throw new Me("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ya({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return tu(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){RD(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let i;if(this.returnSequences?i=[e[0],e[1],s]:i=[e[0],s],this.returnState){const a=[];for(const r of t)a.push([e[0],r]);return[i].concat(a)}else return i}computeMask(e,t){return Le(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(a=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new qn("Constants support is not implemented in RNN yet.");RD(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new ya({shape:[t,null,...s]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!as(this.stateSpec.map(r=>r.shape[r.shape.length-1]),a))throw new Me(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(r=>new ya({shape:[null,r]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Le(()=>{if(!this.stateful)throw new Hu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new Me("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>aa([s,i])):this.states_=[aa([s,this.cell.stateSize])];else if(e==null)Qn(this.states_),this.keptStates!=null&&(Qn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>aa([s,i])):this.states_[0]=aa([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Me(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Qn(this.states_);for(let i=0;i<this.states_.length;++i){const a=e[i],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,o=[s,r];if(!as(a.shape,o))throw new Me(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[i]=a}}this.states_=this.states_.map(i=>ga(i.clone()))})}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const a=q6(e,s,i,this.numConstants);e=a.inputs,s=a.initialState,i=a.constants;let r=[],o=[];if(s!=null){t.initialState=s,r=r.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new ya({shape:c.shape}));o=o.concat(this.stateSpec)}if(i!=null&&(t.constants=i,r=r.concat(i),this.numConstants=i.length),r[0]instanceof hh){const c=[e].concat(r),h=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=h;const p=super.apply(c,t);return this.inputSpec=d,p}else return super.apply(e,t)}call(e,t){return Le(()=>{const s=t==null?null:t.mask,i=t==null?null:t.training;let a=t==null?null:t.initialState;e=Nn(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const r=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==r)throw new Me(`RNN Layer has ${r} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},c=K6((v,_)=>{const S=this.cell.call([v].concat(_),o);return[S[0],S.slice(1)]},e,a,this.goBackwards,s,null,this.unroll,this.returnSequences),h=c[0],d=c[1],p=c[2];this.stateful&&this.resetStates(p,i);const g=this.returnSequences?d:h;return this.returnState?[g].concat(p):g})}getInitialState(e){return Le(()=>{let t=aa(e.shape);return t=sn(t,[1,2]),t=mA(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?MD(t,[1,s]):t):this.cell.stateSize>1?[MD(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===fp.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const i=t.cell,a=dd(i,s);return new e(Object.assign(t,{cell:a}))}}fp.className="RNN";_t(fp);class zN extends ns{}class _L extends zN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ia(this.units,"units"),this.activation=Jf(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=di(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=di(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=di(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fi(e.kernelRegularizer),this.recurrentRegularizer=fi(e.recurrentRegularizer),this.biasRegularizer=fi(e.biasRegularizer),this.kernelConstraint=ba(e.kernelConstraint),this.recurrentConstraint=ba(e.recurrentConstraint),this.biasConstraint=ba(e.biasConstraint),this.dropout=Qx([1,Kf([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qx([1,Kf([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Rs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Le(()=>{if(e=e,e.length!==2)throw new Me(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zf({ones:()=>Zo(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zf({ones:()=>Zo(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let a;const r=this.dropoutMask,o=this.recurrentDropoutMask;r!=null?a=sh(we(e,r),this.kernel.read()):a=sh(e,this.kernel.read()),this.bias!=null&&(a=lu(a,this.bias.read())),o!=null&&(s=we(s,o));let l=bt(a,sh(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Yf(this.activation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),recurrentInitializer:Ci(this.recurrentInitializer),biasInitializer:Ci(this.biasInitializer),kernelRegularizer:Qs(this.kernelRegularizer),recurrentRegularizer:Qs(this.recurrentRegularizer),biasRegularizer:Qs(this.biasRegularizer),activityRegularizer:Qs(this.activityRegularizer),kernelConstraint:va(this.kernelConstraint),recurrentConstraint:va(this.recurrentConstraint),biasConstraint:va(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}_L.className="SimpleRNNCell";_t(_L);class Y6 extends fp{constructor(e){e.cell=new _L(e),super(e)}call(e,t){return Le(()=>{this.cell.dropoutMask!=null&&(Qn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:a})})}static fromConfig(e,t){return new e(t)}}Y6.className="SimpleRNN";_t(Y6);class AL extends zN{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Me("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ia(this.units,"units"),this.activation=Jf(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Jf(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=di(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=di(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=di(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fi(e.kernelRegularizer),this.recurrentRegularizer=fi(e.recurrentRegularizer),this.biasRegularizer=fi(e.biasRegularizer),this.kernelConstraint=ba(e.kernelConstraint),this.recurrentConstraint=ba(e.recurrentConstraint),this.biasConstraint=ba(e.biasConstraint),this.dropout=Qx([1,Kf([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qx([1,Kf([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Rs(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Le(()=>{if(e=e,e.length!==2)throw new Me(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zf({ones:()=>Zo(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zf({ones:()=>Zo(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,r=this.recurrentDropoutMask;let o,l,c;0<this.dropout&&this.dropout<1&&(e=we(e,a[0]));let h=sh(e,this.kernel.read());this.useBias&&(h=lu(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=we(i,r[0]));const d=this.recurrentKernel.read(),[p,g]=wo(d,[2*this.units,this.units],d.rank-1),v=sh(i,p),[_,S,b]=wo(h,3,h.rank-1),[w,T]=wo(v,2,v.rank-1);o=this.recurrentActivation.apply(bt(_,w)),l=this.recurrentActivation.apply(bt(S,T));const E=sh(we(l,i),g);c=this.activation.apply(bt(b,E));const R=bt(we(o,i),we(bt(1,ri(o)),c));return[R,R]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Yf(this.activation),recurrentActivation:Yf(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),recurrentInitializer:Ci(this.recurrentInitializer),biasInitializer:Ci(this.biasInitializer),kernelRegularizer:Qs(this.kernelRegularizer),recurrentRegularizer:Qs(this.recurrentRegularizer),biasRegularizer:Qs(this.biasRegularizer),activityRegularizer:Qs(this.activityRegularizer),kernelConstraint:va(this.kernelConstraint),recurrentConstraint:va(this.recurrentConstraint),biasConstraint:va(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}AL.className="GRUCell";_t(AL);class J6 extends fp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new AL(e),super(e)}call(e,t){return Le(()=>{this.cell.dropoutMask!=null&&(Qn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}J6.className="GRU";_t(J6);class $N extends zN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ia(this.units,"units"),this.activation=Jf(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Jf(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=di(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=di(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=di(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=fi(e.kernelRegularizer),this.recurrentRegularizer=fi(e.recurrentRegularizer),this.biasRegularizer=fi(e.biasRegularizer),this.kernelConstraint=ba(e.kernelConstraint),this.recurrentConstraint=ba(e.recurrentConstraint),this.biasConstraint=ba(e.biasConstraint),this.dropout=Qx([1,Kf([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qx([1,Kf([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Rs(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,r=this.units;i=new(t=class extends hc{apply(l,c){const h=a.apply([r]),d=new cL().apply([r]),p=a.apply([r*2]);return Zz(Zz(h,d),p)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Le(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Me(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zf({ones:()=>Zo(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zf({ones:()=>Zo(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h,d;0<this.dropout&&this.dropout<1&&(e=we(e,r[0]));let p=sh(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=we(i,o[0])),p=bt(p,sh(i,this.recurrentKernel.read())),this.useBias&&(p=lu(p,this.bias.read()));const[g,v,_,S]=wo(p,4,p.rank-1);l=this.recurrentActivation.apply(g),c=this.recurrentActivation.apply(v),h=bt(we(c,a),we(l,this.activation.apply(_))),d=this.recurrentActivation.apply(S);const b=we(d,this.activation.apply(h));return[b,b,h]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Yf(this.activation),recurrentActivation:Yf(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),recurrentInitializer:Ci(this.recurrentInitializer),biasInitializer:Ci(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Qs(this.kernelRegularizer),recurrentRegularizer:Qs(this.recurrentRegularizer),biasRegularizer:Qs(this.biasRegularizer),activityRegularizer:Qs(this.activityRegularizer),kernelConstraint:va(this.kernelConstraint),recurrentConstraint:va(this.recurrentConstraint),biasConstraint:va(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}$N.className="LSTMCell";_t($N);class Z6 extends fp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new $N(e),super(e)}call(e,t){return Le(()=>{this.cell.dropoutMask!=null&&(Qn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Z6.className="LSTM";_t(Z6);class wL extends zN{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Le(()=>{e=e;let s=e.slice(1);const i=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?i.push(s.splice(0,o.stateSize.length)):i.push(s.splice(0,1));i.reverse();const a=[];let r;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=i[o],o===0?r=[e[0]].concat(s):r=[r[0]].concat(s),r=l.call(r,t),a.push(r.slice(1))}s=[];for(const o of a.slice().reverse())s.push(...o);return[r[0]].concat(s)})}build(e){RD(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,i)=>{Jm(`RNNCell_${i}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,s={}){const i=[];for(const a of t.cells)i.push(dd(a,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return ID(e)}setWeights(e){const t=[];for(const s of this.cells){const i=s.weights.length,a=e.splice(i);for(let r=0;r<s.weights.length;++r)t.push([s.weights[r],a[r]])}gL(t)}}wL.className="StackedRNNCells";_t(wL);function Zf(n){const{ones:e,rate:t,training:s=!1,count:i=1,dropoutFunc:a}=n,r=()=>a!=null?a(e(),t):V8(e(),t),o=()=>xA(r,e,s);return!i||i<=1?ga(o().clone()):Array(i).fill(void 0).map(o).map(c=>ga(c.clone()))}var pve=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(t[s[i]]=n[s[i]]);return t};class Q6 extends fp{constructor(e){if(e.unroll)throw new qn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new qn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ya({ndim:5})]}call(e,t){return Le(()=>{if(this.cell.dropoutMask!=null&&(Qn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Me("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,i=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Le(()=>{const{stateSize:t}=this.cell,s=e.shape,i=this.computeSingleOutputShape(s),a=[i[0],...i.slice(2)],r=aa(a);return Array.isArray(t)?Array(t.length).fill(r):[r]})}resetStates(e,t=!1){Le(()=>{if(!this.stateful)throw new Hu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),a=[i[0],...i.slice(2)];if(s[0]==null)throw new Me("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>aa(a)):this.states_=[aa(a)];else if(e==null)Qn(this.states_),this.keptStates!=null&&(Qn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>aa(a)):this.states_[0]=aa(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Me(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Qn(this.states_);for(let o=0;o<this.states_.length;++o){const l=e[o],c=a;if(!as(l.shape,c))throw new Me(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>ga(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:i,padding:a,strides:r,dilationRate:o}=this.cell,l=t==="channelsFirst",c=e[l?3:2],h=e[l?4:3],d=Jc(c,i[0],a,r[0],o[0]),p=Jc(h,i[1],a,r[1],o[1]);return[...e.slice(0,2),...l?[s,d,p]:[d,p,s]]}}Q6.className="ConvRNN2D";class CL extends $N{constructor(e){const{filters:t,kernelSize:s,strides:i,padding:a,dataFormat:r,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ia(this.filters,"filters"),this.kernelSize=Nx(s,2,"kernelSize"),this.kernelSize.forEach(l=>Ia(l,"kernelSize")),this.strides=Nx(i||1,2,"strides"),this.strides.forEach(l=>Ia(l,"strides")),this.padding=a||"valid",El(this.padding),this.dataFormat=r||"channelsLast",Ki(this.dataFormat),this.dilationRate=Nx(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ia(l,"dilationRate"))}build(e){var t;e=Rs(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new Me(`The channel dimension of the input should be defined. Found ${e[s]}`);const i=e[s],a=4,r=this.kernelSize.concat([i,this.filters*a]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,h=this.filters;l=new(t=class extends hc{apply(p,g){const v=c.apply([h]),_=_o([h]),S=c.apply([h*2]);return lL([v,_,S])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Le(()=>{if(e.length!==3)throw new Me(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,i=e[0],a=e[1],r=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Zf({ones:()=>Zo(i),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(le,Y,re)=>!Y||!Y[re]?le:we(Y[re],le);let h=c(i,l,0),d=c(i,l,1),p=c(i,l,2),g=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Zf({ones:()=>Zo(a),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const v=this.recurrentDropoutMask;let _=c(a,v,0),S=c(a,v,1),b=c(a,v,2),w=c(a,v,3);const T=3,[E,R,D,F]=wo(this.kernel.read(),o,T),[U,O,B,L]=this.useBias?wo(this.bias.read(),o):[null,null,null,null];h=this.inputConv(h,E,U,this.padding),d=this.inputConv(d,R,O,this.padding),p=this.inputConv(p,D,B,this.padding),g=this.inputConv(g,F,L,this.padding);const[H,K,Z,Q]=wo(this.recurrentKernel.read(),o,T);_=this.recurrentConv(_,H),S=this.recurrentConv(S,K),b=this.recurrentConv(b,Z),w=this.recurrentConv(w,Q);const P=this.recurrentActivation.apply(bt(h,_)),W=this.recurrentActivation.apply(bt(d,S)),q=bt(we(W,r),we(P,this.activation.apply(bt(p,b)))),se=we(this.recurrentActivation.apply(bt(g,w)),this.activation.apply(q));return[se,se,q]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=pve(e,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,t,s,i){const a=yd(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?lu(a,s,this.dataFormat):a}recurrentConv(e,t){return yd(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}CL.className="ConvLSTM2DCell";_t(CL);class e9 extends Q6{constructor(e){const t=new CL(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}e9.className="ConvLSTM2D";_t(e9);class TL extends ns{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return s}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,a=this.getNoiseShape(s);return xA(()=>V8(s,this.rate,a,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}TL.className="Dropout";_t(TL);class t9 extends TL{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}t9.className="SpatialDropout1D";_t(t9);class n9 extends ns{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ia(this.units,"units"),this.activation=Jf(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=di(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=di(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ba(e.kernelConstraint),this.biasConstraint=ba(e.biasConstraint),this.kernelRegularizer=fi(e.kernelRegularizer),this.biasRegularizer=fi(e.biasRegularizer),this.activityRegularizer=fi(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Rs(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Rs(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e),i=L8(this.activation.getClassName());let a;return i!=null?a=sh(s,this.kernel.read(),i,this.bias?this.bias.read():null):(a=sh(s,this.kernel.read()),this.bias!=null&&(a=lu(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:Yf(this.activation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),biasInitializer:Ci(this.biasInitializer),kernelRegularizer:Qs(this.kernelRegularizer),biasRegularizer:Qs(this.biasRegularizer),activityRegularizer:Qs(this.activityRegularizer),kernelConstraint:va(this.kernelConstraint),biasConstraint:va(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}n9.className="Dense";_t(n9);class s9 extends ns{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Rs(e);for(const t of e.slice(1))if(t==null)throw new Me(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Lf(e,1)]}call(e,t){return Le(()=>{this.invokeCallHook(e,t);let s=Nn(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let a=2;a<s.rank;++a)i.push(a);i.push(1),s=ls(s,i)}return qxe(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}s9.className="Flatten";_t(s9);class i9 extends ns{constructor(e){super(e),this.supportsMasking=!0,this.activation=Jf(e.activation)}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e);return this.activation.apply(s)})}getConfig(){const e={activation:Yf(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}i9.className="Activation";_t(i9);class a9 extends ns{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Le(()=>(e=Nn(e),jxe(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}a9.className="RepeatVector";_t(a9);class r9 extends ns{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",i=t.slice();let a=1,r=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(r===null)r=l;else throw new Me("Can only specifiy one unknown dimension.");else a*=c}const o=Lf(e);if(r!==null){if(a===0||o%a!==0)throw new Me(s);i[r]=o/a}else if(o!==a)throw new Me(s);return i}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e),i=s.shape,a=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return Ee(s,a)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}r9.className="Reshape";_t(r9);class o9 extends ns{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=tu(1,e.dims.length+1);if(!as(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ya({ndim:this.dims.length+1})]}computeOutputShape(e){e=Rs(e);const t=e.slice();return this.dims.forEach((s,i)=>{t[i+1]=e[s]}),t}call(e,t){return ls(Nn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}o9.className="Permute";_t(o9);class l9 extends ns{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Nn(e);return uS(mg(s,this.maskValue),-1)}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e),r=uS(mg(s,this.maskValue),-1,!0);return we(s,Ft(r,s.dtype))})}}l9.className="Masking";_t(l9);class c9 extends ns{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Gs(e.inputLength))}this.inputDim=e.inputDim,Ia(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ia(this.outputDim,"outputDim"),this.embeddingsInitializer=di(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fi(e.embeddingsRegularizer),this.activityRegularizer=fi(e.activityRegularizer),this.embeddingsConstraint=ba(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Le(()=>this.maskZero?(e=Nn(e),mg(e,ps(e))):null)}computeOutputShape(e){if(e=Rs(e),this.inputLength==null)return[...e,this.outputDim];const t=Gs(this.inputLength);if(t.length!==e.length-1)throw new Me(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<t.length;++i){const a=t[i],r=e[i+1];if(a!=null&&r!=null&&a!==r)throw new Me(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[s]=r),s++}}return[e[0],...t,this.outputDim]}call(e,t){return Le(()=>{this.invokeCallHook(e,t);let s=Nn(e);s.dtype!=="int32"&&(s=nh(s,"int32"));const i=G8(this.embeddings.read(),Ee(s,[s.size]));return Ee(i,Rs(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ci(this.embeddingsInitializer),embeddingsRegularizer:Qs(this.embeddingsRegularizer),activityRegularizer:Qs(this.activityRegularizer),embeddingsConstraint:va(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}c9.className="Embedding";_t(c9);class Lg extends ns{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new qn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const a=e[e.length-t.length+i],r=t[i];if(a==null||r==null||a<0||r<0)s.push(null);else if(a===1)s.push(r);else if(r===1)s.push(a);else{if(a!==r)throw new Me("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(a)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Rs(e)]),e=e,e.length<2)throw new Me(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=kf(t),t.length>1)throw new Me(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const r=e[a]==null?null:e[a].slice(1);s=this.computeElementwiseOpOutputShape(s,r)}const i=e.map(a=>a.length);e.indexOf(null)===-1&&kf(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Le(()=>{if(e=e,this.reshapeRequired){const s=[],i=e.map(a=>a.rank);if(i.indexOf(null)===-1){const a=Kf(i);for(let r of e){const o=r.rank;for(let l=0;l<a-o;++l)r=mA(r,1);s.push(r)}return this.mergeFunction(s)}else{let a=!1;for(const l of e){const c=l.rank;if(c==null){const h=l.shape,d=h[0],p=h.slice(1).concat([d]);let g=Ee(l,[d].concat(Lf(h.slice(1))));g=ls(g,[1,0]),g=Ee(g,p),s.push(g),a=!0}else if(c>1){const h=tu(1,c).concat([0]);s.push(ls(l,h)),a=!0}else s.push(l)}let r=this.mergeFunction(s);const o=r.rank;if(a){if(o==null){const l=r.shape,c=l.length,h=l[c-1],d=[h].concat(l.slice(0,l.length-1));r=Ee(ls(Ee(r,[-1,h]),[1,0]),d)}else if(o>1){const l=[o-1].concat(tu(0,o-1));r=ls(r,l)}}return r}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const a=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let s=[];for(const i of e)i!=null&&i[0]!==null&&s.push(i[0]);return s=kf(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return Le(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Me("`mask` should be an Array");if(!Array.isArray(e))throw new Me("`inputs` should be an Array");if(t.length!==e.length)throw new Me(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:gr(i,0));let s=t[0];for(let i=1;i<t.length-1;++i)s=eu(s,t[i]);return s})}}class u9 extends Lg{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=bt(t,e[s]);return t})}}u9.className="Add";_t(u9);class h9 extends Lg{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return t})}}h9.className="Multiply";_t(h9);class d9 extends Lg{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=bt(t,e[s]);return we(1/e.length,t)})}}d9.className="Average";_t(d9);class f9 extends Lg{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=mh(t,e[s]);return t})}}f9.className="Maximum";_t(f9);class p9 extends Lg{constructor(e){super(e)}mergeFunction(e){return Le(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=qf(t,e[s]);return t})}}p9.className="Minimum";_t(p9);class m9 extends Lg{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Me("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const s=[];for(let i=0;i<e.length;++i){const a=e[i].slice();a.splice(this.axis,1);let r=!1;for(const o of s)if(as(o,a)){r=!0;break}r||s.push(a)}if(s.length>1)throw new Me("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Le(()=>lL(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Me("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const a of t.slice(1)){if(s[i]==null||a[i]==null){s[i]=null;break}s[i]+=a[i]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Me("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Me("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Me(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Le(()=>{let s=!0;if(t.forEach(r=>{if(r!=null){s=!1;return}}),s)return null;const i=[];for(let r=0;r<e.length;++r)t[r]==null?i.push(Ft(Zo(e[r]),"bool")):t[r].rank<e[r].rank?i.push(gr(t[r],-1)):i.push(t[r]);const a=ji(i,this.axis);return jM(a,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}m9.className="Concatenate";_t(m9);function S1(n,e){for(;n<0;)n+=e;return n}function mve(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new qn("batchDot is not implemented for tensors of 4D or higher rank yet");if(ee(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),ee(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new qn("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=e.shape.length;t==null&&(t=[s-1,i-2]);const a=t;return Le(()=>{let r;if(s>i){r=s-i;const l=[];for(let c=0;c<r;++c)l.push(1);e=Ee(e,e.shape.concat(l))}else if(i>s){r=i-s;const l=[];for(let c=0;c<r;++c)l.push(1);n=Ee(n,n.shape.concat(l))}else r=0;let o;if(n.shape.length===2&&e.shape.length===2)a[0]===a[1]?o=sn(we(n,e),a[0]):o=sn(we(ls(n,[1,0]),e),a[1]);else{const l=a[0]!==n.shape.length-1,c=a[1]===e.shape.length-1;o=Zn(n,e,l,c)}if(r>0){let l;s>i?l=s+i-3:l=s-1;const c=[];for(let h=l;h<l+r;++h)c.push(h);o=hp(o,c)}return o.shape.length===1&&(o=gr(o,1)),o})}class g9 extends Lg{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){ee(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new qn("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);if(t[i[0]]!==s[i[1]])throw new Me(`Dimension incompatibility: ${t[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Me(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((a,r)=>S1(a,e[r].shape.length)):i=[S1(this.axes,t.shape.length),S1(this.axes,s.shape.length)],this.normalize&&(t=kE(t,i[0]),s=kE(s,i[1])),mve(t,s,i)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[S1(this.axes,e.length),S1(this.axes,t.length)],s}computeOutputShape(e){ee(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new qn("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);t.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const a=t.concat(s);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}g9.className="Dot";_t(g9);class x9 extends ns{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e);return xA(()=>bt(BN(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}x9.className="GaussianNoise";_t(x9);class y9 extends ns{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Le(()=>{this.invokeCallHook(e,t);const s=Nn(e);return this.rate>0&&this.rate<1?xA(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return we(s,BN(s.shape,1,a))},()=>s,t.training||!1):s})}}y9.className="GaussianDropout";_t(y9);class v9 extends ns{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Nn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Le(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return xA(()=>{const a=Nn(e),o=-1.6732632423543772*1.0507009873554805;let l=Td(up(s),this.rate);l=nh(l,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,h=-c*o*this.rate,d=bt(we(a,l),we(bt(l,-1),o));return bt(we(d,c),h)},()=>Nn(e),t.training||!1)}return e})}}v9.className="AlphaDropout";_t(v9);function xS(n,e,t,s,i,a=.001){let r;if(n.rank===2)r=MB(n,e,t,s,i,a);else if(n.rank===3)r=NB(n,e,t,s,i,a);else if(n.rank===4)r=RB(n,e,t,s,i,a);else throw new qn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return r}function gve(n,e,t,s,i=.001){return Le(()=>{const a=sA(n,s),r=a.mean,o=a.variance;return[xS(n,r,o,t,e,i),r,o]})}function xve(n,e,t,s,i=.001){return Le(()=>{const a=sA(n,s),r=a.mean,o=a.variance,l=[];for(const v of tu(0,n.rank))s.indexOf(v)!==-1?l.push(1):l.push(n.shape[v]);const c=Ee(r,l),h=Ee(o,l),d=e==null?null:Ee(e,l),p=t==null?null:Ee(t,l);return[xS(n,c,h,p,d,i),r,o]})}function yve(n,e,t,s,i=.001){return as(s.slice().sort(),tu(0,n.rank-1))?gve(n,e,t,s,i):xve(n,e,t,s,i)}class b9 extends ns{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=di(e.betaInitializer||"zeros"),this.gammaInitializer=di(e.gammaInitializer||"ones"),this.movingMeanInitializer=di(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=di(e.movingVarianceInitializer||"ones"),this.betaConstraint=ba(e.betaConstraint),this.gammaConstraint=ba(e.gammaConstraint),this.betaRegularizer=fi(e.betaRegularizer),this.gammaRegularizer=fi(e.gammaRegularizer)}build(e){e=Rs(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new Me(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ya({ndim:e.length,axes:{[t]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Le(()=>{const s=t.training==null?!1:t.training,i=Nn(e),a=i.shape,r=a.length,o=tu(0,r),l=this.axis>=0?this.axis:this.axis+r;o.splice(l,1);const c=vg(1,r);c[l]=a[l];const h=o.slice();h.sort();const d=!as(h,tu(0,r).slice(0,r-1)),p=()=>{if(d){const w=Ee(this.movingMean.read(),c),T=Ee(this.movingVariance.read(),c),E=this.center?Ee(this.beta.read(),c):null,R=this.scale?Ee(this.gamma.read(),c):null;return xS(i,w,T,E,R,this.epsilon)}else return xS(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return p();const[g,v,_]=yve(i,this.gamma.read(),this.beta.read(),o,this.epsilon),S=(w,T,E)=>{Le(()=>{const R=1-E,D=w.read(),F=we(en(D,T),R);w.write(en(D,F))})};return(()=>{S(this.movingMean,v,this.momentum),S(this.movingVariance,_,this.momentum)})(),g})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ci(this.betaInitializer),gammaInitializer:Ci(this.gammaInitializer),movingMeanInitializer:Ci(this.movingMeanInitializer),movingVarianceInitializer:Ci(this.movingVarianceInitializer),betaRegularizer:Qs(this.betaRegularizer),gammaRegularizer:Qs(this.gammaRegularizer),betaConstraint:va(this.betaConstraint),gammaConstraint:va(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}b9.className="BatchNormalization";_t(b9);class S9 extends ns{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=di(e.betaInitializer||"zeros"),this.gammaInitializer=di(e.gammaInitializer||"ones"),this.betaRegularizer=fi(e.betaRegularizer),this.gammaRegularizer=fi(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Rs(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==kf(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(a=>e[a]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const s=Nn(e),i=s.shape,a=i.length;return Le(()=>{let{mean:o,variance:l}=sA(s,this.axis,!0);const c=vg(1,a);for(const _ of this.axis)c[_]=i[_];const h=_=>_!=null&&_.shape.length!==a?Ee(_,c):_;let d=this.scale?h(this.gamma.read()):null,p=this.center?h(this.beta.read()):null;const g=[],v=[];for(let _=0;_<a;++_)this.axis.indexOf(_)!==-1?(g.push(i[_]),v.push(1)):(g.push(1),v.push(i[_]));return o=vl(o,g),l=vl(l,g),d!=null&&(d=vl(d,v)),p!=null&&(p=vl(p,v)),xS(s,o,l,p,d,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ci(this.betaInitializer),gammaInitializer:Ci(this.gammaInitializer),betaRegularizer:Qs(this.betaRegularizer),gammaRegularizer:Qs(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}S9.className="LayerNormalization";_t(S9);function vve(n,e,t){return Le(()=>{if(n.rank!==4)throw new Me(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Me("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=nu()),t!=="channelsLast"&&t!=="channelsFirst")throw new Me(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Ed(n,s)})}class _9 extends ns{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?nu():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Me(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Me(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Me(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new ya({ndim:4})]}computeOutputShape(e){e=Rs(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return Le(()=>vve(Nn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}_9.className="ZeroPadding2D";_t(_9);function GN(n,e,t,s,i,a){return Le(()=>{Ki(i),U8(a),El(s),t==null&&(t=[1,1]),s==null&&(s="valid"),i==null&&(i=nu()),a==null&&(a="max"),n=SL(n,i);let r;const o=s==="same"?"same":"valid";return a==="max"?r=nA(n,e,t,o):r=q_(n,e,t,o),i==="channelsFirst"&&(r=ls(r,[0,3,1,2])),r})}function A9(n,e,t,s,i,a){return Le(()=>{Ki(i),U8(a),El(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),i==null&&(i=nu()),a==null&&(a="max"),n=z6(n,i);let r;const o=s==="same"?"same":"valid";return a==="max"?r=QB(n,e,t,o):r=EB(n,e,t,o),i==="channelsFirst"&&(r=ls(r,[0,4,1,2,3])),r})}class w9 extends ns{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Me(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ia(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Me(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ia(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,El(this.padding),this.inputSpec=[new ya({ndim:3})]}computeOutputShape(e){e=Rs(e);const t=Jc(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Le(()=>{this.invokeCallHook(e,t),e=mA(Nn(e),2);const s=this.poolingFunction(Nn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return hp(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class C9 extends w9{constructor(e){super(e)}poolingFunction(e,t,s,i,a){return Ki(a),El(i),GN(e,t,s,i,a,"max")}}C9.className="MaxPooling1D";_t(C9);class T9 extends w9{constructor(e){super(e)}poolingFunction(e,t,s,i,a){return Ki(a),El(i),GN(e,t,s,i,a,"avg")}}T9.className="AveragePooling1D";_t(T9);class E9 extends ns{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Me(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ia(this.poolSize,"poolSize"),Ia(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ki(this.dataFormat),El(this.padding),this.inputSpec=[new ya({ndim:4})]}computeOutputShape(e){e=Rs(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Jc(t,this.poolSize[0],this.padding,this.strides[0]),s=Jc(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return Le(()=>(this.invokeCallHook(e,t),this.poolingFunction(Nn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class M9 extends E9{constructor(e){super(e)}poolingFunction(e,t,s,i,a){return Ki(a),El(i),GN(e,t,s,i,a,"max")}}M9.className="MaxPooling2D";_t(M9);class N9 extends E9{constructor(e){super(e)}poolingFunction(e,t,s,i,a){return Ki(a),El(i),GN(e,t,s,i,a,"avg")}}N9.className="AveragePooling2D";_t(N9);class R9 extends ns{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Me(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ia(this.poolSize,"poolSize"),Ia(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ki(this.dataFormat),El(this.padding),this.inputSpec=[new ya({ndim:5})]}computeOutputShape(e){e=Rs(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Jc(t,this.poolSize[0],this.padding,this.strides[0]),s=Jc(s,this.poolSize[1],this.padding,this.strides[1]),i=Jc(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,i]:[e[0],t,s,i,e[4]]}call(e,t){return Le(()=>(this.invokeCallHook(e,t),this.poolingFunction(Nn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class I9 extends R9{constructor(e){super(e)}poolingFunction(e,t,s,i,a){return Ki(a),El(i),A9(e,t,s,i,a,"max")}}I9.className="MaxPooling3D";_t(I9);class D9 extends R9{constructor(e){super(e)}poolingFunction(e,t,s,i,a){return Ki(a),El(i),A9(e,t,s,i,a,"avg")}}D9.className="AveragePooling3D";_t(D9);class O9 extends ns{constructor(e){super(e),this.inputSpec=[new ya({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new qn}}class B9 extends O9{constructor(e){super(e||{})}call(e,t){return Le(()=>{const s=Nn(e);return Ai(s,1)})}}B9.className="GlobalAveragePooling1D";_t(B9);class k9 extends O9{constructor(e){super(e||{})}call(e,t){return Le(()=>{const s=Nn(e);return Al(s,1)})}}k9.className="GlobalMaxPooling1D";_t(k9);class L9 extends ns{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ki(this.dataFormat),this.inputSpec=[new ya({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new qn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class F9 extends L9{call(e,t){return Le(()=>{const s=Nn(e);return this.dataFormat==="channelsLast"?Ai(s,[1,2]):Ai(s,[2,3])})}}F9.className="GlobalAveragePooling2D";_t(F9);class U9 extends L9{call(e,t){return Le(()=>{const s=Nn(e);return this.dataFormat==="channelsLast"?Al(s,[1,2]):Al(s,[2,3])})}}U9.className="GlobalMaxPooling2D";_t(U9);class P9 extends ns{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const i=t.layer,a=dd(i,s);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class z9 extends P9{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Rs(e),e.length<3)throw new Me(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Rs(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),i=e[1];return[s[0],i].concat(s.slice(1))}call(e,t){return Le(()=>(e=Nn(e),K6((r,o)=>[Nn(this.layer.call(r,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}z9.className="TimeDistributed";_t(z9);function bve(n){kg($xe,"BidirectionalMergeMode",n)}const Sve="concat";class $9 extends P9{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=dd(s),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=dd(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Sve:e.mergeMode,bve(this.mergeMode),e.weights)throw new qn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,i,a;return this.returnState&&(a=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(a).concat(a.slice()):[s].concat(a).concat(a.slice()):vo(i)}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const a=q6(e,s,i,this.numConstants);if(e=a.inputs,s=a.initialState,i=a.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&i==null)return super.apply(e,t);const r=[],o=[];if(s!=null){const c=s.length;if(c%2>0)throw new Me("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,r.push(...s);const h=s.map(d=>new ya({shape:d.shape}));this.forwardLayer.stateSpec=h.slice(0,c/2),this.backwardLayer.stateSpec=h.slice(c/2),o.push(...h)}if(i!=null)throw new qn("Support for constants in Bidirectional layers is not implemented yet.");const l=r[0]instanceof hh;for(const c of r)if(c instanceof hh!==l)throw new Me("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(r),h=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=h;const p=super.apply(c,t);return this.inputSpec=d,p}else return super.apply(e,t)}call(e,t){return Le(()=>{const s=t.initialState;let i,a;if(s==null)i=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let r;this.returnState&&(Array.isArray(i)&&(r=i.slice(1).concat(a.slice(1))),i=i[0],a=a[0]),this.returnSequences&&(a=Cl(a,1));let o;return this.mergeMode==="concat"?o=lL([i,a]):this.mergeMode==="sum"?o=bt(i,a):this.mergeMode==="ave"?o=we(.5,bt(i,a)):this.mergeMode==="mul"?o=we(i,a):this.mergeMode==null&&(o=[i,a]),this.returnState?this.mergeMode==null?o.concat(r):[o].concat(r):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Jm(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Jm(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const a=this.forwardLayer.states.map(r=>null);return Array.isArray(s)?s.concat(a).concat(a):[s].concat(a).concat(a)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=dd(t.layer);if(delete t.layer,t.numConstants!=null)throw new qn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=s,new e(i)}}$9.className="Bidirectional";_t($9);class G9 extends ns{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Le(()=>(e=Nn(e),e.dtype!=="float32"&&(e=nh(e,"float32")),bt(we(e,this.scale),this.offset)))}}G9.className="Rescaling";_t(G9);const{resizeBilinear:_ve,cropAndResize:Ave}=qc;class V9 extends ns{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,i,a,r,o,l){return Le(()=>{let c,h=!1;const d=t/r,p=s/o,g=(i+t)/r,v=(a+s)/o,_=[d,p,g,v],S=[];e.rank===3?(h=!0,c=Ro([e])):c=e;for(let R=0;R<c.shape[0];R++)S.push(_);const b=rc(S,[S.length,4]),w=gg(0,S.length,1,"int32"),E=Ave(c,b,w,[i,a],"nearest");return nh(h?Nn(Tl(E)):E,l)})}upsize(e,t,s,i){return Le(()=>{const a=_ve(e,[t,s]);return nh(a,i)})}call(e,t){return Le(()=>{const s=Nn(e),i=s.dtype,a=s.shape,r=a[a.length-3],o=a[a.length-2];let l=0;r!==this.height&&(l=Math.floor((r-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,r,o,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Rs(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}V9.className="CenterCrop";_t(V9);function wve(n,e,t,s){let i=Nn(n);if(i.dtype!=="int32"&&(i=nh(i,"int32")),e==="int")return i;const a=i.shape;if(i.rank===0&&(i=gr(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=gr(i,-1)),i.rank>2)throw new Me(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${i.rank}.`);const r=["multiHot","oneHot"].includes(e),o=i;let l;if(typeof s<"u"&&e==="count"?l=EE(o,s,t,r):l=EE(o,[],t,r),e!=="tfIdf")return l;if(s)return we(l,s);throw new Me("When outputMode is 'tfIdf', weights must be provided.")}class H9 extends ns{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Rs(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Le(()=>{e=Nn(e),e.dtype!=="int32"&&(e=nh(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new Me(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Nn(t.countWeights)}const i=Al(e),a=Xx(e),r=Do(this.numTokens,i).bufferSync().get(0),o=Td(a,0).bufferSync().get(0);if(!(r&&o))throw new Me(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return wve(e,this.outputMode,this.numTokens,s)})}}H9.className="CategoryEncoding";_t(H9);const Cve=["bilinear","nearest"],g$=new Set(Cve);class W9 extends ns{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(g$.has(e.interpolation))this.interpolation=e.interpolation;else throw new Me(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Rs(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Le(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return qc.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return qc.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...g$]} are supported`)})}}W9.className="Resizing";_t(W9);class j9{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}j9.className="RandomSeed";class X9 extends ns{constructor(e){super(e),this.randomGenerator=new j9(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}X9.className="BaseRandomLayer";const Tve=["bilinear","nearest"],x$=new Set(Tve);class q9 extends X9{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Me(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Me(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Me(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(x$.has(s))this.interpolation=s;else throw new Me(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Rs(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return Le(()=>{const s=Nn(e);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=up([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*i;a=Math.round(a);const r=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return qc.resizeBilinear(e,r);case"nearest":return qc.resizeNearestNeighbor(e,r);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...x$]} are supported`)}})}}q9.className="RandomWidth";_t(q9);var y$;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(y$||(y$={}));function rn(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&ee(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const Eve=yN;class VN extends k2{nextDataId(){return VN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new eB(this,Vc())}write(e,t,s){this.firstUse&&(this.firstUse=!1,Pe().get("IS_NODE")&&gl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&Ku(s[0])){const a=s.map(r=>Qu(r));i=this.write(a,e,t)}else i=this.write(s,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,i,a){this.data.set(e,{values:t,dtype:i,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const i=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return vd(i,a)}return iH(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>gd(i));return Hn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Hn(e.shape,e.dtype,t)}makeOutput(e,t,s){return Vc().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=zr();return e(),{kernelMs:zr()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){rn([e],"where");const t=this.readSync(e.dataId);return Eve(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}VN.nextDataId=0;function K9(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const Mve=n=>{const{x:e}=n.inputs,t=n.backend;rn(e,"abs");let s=new Float32Array(qe(e.shape));const i=t.data.get(e.dataId).values;return s=K9(i),t.makeOutput(s,e.shape,e.dtype)},Nve={kernelName:GS,backendName:"cpu",kernelFunc:Mve};function Yi(n){return(e,t,s,i,a)=>{const r=kn(e,t),o=r.length,l=gn(r),c=qe(r),h=ka(a,c),d=e.length,p=t.length,g=gn(e),v=gn(t),_=pg(e,r),S=pg(t,r);if(_.length+S.length===0)for(let b=0;b<h.length;++b)h[b]=n(s[b%s.length],i[b%i.length]);else for(let b=0;b<h.length;++b){const w=Ng(b,o,l),T=w.slice(-d);_.forEach(F=>T[F]=0);const E=Kc(T,d,g),R=w.slice(-p);S.forEach(F=>R[F]=0);const D=Kc(R,p,v);h[b]=n(s[E],i[D])}return[h,r]}}function Ko(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,a=t.data.get(s.dataId).values,r=t.data.get(i.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(o.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",a),imag:t.makeTensorInfo(i.shape,"float32",r)},o}const Rve={kernelName:H2,backendName:"cpu",kernelFunc:Ko};function zE(n,e,t="float32"){if(t==="complex64"){const i=zE(n,e,"float32"),a=zE(n,e,"float32");return Ko({inputs:{real:i,imag:a},backend:n})}const s=tr(qe(e),t);return n.makeTensorInfo(e,t,s)}function dh(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Ive={kernelName:Uy,backendName:"cpu",kernelFunc:dh};function bg(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.real,a=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,a)}const Dve={kernelName:AM,backendName:"cpu",kernelFunc:bg};function Y9(n,e,t,s){if(s==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(s==="bool"){const i=ap([0],t),[a,r]=Yi((o,l)=>o!==l?1:0)(e,[],n,i,"bool");return[r,"bool",a]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Qf(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:a}=s;if(a==="complex64"){if(i.dtype==="complex64")return dh({inputs:{x:i},backend:t});const h=zE(t,i.shape,i.dtype),d=Qf({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),p=Ko({inputs:{real:d,imag:h},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),p}if(i.dtype==="complex64"){const h=bg({inputs:{input:i},backend:t}),d=Qf({inputs:{x:h},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(h),d}if(!sB(i.dtype,a)){const h=dh({inputs:{x:i},backend:t});return{dataId:h.dataId,shape:h.shape,dtype:a}}const r=t.data.get(i.dataId).values,[o,l,c]=Y9(r,i.shape,i.dtype,a);return t.makeTensorInfo(o,l,c)}const Ove={kernelName:Cy,backendName:"cpu",kernelFunc:Qf};function Sa(n,e,t,s){return t==null?({inputs:i,backend:a})=>{const{a:r,b:o}=i,l=a;rn([r,o],n);const c=l.data.get(r.dataId).values,h=l.data.get(o.dataId).values,d=r.dtype==="string"?bd(c):c,p=r.dtype==="string"?bd(h):h,g=s||r.dtype,[v,_]=e(r.shape,o.shape,d,p,g);return l.makeTensorInfo(_,g,v)}:({inputs:i,backend:a})=>{const{a:r,b:o}=i,l=a;if(r.dtype==="complex64"||o.dtype==="complex64"){const c=Qf({inputs:{x:r},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,g=l.data.get(d.dataId).values,v=l.data.get(p.dataId).values,_=Qf({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),S=l.data.get(_.dataId),b=S.complexTensorInfos.real,w=S.complexTensorInfos.imag,T=l.data.get(b.dataId).values,E=l.data.get(w.dataId).values,[R,D,F]=t(r.shape,o.shape,g,v,T,E),U=l.makeTensorInfo(F,"float32",R),O=l.makeTensorInfo(F,"float32",D),B=Ko({inputs:{real:U,imag:O},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(U),l.disposeIntermediateTensorInfo(O),B}else{const c=l.data.get(r.dataId).values,h=l.data.get(o.dataId).values,d=s||r.dtype,[p,g]=e(r.shape,o.shape,c,h,d);return l.makeTensorInfo(g,d,p)}}}function EL(n){return(e,t,s,i,a,r)=>{const o=kn(e,t),l=qe(o),c=o.length,h=gn(o),d=ka("float32",l),p=ka("float32",l),g=pg(e,o),v=pg(t,o),_=vd(s,i),S=vd(a,r),b=e.length,w=gn(e),T=t.length,E=gn(t);if(g.length+v.length===0)for(let R=0;R<d.length;R++){const D=R%_.length,F=R%S.length,U=n(_[D*2],_[D*2+1],S[F*2],S[F*2+1]);d[R]=U.real,p[R]=U.imag}else for(let R=0;R<d.length;R++){const D=Ng(R,c,h),F=D.slice(-b);g.forEach(H=>F[H]=0);const U=Kc(F,b,w),O=D.slice(-T);v.forEach(H=>O[H]=0);const B=Kc(O,T,E),L=n(_[U*2],_[U*2+1],S[B*2],S[B*2+1]);d[R]=L.real,p[R]=L.imag}return[d,p,o]}}const J9=Yi(((n,e)=>n+e)),Bve=EL(((n,e,t,s)=>({real:n+t,imag:e+s}))),ey=Sa(Rg,J9,Bve),kve={kernelName:Rg,backendName:"cpu",kernelFunc:ey};function ML(n,e,t,s,i){const a=qe(s),r=tr(i,t);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(a>0?r[l]+=e[o]:r[l]+=1)}return r}function Z9(n,e,t,s=!1){const i=n.shape[0],a=n.shape[1],r=Hn([i,t],e.dtype);for(let o=0;o<i;o++)for(let l=0;l<a;l++){const c=n.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?r.set(1,o,c):e.size>0?r.set(r.get(o,c)+e.get(o,l),o,c):r.set(r.get(o,c)+1,o,c))}return r}const Q9=Yi(((n,e)=>n&e)),Lve=Sa(YS,Q9),Fve={kernelName:YS,backendName:"cpu",kernelFunc:Lve};function gh(n){return(e,t,s)=>{const i=Ui(t,e.length);for(let a=0;a<e.length;++a)i[a]=n(e[a],s);return i}}function Hs(n,e,t){const s=gh(e);return pp(n,s,t)}function pp(n,e,t){return({inputs:s,attrs:i,backend:a})=>{const{x:r}=s;rn(r,n);const o=a,l=o.data.get(r.dataId).values;let c;if(r.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=bd(l)}else c=l;const h=t||r.dtype,d=e(c,h,i);return o.makeTensorInfo(r.shape,h,d)}}const eW=gh(n=>Math.ceil(n)),Uve=pp(Ty,eW),Pve={kernelName:Ty,backendName:"cpu",kernelFunc:Uve};function tW(n,e,t,s){const i=Ui(t,qe(e));if(s&&t!=="string"){let a=0;n.forEach(r=>{const o=qe(r.shape);i.set(r.vals,a),a+=o})}else{let a=0;n.forEach(r=>{const o=t==="string"?bd(r.vals):r.vals;let l=0;for(let c=0;c<r.shape[0];++c){const h=c*e[1]+a;for(let d=0;d<r.shape[1];++d)i[h+d]=o[l++]}a+=r.shape[1]})}return i}const nW=Yi((n,e)=>n===e?1:0),sW=Sa(a_,nW,null,"bool"),zve={kernelName:a_,backendName:"cpu",kernelFunc:sW};const iW=gh(n=>Math.exp(n)),aW=pp(Oy,iW,"float32"),$ve={kernelName:Oy,backendName:"cpu",kernelFunc:aW};const rW=gh(n=>Math.expm1(n)),Gve=pp(By,rW),Vve={kernelName:By,backendName:"cpu",kernelFunc:Gve};const oW=gh(n=>Math.floor(n)),Hve=pp(ky,oW),Wve={kernelName:ky,backendName:"cpu",kernelFunc:Hve};const lW=Yi((n,e)=>Math.floor(n/e)),jve=Sa(Ly,lW,null,"int32"),Xve={kernelName:Ly,backendName:"cpu",kernelFunc:jve};function cW(n,e,t,s,i,a,r,o,l){const c=Hn([s,a],t);for(let h=0;h<s;h++){const d=[];let p=0;for(let g=0;g<i;g++){const v=n[h*i+g];p+=v*r[g],d.push(v)}if(p<0||p>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let g=0;g<a;g++)c.values[h*a+g]=e.get(...e.indexToLoc(p*a+g))}return c}function uW(n,e,t){const s=Hn(t,n.dtype);for(let i=0;i<s.size;++i){const r=s.indexToLoc(i).slice(),o=r[0],l=r[2],c=e.locToIndex([o,l]);r[2]=e.values[c];const h=n.locToIndex(r);0<=h&&h<n.values.length&&(s.values[i]=n.values[h])}return s}const hW=Yi((n,e)=>n>e?1:0),qve=Sa(c_,hW,null,"bool"),Kve={kernelName:c_,backendName:"cpu",kernelFunc:qve};const dW=Yi((n,e)=>n>=e?1:0),Yve=Sa(Fy,dW,null,"bool"),Jve={kernelName:Fy,backendName:"cpu",kernelFunc:Yve};const fW=Yi((n,e)=>n<e?1:0),Zve=Sa(h_,fW,null,"bool"),Qve={kernelName:h_,backendName:"cpu",kernelFunc:Zve};const pW=Yi((n,e)=>n<=e?1:0),ebe=Sa(d_,pW,null,"bool"),tbe={kernelName:d_,backendName:"cpu",kernelFunc:ebe};function mW(n,e,t){const s=(e-n)/(t-1),i=tr(t,"float32");i[0]=n;for(let a=1;a<i.length;a++)i[a]=i[a-1]+s;return i}const gW=gh(n=>Math.log(n)),nbe=pp(Gy,gW),sbe={kernelName:Gy,backendName:"cpu",kernelFunc:nbe};function xW(n,e,t,s){const i=ka(s,qe(t));for(let a=0;a<i.length;++a){const r=a*e;let o=n[r];for(let l=0;l<e;++l){const c=n[r+l];(Number.isNaN(c)||c>o)&&(o=c)}i[a]=o}return i}const yW=Yi(((n,e)=>Math.max(n,e))),ibe=Sa(Hy,yW),abe={kernelName:Hy,backendName:"cpu",kernelFunc:ibe};const vW=Yi(((n,e)=>Math.min(n,e))),rbe=Sa(Wy,vW),obe={kernelName:Wy,backendName:"cpu",kernelFunc:rbe};const NL=Yi(((n,e)=>n*e)),lbe=EL(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),HN=Sa(Xy,NL,lbe),cbe={kernelName:Xy,backendName:"cpu",kernelFunc:HN};function bW(n,e,t){const s=Ad(-1,t);return NL([],e,s,n,t)}function ube(n){const{inputs:e,backend:t}=n,{x:s}=e;rn(s,"neg");const i=t.data.get(s.dataId).values,[a,r]=bW(i,s.shape,s.dtype);return t.makeTensorInfo(r,s.dtype,a)}const hbe={kernelName:A_,backendName:"cpu",kernelFunc:ube};const SW=Yi(((n,e)=>n!==e?1:0)),dbe=Sa(w_,SW,null,"bool"),fbe={kernelName:w_,backendName:"cpu",kernelFunc:dbe};function RL(n,e,t,s,i){const a=e.length,r=qe(e),o=gn(e),l=gn(i),c=ka(t,qe(i));for(let h=0;h<r;++h){const d=Ng(h,a,o),p=new Array(d.length);for(let v=0;v<p.length;v++)p[v]=d[s[v]];const g=Kc(p,a,l);c[g]=n[h]}return c}function Io(n){const{inputs:e,attrs:t,backend:s}=n,{x:i}=e,{perm:a}=t;rn(i,"transpose");const r=i.shape.length,o=new Array(r);for(let d=0;d<o.length;d++)o[d]=i.shape[a[d]];const l=s.data.get(i.dataId).values,c=RL(l,i.shape,i.dtype,a,o);return{dataId:s.write(c,o,i.dtype),shape:o,dtype:i.dtype}}const pbe={kernelName:Km,backendName:"cpu",kernelFunc:Io};function _W(n,e,t,s){const[i,a]=Ua(n,s),r=To(e,"int32"),o=tr(qe(i),r),l=qe(a);for(let c=0;c<o.length;++c){const h=c*l;let d=1;for(let p=0;p<l;++p)d*=t[h+p];o[c]=d}return{outVals:o,outShape:i,outDtype:r}}function mbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s;rn(i,"prod");const o=i.shape.length,l=es(a,i.shape),c=Mi(l,o);let h=l,d=i;const p=[];c!=null&&(d=Io({inputs:{x:i},backend:t,attrs:{perm:c}}),p.push(d),h=qi(h.length,o));const g=t.data.get(d.dataId).values,{outVals:v,outShape:_,outDtype:S}=_W(d.shape,d.dtype,g,h);let b=_;return r&&(b=Xi(_,l)),p.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(b,S,v)}const gbe={kernelName:R_,backendName:"cpu",kernelFunc:mbe};function xbe(n,e,t){n.forEach((s,i)=>{if(s<0||s>=t){const a=Ng(i,e.length,gn(e)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${t})`)}})}function ybe(n,e){for(let t=0;t<n.length;++t){const s=n[t],i=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function vbe(n,e,t,s){const i=[];let a=0;const r=e.length-1+t.length,o=new Array(r).fill(null).map(()=>[0]);ybe(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const h=e[c+1];for(let d=1;d<l+1;++d)o[c].push(d*h)}for(let c=0;c<n.length;++c){let h=n[c],d=n[c]+1;for(let p=0;p<t.length;++p){const g=t[p],v=p+e.length-1;if(v>=0){const _=o[v],S=_[_.length-1]-g[h];for(let b=h;b<d;++b)o[v].push(g[b+1]+S)}h=g[h],d=g[d]}d!==h&&(i.push([h,d]),a+=d-h)}return{outSplits:o,valueSlices:i,numValues:a}}function bbe(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,i=Ui("int32",s);e.push(i),n[t].forEach((a,r)=>i[r]=a)}return e}function v$(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function Sbe(n,e,t,s,i,a){const r=v$(e,2)[1],o=v$(a,2)[1];let l=0;for(const c of t)for(let h=c[0];h<c[1];++h){for(let d=0;d<s;++d)i[l*o+d]=n[h*r+d];++l}}function _be(n,e,t,s,i){const a=e.slice();a[0]=i;const r=Ui(t,qe(a)),o=n.length,l=o===0?0:o/e[0];return Sbe(n,e,s,l,r,a),[r,a]}function AW(n,e,t,s,i,a,r,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(xbe(a,r,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:h,valueSlices:d,numValues:p}=vbe(a,r,n,c),g=bbe(h),v=_be(t,s,i,d,p);return[g,v[0],v[1]]}const b$=2147483647;function wW(n,e,t,s,i,a,r){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(r.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=i.length===0,c=r.length===0,h=[];o||h.push(e[0]),l||h.push(i[0]),c||h.push(r[0]);for(let S=1;S<h.length;++S)if(h[S]!==h[S-1])throw new Error("starts, limits, and deltas must have the same shape");const d=h.length===0?1:h[0],p=Ui("int32",d+1);p[0]=0;for(let S=0;S<d;++S){const b=o?n[0]:n[S],w=l?s[0]:s[S],T=c?a[0]:a[S];if(T===0)throw new Error("Requires delta != 0");let E;if(T>0&&w<b||T<0&&w>b)E=0;else if(E=Math.ceil(Math.abs((w-b)/T)),E>b$)throw new Error(`Requires ((limit - start) / delta) <= ${b$}`);p[S+1]=p[S]+E}const g=p[d],v=Ui(t,g);let _=0;for(let S=0;S<d;++S){const b=p[S+1]-p[S];let w=o?n[0]:n[S];const T=c?a[0]:a[S];for(let E=0;E<b;++E)v[_++]=w,w+=T}return[p,v]}var Kl=jc;class $E{constructor(e,t,s,i,a,r,o,l,c,h){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=i,this.valuesDType=a,this.defaultValue=r,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=a8(h),this.raggedRank=r8(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Kl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Kl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Kl.VALUE_ROWIDS:return $E.getMaxWidthValueRowID(t);case Kl.ROW_SPLITS:return $E.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Kl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let i=0;i<t-1;++i){const a=e[i+1]-e[i];a>s&&(s=a)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,i=e[0],a=0;for(let r=1;r<t;++r){const o=e[r];o!==i&&(i=o,a=Math.max(r-s,a),s=r)}return Math.max(t-s,a)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return _$(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;o8(s,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=i8(this.raggedRank,i,t);r[0]<0&&(r[0]=e);for(let o=1;o<=this.raggedRank;++o)r[o]<0&&(r[o]=this.getMaxWidth(o));return r}calculateFirstParentOutputIndex(e,t,s){const i=Math.min(e,s),a=[];let r=0;for(let o=0;o<i;++o,r+=t)a.push(r);for(let o=i;o<e;++o)a.push(-1);return ee(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,s,i){const a=e.length,r=[];for(let o=0;o<a-1;++o){const l=e[o+1]-e[o];let c=Math.min(i,l),h=t[o];h===-1&&(c=0);for(let d=0;d<c;++d)r.push(h),h+=s;for(let d=0;d<l-c;++d)r.push(-1)}if(a>0&&r.length!==e[a-1])throw new Error("Invalid row split size.");return r}calculateOutputIndexValueRowID(e,t,s,i){const a=e.length,r=[];if(a===0)return[];let o=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];r.push(c);for(let h=1;h<a;++h){const d=e[h];if(d===l)c>=0&&(++o,o<i?c+=s:c=-1);else{if(o=0,l=d,d>=t.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${t.length}`);c=t[d]}r.push(c)}if(r.length!==e.length)throw new Error("Invalid row ids.");return r}calculateOutputIndex(e,t,s,i){const a=this.getRowPartitionTensor(e),r=this.getRowPartitionTypeByDimension(e);switch(r){case Kl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,s,i);case Kl.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,s,i);default:throw new Error(`Unsupported partition type: ${Kl[r]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Kl.FIRST_DIM_SIZE:return e[0];case Kl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Kl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Kl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*s[l+1];const a=_$(s,!1),r=Ui(this.valuesDType,qe(a));if(i[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,i[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],s[c]);this.setOutput(this.raggedRank,l,r,a)}return[a,r]}setOutput(e,t,s,i){if(s.length===0)return;const a=this.values,r=s;let o=i.slice();o=o.slice(e+1);const l=qe(o),c=t.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const v=this.defaultValueShape;Le(()=>{const _=Ee(h,v);h=Ym(_,o).dataSync()})}let d=0,p=0,g=0;for(let v=0;v<=c;++v){let _=v<c?t[v]:-1;if(_===g){++g;continue}if(p<g){const S=a.subarray(d*l),b=r.subarray(p*l),w=(g-p)*l;S$(b,S,w)}if(v>=c){const S=s.length;_=Math.floor(S/l)}if(_>g)if(this.defaultValue.length===1)r.subarray(g*l,_*l).fill(this.defaultValue[0]),g=_;else for(;_>g;){const S=r.slice(g*l);S$(S,h,l),++g}_<0?(d=v+1,p=g):(d=v,p=g,g=p+1)}}}function S$(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function _$(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function CW(n,e,t,s,i,a,r,o,l,c){return new $E(n,e,t,s,i,a,r,o,l,c).compute()}function TW(n,e,t,s){const i=n===e,a=n<e&&t<0,r=e<n&&t>1;if(i||a||r)return tr(0,s);const o=Math.abs(Math.ceil((e-n)/t)),l=tr(o,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}const EW=gh(n=>1/Math.sqrt(n)),Abe=pp(Qy,EW),wbe={kernelName:Qy,backendName:"cpu",kernelFunc:Abe};function Hm(n,e,t,s,i,a,r,o,l,c){const h=[s/i,i],d=n.values,p=e.values;if(s===0)return Hn(t,e.dtype);const g=l instanceof oa?l:Hn(h,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let v=0;v<a;v++){const _=[];let S=0;for(let b=0;b<r;b++){const w=d[v*r+b];_.push(w),S+=w*o[b]}if(S<0||S>=s/i)throw new Error(`Invalid indices: ${_} does not index into ${t}`);for(let b=0;b<i;b++)c?g.values[S*i+b]+=p[v*i+b]:g.values[S*i+b]=e.rank===0?p[0]:p[v*i+b]}return g}const Cbe=gh(n=>1/(1+Math.exp(-n))),MW=Hs(iv,n=>1/(1+Math.exp(-n))),Tbe={kernelName:iv,backendName:"cpu",kernelFunc:MW};function NW(n,e,t,s,i){const a=Ok(s,e,t),r=qe(t),o=gn(s);if(a){const d=Bk(e,o);return i==="string"?n.slice(d,d+r):n.subarray(d,d+r)}const l=i==="string"?bd(n):n,c=Hn(s,i,l),h=Hn(t,i);for(let d=0;d<h.size;++d){const p=h.indexToLoc(d),g=p.map((v,_)=>v+e[_]);h.set(c.get(...g),...p)}return i==="string"?E8(h.values):h.values}function Sg(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:a,size:r}=s;rn(i,"slice");const[o,l]=NN(i,a,r);Ik(i,o,l);const c=t.data.get(i.dataId).values,h=NW(c,o,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,h)}const Ebe={kernelName:L_,backendName:"cpu",kernelFunc:Sg};function RW(n,e,t,s,i,a,r){const o=e[0],l=a[0],c=new Array(l),h=new Array(o),d=e[1];if(l===0){if(o!==0)throw new Error(p8(o));const S=Ui(t,0),b=Ui(i,0);return[S,[0,d],b,c,h]}let p=!0,g=0;const v=new Array(l).fill(0);for(let S=0;S<o;++S){const b=n[S*d];if(b<0)throw new Error(m8(S,b));if(b>=l)throw new Error(g8(S,b,l));++v[b],p=p&&b>=g,g=b}let _=!0;for(let S=0;S<l;++S){const b=v[S]===0;c[S]=b,_=_&&!b,v[S]=Math.max(v[S],1),S>0&&(v[S]+=v[S-1])}if(_&&p){const S=n,b=s;for(let w=0;w<o;++w)h[w]=w;return[S,[o,d],b,c,h]}else{const S=v[l-1],b=Ui(t,S*d),w=Ui(i,S),T=new Array(l).fill(0);for(let E=0;E<o;++E){const R=n[E*d],D=T[R],F=(R===0?0:v[R-1])+D;T[R]++;for(let U=0;U<d;++U)b[F*d+U]=n[E*d+U];w[F]=s[E],h[E]=F}for(let E=0;E<l;++E)if(T[E]===0){const D=E===0?0:v[E-1];b[D*d+0]=E;for(let F=1;F<d;++F)b[D*d+F]=0;w[D]=r}return[b,[S,d],w,c,h]}}function IW(n,e,t,s,i){const a=qe(s),r=e[0],o=i.length,l=[];let c=1,h=-1;for(let S=0;S<o;++S){const b=i[S];if(b===-1){if(h!==-1)throw new Error(x8(h,S));h=S,l.push(1)}else{if(b<0)throw new Error(y8(S,b));c*=b,l.push(b)}}if(h!==-1){if(c<=0)throw new Error(v8());const S=Math.trunc(a/c);if(c*S!==a)throw new Error(b8(s,l));l[h]=S}if(qe(l)!==a)throw new Error(S8(s,l));const p=s.length,g=[];if(p>0){g[p-1]=1;for(let S=p-2;S>=0;--S)g[S]=g[S+1]*s[S+1]}const v=[];if(o>0){v[o-1]=1;for(let S=o-2;S>=0;--S)v[S]=v[S+1]*l[S+1]}const _=Ui(t,r*o);for(let S=0;S<r;++S){let b=0;for(let w=0;w<p;++w)b+=n[S*p+w]*g[w];for(let w=0;w<o;++w)_[S*o+w]=Math.trunc(b/v[w]),b%=v[w]}return[_,[r,o],l]}function IL(n,e,t,s,i,a=!1,r=0){const o=s.length,l=[e[0],n.length/e[0]],c=l[1],d=o>0?i[o-1]+1:0;if(d<0)throw new Error(mD());const p=e.slice();p[0]=d;const g=p.reduce((T,E)=>T*E,1),v=Ui(t,g);if(o===0)return d>0&&v.fill(r),[v,p];if(d<=0)throw new Error(mD());let _=0,S=1,b=0,w=i[_];for(;;){let T=0;if(S<o){if(T=i[S],w===T){++S;continue}if(w>=T)throw new Error(_8())}if(w<0||w>=d)throw new Error(A8(w,d));w>b&&v.fill(r,b*c,w*c);for(let E=_;E<S;++E){const R=s[E];if(R<0||R>=l[0])throw new Error(w8(E,s[E],l[0]));for(let D=0;D<c;D++)v[w*c+D]+=n[R*c+D]}if(a)for(let E=0;E<c;E++)v[w*c+E]/=S-_;if(_=S,++S,b=w+1,w=T,S>o)break}return b<d&&v.fill(r,b*c,d*c),[v,p]}const Mbe=gh(n=>Math.sqrt(n)),Nbe=Hs(rv,n=>Math.sqrt(n)),Rbe={kernelName:rv,backendName:"cpu",kernelFunc:Nbe};const DW=Yi(((n,e)=>{const t=n-e;return t*t})),Ibe=Sa(ov,DW),Dbe={kernelName:ov,backendName:"cpu",kernelFunc:Ibe};const OW=gh((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:i}=e;return n.replace(new RegExp(t,s?"g":""),i)}),Obe=pp($_,OW),Bbe={kernelName:$_,backendName:"cpu",kernelFunc:Obe};function BW(n,e,t,s){const i=Hn(n,e.dtype);for(let a=0;a<i.size;a++){const r=i.indexToLoc(a),o=new Array(r.length);for(let l=0;l<o.length;l++)o[l]=r[l]*t[l]+s[l];i.set(e.get(...o),...r)}return i}class kbe{constructor(e,t,s,i,a,r){this.separator=Qu(e),this.nGramWidths=t,this.leftPad=Qu(s),this.rightPad=Qu(i),this.padWidth=a,this.preserveShort=r}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,i,a,r){for(let o=0;o<a;++o){const l=this.getPadWidth(r),c=Math.max(0,l-o),h=Math.max(0,l-(a-(o+1))),d=r-(c+h),p=t+(c>0?0:o-l);let g=0;g+=c*this.leftPad.length;for(let w=0;w<d;++w)g+=e[p+w].length;g+=h*this.rightPad.length;const v=c+h+d-1;g+=v*this.separator.length,s[i+o]=new Uint8Array(g);const _=s[i+o];let S=0;const b=w=>w.forEach(T=>_[S++]=T);for(let w=0;w<c;++w)b(this.leftPad),b(this.separator);for(let w=0;w<d-1;++w)b(e[p+w]),b(this.separator);if(d>0){b(e[p+d-1]);for(let w=0;w<h;++w)b(this.separator),b(this.rightPad)}else{for(let w=0;w<h-1;++w)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const s=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let h=t[c]>=l;if(h=h&&t[c]<=s,!h)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const a=i-1,r=Ui("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=a;++c)r[c]=0;return[l,r]}r[0]=0;for(let l=1;l<=a;++l){const c=t[l]-t[l-1];let h=0;this.nGramWidths.forEach(d=>{h+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&h===0&&(h=1),r[l]=r[l-1]+h}const o=new Array(r[a]);for(let l=0;l<a;++l){const c=t[l];let h=r[l];if(this.nGramWidths.forEach(d=>{const p=t[l+1]-t[l],g=this.getNumNGrams(p,d);this.createNGrams(e,c,o,h,g,d),h+=g}),this.preserveShort&&h===r[l]){const d=t[l+1]-t[l];if(d===0)continue;const p=d+2*this.padWidth;this.createNGrams(e,c,o,h,1,p)}}return[o,r]}}function kW(n,e,t,s,i,a,r,o){return new kbe(t,s,i,a,r,o).compute(n,e)}function Lbe(n,e,t,s){if(!n.length)return;if(e.length===0){for(let a=0;a<n.length;++a)s.push(n.subarray(a,a+1));return}if(e.length===1){const a=e[0];let r=n.indexOf(a);for(;r!==-1;){const o=n.subarray(0,r);(!t||o.length!==0)&&s.push(o),n=n.subarray(r+1),r=n.indexOf(a)}(!t||n.length!==0)&&s.push(n);return}let i=0;for(let a=0;a<n.length+1;a++)if(a===n.length||e.indexOf(n[a])!==-1){const r=n.subarray(i,a);(!t||r.length!==0)&&s.push(r),i=a+1}}function LW(n,e,t){const s=n.length,i=[];let a=0,r=0;const o=new Array(s);for(let p=0;p<s;++p){const g=i.length;Lbe(n[p],e,t,i);const v=i.length-g;o[p]=v,a+=v,r=Math.max(r,v)}const l=Ui("int32",a*2),c=new Array(a),h=[s,r];let d=0;for(let p=0;p<s;++p)for(let g=0;g<o[p];++g)l[d*2]=p,l[d*2+1]=g,c[d]=i[d],++d;return[l,c,h]}function FW(n,e){const t=Ui("int32",n.length);for(let s=0;s<n.length;++s)t[s]=mH(n[s]).modulo(e).getLowBitsUnsigned();return t}const UW=Yi(((n,e)=>n-e)),Fbe=EL(((n,e,t,s)=>({real:n-t,imag:e-s}))),DL=Sa(lv,UW,Fbe),Ube={kernelName:lv,backendName:"cpu",kernelFunc:DL};function PW(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const s=Hn(t,n.dtype);for(let i=0;i<s.values.length;++i){const a=s.indexToLoc(i),r=new Array(n.rank);for(let l=0;l<r.length;l++)r[l]=a[l]%n.shape[l];const o=n.locToIndex(r);s.values[i]=n.values[o]}return s}const N1=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function zW(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,l=e-t+1,c=Math.log(o),h=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*h*(o-h)/o)*Math.sign(l-o/2),p=Math.max(t,Math.floor(e-l*h/o+d)),g=Math.min(s,Math.floor(e+(o-l)*h/o+d));zW(n,e,p,g)}const i=n[e];let a=t,r=s;for(rd(n,t,e),N1(n[s],i)>0&&rd(n,t,s);a<r;){for(rd(n,a,r),a++,r--;N1(n[a],i)<0;)a=a+1;for(;N1(n[r],i)>0;)r=r-1}N1(n[t],i)===0?rd(n,t,r):(r=r+1,rd(n,r,s)),r<=e&&(t=r+1),e<=r&&(s=r-1)}}function $W(n,e,t,s,i){const a=e[e.length-1],[r,o]=[n.length/a,a],l=ka(t,r*s),c=ka("int32",r*s);for(let d=0;d<r;d++){const p=d*o,g=n.subarray(p,p+o);let v=new Array(g.length);g.forEach((w,T)=>v[T]={value:w,index:T}),s<v.length&&(zW(v,s),v=v.slice(0,s)),i&&v.sort(N1);const _=d*s,S=l.subarray(_,_+s),b=c.subarray(_,_+s);for(let w=0;w<s;w++)S[w]=v[w].value,b[w]=v[w].index}const h=e.slice();return h[h.length-1]=s,[Hn(h,t,l),Hn(h,"int32",c)]}function GW(n,e,t,s){const i=es(e,t)[0],a=[1,t[0],1];for(let v=0;v<i;v++)a[0]*=t[v];a[1]=t[i];for(let v=i+1;v<t.length;v++)a[2]*=t[v];const r=new Map,o=new Int32Array(t[i]),l=new oa(a,s,n),c=[],h=a[0]===1&&a[2]===1;for(let v=0;v<t[i];v++){let _;if(h)_=n[v].toString();else{const b=[];for(let w=0;w<a[0];w++)for(let T=0;T<a[2];T++)b.push(l.get(w,v,T));_=b.join(",")}const S=r.get(_);if(S!=null)o[v]=S;else{const b=r.size;r.set(_,b),o[v]=b,c.push(v)}}const d=a.slice();d[1]=r.size;const p=new oa(d,s);c.forEach((v,_)=>{for(let S=0;S<a[0];S++)for(let b=0;b<a[2];b++)p.set(l.get(S,v,b),S,_,b)});const g=t.slice();return g[i]=d[1],{outputValues:p.values,outputShape:g,indices:o}}const Pbe=Object.freeze(Object.defineProperty({__proto__:null,addImpl:J9,bincountImpl:ML,bincountReduceImpl:Z9,bitwiseAndImpl:Q9,castImpl:Y9,ceilImpl:eW,concatImpl:tW,equalImpl:nW,expImpl:iW,expm1Impl:rW,floorDivImpl:lW,floorImpl:oW,gatherNdImpl:cW,gatherV2Impl:uW,greaterEqualImpl:dW,greaterImpl:hW,lessEqualImpl:pW,lessImpl:fW,linSpaceImpl:mW,logImpl:gW,maxImpl:xW,maximumImpl:yW,minimumImpl:vW,multiplyImpl:NL,negImpl:bW,notEqualImpl:SW,prodImpl:_W,raggedGatherImpl:AW,raggedRangeImpl:wW,raggedTensorToTensorImpl:CW,rangeImpl:TW,rsqrtImpl:EW,scatterImpl:Hm,sigmoidImpl:Cbe,simpleAbsImpl:K9,sliceImpl:NW,sparseFillEmptyRowsImpl:RW,sparseReshapeImpl:IW,sparseSegmentReductionImpl:IL,sqrtImpl:Mbe,squaredDifferenceImpl:DW,staticRegexReplaceImpl:OW,stridedSliceImpl:BW,stringNGramsImpl:kW,stringSplitImpl:LW,stringToHashBucketFastImpl:FW,subImpl:UW,tileImpl:PW,topKImpl:$W,transposeImpl:RL,uniqueImpl:GW},Symbol.toStringTag,{value:"Module"}));dB("cpu",()=>new VN,1);const VW=Hs(Iy,n=>n>=0?n:Math.exp(n)-1),zbe={kernelName:Iy,backendName:"cpu",kernelFunc:VW};function HW(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:a}=s;rn([i],"leakyRelu");const r=qe(i.shape),o=t.data.get(i.dataId).values,l=ka("float32",r);for(let c=0;c<o.length;c++)l[c]=o[c]<0?a*o[c]:o[c];return t.makeTensorInfo(i.shape,"float32",l)}const $be={kernelName:u_,backendName:"cpu",kernelFunc:HW};const Gbe=Yi((n,e)=>n<0?e*n:n);function WW(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e;rn([s,i],"prelu");const a=t.data.get(s.dataId).values,r=t.data.get(i.dataId).values,[o,l]=Gbe(s.shape,i.shape,a,r,"float32");return t.makeTensorInfo(l,"float32",o)}const Vbe={kernelName:N_,backendName:"cpu",kernelFunc:WW};const jW=Hs(Yy,n=>Math.max(0,n)),Hbe={kernelName:Yy,backendName:"cpu",kernelFunc:jW};const XW=Hs(Jy,n=>Math.min(Math.max(0,n),6)),Wbe={kernelName:Jy,backendName:"cpu",kernelFunc:XW};function GE(n,e,t,s,i){if(t==="linear")return dh({inputs:{x:e},backend:n});if(t==="relu")return jW({inputs:{x:e},backend:n});if(t==="elu")return VW({inputs:{x:e},backend:n});if(t==="relu6")return XW({inputs:{x:e},backend:n});if(t==="prelu")return WW({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return HW({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return MW({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function oi(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:a}=s,r=qe(i.shape),o=nB(a,r),l=qe(o);ee(r===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;h.shape=o,d.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const jbe={kernelName:I_,backendName:"cpu",kernelFunc:oi};function qW(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:a}=e,{transposeA:r,transposeB:o}=s;rn([i,a],"matMul");const l=i.shape.length,c=a.shape.length,h=r?i.shape[l-2]:i.shape[l-1],d=o?a.shape[c-1]:a.shape[c-2],p=r?i.shape[l-1]:i.shape[l-2],g=o?a.shape[c-2]:a.shape[c-1],v=i.shape.slice(0,-2),_=a.shape.slice(0,-2),S=qe(v),b=qe(_),T=kn(i.shape.slice(0,-2),a.shape.slice(0,-2)).concat([p,g]);ee(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${r} and transposeB=${o} must match.`);const E=r?[S,h,p]:[S,p,h],R=o?[b,g,d]:[b,d,g],D=oi({inputs:{x:i},backend:t,attrs:{shape:E}}),F=oi({inputs:{x:a},backend:t,attrs:{shape:R}}),U=r?D.shape[1]:D.shape[2],O=r?D.shape[2]:D.shape[1],B=o?F.shape[1]:F.shape[2],L=Math.max(S,b),H=t.data.get(D.dataId).values,K=t.data.get(F.dataId).values,Z=gn(D.shape),Q=gn(F.shape),[P,W,q]=r?[Z[0],1,Z[1]]:[Z[0],Z[1],1],[se,le,Y]=o?[1,Q[1],Q[0]]:[Q[1],1,Q[0]],re=O*B,he=Hn([L,O,B],D.dtype),me=he.values,Ne=t.blockSize;for(let fe=0;fe<L;fe++){const Te=fe%S,Ge=fe%b;for(let nt=0;nt<O;nt+=Ne){const yt=Math.min(nt+Ne,O);for(let Dt=0;Dt<B;Dt+=Ne){const qt=Math.min(Dt+Ne,B);for(let Bt=0;Bt<U;Bt+=Ne){const Je=Math.min(Bt+Ne,U);for(let oe=nt;oe<yt;oe++)for(let Ze=Dt;Ze<qt;Ze++){let it=0;for(let ft=Bt;ft<Je;ft++){const gt=H[Te*P+oe*W+ft*q],Tt=K[ft*se+Ze*le+Ge*Y];it+=gt*Tt}me[fe*re+(oe*B+Ze)]+=it}}}}}return t.disposeIntermediateTensorInfo(D),t.disposeIntermediateTensorInfo(F),t.makeTensorInfo(T,he.dtype,he.values)}const Xbe={kernelName:qS,backendName:"cpu",kernelFunc:qW};function qbe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:a,bias:r,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s;let p,g,v;const _=[];p=qW({inputs:{a:i,b:a},attrs:{transposeA:l,transposeB:c},backend:t}),r&&(g=ey({inputs:{a:p,b:r},backend:t}),_.push(p),p=g),h&&(v=GE(t,p,h,o,d),_.push(p),p=v);for(const b of _)t.disposeIntermediateTensorInfo(b);return p}const Kbe={kernelName:sS,backendName:"cpu",kernelFunc:qbe};const Ybe=Hs(yy,n=>Math.acos(n)),Jbe={kernelName:yy,backendName:"cpu",kernelFunc:Ybe};const Zbe=Hs(vy,n=>Math.acosh(n)),Qbe={kernelName:vy,backendName:"cpu",kernelFunc:Zbe};function e1e(n){const{inputs:e,backend:t}=n,s=e;rn(e,"addN");const i=s.map(o=>t.data.get(o.dataId).values),a=Hn(s[0].shape,s[0].dtype),r=a.values;for(let o=0;o<s.length;o++){const l=i[o];for(let c=0;c<r.length;c++)r[c]+=l[c]}return t.makeTensorInfo(a.shape,a.dtype,a.values)}const t1e={kernelName:VS,backendName:"cpu",kernelFunc:e1e};function n1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s;rn(i,"all");const o=es(a,i.shape);let l=o;const c=Mi(l,i.shape.length);let h=i;c!=null&&(h=Io({inputs:{x:i},backend:t,attrs:{perm:c}}),l=qi(l.length,i.shape.length)),ir("all",l,h.shape.length);const[d,p]=Ua(h.shape,l),g=qe(p),v=tr(qe(d),h.dtype),_=t.data.get(h.dataId).values;for(let b=0;b<v.length;++b){const w=b*g;let T=_[w];for(let E=0;E<g;++E){const R=_[w+E];T=T&&R}v[b]=T}c!=null&&t.disposeIntermediateTensorInfo(h);const S=t.makeTensorInfo(d,h.dtype,v);if(r){const b=Xi(d,o),w=oi({inputs:{x:S},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(S),w}return S}const s1e={kernelName:U2,backendName:"cpu",kernelFunc:n1e};function i1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s;rn(i,"any");const o=es(a,i.shape);let l=o;const c=Mi(l,i.shape.length);let h=i;c!=null&&(h=Io({inputs:{x:i},backend:t,attrs:{perm:c}}),l=qi(l.length,i.shape.length)),ir("any",l,h.shape.length);const[d,p]=Ua(h.shape,l),g=qe(p),v=tr(qe(d),h.dtype),_=t.data.get(h.dataId).values;for(let b=0;b<v.length;++b){const w=b*g;let T=_[w];for(let E=0;E<g;++E){const R=_[w+E];T=T||R}v[b]=T}c!=null&&t.disposeIntermediateTensorInfo(h);const S=t.makeTensorInfo(d,h.dtype,v);if(r){const b=Xi(d,o),w=oi({inputs:{x:S},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(S),w}return S}const a1e={kernelName:P2,backendName:"cpu",kernelFunc:i1e};function r1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a}=s;rn(i,"argMax");let r=es(a,i.shape);const o=Mi(r,i.shape.length);let l=i;const c=[];o!=null&&(l=Io({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),r=qi(r.length,l.shape.length)),r=[r[0]],ir("argMax",r,l.shape.length);const[h,d]=Ua(l.shape,r),p=qe(h),g=tr(p,"int32"),v=qe(d),_=t.data.get(l.dataId).values;for(let S=0;S<g.length;++S){const b=S*v;let w=_[b],T=0;for(let E=0;E<v;++E){const R=_[b+E];R>w&&(w=R,T=E)}g[S]=T}return c.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(h,"int32",g)}const o1e={kernelName:HS,backendName:"cpu",kernelFunc:r1e};function l1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a}=s;rn(i,"argMin");let r=es(a,i.shape);const o=Mi(r,i.shape.length);let l=i;const c=[];o!=null&&(l=Io({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),r=qi(r.length,l.shape.length)),r=[r[0]],ir("argMin",r,l.shape.length);const[h,d]=Ua(l.shape,r),p=qe(h),g=tr(p,"int32"),v=qe(d),_=t.data.get(l.dataId).values;for(let S=0;S<g.length;++S){const b=S*v;let w=_[b],T=0;for(let E=0;E<v;++E){const R=_[b+E];R<w&&(w=R,T=E)}g[S]=T}return c.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(h,"int32",g)}const c1e={kernelName:WS,backendName:"cpu",kernelFunc:l1e};const u1e=Hs(by,n=>Math.asin(n)),h1e={kernelName:by,backendName:"cpu",kernelFunc:u1e};const d1e=Hs(Sy,n=>Math.asinh(n)),f1e={kernelName:Sy,backendName:"cpu",kernelFunc:d1e};const p1e=Hs(_y,n=>Math.atan(n)),m1e={kernelName:_y,backendName:"cpu",kernelFunc:p1e};const g1e=Yi((n,e)=>Math.atan2(n,e)),x1e=Sa(wy,g1e),y1e={kernelName:wy,backendName:"cpu",kernelFunc:x1e};const v1e=Hs(Ay,n=>Math.atanh(n)),b1e={kernelName:Ay,backendName:"cpu",kernelFunc:v1e};function OL(n,e,t,s,i,a){const r=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,h=i.effectiveFilterHeight,d=i.effectiveFilterWidth,p=i.padInfo.top,g=i.padInfo.left,v=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=Hn(i.outShape,t),S=_.values,b=i.outShape[1]*i.outShape[2]*i.outShape[3],w=i.outShape[2]*i.outShape[3],T=i.outShape[3];for(let E=0;E<i.batchSize;++E){const R=E*b,D=E*s[0];for(let F=0;F<i.inChannels;++F)for(let U=0;U<i.outHeight;++U){const O=U*r-p,B=Math.max(0,O),L=Math.min(i.inHeight,h+O),H=R+U*w;for(let K=0;K<i.outWidth;++K){const Z=K*o-g,Q=Math.max(0,Z),P=Math.min(i.inWidth,d+Z);let W=v,q=0,se=0;for(let Y=B;Y<L;Y+=l){const re=D+Y*s[1];for(let he=Q;he<P;he+=c){const me=re+he*s[2],Ne=n[me+F];a==="max"&&Ne>W?W=Ne:a==="avg"&&(q+=Ne,se++)}if(isNaN(W))break}const le=H+K*T+F;S[le]=a==="avg"?q/se:W}}}return _}function KW(n,e,t,s,i=!1,a=!1){const r=Hn(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,g=s.padInfo.top,v=s.padInfo.left,_=Hn(e,t,n);for(let S=0;S<s.batchSize;++S)for(let b=0;b<s.inChannels;++b)for(let w=0;w<s.outHeight;++w){const T=w*o-g;let E=T;for(;E<0;)E+=c;const R=Math.min(s.inHeight,d+T);for(let D=0;D<s.outWidth;++D){const F=D*l-v;let U=F;for(;U<0;)U+=h;const O=Math.min(s.inWidth,p+F);let B=Number.NEGATIVE_INFINITY,L=-1;for(let H=E;H<R;H+=c){const K=H-T;for(let Z=U;Z<O;Z+=h){const Q=Z-F,P=_.get(S,H,Z,b);P>B&&(B=P,i?L=a?((S*s.inHeight+H)*s.inWidth+Z)*s.inChannels+b:(H*s.inWidth+Z)*s.inChannels+b:L=K*p+Q)}}r.set(L,S,w,D,b)}}return r}function YW(n,e,t,s,i,a){const r=i.strideDepth,o=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,h=i.dilationHeight,d=i.dilationWidth,p=i.effectiveFilterDepth,g=i.effectiveFilterHeight,v=i.effectiveFilterWidth,_=i.padInfo.front,S=i.padInfo.top,b=i.padInfo.left,w=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=Hn(i.outShape,t),E=T.values,R=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],D=i.outShape[2]*i.outShape[3]*i.outShape[4],F=i.outShape[3]*i.outShape[4],U=i.outShape[4];for(let O=0;O<i.batchSize;++O){const B=O*R,L=O*s[0];for(let H=0;H<i.inChannels;++H)for(let K=0;K<i.outDepth;++K){const Z=K*r-_;let Q=Z;for(;Q<0;)Q+=c;const P=Math.min(i.inDepth,p+Z),W=B+K*D;for(let q=0;q<i.outHeight;++q){const se=q*o-S;let le=se;for(;le<0;)le+=h;const Y=Math.min(i.inHeight,g+se),re=W+q*F;for(let he=0;he<i.outWidth;++he){const me=he*l-b;let Ne=me;for(;Ne<0;)Ne+=d;const fe=Math.min(i.inWidth,v+me),Te=re+he*U;let Ge=w,nt=0,yt=0;for(let qt=Q;qt<P;qt+=c){const Bt=L+qt*s[1];for(let Je=le;Je<Y;Je+=h){const oe=Bt+Je*s[2];for(let Ze=Ne;Ze<fe;Ze+=d){const it=oe+Ze*s[3],ft=n[it+H];if(a==="max"&&ft>Ge?Ge=ft:a==="avg"&&(nt+=ft,yt++),isNaN(Ge))break}if(isNaN(Ge))break}if(isNaN(Ge))break}const Dt=Te+H;E[Dt]=a==="avg"?nt/Math.max(yt,1):Ge}}}}return T}function S1e(n,e){const t=Hn(e.outShape,"int32"),s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.front,g=e.padInfo.top,v=e.padInfo.left;for(let _=0;_<e.batchSize;++_)for(let S=0;S<e.inChannels;++S)for(let b=0;b<e.outDepth;++b){const w=b*s-p;let T=w;for(;T<0;)T+=r;const E=Math.min(e.inDepth,c+w);for(let R=0;R<e.outHeight;++R){const D=R*i-g;let F=D;for(;F<0;)F+=o;const U=Math.min(e.inHeight,h+D);for(let O=0;O<e.outWidth;++O){const B=O*a-v;let L=B;for(;L<0;)L+=l;const H=Math.min(e.inWidth,d+B);let K=Number.NEGATIVE_INFINITY,Z=-1;for(let Q=T;Q<E;Q+=r){const P=Q-w;for(let W=F;W<U;W+=o){const q=W-D;for(let se=L;se<H;se+=l){const le=se-B,Y=n.get(_,Q,W,se,S);Y>=K&&(K=Y,Z=P*h*d+q*h+le)}}}t.set(Z,_,b,R,O,S)}}}return t}function _1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;rn(i,"avgPool");const{filterSize:a,strides:r,pad:o,dimRoundingMode:l}=s,c=1;ee(sr(r,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const h=uc(i.shape,a,r,c,o,l);let d;if(h.filterWidth===1&&h.filterHeight===1&&as(h.inShape,h.outShape))d=dh({inputs:{x:i},backend:t});else{const p=t.data.get(i.dataId).values,g=gn(i.shape),v=OL(p,i.shape,i.dtype,g,h,"avg");d=t.makeTensorInfo(h.outShape,i.dtype,v.values)}return d}const A1e={kernelName:jS,backendName:"cpu",kernelFunc:_1e};function w1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:a,strides:r,pad:o,dimRoundingMode:l,dataFormat:c}=s;rn(i,"avgPool3d");const h=wd(i.shape,a,r,1,o,l,c),d=t.data.get(i.dataId).values,p=YW(d,i.shape,i.dtype,gn(i.shape),h,"avg");return t.makeTensorInfo(p.shape,"float32",p.values)}const C1e={kernelName:XS,backendName:"cpu",kernelFunc:w1e};function T1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a}=e,{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=s;rn([i,a],"avgPool3DGrad");const h=wd(a.shape,r,o,1,l,c),d=h.strideDepth,p=h.strideHeight,g=h.strideWidth,v=h.filterDepth,_=h.filterHeight,S=h.filterWidth,b=h.dilationDepth,w=h.dilationHeight,T=h.dilationWidth,E=h.effectiveFilterDepth,R=h.effectiveFilterHeight,D=h.effectiveFilterWidth,F=E-1-h.padInfo.front,U=D-1-h.padInfo.left,O=R-1-h.padInfo.top,B=Hn(a.shape,"float32"),L=1/(v*_*S),H=t.bufferSync(i);for(let K=0;K<h.batchSize;++K)for(let Z=0;Z<h.inChannels;++Z)for(let Q=0;Q<h.inDepth;++Q)for(let P=0;P<h.inHeight;++P)for(let W=0;W<h.inWidth;++W){const q=Q-F,se=P-O,le=W-U;let Y=0;for(let re=0;re<E;re+=b){const he=(q+re)/d;if(!(he<0||he>=h.outDepth||Math.floor(he)!==he))for(let me=0;me<R;me+=w){const Ne=(se+me)/p;if(!(Ne<0||Ne>=h.outHeight||Math.floor(Ne)!==Ne))for(let fe=0;fe<D;fe+=T){const Te=(le+fe)/g;if(Te<0||Te>=h.outWidth||Math.floor(Te)!==Te)continue;const Ge=H.get(K,he,Ne,Te,Z);Y+=Ge}}}B.set(Y*L,K,Q,P,W,Z)}return t.makeTensorInfo(B.shape,B.dtype,B.values)}const E1e={kernelName:$2,backendName:"cpu",kernelFunc:T1e};function M1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a}=e,r=a;rn([i,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,h=uc(r.shape,o,l,1,c),d=h.strideHeight,p=h.strideWidth,g=h.filterHeight,v=h.filterWidth,_=h.dilationHeight,S=h.dilationWidth,b=h.effectiveFilterHeight,w=h.effectiveFilterWidth,T=w-1-h.padInfo.left,E=b-1-h.padInfo.top,R=Hn(r.shape,"float32"),D=1/(g*v),F=t.data.get(i.dataId).values,U=Hn(i.shape,"float32",F);for(let O=0;O<h.batchSize;++O)for(let B=0;B<h.inChannels;++B)for(let L=0;L<h.inHeight;++L)for(let H=0;H<h.inWidth;++H){const K=L-E,Z=H-T;let Q=0;for(let P=0;P<b;P+=_){const W=(K+P)/d;if(!(W<0||W>=h.outHeight||Math.floor(W)!==W))for(let q=0;q<w;q+=S){const se=(Z+q)/p;if(se<0||se>=h.outWidth||Math.floor(se)!==se)continue;const le=U.get(O,W,se,B);Q+=le}}R.set(Q*D,O,L,H,B)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const N1e={kernelName:z2,backendName:"cpu",kernelFunc:M1e};function R1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,scale:a,offset:r,mean:o,variance:l}=e;ee(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ee(r==null||o.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ee(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),rn([i,o,l,a,r],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const h=t.data.get(i.dataId).values,d=t.data.get(o.dataId).values,p=t.data.get(l.dataId).values,g=a?t.data.get(a.dataId).values:new Float32Array([1]),v=r?t.data.get(r.dataId).values:new Float32Array([0]),_=new Float32Array(h.length),S=v.length,b=g.length,w=p.length,T=d.length;let E=0,R=0,D=0,F=0;for(let U=0;U<h.length;++U)_[U]=v[E++]+(h[U]-d[R++])*g[D++]/Math.sqrt(p[F++]+c),E>=S&&(E=0),R>=T&&(R=0),D>=b&&(D=0),F>=w&&(F=0);return t.makeTensorInfo(i.shape,i.dtype,_)}const I1e={kernelName:o_,backendName:"cpu",kernelFunc:R1e};function D1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:a,crops:r}=s;rn([i],"batchToSpaceND");const o=a.reduce((b,w)=>b*w),l=hA(i.shape,a,o),c=dA(l.length,a.length),h=fA(i.shape,a,o),d=zk(r,a.length),p=$k(h,r,a.length),g=oi({inputs:{x:i},backend:t,attrs:{shape:l}}),v=Io({inputs:{x:g},backend:t,attrs:{perm:c}}),_=oi({inputs:{x:v},backend:t,attrs:{shape:h}}),S=Sg({inputs:{x:_},backend:t,attrs:{begin:d,size:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(_),S}const O1e={kernelName:KS,backendName:"cpu",kernelFunc:D1e};function B1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:a}=e,{size:r}=s,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values,c=ML(o,l,a.dtype,a.shape,r);return t.makeTensorInfo([r],a.dtype,c)}const k1e={kernelName:G2,backendName:"cpu",kernelFunc:B1e};function L1e(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,a=t.data.get(s.dataId).values,r=t.data.get(i.dataId).values,o=kn(Array.from(a),Array.from(r));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const F1e={kernelName:V2,backendName:"cpu",kernelFunc:L1e};const U1e=Hs(Ey,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),P1e={kernelName:Ey,backendName:"cpu",kernelFunc:U1e};const z1e=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(qe(e.shape)),i=t.data.get(e.dataId),a=i.complexTensorInfos.real,r=i.complexTensorInfos.imag,o=t.data.get(a.dataId).values,l=t.data.get(r.dataId).values;for(let c=0;c<o.length;c++){const h=o[c],d=l[c];s[c]=Math.hypot(h,d)}return t.makeOutput(s,e.shape,"float32")},$1e={kernelName:JS,backendName:"cpu",kernelFunc:z1e};function ty(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.imag,a=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,a)}const G1e={kernelName:cM,backendName:"cpu",kernelFunc:ty};function ny(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,a=es(i,e[0].shape)[0],r=e.map(_=>_.shape);Fk(r,a);let o=th(e.map(_=>_.shape),a);if(qe(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(_=>qe(_.shape)>0);if(l.length===1)return dh({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const _=l.map(E=>bg({inputs:{input:E},backend:t})),S=l.map(E=>ty({inputs:{input:E},backend:t})),b=ny({inputs:_,backend:t,attrs:{axis:a}}),w=ny({inputs:S,backend:t,attrs:{axis:a}}),T=Ko({inputs:{real:b,imag:w},backend:t});return _.forEach(E=>t.disposeIntermediateTensorInfo(E)),S.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),T}const c=l.map(_=>{const b=[-1,qe(_.shape.slice(a))];return oi({inputs:{x:_},backend:t,attrs:{shape:b}})}),h=c.map(_=>({vals:t.data.get(_.dataId).values,shape:_.shape}));o=th(c.map(_=>_.shape),1);const d=c[0].shape[0]===1,p=tW(h,o,e[0].dtype,d),g=th(l.map(_=>_.shape),a),v=t.makeTensorInfo(g,e[0].dtype,p);return c.forEach(_=>t.disposeIntermediateTensorInfo(_)),v}const V1e={kernelName:ZS,backendName:"cpu",kernelFunc:ny};function JW(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dataFormat:l,dilations:c,dimRoundingMode:h}=s;rn([i,a],"conv2d");const d=Cd(l),p=Fa(i.shape,a.shape,r,c,o,h,!1,d),g=p.filterHeight,v=p.filterWidth,_=p.dilationHeight,S=p.dilationWidth,b=p.padInfo.left,w=p.padInfo.top,T=p.dataFormat==="channelsLast",E=new oa(p.outShape,i.dtype),R=gn(i.shape),D=gn(a.shape),F=R[0],U=T?R[1]:R[2],O=T?R[2]:1,B=T?1:R[1],L=E.strides[0],H=T?E.strides[1]:E.strides[2],K=T?E.strides[2]:1,Z=T?1:E.strides[1],Q=t.data.get(i.dataId).values,P=t.data.get(a.dataId).values,W=E.values;for(let q=0;q<p.batchSize;++q){const se=q*F,le=q*L;for(let Y=0;Y<p.outHeight;++Y){const re=le+Y*H,he=Y*p.strideHeight-w;for(let me=0;me<g;++me){const Ne=he+me*_;if(Ne<0||Ne>=p.inHeight)continue;const fe=me*D[0],Te=se+Ne*U;for(let Ge=0;Ge<p.outWidth;++Ge){const nt=re+Ge*K,yt=Ge*p.strideWidth-b;for(let Dt=0;Dt<v;++Dt){const qt=yt+Dt*S;if(qt<0||qt>=p.inWidth)continue;const Bt=fe+Dt*D[1],Je=Te+qt*O;let oe=Bt;for(let Ze=0;Ze<p.inChannels;++Ze){const it=Q[Je+Ze*B];for(let ft=0;ft<p.outChannels;++ft)W[nt+ft*Z]+=it*P[oe+ft];oe+=p.outChannels}}}}}}return t.makeTensorInfo(E.shape,E.dtype,W)}const H1e={kernelName:QS,backendName:"cpu",kernelFunc:JW};function W1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:a}=e,{strides:r,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:h}=s;rn([i,a],"conv2dBackpropFilter");const d=Cd(l),p=Fa(i.shape,h,r,1,o,c,!1,d),{strideHeight:g,strideWidth:v,filterHeight:_,filterWidth:S}=p,b=p.dataFormat==="channelsLast",w=new oa(p.filterShape,"float32"),T=p.padInfo.left,E=p.padInfo.top,R=t.data.get(i.dataId).values,D=t.data.get(a.dataId).values,F=new oa(i.shape,i.dtype,R),U=new oa(a.shape,a.dtype,D);for(let O=0;O<_;++O){const B=Math.max(0,Math.ceil((E-O)/g)),L=Math.min(p.outHeight,(p.inHeight+E-O)/g);for(let H=0;H<S;++H){const K=Math.max(0,Math.ceil((T-H)/v)),Z=Math.min(p.outWidth,(p.inWidth+T-H)/v);for(let Q=0;Q<p.inChannels;++Q)for(let P=0;P<p.outChannels;++P){let W=0;for(let q=0;q<p.batchSize;++q)for(let se=B;se<L;++se){const le=O+se*g-E;for(let Y=K;Y<Z;++Y){const re=H+Y*v-T;b?W+=F.get(q,le,re,Q)*U.get(q,se,Y,P):W+=F.get(q,Q,le,re)*U.get(q,P,se,Y)}}w.set(W,O,H,Q,P)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const j1e={kernelName:W2,backendName:"cpu",kernelFunc:W1e};function X1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:a}=e,{inputShape:r,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s;rn([i,a],"conv2dBackpropInput");const d=gn(a.shape),p=gn(i.shape);let g=Cd(c);const v=Fa(r,a.shape,o,1,l,h,!1,g),_=new oa(v.inShape,"float32"),S=_.values,b=t.data.get(i.dataId).values,w=t.data.get(a.dataId).values,[T,E,R]=d,{batchSize:D,filterHeight:F,filterWidth:U,inChannels:O,inHeight:B,inWidth:L,outChannels:H,outHeight:K,outWidth:Z,strideHeight:Q,strideWidth:P}=v;g=v.dataFormat;const W=F-1-v.padInfo.top,q=U-1-v.padInfo.left,se=g==="channelsLast",le=_.strides[0],Y=se?_.strides[1]:_.strides[2],re=se?_.strides[2]:1,he=se?1:_.strides[1],me=p[0],Ne=se?p[1]:p[2],fe=se?p[2]:1,Te=se?1:p[1];for(let Ge=0;Ge<D;++Ge)for(let nt=0;nt<O;++nt)for(let yt=0;yt<B;++yt){const Dt=yt-W,qt=Math.max(0,Math.ceil(Dt/Q)),Bt=Math.min(K,(F+Dt)/Q);for(let Je=0;Je<L;++Je){const oe=Je-q,Ze=Math.max(0,Math.ceil(oe/P)),it=Math.min(Z,(U+oe)/P);let ft=0;for(let Tt=qt;Tt<Bt;++Tt){const Et=Tt*Q-Dt;for(let kt=Ze;kt<it;++kt){const ce=kt*P-oe,J=me*Ge+Ne*Tt+fe*kt,Ie=T*(F-1-Et)+E*(U-1-ce)+R*nt;for(let Ye=0;Ye<H;++Ye){const lt=b[J+Te*Ye],Ve=w[Ie+Ye];ft+=lt*Ve}}}const gt=le*Ge+Y*yt+re*Je+he*nt;S[gt]=ft}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const q1e={kernelName:e_,backendName:"cpu",kernelFunc:X1e};function K1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dilations:l}=s;rn([i,a],"conv3d");const c=op(i.shape,a.shape,r,l,o),{filterDepth:h,filterHeight:d,filterWidth:p,dilationDepth:g,dilationHeight:v,dilationWidth:_,padInfo:S}=c,b=S.front,w=S.left,T=S.top,E=new oa(c.outShape,i.dtype),R=t.data.get(i.dataId).values,D=t.data.get(a.dataId).values,F=E.values,U=gn(i.shape),O=gn(a.shape);for(let B=0;B<c.batchSize;++B){const L=B*U[0],H=B*E.strides[0];for(let K=0;K<c.outDepth;++K){const Z=H+K*E.strides[1],Q=K*c.strideDepth-b;for(let P=0;P<h;++P){const W=Q+P*g;if(W<0||W>=c.inDepth)continue;const q=P*O[0],se=L+W*U[1];for(let le=0;le<c.outHeight;++le){const Y=Z+le*E.strides[2],re=le*c.strideHeight-T;for(let he=0;he<d;++he){const me=re+he*v;if(me<0||me>=c.inHeight)continue;const Ne=q+he*O[1],fe=se+me*U[2];for(let Te=0;Te<c.outWidth;++Te){const Ge=Y+Te*c.outChannels,nt=Te*c.strideWidth-w;for(let yt=0;yt<p;++yt){const Dt=nt+yt*_;if(Dt<0||Dt>=c.inWidth)continue;const qt=Ne+yt*O[2],Bt=fe+Dt*c.inChannels;let Je=qt;for(let oe=0;oe<c.inChannels;++oe){const Ze=R[Bt+oe];for(let it=0;it<c.outChannels;++it)F[Ge+it]+=Ze*D[Je+it];Je+=c.outChannels}}}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Y1e={kernelName:t_,backendName:"cpu",kernelFunc:K1e};function J1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:a}=e,{strides:r,pad:o,filterShape:l}=s;rn([i,a],"conv3dBackpropFilterV2");const c=gn(i.shape),h=gn(a.shape),d=op(i.shape,l,r,1,o),p=d.strideDepth,g=d.strideHeight,v=d.strideWidth,_=d.filterDepth,S=d.filterHeight,b=d.filterWidth,w=new oa(d.filterShape,"float32"),T=w.values,[E,R,D,F]=w.strides,U=t.data.get(a.dataId).values,[O,B,L,H]=h,K=t.data.get(i.dataId).values,[Z,Q,P,W]=c,q=d.padInfo.front,se=d.padInfo.left,le=d.padInfo.top;for(let Y=0;Y<_;++Y){const re=Math.max(0,Math.ceil((q-Y)/p)),he=Math.min(d.outDepth,(d.inDepth+q-Y)/p),me=Y*E;for(let Ne=0;Ne<S;++Ne){const fe=Math.max(0,Math.ceil((le-Ne)/g)),Te=Math.min(d.outHeight,(d.inHeight+le-Ne)/g),Ge=Ne*R+me;for(let nt=0;nt<b;++nt){const yt=Math.max(0,Math.ceil((se-nt)/v)),Dt=Math.min(d.outWidth,(d.inWidth+se-nt)/v),qt=nt*D+Ge;for(let Bt=0;Bt<d.inChannels;++Bt){const Je=Bt*F+qt;for(let oe=0;oe<d.outChannels;++oe){let Ze=0;for(let it=0;it<d.batchSize;++it){const ft=it*Z,gt=it*O;for(let Tt=re;Tt<he;++Tt){const kt=(Y+Tt*p-q)*Q+ft,ce=Tt*B+gt;for(let J=fe;J<Te;++J){const Ye=(Ne+J*g-le)*P+kt,lt=J*L+ce;for(let Ve=yt;Ve<Dt;++Ve){const Lt=(nt+Ve*v-se)*W+Ye,tn=Ve*H+lt;Ze+=K[Lt+Bt]*U[tn+oe]}}}}T[Je+oe]=Ze}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const Z1e={kernelName:j2,backendName:"cpu",kernelFunc:J1e};function Q1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:a}=e,{pad:r,strides:o,inputShape:l}=s;rn([i],"conv3dBackpropInputV2");const c=gn(i.shape),h=gn(a.shape),d=op(l,a.shape,o,1,r),p=new oa(d.inShape,"float32"),g=p.values,[v,_,S,b]=p.strides,w=t.data.get(i.dataId).values,[T,E,R,D]=c,F=t.data.get(a.dataId).values,[U,O,B,L]=h,{batchSize:H,filterDepth:K,filterHeight:Z,filterWidth:Q,inChannels:P,inDepth:W,inHeight:q,inWidth:se,outChannels:le,outDepth:Y,outHeight:re,outWidth:he,strideDepth:me,strideHeight:Ne,strideWidth:fe}=d,Te=K-1-d.padInfo.front,Ge=Z-1-d.padInfo.top,nt=Q-1-d.padInfo.left;for(let yt=0;yt<H;++yt)for(let Dt=0;Dt<P;++Dt)for(let qt=0;qt<W;++qt){const Bt=qt-Te,Je=Math.max(0,Math.ceil(Bt/me)),oe=Math.min(Y,(K+Bt)/me);for(let Ze=0;Ze<q;++Ze){const it=Ze-Ge,ft=Math.max(0,Math.ceil(it/Ne)),gt=Math.min(re,(Z+it)/Ne);for(let Tt=0;Tt<se;++Tt){const Et=Tt-nt,kt=Math.max(0,Math.ceil(Et/fe)),ce=Math.min(he,(Q+Et)/fe);let J=0;for(let Ie=Je;Ie<oe;++Ie){const Ye=Ie*me-Bt;for(let lt=ft;lt<gt;++lt){const Ve=lt*Ne-it;for(let Gt=kt;Gt<ce;++Gt){const Lt=Gt*fe-Et,tn=T*yt+E*Ie+R*lt+D*Gt,Jt=U*(K-1-Ye)+O*(Z-1-Ve)+B*(Q-1-Lt)+L*Dt;for(let at=0;at<le;++at){const ut=w[tn+at],Zt=F[Jt+at];J+=ut*Zt}}}}g[v*yt+_*qt+S*Ze+b*Tt+Dt]=J}}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const eSe={kernelName:X2,backendName:"cpu",kernelFunc:Q1e};const tSe=Hs(My,n=>Math.cos(n)),nSe={kernelName:My,backendName:"cpu",kernelFunc:tSe};const sSe=Hs(Ny,n=>Math.cosh(n)),iSe={kernelName:Ny,backendName:"cpu",kernelFunc:sSe};function aSe(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:a,boxInd:r}=e,{cropSize:o,method:l,extrapolationValue:c}=s,[h,d,p,g]=i.shape,v=a.shape[0],[_,S]=o,b=Hn([v,_,S,g],"float32"),w=t.data.get(a.dataId).values,T=t.data.get(r.dataId).values,E=t.data.get(i.dataId).values,R=gn(i.shape),D=gn(b.shape);for(let F=0;F<v;F++){const U=F*4,O=w[U],B=w[U+1],L=w[U+2],H=w[U+3],K=T[F];if(K>=h)continue;const Z=_>1?(L-O)*(d-1)/(_-1):0,Q=S>1?(H-B)*(p-1)/(S-1):0;for(let P=0;P<_;P++){const W=_>1?O*(d-1)+P*Z:.5*(O+L)*(d-1);if(W<0||W>d-1){for(let q=0;q<S;q++)for(let se=0;se<g;se++){const le=se+q*D[2]+P*D[1]+F*D[0];b.values[le]=c}continue}if(l==="bilinear"){const q=Math.floor(W),se=Math.ceil(W),le=W-q;for(let Y=0;Y<S;Y++){const re=S>1?B*(p-1)+Y*Q:.5*(B+H)*(p-1);if(re<0||re>p-1){for(let fe=0;fe<g;fe++){const Te=fe+Y*D[2]+P*D[1]+F*D[0];b.values[Te]=c}continue}const he=Math.floor(re),me=Math.ceil(re),Ne=re-he;for(let fe=0;fe<g;fe++){let Te=fe+he*R[2]+q*R[1]+K*R[0];const Ge=E[Te];Te=fe+me*R[2]+q*R[1]+K*R[0];const nt=E[Te];Te=fe+he*R[2]+se*R[1]+K*R[0];const yt=E[Te];Te=fe+me*R[2]+se*R[1]+K*R[0];const Dt=E[Te],qt=Ge+(nt-Ge)*Ne,Bt=yt+(Dt-yt)*Ne;Te=fe+Y*D[2]+P*D[1]+F*D[0],b.values[Te]=qt+(Bt-qt)*le}}}else for(let q=0;q<S;++q){const se=S>1?B*(p-1)+q*Q:.5*(B+H)*(p-1);if(se<0||se>p-1){for(let re=0;re<g;re++){const he=re+q*D[2]+P*D[1]+F*D[0];b.values[he]=c}continue}const le=Math.round(se),Y=Math.round(W);for(let re=0;re<g;re++){const he=re+le*R[2]+Y*R[1]+K*R[0],me=re+q*D[2]+P*D[1]+F*D[0];b.values[me]=E[he]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const rSe={kernelName:K2,backendName:"cpu",kernelFunc:aSe};function oSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,exclusive:r,reverse:o}=s;rn(i,"cumprod");const l=Mi([a],i.shape.length);let c=i;l!=null&&(c=Io({inputs:{x:i},backend:t,attrs:{perm:l}}));const h=qi(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const d=To(c.dtype,"int32"),p=F2(qe(c.shape),d),g=t.data.get(c.dataId).values,v=c.shape[c.shape.length-1],_=o?(b,w)=>b+v-w-1:(b,w)=>b+w;for(let b=0;b<g.length;b+=v)for(let w=0;w<v;w++){const T=_(b,w);if(w===0)p[T]=r?1:g[T];else{const E=_(b,w-1);p[T]=r?g[E]*p[E]:g[T]*p[E]}}const S=t.makeTensorInfo(c.shape,d,p);if(l!=null){const b=lp(l),w=Io({inputs:{x:S},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(c),w}return S}const lSe={kernelName:q2,backendName:"cpu",kernelFunc:oSe};function cSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,exclusive:r,reverse:o}=s;rn(i,"cumsum");const l=Mi([a],i.shape.length);let c=i;l!=null&&(c=Io({inputs:{x:i},backend:t,attrs:{perm:l}}));const h=qi(1,i.shape.length)[0];if(h!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${h}`);const d=To(c.dtype,"int32"),p=tr(qe(c.shape),d),g=t.data.get(c.dataId).values,v=c.shape[c.shape.length-1],_=o?(b,w)=>b+v-w-1:(b,w)=>b+w;for(let b=0;b<g.length;b+=v)for(let w=0;w<v;w++){const T=_(b,w);if(w===0)p[T]=r?0:g[T];else{const E=_(b,w-1);p[T]=r?g[E]+p[E]:g[T]+p[E]}}const S=t.makeTensorInfo(c.shape,d,p);if(l!=null){const b=lp(l),w=Io({inputs:{x:S},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(c),w}return S}const uSe={kernelName:n_,backendName:"cpu",kernelFunc:cSe};function hSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:a}=e,{size:r,binaryOutput:o}=s;if(i.shape.length===1){const l=t.data.get(i.dataId).values,c=t.data.get(a.dataId).values,h=ML(l,c,a.dtype,a.shape,r);return t.makeTensorInfo([r],a.dtype,h)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(a),h=Z9(l,c,r,o);return t.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const dSe={kernelName:Y2,backendName:"cpu",kernelFunc:hSe};function fSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:a,dataFormat:r}=s;ee(r==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`);const o=i.shape[0],l=i.shape[1],c=i.shape[2],h=i.shape[3],d=l*a,p=c*a,g=h/(a*a),v=t.data.get(i.dataId).values,_=new Float32Array(o*d*p*g);let S=0;for(let b=0;b<o;++b)for(let w=0;w<d;++w){const T=Math.floor(w/a),E=w%a;for(let R=0;R<p;++R){const D=Math.floor(R/a),F=R%a,U=(E*a+F)*g;for(let O=0;O<g;++O){const L=O+U+h*(D+c*(T+l*b));_[S++]=v[L]}}}return t.makeTensorInfo([o,d,p,g],i.dtype,_)}const pSe={kernelName:J2,backendName:"cpu",kernelFunc:fSe};function ZW(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dilations:l,dimRoundingMode:c}=s;rn([i,a],"depthwiseConv2DNative");const h=gn(i.shape),d=gn(a.shape);let p=l;p==null&&(p=[1,1]),ee(sr(r,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${p}'`);const g=Fa(i.shape,a.shape,r,p,o,c,!0),{filterHeight:v,filterWidth:_,dilationHeight:S,dilationWidth:b,padInfo:w}=g,T=w.left,E=w.top,R=g.outChannels/g.inChannels,D=new oa(g.outShape,i.dtype),F=t.data.get(i.dataId).values,U=t.data.get(a.dataId).values,O=D.values;for(let B=0;B<g.batchSize;++B){const L=B*h[0],H=B*D.strides[0];for(let K=0;K<g.outHeight;++K){const Z=H+K*D.strides[1],Q=K*g.strideHeight-E;for(let P=0;P<v;++P){const W=Q+P*S;if(W<0||W>=g.inHeight)continue;const q=P*d[0],se=L+W*h[1];for(let le=0;le<g.outWidth;++le){const Y=Z+le*D.strides[2],re=le*g.strideWidth-T;for(let he=0;he<_;++he){const me=re+he*b;if(me<0||me>=g.inWidth)continue;const Ne=q+he*d[1],fe=se+me*g.inChannels;let Te=Y,Ge=Ne;for(let nt=0;nt<g.inChannels;++nt){const yt=F[fe+nt];for(let Dt=0;Dt<R;++Dt)O[Te+Dt]+=yt*U[Ge+Dt];Te+=R,Ge+=R}}}}}}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const mSe={kernelName:s_,backendName:"cpu",kernelFunc:ZW};function gSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:a}=e,{strides:r,dilations:o,pad:l,dimRoundingMode:c,filterShape:h}=s;rn([i,a],"depthwiseConv2dNativeBackpropFilter");const d=Fa(i.shape,h,r,o,l,c,!0),{strideHeight:p,strideWidth:g,filterHeight:v,filterWidth:_}=d,S=new oa(d.filterShape,"float32"),b=d.padInfo.left,w=d.padInfo.top,T=d.outChannels/d.inChannels,E=t.data.get(i.dataId).values,R=new oa(i.shape,i.dtype,E),D=t.data.get(a.dataId).values,F=new oa(a.shape,a.dtype,D);for(let U=0;U<v;++U){const O=Math.max(0,Math.ceil((w-U)/p)),B=Math.min(d.outHeight,(d.inHeight+w-U)/p);for(let L=0;L<_;++L){const H=Math.max(0,Math.ceil((b-L)/g)),K=Math.min(d.outWidth,(d.inWidth+b-L)/g);for(let Z=0;Z<d.outChannels;++Z){const Q=Math.trunc(Z/T),P=Z%T;let W=0;for(let q=0;q<d.batchSize;++q)for(let se=O;se<B;++se){const le=U+se*p-w;for(let Y=H;Y<K;++Y){const re=L+Y*g-b;W+=R.get(q,le,re,Q)*F.get(q,se,Y,Z)}}S.set(W,U,L,Q,P)}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const xSe={kernelName:Z2,backendName:"cpu",kernelFunc:gSe};function ySe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:a}=e,{strides:r,dilations:o,pad:l,dimRoundingMode:c,inputShape:h}=s;rn([i,a],"depthwiseConv2DNativeBackpropInput");const d=gn(i.shape),p=gn(a.shape),g=Fa(h,a.shape,r,o,l,c,!0),v=new oa(g.inShape,"float32"),_=v.values,[S,b,w]=v.strides,T=t.data.get(i.dataId).values,[E,R,D]=d,F=t.data.get(a.dataId).values,[U,O,B]=p,{batchSize:L,filterHeight:H,filterWidth:K,inChannels:Z,inHeight:Q,inWidth:P,outChannels:W,outHeight:q,outWidth:se,strideHeight:le,strideWidth:Y}=g,re=H-1-g.padInfo.top,he=K-1-g.padInfo.left,me=W/Z;for(let Ne=0;Ne<L;++Ne)for(let fe=0;fe<Z;++fe)for(let Te=0;Te<Q;++Te){const Ge=Te-re,nt=Math.max(0,Math.ceil(Ge/le)),yt=Math.min(q,(H+Ge)/le);for(let Dt=0;Dt<P;++Dt){const qt=Dt-he,Bt=Math.max(0,Math.ceil(qt/Y)),Je=Math.min(se,(K+qt)/Y);let oe=0;for(let Ze=nt;Ze<yt;++Ze){const it=Ze*le-Ge;for(let ft=Bt;ft<Je;++ft){const gt=ft*Y-qt,Tt=E*Ne+R*Ze+D*ft,Et=U*(H-1-it)+O*(K-1-gt)+B*fe;for(let kt=0;kt<me;++kt){const ce=fe*me+kt,J=T[Tt+ce],Ie=F[Et+kt];oe+=J*Ie}}}_[S*Ne+b*Te+w*Dt+fe]=oe}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const vSe={kernelName:Q2,backendName:"cpu",kernelFunc:ySe};function bSe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=qe(s.shape),a=t.data.get(s.dataId).values,r=Hn([i,i],s.dtype),o=r.values;for(let c=0;c<a.length;c++)o[c*i+c]=a[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,r.dtype,r.values)}const SSe={kernelName:eM,backendName:"cpu",kernelFunc:bSe};const _Se={kernelName:i_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i}=n,{strides:a,pad:r,dilations:o}=t,l=e,c=l.data.get(s.dataId).values,h=s.shape.length,d=l.data.get(i.dataId).values,p=i.shape.length,{batchSize:g,inHeight:v,inWidth:_,inChannels:S,outHeight:b,outWidth:w,padInfo:T,strideHeight:E,strideWidth:R,filterHeight:D,filterWidth:F,dilationHeight:U,dilationWidth:O,outShape:B}=X_(s.shape,i.shape,a,r,"NHWC",o),L=qe(B),H=B.length,K=Ui(s.dtype,L);for(let Q=0;Q<g;++Q)for(let P=0;P<b;++P){const W=P*E-T.top;for(let q=0;q<w;++q){const se=q*R-T.left;for(let le=0;le<S;++le){let Y=Number.MIN_SAFE_INTEGER;for(let he=0;he<D;++he){const me=W+he*U;if(me>=0&&me<v)for(let Ne=0;Ne<F;++Ne){const fe=se+Ne*O;if(fe>=0&&fe<_){const Te=Kc([Q,me,fe,le],h,gn(s.shape)),Ge=Kc([he,Ne,le],p,gn(i.shape)),nt=c[Te]+d[Ge];nt>Y&&(Y=nt)}}}const re=Kc([Q,P,q,le],H,gn(B));K[re]=Y}}}return{dataId:l.write(ap(K,s.dtype),B,s.dtype),shape:B,dtype:s.dtype}}};const ASe={kernelName:AE,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:a}=n,{strides:r,pad:o,dilations:l}=t,c=e,h=_l(s.shape,c.data.get(s.dataId).values),d=_l(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:g,inWidth:v,inChannels:_,outHeight:S,outWidth:b,padInfo:w,strideHeight:T,strideWidth:E,filterHeight:R,filterWidth:D,dilationHeight:F,dilationWidth:U,outShape:O}=X_(s.shape,i.shape,r,o,"NHWC",l);ee(a.rank===O.length,()=>`Error in ${AE}, dy must have the same rank as output ${O.length}, but got ${a.rank}`);const B=_l(O,c.data.get(a.dataId).values),L=iB(i.shape,i.dtype);for(let K=0;K<p;++K)for(let Z=0;Z<S;++Z){const Q=Z*T-w.top;for(let P=0;P<b;++P){const W=P*E-w.left;for(let q=0;q<_;++q){let se=Number.MIN_SAFE_INTEGER,le=0,Y=0;for(let re=0;re<R;++re){const he=Q+re*F;if(he>=0&&he<g)for(let me=0;me<D;++me){const Ne=W+me*U;if(Ne>=0&&Ne<v){const fe=h[K][he][Ne][q]+d[re][me][q];fe>se&&(se=fe,le=re,Y=me)}}}L[le][Y][q]+=B[K][Z][P][q]}}}return{dataId:c.write(ap(L,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};const wSe={kernelName:_E,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:a}=n,{strides:r,pad:o,dilations:l}=t,c=e,h=_l(s.shape,c.data.get(s.dataId).values),d=_l(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:g,inWidth:v,inChannels:_,outHeight:S,outWidth:b,padInfo:w,strideHeight:T,strideWidth:E,filterHeight:R,filterWidth:D,dilationHeight:F,dilationWidth:U,outShape:O}=X_(s.shape,i.shape,r,o,"NHWC",l);ee(a.rank===O.length,()=>`Error in ${_E}, dy must have the same rank as output ${O.length}, but got ${a.rank}`);const B=_l(O,c.data.get(a.dataId).values),L=iB(s.shape,s.dtype);for(let K=0;K<p;++K)for(let Z=0;Z<S;++Z){const Q=Z*T-w.top;for(let P=0;P<b;++P){const W=P*E-w.left;for(let q=0;q<_;++q){let se=Number.MIN_SAFE_INTEGER,le=Q<0?0:Q,Y=W<0?0:W;for(let re=0;re<R;++re){const he=Q+re*F;if(he>=0&&he<g)for(let me=0;me<D;++me){const Ne=W+me*U;if(Ne>=0&&Ne<v){const fe=h[K][he][Ne][q]+d[re][me][q];fe>se&&(se=fe,le=he,Y=Ne)}}}L[K][le][Y][q]+=B[K][Z][P][q]}}}return{dataId:c.write(ap(L,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function CSe(n){const{inputs:e,backend:t,attrs:s}=n,{image:i}=e,{canvas:a,options:r}=s,{contextOptions:o,imageOptions:l}=r||{},c=l?.alpha||1,h=o?.contextType||"2d";if(h!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(h,o?.contextAttributes||{});if(d==null)throw new Error(`Could not get the context with ${h} type.`);const[p,g]=i.shape.slice(0,2),v=i.shape.length===2?1:i.shape[2],_=t.data.get(i.dataId).values,S=i.dtype==="float32"?255:1,b=new Uint8ClampedArray(g*p*4);for(let T=0;T<p*g;++T){const E=[0,0,0,255*c];for(let D=0;D<v;D++){const F=_[T*v+D];if(i.dtype==="float32"){if(F<0||F>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${F}.`)}else if(i.dtype==="int32"&&(F<0||F>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${F}.`);v===1?(E[0]=F*S,E[1]=F*S,E[2]=F*S):E[D]=F*S}const R=T*4;b[R+0]=Math.round(E[0]),b[R+1]=Math.round(E[1]),b[R+2]=Math.round(E[2]),b[R+3]=Math.round(E[3])}a.width=g,a.height=p;const w=new ImageData(b,g,p);return d.putImageData(w,0,0),i}const TSe={kernelName:tM,backendName:"cpu",kernelFunc:CSe};function _A(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s;rn(i,"sum");let o;i.dtype==="bool"?o=Qf({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):o=dh({inputs:{x:i},backend:t});const l=o.shape.length,c=es(a,o.shape),h=Mi(c,l);let d=c,p=o;h!=null&&(p=Io({inputs:{x:o},backend:t,attrs:{perm:h}}),d=qi(d.length,l)),ir("sum",d,p.shape.length);const[g,v]=Ua(p.shape,d),_=To(p.dtype,"int32");let S=zE(t,g,_);const b=qe(v),w=t.data.get(S.dataId).values,T=t.data.get(p.dataId).values;for(let E=0;E<w.length;++E){const R=E*b;let D=0;for(let F=0;F<b;++F)D+=T[R+F];w[E]=D}if(r){const E=Xi(S.shape,c),R=S;S=oi({inputs:{x:S},backend:t,attrs:{shape:E}}),t.disposeIntermediateTensorInfo(R)}return t.disposeIntermediateTensorInfo(o),h!=null&&t.disposeIntermediateTensorInfo(p),S}const ESe={kernelName:F_,backendName:"cpu",kernelFunc:_A};function MSe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,a=e,{allDims:r,summedDims:o,idDims:l}=Kk(i,a.length);Jk(r.length,l,a);const{path:c,steps:h}=Zk(o,l),d=h.length;let p=null,g=r.length;const v=[];for(let _=0;_<d;++_){for(const S of h[_]){const{permutationIndices:b,expandDims:w}=Yk(g,l[S]);let T;Qk(b)?T=a[S]:(T=Io({inputs:{x:a[S]},backend:t,attrs:{perm:b}}),v.push(T));const E=T.shape.slice();for(let R=0;R<w.length;++R)E.splice(w[R],0,1);as(T.shape,E)||(T=oi({inputs:{x:T},backend:t,attrs:{shape:E}}),v.push(T)),p===null?p=T:(p=HN({inputs:{a:T,b:p},backend:t}),v.push(p))}_<d-1&&(c[_]>=0&&(p=_A({inputs:{x:p},backend:t,attrs:{axis:c[_]-(r.length-g),keepDims:!1}}),v.push(p)),g--)}for(const _ of v)_!==p&&t.disposeIntermediateTensorInfo(_);return p}const NSe={kernelName:nM,backendName:"cpu",kernelFunc:MSe};function RSe(n){const{inputs:e,backend:t}=n,{dy:s,y:i}=e;rn([s,i],"eluGrad");const a=new Float32Array(qe(i.shape)),r=t.data.get(i.dataId).values,o=t.data.get(s.dataId).values;for(let l=0;l<r.length;++l){const c=r[l];c>=0?a[l]=o[l]:a[l]=o[l]*(c+1)}return t.makeTensorInfo(i.shape,"float32",a)}const ISe={kernelName:sM,backendName:"cpu",kernelFunc:RSe};const DSe=Gk,OSe=Vk,BSe=Hk,kSe=Wk,LSe=jk,FSe=Xk,USe=Hs(Dy,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+DSe*t);return e*(1-((((FSe*s+LSe)*s+kSe)*s+BSe)*s+OSe)*s*Math.exp(-t*t))}),PSe={kernelName:Dy,backendName:"cpu",kernelFunc:USe};function VE(n){const{inputs:e,backend:t,attrs:s}=n,{input:i}=e,{dim:a}=s,r=i.shape.length,o=i.shape.slice();let l=a;return a<0&&(ee(-(r+1)<=a,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),l=r+a+1),o.splice(l,0,1),oi({inputs:{x:i},backend:t,attrs:{shape:o}})}const zSe={kernelName:r_,backendName:"cpu",kernelFunc:VE};const $Se=Yi((n,e)=>n/e),BL=Sa(Ry,$Se),FD={kernelName:Ry,backendName:"cpu",kernelFunc:BL};function QW(n,e,t){const s=n.shape,i=s[0],a=s[1],r=t.data.get(n.dataId),o=r.complexTensorInfos.real,l=r.complexTensorInfos.imag,c=[i,a],h=qe(c),d=ka("float32",h),p=ka("float32",h);for(let S=0;S<i;S++){const b=Sg({inputs:{x:o},backend:t,attrs:{begin:[S,0],size:[1,a]}}),w=Sg({inputs:{x:l},backend:t,attrs:{begin:[S,0],size:[1,a]}}),T=Ko({inputs:{real:b,imag:w},backend:t}),{real:E,imag:R}=GSe(T,e,t),D=vd(E,R);for(let F=0;F<a;F++){const U=qk(D,F);d[S*a+F]=U.real,p[S*a+F]=U.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(T)}const g=t.makeTensorInfo(c,"float32",d),v=t.makeTensorInfo(c,"float32",p),_=Ko({inputs:{real:g,imag:v},backend:t});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),_}function GSe(n,e,t){const s=qe(n.shape),i=t.data.get(n.dataId),a=t.data.get(i.complexTensorInfos.real.dataId).values,r=t.data.get(i.complexTensorInfos.imag.dataId).values;if(VSe(s)){const o=UD(a,r,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",o.real),h=t.makeTensorInfo(l,"float32",o.imag),d=t.makeTensorInfo([],"float32",Ad(s,"float32")),p=dh({inputs:{x:d},backend:t}),g=FD.kernelFunc({inputs:{a:c,b:d},backend:t}),v=FD.kernelFunc({inputs:{a:h,b:p},backend:t}),_=t.data.get(g.dataId).values,S=t.data.get(v.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),{real:_,imag:S}}return o}else{const o=vd(a,r),l=HSe(o,s,e);return l8(l)}}function VSe(n){return(n&n-1)===0}function UD(n,e,t,s,i){if(t===1)return{real:n,imag:e};const a=vd(n,e),r=t/2,o=c8(a),l=o.real,c=o.imag,h=[l.length],d=i.makeTensorInfo(h,"float32",l),p=i.makeTensorInfo(h,"float32",c),g=Ko({inputs:{real:d,imag:p},backend:i}),v=u8(a),_=v.real,S=v.imag,b=[_.length],w=i.makeTensorInfo(b,"float32",_),T=i.makeTensorInfo(b,"float32",S),E=Ko({inputs:{real:w,imag:T},backend:i}),R=UD(l,c,r,s,i),D=R.real,F=R.imag,U=[D.length],O=i.makeTensorInfo(U,"float32",D),B=i.makeTensorInfo(U,"float32",F),L=Ko({inputs:{real:O,imag:B},backend:i}),H=UD(_,S,r,s,i),K=H.real,Z=H.imag,Q=[K.length],P=i.makeTensorInfo(Q,"float32",K),W=i.makeTensorInfo(Q,"float32",Z),q=Ko({inputs:{real:P,imag:W},backend:i}),se=d8(t,s),le=[se.real.length],Y=i.makeTensorInfo(le,"float32",se.real),re=i.makeTensorInfo(le,"float32",se.imag),he=Ko({inputs:{real:Y,imag:re},backend:i}),me=HN({inputs:{a:he,b:q},backend:i}),Ne=ey({inputs:{a:L,b:me},backend:i}),fe=DL({inputs:{a:L,b:me},backend:i}),Te=bg({inputs:{input:Ne},backend:i}),Ge=bg({inputs:{input:fe},backend:i}),nt=ty({inputs:{input:Ne},backend:i}),yt=ty({inputs:{input:fe},backend:i}),Dt=ny({inputs:[Te,Ge],backend:i,attrs:{axis:0}}),qt=ny({inputs:[nt,yt],backend:i,attrs:{axis:0}}),Bt=i.data.get(Dt.dataId).values,Je=i.data.get(qt.dataId).values;return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(W),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(re),i.disposeIntermediateTensorInfo(he),i.disposeIntermediateTensorInfo(me),i.disposeIntermediateTensorInfo(Ne),i.disposeIntermediateTensorInfo(fe),i.disposeIntermediateTensorInfo(Te),i.disposeIntermediateTensorInfo(nt),i.disposeIntermediateTensorInfo(Ge),i.disposeIntermediateTensorInfo(yt),i.disposeIntermediateTensorInfo(Dt),i.disposeIntermediateTensorInfo(qt),{real:Bt,imag:Je}}function HSe(n,e,t){const s=new Float32Array(e*2);for(let i=0;i<e;i++){let a=0,r=0;for(let o=0;o<e;o++){const l=f8(i*o,e,t),c=qk(n,o);a+=c.real*l.real-c.imag*l.imag,r+=c.real*l.imag+c.imag*l.real}t&&(a/=e,r/=e),h8(s,a,r,i)}return s}function WSe(n){const{inputs:e,backend:t}=n,{input:s}=e,i=qe(s.shape),a=s.shape[s.shape.length-1],r=i/a,o=oi({inputs:{x:s},backend:t,attrs:{shape:[r,a]}}),l=QW(o,!1,t),c=oi({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const jSe={kernelName:iM,backendName:"cpu",kernelFunc:WSe};function kL(n){const{backend:e,attrs:t}=n,{shape:s,value:i,dtype:a}=t,r=a||Mg(i),o=Ui(r,qe(s));return qSe(o,i,r),e.makeTensorInfo(s,r,o)}const XSe={kernelName:aM,backendName:"cpu",kernelFunc:kL};function qSe(n,e,t){n.fill(e)}const KSe={kernelName:rM,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,i=t,a=ka(s.dtype,qe(s.shape)),[r,o,l,c]=s.shape,h=i.data.get(s.dataId).values;for(let p=0;p<r;p++){const g=p*l*o*c;for(let v=0;v<o;v++){const _=v*(l*c);for(let S=0;S<l;S++){const b=S*c;for(let w=0;w<c;w++){const T=Math.round(l-S-1),E=g+_+b+w;let R=h[E];if(T>=0&&T<l){const D=T*c,F=g+_+D+w;R=h[F]}a[E]=R}}}}return{dataId:i.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function YSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a,bias:r,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:g,leakyreluAlpha:v}=s;let _=JW({inputs:{x:i,filter:a},backend:t,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(r){const S=_;if(h==="NCHW"&&r.shape.length===1&&r.shape[0]!==1){const b=oi({inputs:{x:r},backend:t,attrs:{shape:[r.shape[0],1,1]}});_=ey({inputs:{a:_,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else _=ey({inputs:{a:_,b:r},backend:t});t.disposeIntermediateTensorInfo(S)}if(g){const S=_;if(h==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const b=oi({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});_=GE(t,_,g,b,v),t.disposeIntermediateTensorInfo(b)}else _=GE(t,_,g,o,v);t.disposeIntermediateTensorInfo(S)}return _}const JSe={kernelName:iS,backendName:"cpu",kernelFunc:YSe};function ZSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a,bias:r,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:g,leakyreluAlpha:v}=s;let _=ZW({inputs:{x:i,filter:a},backend:t,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(r){const S=_;_=ey({inputs:{a:_,b:r},backend:t}),t.disposeIntermediateTensorInfo(S)}if(g){const S=_;_=GE(t,_,g,o,v),t.disposeIntermediateTensorInfo(S)}return _}const QSe={kernelName:aS,backendName:"cpu",kernelFunc:ZSe};function e_e(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,a=qe(s.shape),r=i.shape,o=r[r.length-1],[l,c,h,d]=MN(s,i);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const p=t.data.get(i.dataId).values,g=t.bufferSync(s),v=cW(p,g,s.dtype,c,o,h,d,s.shape,a);return t.makeTensorInfo(l,s.dtype,v.values)}const t_e={kernelName:oM,backendName:"cpu",kernelFunc:e_e};function n_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:a}=e,{axis:r,batchDims:o}=s;rn([i,a],"gatherV2");const l=es(r,i.shape)[0],c=t.data.get(a.dataId).values,h=i.shape[l];for(let E=0;E<c.length;++E){const R=c[E];ee(R<=h-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${h-1}]`)}let d=o;o==null&&(d=0);const p=qe(a.shape),g=tL(i,a,l,d),v=oi({inputs:{x:i},backend:t,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),_=oi({inputs:{x:a},backend:t,attrs:{shape:[g.batchSize,p/g.batchSize]}}),S=[g.batchSize,g.outerSize,p/g.batchSize,g.sliceSize],b=t.bufferSync(_),w=t.bufferSync(v),T=uW(w,b,S);return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(g.outputShape,T.dtype,T.values)}const s_e={kernelName:l_,backendName:"cpu",kernelFunc:n_e};function i_e(n){const{inputs:e,backend:t}=n,{input:s}=e,i=qe(s.shape),a=s.shape[s.shape.length-1],r=i/a,o=oi({inputs:{x:s},backend:t,attrs:{shape:[r,a]}}),l=QW(o,!0,t),c=oi({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const a_e={kernelName:lM,backendName:"cpu",kernelFunc:i_e};const r_e=Hs(Py,n=>Number.isFinite(n)?1:0,"bool"),o_e={kernelName:Py,backendName:"cpu",kernelFunc:r_e};const l_e=Hs(zy,n=>Math.abs(n)===1/0?1:0,"bool"),c_e={kernelName:zy,backendName:"cpu",kernelFunc:l_e};const u_e=Hs($y,n=>Number.isNaN(n)?1:0,"bool"),h_e={kernelName:$y,backendName:"cpu",kernelFunc:u_e};function d_e(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:a}=t,r=mW(s,i,a);return e.makeTensorInfo([r.length],"float32",r)}const f_e={kernelName:uM,backendName:"cpu",kernelFunc:d_e};const p_e=Hs(Vy,n=>Math.log1p(n)),m_e={kernelName:Vy,backendName:"cpu",kernelFunc:p_e};const g_e=Yi((n,e)=>n&&e),x_e=Sa(f_,g_e,null,"bool"),y_e={kernelName:f_,backendName:"cpu",kernelFunc:x_e};const v_e=Hs(p_,n=>n?0:1,"bool"),b_e={kernelName:p_,backendName:"cpu",kernelFunc:v_e};const S_e=Yi((n,e)=>n||e),__e=Sa(m_,S_e,null,"bool"),A_e={kernelName:m_,backendName:"cpu",kernelFunc:__e};function w_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:a,bias:r,alpha:o,beta:l}=s;rn(i,"LRN");const c=i.shape[3],h=c-1,d=t.data.get(i.dataId).values,p=qe(i.shape),g=new Float32Array(p);function v(_){const S=_%c;let b=_-S+Math.max(0,S-a);const w=_-S+Math.min(S+a,h);let T=0;for(;b<=w;b++){const E=d[b];T+=E*E}return T}for(let _=0;_<p;_++){const S=v(_),b=d[_]*Math.pow(r+o*S,-l);g[_]=b}return t.makeTensorInfo(i.shape,i.dtype,g)}const C_e={kernelName:g_,backendName:"cpu",kernelFunc:w_e};function T_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:a,dy:r}=e,{depthRadius:o,bias:l,alpha:c,beta:h}=s;rn(r,"LRNGrad");const d=qe(r.shape),p=r.shape[3],g=t.data.get(r.dataId).values,v=t.data.get(i.dataId).values,_=t.data.get(a.dataId).values,S=new Float32Array(d),b=d;for(let w=0;w<b;w++){const T=w%p,E=w-T+Math.max(0,T-o),R=w-T+Math.min(p,T+o+1);let D=0;for(let F=E;F<R;F++)D+=Math.pow(v[F],2);D=c*D+l;for(let F=E;F<R;F++){let U=-2*c*h*v[F]*_[w]/D;w===F&&(U+=Math.pow(D,-h)),U*=g[w],S[F]+=U}}return t.makeTensorInfo(r.shape,i.dtype,S)}const E_e={kernelName:hM,backendName:"cpu",kernelFunc:T_e};function ej(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:a,keepDims:r}=s,o=t;let l=i.shape;const c=l.length,h=es(a,l);let d=h;const p=Mi(d,c);let g=o.data.get(i.dataId).values;if(p!=null){const E=new Array(c);for(let R=0;R<E.length;R++)E[R]=l[p[R]];g=RL(g,l,i.dtype,p,E),d=qi(d.length,c),l=E}rn(i,"max"),ir("max",d,c);const[v,_]=Ua(l,d),S=qe(_),b=xW(g,S,v,i.dtype),w=o.write(b,v,i.dtype);let T=v;return r&&(T=Xi(v,h)),{dataId:w,shape:T,dtype:i.dtype}}const M_e={kernelName:x_,backendName:"cpu",kernelFunc:ej};function N_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;rn(i,"maxPool");const{filterSize:a,strides:r,pad:o,dimRoundingMode:l}=s,c=1;ee(sr(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const h=uc(i.shape,a,r,c,o,l);let d;if(h.filterWidth===1&&h.filterHeight===1&&as(h.inShape,h.outShape))d=dh({inputs:{x:i},backend:t});else{const p=t.data.get(i.dataId).values,g=gn(i.shape),v=OL(p,i.shape,i.dtype,g,h,"max");d=t.makeTensorInfo(h.outShape,i.dtype,v.values)}return d}const R_e={kernelName:y_,backendName:"cpu",kernelFunc:N_e};function I_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:a,strides:r,pad:o,dimRoundingMode:l,dataFormat:c}=s;rn(i,"maxPool3d");const h=wd(i.shape,a,r,1,o,l,c),d=t.data.get(i.dataId).values,p=YW(d,i.shape,i.dtype,gn(i.shape),h,"max");return t.makeTensorInfo(p.shape,"float32",p.values)}const D_e={kernelName:v_,backendName:"cpu",kernelFunc:I_e};function O_e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a}=e,{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=s;rn([i,a],"maxPool3DGrad");const h=wd(a.shape,r,o,1,l,c),d=t.bufferSync(a),p=S1e(d,h),g=h.strideDepth,v=h.strideHeight,_=h.strideWidth,S=h.dilationDepth,b=h.dilationHeight,w=h.dilationWidth,T=h.effectiveFilterDepth,E=h.effectiveFilterHeight,R=h.effectiveFilterWidth,D=T-1-h.padInfo.front,F=R-1-h.padInfo.left,U=E-1-h.padInfo.top,O=Hn(a.shape,"float32"),B=t.bufferSync(i);for(let L=0;L<h.batchSize;++L)for(let H=0;H<h.inChannels;++H)for(let K=0;K<h.inDepth;++K)for(let Z=0;Z<h.inHeight;++Z)for(let Q=0;Q<h.inWidth;++Q){const P=K-D,W=Z-U,q=Q-F;let se=0;for(let le=0;le<T;le+=S){const Y=(P+le)/g;if(!(Y<0||Y>=h.outDepth||Math.floor(Y)!==Y))for(let re=0;re<E;re+=b){const he=(W+re)/v;if(!(he<0||he>=h.outHeight||Math.floor(he)!==he))for(let me=0;me<R;me+=w){const Ne=(q+me)/_;if(Ne<0||Ne>=h.outWidth||Math.floor(Ne)!==Ne)continue;const fe=T*E*R-1-p.get(L,Y,he,Ne,H),Te=le*E*R+re*R+me,Ge=fe===Te?1:0;if(Ge===0)continue;const nt=B.get(L,Y,he,Ne,H);se+=nt*Ge}}}O.set(se,L,K,Z,Q,H)}return t.makeTensorInfo(O.shape,O.dtype,O.values)}const B_e={kernelName:fM,backendName:"cpu",kernelFunc:O_e};function k_e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a,output:r}=e,o=a;rn([a,r],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=uc(o.shape,l,c,1,h,d),g=t.data.get(o.dataId).values,v=Hn(p.outShape,o.dtype,KW(g,o.shape,o.dtype,p).values),_=p.strideHeight,S=p.strideWidth,b=p.dilationHeight,w=p.dilationWidth,T=p.effectiveFilterHeight,E=p.effectiveFilterWidth,R=E-1-p.padInfo.left,D=T-1-p.padInfo.top,F=Hn(o.shape,"float32"),U=t.data.get(i.dataId).values,O=Hn(i.shape,"float32",U);for(let B=0;B<p.batchSize;++B)for(let L=0;L<p.inChannels;++L)for(let H=0;H<p.inHeight;++H)for(let K=0;K<p.inWidth;++K){const Z=H-D,Q=K-R;let P=0;for(let W=0;W<T;W+=b){const q=(Z+W)/_;if(!(q<0||q>=p.outHeight||Math.floor(q)!==q))for(let se=0;se<E;se+=w){const le=(Q+se)/S;if(le<0||le>=p.outWidth||Math.floor(le)!==le)continue;const Y=T*E-1-v.get(B,q,le,L),re=W*E+se,he=Y===re?1:0;if(he===0)continue;const me=O.get(B,q,le,L);P+=me*he}}F.set(P,B,H,K,L)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const L_e={kernelName:dM,backendName:"cpu",kernelFunc:k_e};function F_e(n,e,t,s,i){const a=gn(e),r=OL(n,e,t,a,i,"max"),o=KW(n,e,t,i,!0,s);return[r.values,o.values]}const U_e={kernelName:pM,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:a,pad:r,includeBatchInIndex:o}=e,l=t;rn(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,h=uc(s.shape,i,a,[1,1],r),[d,p]=F_e(c,s.shape,s.dtype,o,h),g=l.write(d,h.outShape,s.dtype),v=l.write(p,h.outShape,s.dtype);return[{dataId:g,shape:h.outShape,dtype:s.dtype},{dataId:v,shape:h.outShape,dtype:"int32"}]}};function P_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s,o=es(a,i.shape),c=Ua(i.shape,o)[1],h=qe(c),d=[],p=t.makeTensorInfo([],"float32",new Float32Array([h]));d.push(p);const g=Qf({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});d.push(g);const v=BL({inputs:{a:g,b:p},backend:t});d.push(v);const _=_A({inputs:{x:v},backend:t,attrs:{axis:a,keepDims:r}});return d.forEach(S=>t.disposeIntermediateTensorInfo(S)),_}const z_e={kernelName:b_,backendName:"cpu",kernelFunc:P_e};function $_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s;rn(i,"min");const o=es(a,i.shape);let l=o;const c=Mi(l,i.shape.length);let h=i;c!=null&&(h=Io({inputs:{x:i},backend:t,attrs:{perm:c}}),l=qi(l.length,i.shape.length)),ir("min",l,h.shape.length);const[d,p]=Ua(h.shape,l),g=qe(p),v=tr(qe(d),h.dtype),_=t.data.get(h.dataId).values;for(let b=0;b<v.length;++b){const w=b*g;let T=_[w];for(let E=0;E<g;++E){const R=_[w+E];(Number.isNaN(R)||R<T)&&(T=R)}v[b]=T}c!=null&&t.disposeIntermediateTensorInfo(h);const S=t.makeTensorInfo(d,h.dtype,v);if(r){const b=Xi(d,o),w=oi({inputs:{x:S},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(S),w}return S}const G_e={kernelName:S_,backendName:"cpu",kernelFunc:$_e};function V_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:a,mode:r}=s;rn(i,"mirrorPad");const o=a.map((T,E)=>T[0]+i.shape[E]+T[1]),l=a.map(T=>T[0]),c=a.map((T,E)=>T[0]+i.shape[E]),h=r==="reflect"?0:1,d=t.data.get(i.dataId).values,p=i.shape.length,g=gn(i.shape),v=qe(o),_=o.length,S=gn(o),b=ka(i.dtype,v);for(let T=0;T<v;T++){let E=Ng(T,_,S);for(let D=0;D<_;D++)E[D]<l[D]?E[D]=l[D]*2-E[D]-h:E[D]>=c[D]&&(E[D]=(c[D]-1)*2-E[D]+h);E=E.map((D,F)=>D-l[F]);const R=Kc(E,p,g);b[T]=d[R]}return{dataId:t.write(b,o,i.dtype),shape:o,dtype:i.dtype}}const H_e={kernelName:__,backendName:"cpu",kernelFunc:V_e};const W_e=Yi(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),j_e=Sa(jy,W_e),X_e={kernelName:jy,backendName:"cpu",kernelFunc:j_e};function tj(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:a}=s,r=i.shape.length;let o=a;if(o===-1&&(o=r-1),o!==r-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${r} and dim was ${o}`);const l=es([o],i.shape),c=ej({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),h=Xi(c.shape,l),d=oi({inputs:{x:c},backend:t,attrs:{shape:h}}),p=DL({inputs:{a:i,b:d},backend:t}),g=aW({inputs:{x:p},backend:t}),v=_A({inputs:{x:g},backend:t,attrs:{axis:l,keepDims:!1}}),_=oi({inputs:{x:v},backend:t,attrs:{shape:h}}),S=BL({inputs:{a:g,b:_},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(_),S}const q_e={kernelName:z_,backendName:"cpu",kernelFunc:tj};function K_e(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:a,seed:r,normalized:o}=s;rn(i,"multinomial");const l=o?i:tj({inputs:{logits:i},backend:t,attrs:{dim:-1}}),c=l.shape[0],h=l.shape[1],d=t.data.get(l.dataId).values,p=[c,a],g=tr(qe(p),"int32");for(let v=0;v<c;++v){const _=v*h,S=new Float32Array(h-1);S[0]=d[_];for(let T=1;T<S.length;++T)S[T]=S[T-1]+d[_+T];const b=sN.alea(r.toString()),w=v*a;for(let T=0;T<a;++T){const E=b();g[w+T]=S.length;for(let R=0;R<S.length;R++)if(E<S[R]){g[w+T]=R;break}}}return o||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(p,"int32",g)}const Y_e={kernelName:mM,backendName:"cpu",kernelFunc:K_e};const J_e=wN;function Z_e(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:a}=e,{maxOutputSize:r,iouThreshold:o,scoreThreshold:l}=s;rn(i,"NonMaxSuppression");const c=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,{selectedIndices:d}=J_e(c,h,r,o,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const Q_e={kernelName:gM,backendName:"cpu",kernelFunc:Z_e};const eAe=CN;function tAe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:a}=e,{maxOutputSize:r,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s;rn(i,"NonMaxSuppressionPadded");const h=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values,{selectedIndices:p,validOutputs:g}=eAe(h,d,r,o,l,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const nAe={kernelName:xM,backendName:"cpu",kernelFunc:tAe};const sAe=TN;function iAe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:a}=e,{maxOutputSize:r,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s;rn(i,"NonMaxSuppressionWithScore");const h=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values,p=r,g=o,v=l,_=c,{selectedIndices:S,selectedScores:b}=sAe(h,d,p,g,v,_);return[t.makeTensorInfo([S.length],"int32",new Int32Array(S)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const aAe={kernelName:yM,backendName:"cpu",kernelFunc:iAe};function rAe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:a,depth:r,onValue:o,offValue:l}=s;rn(i,"oneHot");const c=qe(i.shape),h=new Float32Array(c*r);h.fill(l);const d=t.data.get(i.dataId).values;for(let p=0;p<c;++p)d[p]>=0&&d[p]<r&&(h[p*r+d[p]]=o);return t.makeTensorInfo([...i.shape,r],a,h)}const oAe={kernelName:T_,backendName:"cpu",kernelFunc:rAe};function HE(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=bg({inputs:{input:s},backend:t}),a=HE({inputs:{x:i},backend:t}),r=ty({inputs:{input:s},backend:t}),o=HE({inputs:{x:r},backend:t}),l=Ko({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),l}else return kL({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const lAe={kernelName:H_,backendName:"cpu",kernelFunc:HE};function nj(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=bg({inputs:{input:s},backend:t}),a=nj({inputs:{x:i},backend:t}),r=ty({inputs:{input:s},backend:t}),o=HE({inputs:{x:r},backend:t}),l=Ko({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),l}else return kL({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const cAe={kernelName:C_,backendName:"cpu",kernelFunc:nj};function sj(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return VE({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const a=e[0].shape,r=e[0].dtype;e.forEach(h=>{nr(a,h.shape,"All tensors passed to stack must have matching shapes"),ee(r===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(h=>{const d=VE({inputs:{input:h},backend:t,attrs:{dim:i}});return o.push(d),d}),c=ny({inputs:l,backend:t,attrs:{axis:i}});return o.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const uAe={kernelName:E_,backendName:"cpu",kernelFunc:sj};function hAe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:a,constantValue:r}=s;rn(i,"pad");const o=a.map((w,T)=>w[0]+i.shape[T]+w[1]),l=a.map(w=>w[0]),c=t.data.get(i.dataId).values,h=qe(i.shape),d=i.shape.length,p=gn(i.shape),g=qe(o),v=o.length,_=gn(o),S=ka(i.dtype,g);r!==0&&S.fill(r);for(let w=0;w<h;w++){const E=Ng(w,d,p).map((D,F)=>D+l[F]),R=Kc(E,v,_);S[R]=c[w]}return{dataId:t.write(S,o,i.dtype),shape:o,dtype:i.dtype}}const ij={kernelName:M_,backendName:"cpu",kernelFunc:hAe};const dAe=Yi((n,e)=>Math.pow(n,e)),fAe=Sa(qy,dAe),pAe={kernelName:qy,backendName:"cpu",kernelFunc:fAe};function mAe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:a,indices:r}=e,{outputRaggedRank:o}=s,l=i.map(b=>t.data.get(b.dataId).values),c=i.map(b=>b.shape),h=t.data.get(a.dataId).values,d=t.data.get(r.dataId).values,[p,g,v]=AW(l,c,h,a.shape,a.dtype,d,r.shape),_=p.map(b=>t.makeTensorInfo([b.length],"int32",b)),S=t.makeTensorInfo(v,a.dtype,g);return _.concat([S])}const gAe={kernelName:vM,backendName:"cpu",kernelFunc:mAe};function xAe(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:a}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values,[c,h]=wW(r,s.shape,s.dtype,o,i.shape,l,a.shape),d=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([h.length],s.dtype,h);return[d,p]}const yAe={kernelName:bM,backendName:"cpu",kernelFunc:xAe};function vAe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:a,defaultValue:r,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(r.dataId).values,p=o.map(S=>t.data.get(S.dataId).values),g=o.map(S=>S.shape),[v,_]=CW(c,i.shape,h,a.shape,a.dtype,d,r.shape,p,g,l);return t.makeTensorInfo(v,a.dtype,_)}const bAe={kernelName:SM,backendName:"cpu",kernelFunc:vAe};function SAe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,dtype:a,step:r}=t,o=TW(s,i,r,a);return e.makeTensorInfo([o.length],a,o)}const _Ae={kernelName:_M,backendName:"cpu",kernelFunc:SAe};const AAe=Hs(Ky,n=>1/n),wAe={kernelName:Ky,backendName:"cpu",kernelFunc:AAe};function CAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:a,halfPixelCenters:r,size:o}=s;rn(i,"resizeBilinear");const l=gn(i.shape),[c,h]=o,[d,p,g,v]=i.shape,_=t.data.get(i.dataId).values,S=new Float32Array(qe([d,c,h,v])),b=[a&&c>1?p-1:p,a&&h>1?g-1:g],w=[a&&c>1?c-1:c,a&&h>1?h-1:h];let T=0;const E=b[0]/w[0],R=b[1]/w[1];for(let D=0;D<d;D++)for(let F=0;F<c;F++){let U;r?U=E*(F+.5)-.5:U=E*F;const O=Math.max(0,Math.floor(U)),B=U-O,L=Math.min(p-1,Math.ceil(U)),H=D*l[0]+O*l[1],K=D*l[0]+L*l[1];for(let Z=0;Z<h;Z++){let Q;r?Q=R*(Z+.5)-.5:Q=R*Z;const P=Math.max(0,Math.floor(Q)),W=Q-P,q=Math.min(g-1,Math.ceil(Q)),se=H+P*l[2],le=K+P*l[2],Y=H+q*l[2],re=K+q*l[2];for(let he=0;he<v;he++){const me=_[se+he],Ne=_[le+he],fe=_[Y+he],Te=_[re+he],Ge=me+(fe-me)*W,nt=Ne+(Te-Ne)*W,yt=Ge+(nt-Ge)*B;S[T++]=yt}}}return t.makeTensorInfo([d,c,h,v],"float32",S)}const TAe={kernelName:O_,backendName:"cpu",kernelFunc:CAe};function EAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:a}=e,{alignCorners:r}=s;rn([a,i],"resizeBilinearGrad");const o=gn(i.shape),[l,c,h,d]=i.shape,[,p,g]=a.shape,v=new Float32Array(l*c*h*d),_=[r&&p>1?c-1:c,r&&g>1?h-1:h],S=[r&&p>1?p-1:p,r&&g>1?g-1:g],b=_[0]/S[0],w=_[1]/S[1],T=t.data.get(a.dataId).values;let E=0;for(let R=0;R<l;R++){const D=R*o[0];for(let F=0;F<p;F++){const U=F*b,O=Math.floor(U),B=Math.min(Math.ceil(U),c-1),L=D+O*o[1],H=D+B*o[1],K=U-O,Z=1-K;for(let Q=0;Q<g;Q++){const P=Q*w,W=Math.floor(P),q=Math.min(Math.ceil(P),h-1),se=P-W,le=1-se,Y=L+W*o[2],re=L+q*o[2],he=H+W*o[2],me=H+q*o[2],Ne=Z*le,fe=Z*se,Te=K*le,Ge=K*se;for(let nt=0;nt<d;nt++){const yt=T[E++];v[Y+nt]+=yt*Ne,v[re+nt]+=yt*fe,v[he+nt]+=yt*Te,v[me+nt]+=yt*Ge}}}}return t.makeTensorInfo([l,h,c,d],"float32",v)}const MAe={kernelName:CM,backendName:"cpu",kernelFunc:EAe};function NAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:a,halfPixelCenters:r,size:o}=s;rn(i,"resizeNearestNeighbor");const l=gn(i.shape),[c,h]=o,[d,p,g,v]=i.shape,_=t.data.get(i.dataId).values,S=new Float32Array(d*c*h*v),b=[a&&c>1?p-1:p,a&&h>1?g-1:g],w=[a&&c>1?c-1:c,a&&h>1?h-1:h],T=b[0]/w[0],E=b[1]/w[1];let R=0;for(let D=0;D<d;D++){const F=D*l[0];for(let U=0;U<c;U++){const O=r?T*(U+.5):T*U;let B=Math.min(p-1,a?Math.round(O):Math.floor(O));r&&(B=Math.max(0,B));const L=F+B*l[1];for(let H=0;H<h;H++){const K=r?E*(H+.5):E*H;let Z=Math.min(g-1,a?Math.round(K):Math.floor(K));r&&(Z=Math.max(0,Z));const Q=L+Z*l[2];for(let P=0;P<v;P++){const W=_[Q+P];S[R++]=W}}}}return t.makeTensorInfo([d,c,h,v],i.dtype,S)}const RAe={kernelName:D_,backendName:"cpu",kernelFunc:NAe};function IAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:a}=e,{alignCorners:r}=s;rn([a,i],"resizeNearestNeighborGrad");const o=gn(i.shape),l=gn(a.shape),[c,h,d,p]=i.shape,[,g,v]=a.shape,_=new Float32Array(c*h*d*p),S=t.data.get(a.dataId).values,b=[r&&g>1?h-1:h,r&&v>1?d-1:d],w=[r&&g>1?g-1:g,r&&v>1?v-1:v],T=b[0]/w[0],E=b[1]/w[1],R=1/T,D=1/E,F=Math.ceil(R)*2+2,U=Math.ceil(D)*2+2;for(let O=0;O<c;O++){const B=O*o[0];for(let L=0;L<h;L++){const H=B+L*o[1],K=Math.floor(L*R),Z=Math.floor(K-F/2);for(let Q=0;Q<d;Q++){const P=H+Q*o[2],W=Math.floor(Q*D),q=Math.floor(W-U/2);for(let se=0;se<p;se++){let le=0;for(let Y=0;Y<F;Y++){const re=Y+Z;if(re<0||re>=g)continue;const he=B+re*l[1],me=re*T,Ne=Math.min(h-1,r?Math.round(me):Math.floor(me));if(L===Ne)for(let fe=0;fe<U;fe++){const Te=fe+q;if(Te<0||Te>=v)continue;const Ge=he+Te*l[2],nt=Te*E,yt=Math.min(d-1,r?Math.round(nt):Math.floor(nt));Q===yt&&(le+=S[Ge+se])}}_[P+se]=le}}}}return t.makeTensorInfo(i.shape,i.dtype,_)}const DAe={kernelName:wM,backendName:"cpu",kernelFunc:IAe};function OAe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:a}=s;rn(i,"reverse");const r=i.shape.length,o=es(a,i.shape);if(r===0)return dh({inputs:{x:i},backend:t});const l=new oa(i.shape,i.dtype),c=t.bufferSync(i);for(let h=0;h<l.size;h++){const d=l.indexToLoc(h),p=d.slice();o.forEach(g=>p[g]=i.shape[g]-1-p[g]),l.set(c.get(...p),...d)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const BAe={kernelName:B_,backendName:"cpu",kernelFunc:OAe};const kAe={kernelName:GM,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:a,center:r}=e,o=t,l=ka(s.dtype,qe(s.shape)),[c,h,d,p]=s.shape,[g,v]=Pk(r,h,d),_=255,S=Math.sin(i),b=Math.cos(i),w=o.data.get(s.dataId).values;for(let E=0;E<c;E++){const R=E*d*h*p;for(let D=0;D<h;D++){const F=D*(d*p);for(let U=0;U<d;U++){const O=U*p;for(let B=0;B<p;B++){const L=[c,D,U,B],H=L[2],K=L[1];let Z=(H-g)*b-(K-v)*S,Q=(H-g)*S+(K-v)*b;Z=Math.round(Z+g),Q=Math.round(Q+v);let P=a;if(typeof a!="number"&&(B===3?P=_:P=a[B]),Z>=0&&Z<d&&Q>=0&&Q<h){const q=Q*(d*p),se=Z*p,le=R+q+se+B;P=w[le]}const W=R+F+O+B;l[W]=P}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const LAe=Hs(Zy,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),FAe={kernelName:Zy,backendName:"cpu",kernelFunc:LAe};function UAe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:a}=e,{shape:r}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=dp(a,i,r),p=!0,g=t.bufferSync(i),v=t.bufferSync(a),_=Hm(g,v,r,d,c,l,o,h,0,p);return t.makeTensorInfo(r,_.dtype,_.values)}const PAe={kernelName:TM,backendName:"cpu",kernelFunc:UAe};function zAe(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<e?t=i+1:s=i;return s}function $Ae(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<=e?t=i+1:s=i;return s}function GAe(n,e,t,s,i,a){const r=Ui("int32",t*i);for(let o=0;o<t;++o){const l=n.slice(o*s,(o+1)*s),c=o*i;for(let h=0;h<i;++h)r[c+h]=a==="left"?zAe(l,e[h+c]):$Ae(l,e[h+c])}return r}function VAe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:a}=e,{side:r}=s,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values,c=GAe(o,l,i.shape[0],i.shape[1],a.shape[1],r);return t.makeTensorInfo(a.shape,"int32",c)}const HAe={kernelName:MM,backendName:"cpu",kernelFunc:VAe};function WAe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:a}=e;rn([s,i,a],"select");const r=s.shape.length,o=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(a.dataId).values,h=To(i.dtype,a.dtype),d=tr(qe(i.shape),h);let p=0;const g=r===0||r>1||i.shape.length===1?1:qe(i.shape.slice(1));for(let v=0;v<o.length;v++)for(let _=0;_<g;_++)o[v]===1?d[p++]=l[v]:d[p++]=c[v];return t.makeTensorInfo(i.shape,h,d)}const jAe={kernelName:k_,backendName:"cpu",kernelFunc:WAe};const XAe=IN,qAe=DN,KAe=Hs(ev,n=>n>=0?qAe*n:XAe*(Math.exp(n)-1)),YAe={kernelName:ev,backendName:"cpu",kernelFunc:KAe};const JAe=Hs(sv,n=>n<0?-1:n>0?1:0),ZAe={kernelName:sv,backendName:"cpu",kernelFunc:JAe};const QAe=Hs(tv,n=>Math.sin(n)),ewe={kernelName:tv,backendName:"cpu",kernelFunc:QAe};const twe=Hs(nv,n=>Math.sinh(n)),nwe={kernelName:nv,backendName:"cpu",kernelFunc:twe};const swe=11920928955078125e-23,A$=Math.log(swe)+2,iwe=Hs(av,n=>{const e=n>-A$,t=n<A$,s=Math.exp(n);let i;return t?i=s:e?i=n:i=Math.log(1+s),i}),awe={kernelName:av,backendName:"cpu",kernelFunc:iwe};function rwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:a,paddings:r}=s;rn([i],"spaceToBatchND");const o=qe(a),l=[[0,0]];l.push(...r);for(let D=1+a.length;D<i.shape.length;++D)l.push([0,0]);const c=ij.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),h=hA(c.shape,a,o,!1),d=dA(h.length,a.length,!1),p=fA(c.shape,a,o,!1),_=oi({inputs:{x:c},backend:t,attrs:{shape:h}}),w=Io({inputs:{x:_},backend:t,attrs:{perm:d}}),R=oi({inputs:{x:w},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(w),R}const owe={kernelName:U_,backendName:"cpu",kernelFunc:rwe};function lwe(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:a,defaultValue:r}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${r.shape}`);const o=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(a.dataId).values,h=t.data.get(r.dataId).values[0],[d,p,g,v,_]=RW(o,s.shape,s.dtype,l,i.dtype,c,h);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],i.dtype,g),t.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(S=>Number(S)))),t.makeTensorInfo([_.length],s.dtype,new Int32Array(_))]}const cwe={kernelName:NM,backendName:"cpu",kernelFunc:lwe};function uwe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const r=Array.from(t.data.get(i.dataId).values),o=t.data.get(s.dataId).values,l=Array.from(t.data.get(a.dataId).values),[c,h,d]=IW(o,s.shape,s.dtype,r,l);return[t.makeTensorInfo(h,s.dtype,c),t.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const hwe={kernelName:RM,backendName:"cpu",kernelFunc:uwe};function dwe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(i.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values,[c,h]=IL(r,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(h,s.dtype,c)}const fwe={kernelName:IM,backendName:"cpu",kernelFunc:dwe};function pwe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(i.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values,[c,h]=IL(r,s.shape,s.dtype,o,l);return t.makeTensorInfo(h,s.dtype,c)}const mwe={kernelName:DM,backendName:"cpu",kernelFunc:pwe};function gwe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:a,defaultValue:r}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=dp(a,i,o),g=!1,v=t.bufferSync(i);let _;switch(a.dtype){case"bool":{const S=t.bufferSync(a),b=!!t.data.get(r.dataId).values[0];_=Hm(v,S,o,p,h,c,l,d,b,g);break}case"float32":{const S=t.bufferSync(a),b=t.data.get(r.dataId).values[0];_=Hm(v,S,o,p,h,c,l,d,b,g);break}case"int32":{const S=t.bufferSync(a),b=t.data.get(r.dataId).values[0];_=Hm(v,S,o,p,h,c,l,d,b,g);break}case"string":{const S=t.bufferSync(a),b=gd(t.data.get(r.dataId).values[0]);_=Hm(v,S,o,p,h,c,l,d,b,g);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return t.makeTensorInfo(o,_.dtype,_.values)}const xwe={kernelName:OM,backendName:"cpu",kernelFunc:gwe};function ywe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:a,axis:r}=s,o=es(r,i.shape)[0],l=eL(i,a,o),c=new Array(i.shape.length).fill(0),h=i.shape.slice();return l.map(d=>{const p=[...h];p[o]=d;const g=Sg({inputs:{x:i},backend:t,attrs:{begin:c,size:p}});return c[o]+=d,g})}const vwe={kernelName:P_,backendName:"cpu",kernelFunc:ywe};const bwe={kernelName:BM,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;rn(t,"square");const i=s.data.get(t.dataId).values,a=new Float32Array(i.length);for(let o=0;o<i.length;++o){const l=i[o];a[o]=l*l}return{dataId:s.write(a,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const Swe=Hs(dv,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),_we={kernelName:dv,backendName:"cpu",kernelFunc:Swe};function Awe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:a,end:r,strides:o,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s;rn(i,"stridedSlice");const{finalShapeSparse:g,finalShape:v,isIdentity:_,sliceDim0:S,isSimpleSlice:b,begin:w,end:T,strides:E}=kk(i.shape,a,r,o,l,c,h,d,p);let R;if(_)R=oi({inputs:{x:i},backend:t,attrs:{shape:v}});else if(S||b){ee(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const D=Dk(w,T,E),F=Sg({inputs:{x:i},backend:t,attrs:{begin:w,size:D}});R=oi({inputs:{x:F},backend:t,attrs:{shape:v}}),t.disposeIntermediateTensorInfo(F)}else{const D=t.bufferSync(i),F=BW(g,D,E,w);R=t.makeTensorInfo(v,F.dtype,F.values)}return R}const wwe={kernelName:kM,backendName:"cpu",kernelFunc:Awe};function Cwe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:a,leftPad:r,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=e,p=t.data.get(h.dataId).values,g=t.data.get(d.dataId).values,[v,_]=kW(p,g,i,a,r,o,l,c);return[t.makeTensorInfo([v.length],"string",v),t.makeTensorInfo(d.shape,"int32",_)]}const Twe={kernelName:LM,backendName:"cpu",kernelFunc:Cwe};function Ewe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:a,delimiter:r}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(r.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const o=t.data.get(a.dataId).values,l=t.data.get(r.dataId).values[0],[c,h,d]=LW(o,l,i),p=h.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const Mwe={kernelName:FM,backendName:"cpu",kernelFunc:Ewe};function Nwe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const r=t.data.get(a.dataId).values,o=FW(r,i);return t.makeTensorInfo(a.shape,"int32",o)}const Rwe={kernelName:UM,backendName:"cpu",kernelFunc:Nwe};const Iwe=Hs(cv,n=>Math.tan(n)),Dwe={kernelName:cv,backendName:"cpu",kernelFunc:Iwe};const Owe=Hs(uv,n=>Math.tanh(n)),Bwe={kernelName:uv,backendName:"cpu",kernelFunc:Owe};function kwe(n){const{inputs:e,backend:t}=n,{tensor:s,indices:i,updates:a}=e,{sliceRank:r,numUpdates:o,sliceSize:l,strides:c,outputSize:h}=dp(a,i,s.shape),d=!1,p=t.bufferSync(i),g=t.bufferSync(a),v=t.bufferSync(s),_=Hm(p,g,s.shape,h,l,o,r,c,v,d);return t.makeTensorInfo(s.shape,_.dtype,_.values)}const Lwe={kernelName:EM,backendName:"cpu",kernelFunc:kwe};function Fwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:a}=s;rn(i,"tile");const r=PW(t.bufferSync(i),a);return t.makeTensorInfo(r.shape,r.dtype,r.values)}const Uwe={kernelName:hv,backendName:"cpu",kernelFunc:Fwe};function Pwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:a,sorted:r}=s;rn(i,"topk");const o=t.data.get(i.dataId).values,[l,c]=$W(o,i.shape,i.dtype,a,r);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const zwe={kernelName:PM,backendName:"cpu",kernelFunc:Pwe};function $we(n){const{inputs:e,attrs:t,backend:s}=n,{image:i,transforms:a}=e,{interpolation:r,fillMode:o,fillValue:l,outputShape:c}=t,[h,d,p,g]=i.shape,[v,_]=c??[d,p],S=[h,v,_,g],b=gn(i.shape),w=b[0],T=b[1],E=b[2],R=gn(S),D=R[0],F=R[1],U=R[2],O=ka(i.dtype,qe(S));O.fill(l);const B=s.data.get(i.dataId).values,L=s.data.get(a.dataId).values;for(let K=0;K<h;++K){const Z=a.shape[0]===1?L:L.subarray(K*8,K*8+8);for(let Q=0;Q<v;++Q)for(let P=0;P<_;++P)for(let W=0;W<g;++W){let q;const se=Z[6]*P+Z[7]*Q+1;if(se===0)continue;const le=(Z[0]*P+Z[1]*Q+Z[2])/se,Y=(Z[3]*P+Z[4]*Q+Z[5])/se,re=w$(le,p,o),he=w$(Y,d,o);switch(r){case"nearest":q=Xwe(B,d,p,w,T,E,K,he,re,W,l);break;case"bilinear":q=qwe(B,d,p,w,T,E,K,he,re,W,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${r}`)}const me=K*D+Q*F+P*U+W;O[me]=q}return s.makeTensorInfo(S,i.dtype,O)}return{dataId:s.write(O,S,i.dtype),shape:i.shape,dtype:i.dtype}}const Gwe={kernelName:zM,backendName:"cpu",kernelFunc:$we};function w$(n,e,t){switch(t){case"reflect":return Vwe(n,e);case"wrap":return Hwe(n,e);case"nearest":return jwe(n,e);case"constant":default:return Wwe(n)}}function Vwe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Gf(0,t,e-1)}function Hwe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Gf(0,t,e-1)}function Wwe(n,e){return n}function jwe(n,e){return Gf(0,n,e-1)}function R1(n,e,t,s,i,a,r,o,l,c,h){const d=r*s+o*i+l*a+c;return 0<=o&&o<e&&0<=l&&l<t?n[d]:h}function Xwe(n,e,t,s,i,a,r,o,l,c,h){const d=Math.round(o),p=Math.round(l);return R1(n,e,t,s,i,a,r,d,p,c,h)}function qwe(n,e,t,s,i,a,r,o,l,c,h){const d=Math.floor(o),p=Math.floor(l),g=d+1,v=p+1,_=(v-l)*R1(n,e,t,s,i,a,r,d,p,c,h)+(l-p)*R1(n,e,t,s,i,a,r,d,v,c,h),S=(v-l)*R1(n,e,t,s,i,a,r,g,p,c,h)+(l-p)*R1(n,e,t,s,i,a,r,g,v,c,h);return(g-o)*_+(o-d)*S}function Kwe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:a}=e;rn(a,"unique");const r=s.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:c}=GW(r,i,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const Ywe={kernelName:$M,backendName:"cpu",kernelFunc:Kwe};function Jwe(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:a}=s;a<0&&(a+=i.shape.length);const r=i.shape.length,o=i.shape[a],l=new Array(r-1);let c=0;for(let g=0;g<r;g++)g!==a&&(l[c++]=i.shape[g]);const h=new Array(r).fill(0),d=i.shape.slice();d[a]=1;const p=new Array(o);for(let g=0;g<p.length;g++){h[a]=g;const v=Sg({inputs:{x:i},backend:t,attrs:{begin:h,size:d}});p[g]=oi({inputs:{x:v},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(v)}return p}const Zwe={kernelName:G_,backendName:"cpu",kernelFunc:Jwe};function Qwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:a}=e,{numSegments:r}=s;rn(i,"unsortedSegmentSum");const o=i.shape.length,l=a.shape.length,c=[],h=[],d=o-l;let p=a;for(let v=0;v<d;++v){const _=VE({inputs:{input:p},backend:t,attrs:{dim:v+1}});p=_,h.push(_)}for(let v=0;v<r;++v){const _=Ad(v,"int32"),S=t.makeTensorInfo([],"int32",_),b=sW({inputs:{a:S,b:p},backend:t}),w=Qf({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),T=HN({inputs:{a:w,b:i},backend:t}),E=_A({inputs:{x:T},backend:t,attrs:{axis:0,keepDims:!1}});c.push(E),h.push(S),h.push(b),h.push(w),h.push(T),h.push(E)}const g=sj({inputs:c,backend:t,attrs:{axis:0}});return h.forEach(v=>t.disposeIntermediateTensorInfo(v)),g}const eCe={kernelName:V_,backendName:"cpu",kernelFunc:Qwe};const tCe=[Kbe,Nve,Jbe,Qbe,kve,t1e,s1e,a1e,o1e,c1e,h1e,f1e,m1e,y1e,b1e,A1e,C1e,E1e,N1e,Xbe,I1e,O1e,k1e,Fve,F1e,Ove,Pve,P1e,Rve,$1e,V1e,H1e,j1e,q1e,Y1e,Z1e,eSe,nSe,iSe,rSe,lSe,uSe,dSe,pSe,mSe,xSe,vSe,SSe,_Se,ASe,wSe,TSe,NSe,zbe,ISe,zve,PSe,$ve,zSe,Vve,jSe,XSe,KSe,Wve,Xve,JSe,QSe,t_e,s_e,Kve,Jve,Ive,a_e,G1e,o_e,c_e,h_e,$be,Qve,tbe,f_e,sbe,m_e,y_e,b_e,A_e,C_e,E_e,M_e,abe,R_e,D_e,B_e,L_e,U_e,z_e,G_e,obe,H_e,X_e,Y_e,cbe,hbe,Q_e,nAe,aAe,fbe,oAe,cAe,uAe,ij,pAe,Vbe,gbe,gAe,yAe,bAe,_Ae,Dve,FD,wAe,Hbe,Wbe,jbe,TAe,MAe,RAe,DAe,BAe,kAe,FAe,wbe,PAe,HAe,jAe,YAe,Tbe,ZAe,ewe,nwe,Ebe,q_e,awe,owe,cwe,hwe,fwe,mwe,xwe,vwe,Rbe,bwe,Dbe,Bbe,_we,wwe,Twe,Mwe,Rwe,Ube,ESe,Dwe,Bwe,Lwe,Uwe,zwe,Gwe,pbe,Ywe,Zwe,eCe,lAe];for(const n of tCe)VM(n);const km={},ZC={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function nCe(n,e){km[n]=e}function su(n,e){if(!(n in km)||e!=null){const s=iCe(n,e);if(s!==null)km[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=km[n];return t==null||t.isContextLost()?(delete km[n],su(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),km[n])}function sCe(n){if(!Pe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function iCe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??sCe(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete km[n]},!1),Pe().getBool("SOFTWARE_WEBGL_ENABLED")&&(ZC.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",ZC)||t.getContext("experimental-webgl",ZC):t.getContext("webgl2",ZC)}var yS;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(yS||(yS={}));var bl;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(bl||(bl={}));var Ya;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ya||(Ya={}));function AA(n,e){return[e,n]}function aCe(n,e){return n*e}function QC(n){const e=qe(n),t=Math.ceil(e/4);return vE(t)}function Sv(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function rCe(n,e){const[t,s]=Sv(n,e);return t*s*4}function LL(n,e){const t=n;let s,i,a,r,o,l,c,h,d,p;return Pe().getNumber("WEBGL_VERSION")===2?(s=t.R32F,i=t.R16F,a=t.RGBA16F,r=t.RGBA32F,o=t.RED,c=4,h=1,d=t.HALF_FLOAT,p=t.FLOAT,l=t.RGBA8):(s=n.RGBA,i=n.RGBA,a=n.RGBA,r=t.RGBA,o=n.RGBA,c=4,h=4,d=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:r,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:d,textureTypeFloat:p}}function Xt(n,e){const t=e();return Pe().getBool("DEBUG")&&oCe(n),t}function oCe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+hCe(n,e))}const lCe=596e-10,cCe=65504;function uCe(n){return!!(Pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||lCe<Math.abs(n)&&Math.abs(n)<cCe)}function hCe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function eT(n,e){return Rd(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function dCe(n,e){const t=Rd(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Xt(n,()=>n.shaderSource(t,e)),Xt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function fCe(n,e){const t=Rd(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Xt(n,()=>n.shaderSource(t,e)),Xt(n,()=>n.compileShader(t)),Pe().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw aj(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const pCe=/ERROR: [0-9]+:([0-9]+):/g;function aj(n,e){const t=pCe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],i=n.split(`
`),a=i.length.toString().length+2,r=i.map((d,p)=>qm((p+1).toString(),a)+d);let o=0;for(let d=0;d<r.length;d++)o=Math.max(r[d].length,o);const l=r.slice(0,s-1),c=r.slice(s-1,s),h=r.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${qm(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function mCe(n){return Rd(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function gCe(n,e){if(Xt(n,()=>n.linkProgram(e)),!Pe().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function m3(n,e){if(Xt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function xCe(n,e){const t=Rd(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Xt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Xt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function yCe(n,e){const t=Rd(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Xt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Xt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function vCe(n){return Rd(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function bCe(n,e){const t=Pe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function SCe(n){return Rd(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function C$(n,e,t,s,i,a,r){const o=n.getAttribLocation(e,t);return o===-1?!1:(Xt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Xt(n,()=>n.vertexAttribPointer(o,i,n.FLOAT,!1,a,r)),Xt(n,()=>n.enableVertexAttribArray(o)),!0)}function _Ce(n,e,t){ECe(n,t),Xt(n,()=>n.activeTexture(n.TEXTURE0+t)),Xt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function ACe(n,e,t){return Rd(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function wCe(n,e,t){return n.getUniformLocation(e,t)}function CCe(n,e,t,s){Xt(n,()=>_Ce(n,e,s)),Xt(n,()=>n.uniform1i(t,s))}function g3(n,e,t){Xt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Xt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function T$(n,e){Xt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Xt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function tT(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+TCe(n,e))}function TCe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Rd(n,e,t){const s=Xt(n,()=>e());if(s==null)throw new Error(t);return s}function ECe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function sy(n,e=2){return qe(n.slice(0,n.length-e))}function iy(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function nT(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[sy(n),...iy(n)]),e}function MCe(n,e=!1){let t=Pe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=Pe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&Pe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,l)=>l>=n.length-2?L2(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=_d(n).newShape);let i=qe(n),a=null;n.length<=1&&i<=t?a=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?a=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?a=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?a=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?a=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(a=[n[0],n[1]*n[2]*n[3]]);const r=a!=null&&Math.max(...a)>s&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||r)if(e){const o=sy(n);let l=2,c=2;n.length&&([l,c]=iy(n)),i=o*(l/2)*(c/2),a=vE(i).map(h=>h*2)}else a=vE(i);return a}function sT(n){return n%2===0}function WE(n,e){if(n=n.slice(-2),e=e.slice(-2),as(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||sT(t)&&sT(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&sT(n[0])&&sT(e[0])}let x3,y3;function NCe(n){if(x3==null){const e=su(n);x3=e.getParameter(e.MAX_TEXTURE_SIZE)}return x3}function RCe(n){if(y3==null){const e=su(n);y3=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,y3)}function ICe(n){if(n===0)return 0;let e;const t=su(n);return sc(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:sc(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function sc(n,e){return n.getExtension(e)!=null}function E$(n){try{if(su(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function DCe(n){if(n===0)return!1;const e=su(n);if(n===1){if(!sc(e,"OES_texture_float"))return!1}else if(!sc(e,"EXT_color_buffer_float"))return!1;return PD(e)}function OCe(n){if(n===0)return!1;const e=su(n);if(n===1){if(!sc(e,"OES_texture_float")||!sc(e,"WEBGL_color_buffer_float"))return!1}else{if(sc(e,"EXT_color_buffer_float"))return PD(e);const s="EXT_color_buffer_half_float";if(sc(e,s)){const i=e.getExtension(s);return BCe(e,i)}return!1}return PD(e)}function PD(n){const e=LL(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(a),r}function BCe(n,e){const t=LL(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(r),o}function kCe(n){return n!==2?!1:su(n).fenceSync!=null}function wA(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&ee(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const ln=Pe();ln.registerFlag("HAS_WEBGL",()=>ln.getNumber("WEBGL_VERSION")>0);ln.registerFlag("WEBGL_VERSION",()=>E$(2)?2:E$(1)?1:0);ln.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ln.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ln.get("WEBGL_VERSION")===2);ln.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ln.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ln.registerFlag("WEBGL_PACK",()=>ln.getBool("HAS_WEBGL"));ln.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_CLIP",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_REDUCE",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_LAZILY_UNPACK",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_CONV_IM2COL",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ln.getBool("WEBGL_PACK"));ln.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>NCe(ln.getNumber("WEBGL_VERSION")));ln.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>RCe(ln.getNumber("WEBGL_VERSION")));ln.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ln.getNumber("WEBGL_VERSION");return n===0?0:ICe(n)});ln.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ln.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!cB());ln.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>DCe(ln.getNumber("WEBGL_VERSION")));ln.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ln.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ln.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ln.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>OCe(ln.getNumber("WEBGL_VERSION")));ln.registerFlag("WEBGL_FENCE_API_ENABLED",()=>kCe(ln.getNumber("WEBGL_VERSION")));ln.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ln.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ln.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ln.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>cB()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ln.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ln.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ln.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ln.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ln.registerFlag("WEBGL_EXP_CONV",()=>!1);ln.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ln.getBool("IS_TEST"));ln.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ln.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ln.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ln.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Yr(){let n,e,t,s,i,a,r,o,l,c;return Pe().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",i="texture",a="outputColor",r="out vec4 outputColor;",o=Pe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",i="texture2D",a="gl_FragColor",r="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:i,output:a,defineOutput:r,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}function Fg(n,e,t="index"){const s=gn(e);return s.map((i,a)=>{const r=`int ${n[a]} = ${t} / ${i}`,o=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${i}`:`index -= ${n[a]} * ${i}`;return`${r}; ${o};`}).join("")}function WN(n,e,t="index"){const s=gn(e);return s.map((i,a)=>{const r=`int ${n[a]} = ${t} / outShapeStrides[${a}]`,o=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * outShapeStrides[${a}]`:`index -= ${n[a]} * outShapeStrides[${a}]`;return`${r}; ${o};`}).join("")}function LCe(n,e){const t=n.length,s=n.map(a=>`${e}[${a}]`),i=new Array(t-1);i[t-2]=s[t-1];for(let a=t-3;a>=0;--a)i[a]=`(${i[a+1]} * ${s[a+1]})`;return i}function FCe(n,e,t="index"){const s=n.map((a,r)=>r),i=LCe(s,e);return i.map((a,r)=>{const o=`int ${n[r]} = ${t} / ${i[r]}`,l=r===i.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * ${i[r]}`:`index -= ${n[r]} * ${i[r]}`;return`${o}; ${l};`}).join("")}function FL(n){const e=gn(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function UL(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const rj=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:oj}=M8;function UCe(n,e,t){const s=[];if(n.forEach(g=>{const v=qe(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?s.push(`uniform float ${g.name}${v>1?`[${v}]`:""};`):(s.push(`uniform sampler2D ${g.name};`),s.push(`uniform int offset${g.name};`)),t.enableShapeUniforms){const{uniformShape:_}=PL(t.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(_.length){case 1:s.push(`uniform int ${g.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${g.name}Shape;`);break}s.push(`uniform ivec2 ${g.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(g=>{s.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const i=s.join(`
`),a=n.map(g=>PCe(g,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),r=e.texShape,o=Yr(),l=GCe(o);let c,h,d=WCe(o);return e.isPacked?(c=zCe(e.logicalShape,r,t.enableShapeUniforms),h=HCe(o)):(c=$Ce(e.logicalShape,r,t.enableShapeUniforms),h=VCe(o)),t.packedInputs&&(d+=KCe),[d,l,h,i,c,a,t.userCode].join(`
`)}function _v(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return oTe(n,e);case 1:return cTe(n,e);case 2:return hTe(n,e);case 3:return fTe(n,e);case 4:return mTe(n,e);case 5:return gTe(n);case 6:return xTe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function lj(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return rTe(n);case 1:return lTe(n,e);case 2:return uTe(n,e);case 3:return dTe(n,e);default:return pTe(n,e)}}function PCe(n,e,t=!1,s){let i="";t?i+=lj(n,s):i+=_v(n,s);const a=n.shapeInfo.logicalShape,r=e.logicalShape;return a.length<=r.length&&(t?i+=yTe(n,e):i+=vTe(n,e)),i}function zCe(n,e,t){switch(n.length){case 0:return cj();case 1:return YCe(n,e,t);case 2:return iTe(n,e,t);case 3:return ZCe(n,e,t);default:return eTe(n,e,t)}}function $Ce(n,e,t){switch(n.length){case 0:return cj();case 1:return JCe(n,e,t);case 2:return aTe(n,e,t);case 3:return QCe(n,e,t);case 4:return tTe(n,e,t);case 5:return nTe(n,e);case 6:return sTe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function GCe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function VCe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function HCe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function WCe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${jCe}
    ${XCe}
    ${qCe}
  `}const jCe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,XCe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qCe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,KCe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function cj(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function YCe(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function JCe(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function ZCe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),a=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function QCe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${WN(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Fg(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function eTe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),a=i*Math.ceil(n[n.length-2]/2);let r=a,o="",l="b, r, c";for(let c=2;c<n.length-1;c++)r*=n[n.length-c-1],o=`
      int b${c} = index / ${r};
      index -= b${c} * ${r};
    `+o,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function tTe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${WN(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Fg(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function nTe(n,e){const t=Fg(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function sTe(n,e){const t=Fg(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function iTe(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(as(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function aTe(n,e,t){return as(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Ug(n){return`offset${n}`}function rTe(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Yr();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function oTe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[i,a]=n.shapeInfo.texShape;if(i===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const r=Ug(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${r});
      return sampleTexture(${t}, uv);
    }
  `;const[o,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${r});
      return sampleTexture(${t}, uv);
    }
  `}function lTe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,a=Yr();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${t}, uv);
    }
  `;const r=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${r[0]}, ${r[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }
  `}function cTe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Av(n)}
      }
    `;const i=n.shapeInfo.texShape,a=i[0],r=i[1];if(r===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Ug(t);return r===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${t}, uv);
      }
    `:a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${r}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${r}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function uTe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,r=a[0],o=a[1],l=Yr();if(a!=null&&as(t,a))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${r}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],h=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function hTe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape;if(a!=null&&as(t,a)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=a[0],g=a[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:r,keptDims:o}=_d(t),l=r;if(l.length<t.length){const p=wv(n,l),g=["row","col"];return`
      ${_v(p,e)}
      float ${i}(int row, int col) {
        return ${i}(${Cv(g,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Av(n)}
      }
    `;const c=a[0],h=a[1],d=Ug(s);return h===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${h}, index);
    return sampleTexture(${s}, uv);
  }
`}function dTe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,r=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(t[0]===1){const p=t.slice(1),g=[1,2],v=wv(n,p),_=["b","row","col"];return`
        ${lj(v,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Cv(_,g)});
        }
      `}const o=Yr();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=r[0],c=r[1],h=Math.ceil(t[2]/2),d=h*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${h}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function fTe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t[1]*t[2],r=t[2],{newShape:o,keptDims:l}=_d(t),c=o;if(c.length<t.length){const _=wv(n,c),S=["row","col","depth"];return`
        ${_v(_,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Cv(S,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${r}, 1)));
        ${Av(n)}
      }
    `;const h=n.shapeInfo.texShape,d=h[0],p=h[1],g=n.shapeInfo.flatOffset;if(p===a&&g==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${r}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===r&&g==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const v=Ug(s);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${v};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${r} + depth + ${v};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function pTe(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=Yr();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const a=n.shapeInfo.logicalShape,r=a.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],h=l[1],d=Math.ceil(a[r-1]/2);let p=d*Math.ceil(a[r-2]/2),g="int b, int row, int col",v=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let _=2;_<r-1;_++)g=`int b${_}, `+g,p*=a[r-_-1],v=`b${_} * ${p} + `+v;return`
    vec4 ${s}(${g}) {
      int index = ${v};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});
      return ${i.texture2D}(${t}, uv);
    }
  `}function mTe(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t[3],r=t[2]*a,o=t[1]*r,{newShape:l,keptDims:c}=_d(t);if(l.length<t.length){const w=wv(n,l),T=["row","col","depth","depth2"];return`
      ${_v(w,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Cv(T,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${r}, ${a}, 1)));
        ${Av(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],g=d[1],v=`int stride2 = ${s}Shape[3];`,_=`int stride1 = ${s}Shape[2] * stride2;`,S=`int stride0 = ${s}Shape[1] * stride1;`;if(g===o&&h==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${v}
        ${_}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${r}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(g===a&&h==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const b=Ug(s);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${v}
      ${_}
      ${S}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${r} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${g}, index + ${b});
      return sampleTexture(${s}, uv);
    }
  `}function gTe(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],a=e[3]*i,r=e[2]*a,o=e[1]*r,{newShape:l,keptDims:c}=_d(e);if(l.length<e.length){const _=wv(n,l),S=["row","col","depth","depth2","depth3"];return`
      ${_v(_)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Cv(S,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${r}, ${a}, ${i})) +
          depth3;
        ${Av(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],g=d[1];if(g===o&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${r}, ${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===i&&h==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const v=Ug(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${r} + depth * ${a} +
          depth2 * ${i} + depth3 + ${v};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function xTe(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:a}=_d(e);if(i.length<e.length){const S=wv(n,i),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${_v(S)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Cv(b,a)});
      }
    `}const r=e[5],o=e[4]*r,l=e[3]*o,c=e[2]*l,h=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${r}, 1)));
        ${Av(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,g=p[0],v=p[1];if(v===h&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${r})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${v}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(v===r&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${v}.0, ${g}.0);
        return sampleTexture(${t}, uv);
      }
    `;const _=Ug(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${r} + depth4 + ${_};
      vec2 uv = uvFromFlat(${g}, ${v}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Av(n){const e=n.name,t=qe(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function yTe(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",a=n.shapeInfo.logicalShape.length,r=e.logicalShape.length,o=oj(n.shapeInfo.logicalShape,e.logicalShape),l=qs(r),c=r-a;let h;const d=["x","y","z","w","u","v"];a===0?h="":r<2&&o.length>=1?h="coords = 0;":h=o.map(w=>`coords.${d[w+c]} = 0;`).join(`
`);let p="";r<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((w,T)=>`coords.${d[T+c]}`).join(", ");let g="return outputValue;";const _=qe(n.shapeInfo.logicalShape)===1,b=qe(e.logicalShape)===1;if(a===1&&!_&&!b)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(_&&!b)r===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){const w=a-2,T=a-1;o.indexOf(w)>-1&&o.indexOf(T)>-1?g="return vec4(outputValue.x);":o.indexOf(w)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(T)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${s}(${p});
      ${g}
    }
  `}function vTe(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",a=e.texShape,r=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&n.shapeInfo.flatOffset==null&&as(r,a))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=qs(l),h=oj(n.shapeInfo.logicalShape,e.logicalShape),d=l-o;let p;const g=["x","y","z","w","u","v"];o===0?p="":l<2&&h.length>=1?p="coords = 0;":p=h.map(_=>`coords.${g[_+d]} = 0;`).join(`
`);let v="";return l<2&&o>0?v="coords":v=n.shapeInfo.logicalShape.map((_,S)=>`coords.${g[S+d]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${p}
      return get${s}(${v});
    }
  `}function qs(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function PL(n,e,t){const{newShape:s,keptDims:i}=_d(e),a=e.length,r=n&&a===3&&e[0]===1,o=r?e.slice(1):s,l=!n&&a>1&&!as(e,t)&&s.length<a||r;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:i}}function wv(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Cv(n,e){return e.map(t=>n[t]).join(", ")}function bTe(n,e,t,s){const i=t.map((h,d)=>{const p={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(p.flatOffset=h.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:p}}),a=i.map(h=>h.shapeInfo),r={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=UCe(i,r,e),l=fCe(n.gl,o),c=n.createProgram(l);return Pe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:r,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:r},uj(n,e,c)))}function uj(n,e,t){const s=[],i=[];let a,r,o,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),Pe().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const h=!1;for(const d of e.variableNames){const p={name:d,uniform:n.getUniformLocation(t,d,h),offset:n.getUniformLocation(t,`offset${d}`,h)};e.enableShapeUniforms&&(p.shape=n.getUniformLocation(t,`${d}Shape`,h),p.texShape=n.getUniformLocation(t,`${d}TexShape`,h)),s.push(p)}if(e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",h),o=n.getUniformLocation(t,"outShapeStrides",h),r=n.getUniformLocation(t,"outTexShape",h)),e.customUniforms)for(const d of e.customUniforms)i.push(n.getUniformLocation(t,d.name,h));return{variablesLocations:s,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:r}}function M$(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const i=t.logicalShape,a=e[s],r=a.shape;if(!as(i,r))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${r} must match`);if(t.isUniform&&a.isUniform)return;const o=t.texShape,l=a.isUniform?null:a.texData.texShape;if(!as(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function STe(n,e,t,s,i){e.program.enableShapeUniforms||(M$(e.inShapeInfos,t),M$([e.outShapeInfo],[s]));const a=s.texData.texture,r=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(a.texture,r[0],r[1]):n.setOutputMatrixTexture(a.texture,r[0],r[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),Pe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:h,offset:d,shape:p,texShape:g}=e.variablesLocations[l];if(p){const{uniformShape:v}=PL(e.program.packedInputs,c.shape,c.texData.texShape);switch(v.length){case 1:n.gl.uniform1iv(p,new Int32Array(v));break;case 2:n.gl.uniform2iv(p,new Int32Array(v));break;case 3:n.gl.uniform3iv(p,new Int32Array(v));break;case 4:n.gl.uniform4iv(p,new Int32Array(v));break}}if(g&&n.gl.uniform2i(g,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(qe(c.shape)<2)n.gl.uniform1f(h,c.uniformValues[0]);else{let v=c.uniformValues;v instanceof Float32Array||(v=new Float32Array(v)),n.gl.uniform1fv(h,v)}continue}c.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,h,l)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=gn(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],h=e.customUniformLocations[l],d=i[l];if(c.type==="float")n.gl.uniform1fv(h,d);else if(c.type==="vec2")n.gl.uniform2fv(h,d);else if(c.type==="vec3")n.gl.uniform3fv(h,d);else if(c.type==="vec4")n.gl.uniform4fv(h,d);else if(c.type==="int")n.gl.uniform1iv(h,d);else if(c.type==="ivec2")n.gl.uniform2iv(h,d);else if(c.type==="ivec3")n.gl.uniform3iv(h,d);else if(c.type==="ivec4")n.gl.uniform4iv(h,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function _Te(n,e,t){let s="";e.concat(t).forEach(r=>{const o=r.texData!=null&&r.texData.slice!=null&&r.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!r.isUniform){const l=r.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:d}=PL(n.packedInputs,r.shape,l);let p="",g="",v="";if(h.length===1&&n.packedInputs){const R=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${R[0]>1}_${R[1]>1}`}else if(h.length===2&&!n.packedInputs)g=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const R=gn(h);v=`${R[0]===l[1]}_${R[R.length-1]===l[1]}`}const _=r.shape.length,S=h.length===2&&as(r.shape,l),b=qe(r.shape)===1,w=pg(r.shape,t.shape),T=!n.packedInputs&&_===t.shape.length&&as(l,t.texData.texShape),E=n.packedInputs||h.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${_}_${T}_${c?d:""}_${h.length}_${b}_${w}_${S}_${p}_${g}_${v}_${E}_${o}`}else{const l=r.isUniform?"uniform":r.texData.texShape;s+=`${r.shape}_${l}_${o}`}});const i=n.userCode;let a=n.constructor.name;return a+="_"+s+"_"+i+`${Pe().getNumber("WEBGL_VERSION")}`,a}function _r(n){return Pe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class ATe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=yS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Yr();this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?WN(["r","c","d"],e):Fg(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class wTe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=yS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Yr();this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?WN(["r","c","d"],e):Fg(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class CTe{constructor(e){this.variableNames=["A"],this.outTexUsage=bl.DOWNLOAD;const t=Yr();this.outputShape=e,this.userCode=`
      ${rj}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class TTe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=bl.DOWNLOAD;const t=Yr();this.outputShape=e,this.userCode=`
      ${rj}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const ETe={R:0,G:1,B:2,A:3};class N${constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Yr();this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let r="";for(let o=0;o<s.length;o++){const l=s[o];r+=`
          if(offset == ${o}) {
            result = values[${ETe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?UL():FL(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${r}
        }
        ${i.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}class MTe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Yr();this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length);let i="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){const l=r*2+o;i+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${r} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${r};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?UL():FL(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${a};
        }
    `}}function NTe(n){const e=Yr(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return dCe(n,t)}function RTe(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return xCe(n,e)}function ITe(n){const e=new Uint16Array([0,1,2,2,1,3]);return yCe(n,e)}function CA(n,e,t,s,i,a){bCe(e,t);const r=vCe(n),o=n.TEXTURE_2D;return Xt(n,()=>n.bindTexture(o,r)),Xt(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Xt(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Xt(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Xt(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),Pe().getNumber("WEBGL_VERSION")===1?Xt(n,()=>n.texImage2D(o,0,s,e,t,0,i,a,null)):Xt(n,()=>n.texStorage2D(o,1,s,e,t)),Xt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:r,texShape:[t,e]}}function hj(n){return n.internalFormatFloat}function DTe(n,e,t,s){const[i,a]=AA(e,t);return CA(n,i,a,hj(s),s.textureFormatFloat,n.FLOAT)}function dj(n){return n.internalFormatHalfFloat}function OTe(n,e,t,s){const[i,a]=AA(e,t);return CA(n,i,a,dj(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function fj(n){return n.downloadTextureFormat}function BTe(n,e,t,s){const[i,a]=AA(e,t);return CA(n,i,a,fj(s),n.RGBA,n.UNSIGNED_BYTE)}function pj(n){return n.internalFormatPackedFloat}function kTe(n,e,t,s){const[i,a]=Sv(e,t);return CA(n,i,a,pj(s),n.RGBA,n.FLOAT)}function mj(n){return n.internalFormatPackedHalfFloat}function LTe(n,e,t,s){const[i,a]=Sv(e,t);return CA(n,i,a,mj(s),n.RGBA,s.textureTypeHalfFloat)}function FTe(n,e,t){return Xt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),C$(n,e,"clipSpacePos",t,3,20,0)&&C$(n,e,"uv",t,2,20,12)}function UTe(n,e,t,s,i,a){Xt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let r,o,l;i instanceof Uint8Array?(r=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(r=new Float32Array(t*s*4),o=n.FLOAT,l=a.internalFormatPackedFloat),r.set(i),Pe().getNumber("WEBGL_VERSION")===2?Xt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,r)):Xt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,o,r)),Xt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function PTe(n,e,t){Xt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?Pe().getNumber("WEBGL_VERSION")===2?Xt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Xt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):Pe().getNumber("WEBGL_VERSION")===2?Xt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Xt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Xt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function zTe(n,e,t,s){const i=n.createBuffer();Xt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const o=4*4*e*t;return Xt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Xt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Xt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function $Te(n,e,t){const s=n,i=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function GTe(n,e,t,s){const[i,a]=AA(e,t),r=4,o=new Uint8Array(aCe(e*t,r));return Xt(n,()=>n.readPixels(0,0,i,a,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function VTe(n,e,t,s,i,a,r,o){const l=n,c=new Float32Array(rCe(a,r));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function HTe(n,e,t){const s=new Float32Array(e*t*4);return Xt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}class v3{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Pe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,nCe(t,e)):this.gl=su(t),e=this.gl,Pe().getNumber("WEBGL_VERSION")===2){const a=e;this.createVertexArray=()=>Xt(a,()=>a.createVertexArray()),this.bindVertexArray=r=>Xt(a,()=>a.bindVertexArray(r)),this.deleteVertexArray=r=>Xt(a,()=>a.deleteVertexArray(r)),this.getVertexArray=()=>Xt(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){const a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Xt(e,()=>a.createVertexArrayOES()),this.bindVertexArray=r=>Xt(e,()=>a.bindVertexArrayOES(r)),this.deleteVertexArray=r=>Xt(e,()=>a.deleteVertexArrayOES(r)),this.getVertexArray=()=>Xt(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Pe().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",r="OES_texture_half_float";if(this.textureFloatExtension=eT(this.gl,a),sc(this.gl,r))this.textureHalfFloatExtension=eT(this.gl,r);else if(Pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),sc(this.gl,i))this.colorBufferHalfFloatExtension=eT(this.gl,i);else if(Pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",sc(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(sc(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=RTe(this.gl),this.indexBuffer=ITe(this.gl),this.framebuffer=SCe(this.gl),this.textureConfig=LL(this.gl,this.textureHalfFloatExtension)}get debug(){return Pe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Xt(e,()=>e.finish()),Xt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Xt(e,()=>e.deleteFramebuffer(this.framebuffer)),Xt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Xt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Xt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),DTe(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),OTe(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),BTe(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),PTe(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,i){this.throwIfDisposed(),UTe(this.gl,e,t,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),LTe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),kTe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(T$(this.gl,this.framebuffer),this.outputTexture=null),Xt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>GTe(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,i,a,r){return VTe(this.gl,e,t,s,i,a,r,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return $Te(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const i=zTe(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(Pe().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,a=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const r=i.clientWaitSync(a,0,0);return r===i.ALREADY_SIGNALED||r===i.CONDITION_SATISFIED},t=a}else Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>HTe(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=NTe(t));const s=mCe(t);Xt(t,()=>t.attachShader(s,this.vertexShader)),Xt(t,()=>t.attachShader(s,e)),gCe(t,s);const i=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&m3(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Xt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),FTe(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Xt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&m3(this.gl,this.program),Xt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?ACe(this.gl,e,t):wCe(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Xt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),CCe(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[i,a]=Sv(t,s);this.setOutputMatrixTextureDriver(e,i,a)}setOutputMatrixWriteRegion(e,t,s,i){this.setOutputMatrixWriteRegionDriver(s,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&m3(this.gl,this.program),tT(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Xt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Xt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=eT(this.gl,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await K3(()=>this.disposed||this.isQueryAvailable(e,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=WTe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in Pe().platform&&(s=Pe().platform.setTimeoutCustom.bind(Pe().platform)),K3(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),g3(this.gl,e,this.framebuffer),this.debug&&tT(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(g3(this.gl,this.outputTexture,this.framebuffer),this.debug&&tT(this.gl)):T$(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const i=this.gl;g3(i,e,this.framebuffer),this.debug&&tT(i),this.outputTexture=e,Xt(i,()=>i.viewport(0,0,t,s)),Xt(i,()=>i.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,i){this.throwIfDisposed(),Xt(this.gl,()=>this.gl.scissor(e,t,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function WTe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:jTe,bincountImpl:gj,bincountReduceImpl:XTe,bitwiseAndImpl:qTe,castImpl:KTe,ceilImpl:YTe,concatImpl:JTe,equalImpl:ZTe,expImpl:QTe,expm1Impl:eEe,floorImpl:tEe,gatherNdImpl:nEe,gatherV2Impl:sEe,greaterImpl:iEe,greaterEqualImpl:aEe,lessImpl:rEe,lessEqualImpl:oEe,linSpaceImpl:lEe,logImpl:cEe,maxImpl:uEe,maximumImpl:hEe,minimumImpl:dEe,multiplyImpl:fEe,negImpl:pEe,notEqualImpl:mEe,prodImpl:gEe,raggedGatherImpl:xEe,raggedRangeImpl:yEe,raggedTensorToTensorImpl:vEe,rangeImpl:bEe,rsqrtImpl:SEe,scatterImpl:_Ee,sigmoidImpl:AEe,simpleAbsImpl:xj,sliceImpl:wEe,sparseFillEmptyRowsImpl:CEe,sparseReshapeImpl:TEe,sparseSegmentReductionImpl:yj,sqrtImpl:EEe,staticRegexReplaceImpl:MEe,stridedSliceImpl:NEe,stringNGramsImpl:REe,stringSplitImpl:IEe,stringToHashBucketFastImpl:DEe,subImpl:OEe,tileImpl:BEe,topKImpl:kEe,transposeImpl:zL,uniqueImpl:LEe}=Pbe;function vj(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Hr(n,e){return e===1?[n]:vj(n,e)}function FEe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class UEe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=_r(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Hr("rc",this.rank),s=qs(this.rank),i=this.getOutOfBoundsCondition(t),a=this.getSetup(t),r=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${r}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let a=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let r=2;r<this.rank;r++)a=`${e[e.length-1-r]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class bj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length);let s="";for(let i=0;i<4;i++){let a="thisRC = rc;";i%2===1&&(a+="thisRC.z += 1;"),i>1&&(a+="thisRC.y += 1;"),s+=`
        ${a}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${PEe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?UL():FL(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function PEe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?FCe(["r","c","d"],"inputShape"):Fg(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class zEe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const i=I$(t,s),a=D$(e,i,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const r=R$(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=r,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let o;return i===Ya.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Ya.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Ya.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Ya.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Ya.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=r,this.log(),o}releaseTexture(e,t,s,i){if(this.freeTextures==null)return;const a=I$(s,i),r=D$(t,a,i);r in this.freeTextures||(this.freeTextures[r]=[]);const o=R$(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Pe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[r].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[r],h=c&&c.indexOf(e);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[h]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function $Ee(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function R$(n,e,t,s,i){const a=GEe(e,s);let r;if(i){const[l,c]=Sv(n[0],n[1]);r=l*c}else{const[l,c]=AA(n[0],n[1]);r=l*c}const o=$Ee(t,a);return r*o}function GEe(n,e){switch(n){case Ya.PACKED_2X2_FLOAT32:return pj(e);case Ya.PACKED_2X2_FLOAT16:return mj(e);case Ya.UNPACKED_FLOAT32:return hj(e);case Ya.UNPACKED_FLOAT16:return dj(e);case Ya.PACKED_4X1_UNSIGNED_BYTE:return fj(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function VEe(n){return Pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ya.PACKED_2X2_FLOAT32:Ya.UNPACKED_FLOAT32:n?Ya.PACKED_2X2_FLOAT16:Ya.UNPACKED_FLOAT16}function I$(n,e){if(n===bl.UPLOAD)return Ya.PACKED_2X2_FLOAT32;if(n===bl.RENDER||n==null)return VEe(e);if(n===bl.DOWNLOAD||n===bl.PIXELS)return Ya.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function D$(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class Yu{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const dc="if (isnan(x)) return x;",HEe="return x;",O$="return abs(x);",WEe="return (x >= 0.0) ? x : (exp(x) - 1.0);",jEe=dc+`
  return (x < 0.0) ? 0.0 : x;
`,XEe=dc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Cf="return x;",qEe="return 1.0 / (1.0 + exp(-1.0 * x));";const KEe="return x;",YEe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,JEe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZEe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QEe="return 1.0 / (1.0 + exp(-1.0 * x));";class Df{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class e2e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length);const t=e.length,s=Hr("rc",t),i=qs(t),a=FEe(t,s),r=s.slice(-2),o=t<=1?"rc":`vec2(${r.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}const t2e=yN,n2e=1e-7,s2e=1e-4,iT={};function i2e(n){return n in iT||(iT[n]={}),iT[n]}const a2e=Pe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),r2e=600;function o2e(){return Pe().global.screen==null?1024:Pe().global.screen.height*Pe().global.screen.width*window.devicePixelRatio*r2e/1024/1024}class jN extends k2{nextDataId(){return jN.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Pe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof v3)t=e;else{const s=su(Pe().getNumber("WEBGL_VERSION"),e);t=new v3(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=su(Pe().getNumber("WEBGL_VERSION"));t=new v3(s),this.binaryCache=i2e(Pe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zEe(this.gpgpu),this.numMBBeforeWarning=o2e(),this.texData=new eB(this,Vc())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,i,a,r){const o=this.makeTensorInfo(t,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,a]},l.texShape=[i,a];const c=nT(t),h=new N$(c,!1,r),d=this.runWebGLProgram(h,[o],s,[[i,a]]);return d.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(e,t,s){if((Pe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Pe().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:s,values:e,usage:bl.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,i,a){if(Pe().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:t,usage:bl.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:a,slice:r,shape:o,isPacked:l}=t;if(r!=null){let p;l?p=new Df(o,Cf):p=new Yu(o,Cf);const g=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:i}],i),v=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),v}if(s!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return s;const c=this.activeTimers!=null;let h;c&&(h=zr());let d;if(i==="complex64"){const p=this.readSync(a.real.dataId),g=this.readSync(a.imag.dataId);d=vd(p,g)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=zr()-h),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const v=this.pendingRead.get(e);return new Promise(_=>v.push(_))}const t=this.texData.get(e),{values:s,shape:i,slice:a,dtype:r,complexTensorInfos:o,isPacked:l}=t;if(a!=null){let v;l?v=new Df(i,Cf):v=new Yu(i,Cf);const _=this.runWebGLProgram(v,[{dataId:e,shape:i,dtype:r}],r),S=this.read(_.dataId);return this.disposeIntermediateTensorInfo(_),S}if(s!=null)return this.convertAndCacheOnCPU(e);if(Pe().getBool("DEBUG")&&!Pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Pe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(r!=="complex64"&&Pe().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const v=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(v.texture.texture,...QC(i))}this.pendingRead.set(e,[]),r!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(r==="complex64"){const v=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),_=v[0],S=v[1];d=vd(_,S)}else if(c==null)d=this.getValuesFromTexture(e);else{const v=qe(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,v)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const v=this.gpgpu.gl;Xt(v,()=>v.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,d),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(v=>v(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Vc().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const s=this.texData.get(e),{values:i,shape:a,slice:r,dtype:o,isPacked:l,texture:c}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(r!=null){let g;l?g=new Df(a,Cf):g=new Yu(a,Cf);const v=this.runWebGLProgram(g,[{dataId:e,shape:a,dtype:o}],o),_=this.readToGPU(v,t);return this.disposeIntermediateTensorInfo(v),_}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),d=Vc().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>gd(i));return Hn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Hn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!uCe(s))throw Pe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:i}=this.texData.get(e),a=qe(t);if(Pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),g=this.texData.get(p.dataId),v=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...QC(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(p),v}const r=Pe().getBool("WEBGL_PACK")&&i===!0,o=r?nT(t):t,l=r?new TTe(o):new CTe(o),c=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:e}],"float32"),h=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=oh(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),r=oh(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=JV(l),o.getExtraProfileInfo=()=>l.map((c,h)=>({name:r[h],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:zr(),endMs:null}}endTimer(e){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=zr(),e)}async getQueryTime(e){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:i,usage:a,isPacked:r,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,i,a,r)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=a2e){return Pe().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&qe(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return t2e(e.shape,t)}packedUnaryOp(e,t,s){const i=new Df(e.shape,t),a=this.compileAndRun(i,[e],s);return Vc().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=xj(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,O$,e.dtype);const t=new Yu(e.shape,O$),s=this.compileAndRun(t,[e]);return Vc().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&Ku(s[0])){const a=s.map(r=>Qu(r));i=this.write(a,e,t)}else i=this.write(s,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,s){return Vc().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new e2e(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new UEe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[sy(e.shape),...iy(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},a=[sy(t),...iy(t)],r=new bj(a,s),o=!0,l=[s],c=this.runWebGLProgram(r,[i],e.dtype,l,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:i,shape:a,dtype:r}=s;if(t!=null){const p=qe(a),g=t[0]*t[1]*4;ee(p<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=nT(a);let l;i?l=new wTe(o):l=new ATe(o);const c=!0,h=[t??QC(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:e}],r,h,c,t);return{dtype:r,shape:a,dataId:d.dataId}}runWebGLProgram(e,t,s,i,a=!1,r){const o=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===yS.DENSE){const b=r??QC(e.outputShape);l.texShape=b.map(w=>w*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),qe(o.shape)===0)return l.values=ka(o.dtype,0),o;const c=[],h=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(b.dataId);if(w.texture==null){if(!e.packedInputs&&qe(b.shape)<=Pe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!w.isPacked!=!!e.packedInputs)b=w.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),w=this.texData.get(b.dataId);else if(w.isPacked&&!WE(w.shape,b.shape)){const T=b,E=b.shape;b.shape=w.shape,b=this.packedReshape(b,E),c.push(b),w=this.texData.get(b.dataId),T.shape=E}return{shape:b.shape,texData:w,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:l,isUniform:!1},p=_Te(e,h,d),g=this.getAndSaveBinary(p,()=>bTe(this.gpgpu,e,h,d)),v=this.activeTimers!=null;let _;v&&(_=this.startTimer()),Pe().get("ENGINE_COMPILE_ONLY")||STe(this.gpgpu,g,h,d,i),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),v&&(_=this.endTimer(_),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(_)}));const S=Pe().getNumber("WEBGL_FLUSH_THRESHOLD");if(S>0){const b=zr();b-this.lastGlFlushTime>S&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!Pe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(e,t,s,i,a=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,i,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Pe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Le(()=>{if(!Pe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Pe().getBool("DEBUG");Pe().set("DEBUG",!1);const t=this.abs(vn(1e-8)).dataSync()[0];if(Pe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?n2e:s2e}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:i,values:a,texture:r,usage:o,isPacked:l}=t;if(r!=null)return;const c=this.activeTimers!=null;let h;c&&(h=zr());let d=t.texShape;if(d==null&&(d=MCe(s,l),t.texShape=d),a!=null){const p=nT(s);let g,v=d[1],_=d[0];const S=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!S)&&([v,_]=Sv(d[0],d[1])),l?g=new MTe(p,S):g=new N$(p,S);const b=S?[_,v]:d,w=this.makeTensorInfo(b,i),T=this.texData.get(w.dataId);S?T.usage=bl.PIXELS:T.usage=bl.UPLOAD,T.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),v,_,a);const E=[[_,v]],D=this.runWebGLProgram(g,[w],i,E,!0),F=this.texData.get(D.dataId);t.texShape=F.texShape,t.isPacked=F.isPacked,t.usage=F.usage,Pe().get("ENGINE_COMPILE_ONLY")?this.disposeData(D.dataId):(t.texture=F.texture,t.values=null,this.texData.delete(D.dataId)),this.disposeIntermediateTensorInfo(w),c&&(this.uploadWaitMs+=zr()-h)}else{const p=this.acquireTexture(d,o,i,l);t.texture=p}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:i}=s;return t!=null&&(s.values=l2e(t,i)),s.values}acquireTexture(e,t,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*nS(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(a){throw a}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Lk(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(aj(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:i,nanLoc:a,outShapeLocation:r,outShapeStridesLocation:o,outTexShapeLocation:l}=uj(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=a,e.outShapeLocation=r,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:i,height:a,width:r,channels:o}=e,l=Vc().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,s,a,r,o);return Vc().makeTensorFromDataId(c,t,s,l)}}jN.nextDataId=0;function l2e(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}uB()&&dB("webgl",()=>new jN,2);const $L=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class _g{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=kn(t,s),this.enableShapeUniforms=_r(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Pg=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Tv{constructor(e,t,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=kn(t,s);const a=this.outputShape.length;this.enableShapeUniforms=_r(a);let r="";if(i)if(a===0||qe(this.outputShape)===1)r=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(r=`
          ${qs(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?r+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:r+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Hr("coords",a);this.enableShapeUniforms?r+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:r+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${r}

        setOutput(result);
      }
    `}}function el(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const c2e={kernelName:Uy,backendName:"webgl",kernelFunc:el};function mp(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,a=t.makeTensorInfo(s.shape,"complex64"),r=t.texData.get(a.dataId),o=el({inputs:{x:s},backend:t}),l=el({inputs:{x:i},backend:t});return r.complexTensorInfos={real:o,imag:l},a}const u2e={kernelName:H2,backendName:"webgl",kernelFunc:mp};const Sj="return (a < 0.) ? b * a : a;",_j=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function h2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:a}=s,r=t.makeTensorInfo([],"float32",Ad(a,"float32")),o=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tv(_j,i.shape,r.shape):new _g(Sj,i.shape,r.shape),l=t.runWebGLProgram(o,[i,r],"float32");return t.disposeIntermediateTensorInfo(r),l}const d2e={kernelName:u_,backendName:"webgl",kernelFunc:h2e};const Aj="return (a < 0.) ? b * a : a;",wj=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function f2e(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,a=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tv(wj,s.shape,i.shape):new _g(Aj,s.shape,i.shape);return t.runWebGLProgram(a,[s,i],"float32")}const p2e={kernelName:N_,backendName:"webgl",kernelFunc:f2e};const Ev="if (isnan(x)) return x;";function Ms({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:i,backend:a})=>{const{x:r}=i,o=a,l=s||r.dtype;if(o.shouldExecuteOnCPU([r])&&t!=null){const d=o.texData.get(r.dataId),p=t(d.values,l);return o.makeTensorInfo(r.shape,l,p)}const c=Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return c?h=new Df(r.shape,e):h=new Yu(r.shape,n),o.runWebGLProgram(h,[r],l)}}function rr({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:a}){return({inputs:r,backend:o})=>{const{a:l,b:c}=r,h=o;if(s&&l.dtype==="complex64"){const v=h.texData.get(l.dataId),_=h.texData.get(c.dataId),[S,b]=[[v.complexTensorInfos.real,_.complexTensorInfos.real],[v.complexTensorInfos.imag,_.complexTensorInfos.imag]].map(T=>{const[E,R]=T,D={dataId:E.dataId,dtype:E.dtype,shape:l.shape},F={dataId:R.dataId,dtype:R.dtype,shape:c.shape},U=new _g(n,l.shape,c.shape);return h.runWebGLProgram(U,[D,F],To(E.dtype,R.dtype))}),w=mp({inputs:{real:S,imag:b},backend:h});return h.disposeIntermediateTensorInfo(S),h.disposeIntermediateTensorInfo(b),w}const d=a||To(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&i!=null){const v=h.texData.get(l.dataId).values,_=h.texData.get(c.dataId).values,S=l.dtype==="string"?bd(v):v,b=l.dtype==="string"?bd(_):_,[w,T]=i(l.shape,c.shape,S,b,d),E=h.makeTensorInfo(T,d),R=h.texData.get(E.dataId);return R.values=w,E}const p=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return p?g=new Tv(e,l.shape,c.shape,t):g=new _g(n,l.shape,c.shape),h.runWebGLProgram(g,[l,c],d)}}function vS(n,e=!1){if(n==="linear")return e?KEe:HEe;if(n==="relu")return e?JEe:jEe;if(n==="elu")return e?YEe:WEe;if(n==="relu6")return e?ZEe:XEe;if(n==="prelu")return e?wj:Aj;if(n==="leakyrelu")return e?_j:Sj;if(n==="sigmoid")return e?QEe:qEe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class Cj{constructor(e,t,s,i=!1,a=!1,r=!1,o=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=_r(this.outputShape.length);const h=i?e[1]:e[2],d=Math.ceil(h/2),p=i?"i * 2, rc.y":"rc.y, i * 2",g=a?"rc.z, i * 2":"i * 2, rc.z",v=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],_=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let S="",b="";o&&(l?S=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?S=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:S=`vec4 activation(vec4 x) {
          ${o}
        }`,b="result = activation(result);");const w=r?"result += getBiasAtOutCoords();":"";r&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let T="rc.x",E="rc.x";e[0]<t[0]?T=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(E=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${S}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${T};
        int batchB = ${E};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${v[0]} * ${_[0]});
          result += (${v[1]} * ${_[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${b}

        setOutput(result);
      }
    `}}const B$={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class k${constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=kn(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const L$="return a * b;";function GL(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,a=To(s.dtype,i.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),l=t.texData.get(i.dataId),c=new k$(B$.REAL,s.shape,i.shape),h=new k$(B$.IMAG,s.shape,i.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],p=t.runWebGLProgram(c,d,"float32"),g=t.runWebGLProgram(h,d,"float32"),v=mp({inputs:{real:p,imag:g},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),v}if(t.shouldExecuteOnCPU([s,i])){const o=t.texData.get(s.dataId),l=t.texData.get(i.dataId),[c,h]=fEe(s.shape,i.shape,o.values,l.values,a),d=t.makeTensorInfo(h,a),p=t.texData.get(d.dataId);return p.values=c,d}let r;return Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?r=new Tv(L$,s.shape,i.shape):r=new _g(L$,s.shape,i.shape),t.runWebGLProgram(r,[s,i],a)}const m2e={kernelName:Xy,backendName:"webgl",kernelFunc:GL};function g2e(n,e,t){const s=[sy(n.shape),...iy(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},a=[sy(e),...iy(e)],r=new bj(a,s),o=!0,l=[s],c=t.runWebGLProgram(r,[i],n.dtype,l,o);return{dataId:c.dataId,shape:e,dtype:c.dtype}}function zt(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:a}=s,r=t,o=qe(i.shape),l=nB(a,o),c=qe(l);ee(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const h=r.texData.get(i.dataId);return h.isPacked&&!WE(i.shape,l)&&!(h.texture!==null&&WE(h.shape,l))?g2e(i,l,r):(r.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const x2e={kernelName:I_,backendName:"webgl",kernelFunc:zt};class F${constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:a,outSize:r}=e;this.outputShape=[i,r];const o=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const d=1/t;c=`sumValue += dot(values * ${lg(d)?d.toPrecision(2):d}, ones);`}let h="";a%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}class y2e{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:a,outSize:r}=e;this.outputShape=[i,r];let o="0.0",l="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",l="min"):t==="max"&&(o="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const h=Math.floor(s/4)*4,d=s%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";t==="all"?(o="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):t==="any"&&(o="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let v="";a%s>0&&(v=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${v}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}function v2e(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=RN(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function zg(n,e,t,s){const i=v2e(n.shape);let a=n;for(let r=0;r<i.length;r++){const{inSize:o,windowSize:l,outSize:c}=i[r];let h,d;t==="mean"?h=r===0?new F$({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},o):new F$({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c}):h=new y2e({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},t),d=a,a=s.runWebGLProgram(h,[a],e),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return a}class b2e{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[t[r]];this.outputShape=s,this.rank=s.length;const i=qs(this.rank),a=S2e(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function S2e(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let i=0;i<n.length;i++)s[n[i]]=t[i];return s.join()}class _2e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let h=0;h<s.length;h++)s[h]=e[t[h]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=qs(this.rank),a=vj("rc",this.rank),r=new Array(this.rank);for(let h=0;h<t.length;h++)r[t[h]]=a[h];const o=`vec2(${r.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${r.join()}), ${o})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}function XN(n,e,t){const s=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _2e(n.shape,e):new b2e(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function A2e(n,e,t,s){const i=e,a=n.shape.length,r=es(i,n.shape);let o=r;const l=Mi(o,a),c=l!=null;let h=n;c&&(h=XN(n,l,s),o=qi(o.length,a)),ir("sum",o,a);const[d,p]=Ua(h.shape,o);let g=d;t&&(g=Xi(d,r));const v=qe(p),S=qe(n.shape)/v,b=zt({inputs:{x:h},attrs:{shape:[S,v]},backend:s}),w=HM(n.dtype),T=zg(b,w,"sum",s),E=zt({inputs:{x:T},attrs:{shape:g},backend:s});return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(T),c&&s.disposeIntermediateTensorInfo(h),E}function qN(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s;return A2e(i,a,r,t)}const w2e={kernelName:F_,backendName:"webgl",kernelFunc:qN};function Xr(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:a}=s,r=t,o=i.shape.length,l=new Array(o);for(let h=0;h<l.length;h++)l[h]=i.shape[a[h]];let c;if(r.shouldExecuteOnCPU([i])){const d=r.texData.get(i.dataId).values,p=zL(d,i.shape,i.dtype,a,l);c=r.makeTensorInfo(l,i.dtype);const g=r.texData.get(c.dataId);g.values=p}else c=XN(i,a,r);return c}const C2e={kernelName:Km,backendName:"webgl",kernelFunc:Xr};const Tj=1e3;function jE({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:a=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape.length,h=e.shape.length,d=t?n.shape[c-2]:n.shape[c-1],p=s?e.shape[h-1]:e.shape[h-2],g=t?n.shape[c-1]:n.shape[c-2],v=s?e.shape[h-2]:e.shape[h-1],_=n.shape.slice(0,-2),S=e.shape.slice(0,-2),b=qe(_),w=qe(S),E=kn(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,v]);ee(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const R=t?[b,d,g]:[b,g,d],D=s?[w,v,p]:[w,p,v],F=zt({inputs:{x:n},backend:i,attrs:{shape:R}}),U=zt({inputs:{x:e},backend:i,attrs:{shape:D}}),O=[F,U],B=Math.max(b,w),L=t?F.shape[1]:F.shape[2],H=a!=null,K=r!=null,Z=l==="leakyrelu",Q=l!=null?vS(l,!0):null,P=H||K||Z||Q!=null;let W;if((g===1||v===1)&&L>Tj&&P===!1){let se=F,le=U;t&&(se=Xr({inputs:{x:F},backend:i,attrs:{perm:[0,2,1]}}),O.push(se)),s&&(le=Xr({inputs:{x:U},backend:i,attrs:{perm:[0,2,1]}}),O.push(le));const Y=v!==1,re=v===1;let he=se;Y&&(he=zt({inputs:{x:se},backend:i,attrs:{shape:[B,L,1]}}),O.push(he));const me=v===1?2:1;let Ne=le;re&&(Ne=zt({inputs:{x:le},backend:i,attrs:{shape:[B,1,L]}}),O.push(Ne));const fe=GL({inputs:{a:he,b:Ne},backend:i});W=qN({inputs:{x:fe},backend:i,attrs:{axis:me,keepDims:!0}}),O.push(fe)}else{const se=To(n.dtype,e.dtype),le=new Cj(R,D,[B,g,v],t,s,H,Q,K,Z),Y=[F,U];if(a!=null&&Y.push(a),K&&Y.push(r),Z){const re=i.makeTensorInfo([],"float32",Ad(o,"float32"));Y.push(re),O.push(re)}W=i.runWebGLProgram(le,Y,se)}const q=zt({inputs:{x:W},backend:i,attrs:{shape:E}});O.push(W);for(const se of O)i.disposeIntermediateTensorInfo(se);return q}function T2e(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:a,bias:r,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=s;return jE({a:i,b:a,transposeA:l,transposeB:c,backend:t,bias:r,preluActivationWeights:o,leakyreluAlpha:d,activation:h})}const E2e={kernelName:sS,backendName:"webgl",kernelFunc:T2e};const U$="return abs(x);";function M2e(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const a=t.texData.get(s.dataId),r=xj(a.values);return t.makeTensorInfo(s.shape,s.dtype,r)}let i;return Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Df(s.shape,U$):i=new Yu(s.shape,U$),t.runWebGLProgram(i,[s],s.dtype)}const N2e={kernelName:GS,backendName:"webgl",kernelFunc:M2e};const R2e=dc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,I2e=Ms({opSnippet:R2e}),D2e={kernelName:yy,backendName:"webgl",kernelFunc:I2e};const O2e=dc+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,B2e=Ms({opSnippet:O2e}),k2e={kernelName:vy,backendName:"webgl",kernelFunc:B2e};const P$="return a + b;",L2e=rr({opSnippet:P$,packedOpSnippet:P$,supportsComplex:!0,cpuKernelImpl:jTe}),F2e={kernelName:Rg,backendName:"webgl",kernelFunc:L2e};class U2e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,r)=>`T${r}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const i=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}class P2e{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,r)=>`T${r}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const i=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}function AT(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return el({inputs:{x:s[0]},backend:t});if(s.length>Pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=AT({inputs:s.slice(0,l),backend:t}),h=AT({inputs:s.slice(l),backend:t});return AT({inputs:[c,h],backend:t})}const i=s.map(l=>l.dtype).reduce((l,c)=>To(l,c)),a=s.map(l=>l.shape),o=Pe().getBool("WEBGL_PACK")?new P2e(s[0].shape,a):new U2e(s[0].shape,a);return t.runWebGLProgram(o,s,i)}const z2e={kernelName:VS,backendName:"webgl",kernelFunc:AT};function $2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s,o=i.shape.length,l=es(a,i.shape);let c=l;const h=Mi(c,o);let d=i;h!=null&&(d=Xr({inputs:{x:i},backend:t,attrs:{perm:h}}),c=qi(c.length,o)),ir("all",c,o);const[p,g]=Ua(d.shape,c),v=qe(g),_=zt({inputs:{x:d},backend:t,attrs:{shape:[-1,v]}}),S=zg(_,_.dtype,"all",t);let b;if(r){const w=Xi(p,l);b=zt({inputs:{x:S},backend:t,attrs:{shape:w}})}else b=zt({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(S),h!=null&&t.disposeIntermediateTensorInfo(d),b}const G2e={kernelName:U2,backendName:"webgl",kernelFunc:$2e};function V2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s,o=i.shape.length,l=es(a,i.shape);let c=l;const h=Mi(c,o);let d=i;h!=null&&(d=Xr({inputs:{x:i},backend:t,attrs:{perm:h}}),c=qi(c.length,o)),ir("any",c,o);const[p,g]=Ua(d.shape,c),v=qe(g),_=zt({inputs:{x:d},backend:t,attrs:{shape:[-1,v]}}),S=zg(_,_.dtype,"any",t);let b;if(r){const w=Xi(p,l);b=zt({inputs:{x:S},backend:t,attrs:{shape:w}})}else b=zt({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(S),h!=null&&t.disposeIntermediateTensorInfo(d),b}const H2e={kernelName:P2,backendName:"webgl",kernelFunc:V2e};class W2e{constructor(e,t,s){this.variableNames=["A"];const{windowSize:i,batchSize:a,outSize:r}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,r];const o=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class j2e{constructor(e,t,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ee(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],r=Math.ceil(a/t);this.outputShape=e.slice(0,-1),r>1&&this.outputShape.push(r),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,c=qs(l),h=Hr("coords",l);let d,p;if(r===1){p=l+1;const U=qs(p);d=`
        ${U} sourceLocR = ${U}(${h.join()}, 0);
        ++${h[l-1]};
        ${U} sourceLocG = ${U}(${h.join()}, 0);
        ++${h[l-2]};
        ${U} sourceLocA = ${U}(${h.join()}, 0);
        --${h[l-1]};
        ${U} sourceLocB = ${U}(${h.join()}, 0);
        --${h[l-2]};`}else p=l,d=`
        ${c} sourceLocR = coords;
        ++${h[l-1]};
        ${c} sourceLocG = coords;
        ++${h[l-2]};
        ${c} sourceLocA = coords;
        --${h[l-1]};
        ${c} sourceLocB = coords;
        --${h[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,p),v="."+g[p-1],_=g.map(U=>"int "+U),S=Hr("sourceLocR",p-1).concat("inIdx.r"),b=Hr("sourceLocG",p-1).concat("inIdx.g"),w=Hr("sourceLocB",p-1).concat("inIdx.b"),T=Hr("sourceLocA",p-1).concat("inIdx.a"),E=s==="max"?"greaterThan":"lessThan",R=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${T.join()})));`,D=`vec4(
            getAChannel(${S.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,F=i?"":`
      float getBestIndicesAChannel(${_.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${_.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${F}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${h[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${h[l-2]} < ${o[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${v}, sourceLocG${v},
          sourceLocB${v}, sourceLocA${v}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${D};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${R}
          vec4 candidate = ${D};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${E}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function Ej(n,e,t,s=null){let i=e.shape[0],a=e.shape[1];s!=null&&(i=s.shape[0],a=s.shape[1]);const r=RN(a),o={windowSize:r,inSize:a,batchSize:i,outSize:Math.ceil(a/r)},l=new W2e(o,t,s==null),c=[e];s!=null&&c.push(s);const h=n.runWebGLProgram(l,c,"int32");if(h.shape[1]===1)return h;const d=Ej(n,e,t,h);return n.disposeIntermediateTensorInfo(h),d}function Mj(n,e,t,s=null){const i=s!=null?s.shape:e.shape,a=i[i.length-1],r=RN(a),o=new j2e(i,r,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(o,l,"int32");if(c.shape.length===e.shape.length){const h=Mj(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}return c}function Nj(n,e,t,s){const i=[t];if(ir("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,e.shape.length),!Pe().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],r=n.texData.get(e.dataId),o=r!==null&&r.isPacked;let l=e;o&&(l=n.unpackTensor(e),a.push(l));const[c,h]=Ua(l.shape,i),d=qe(h),p=zt({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});a.push(p);const g=Ej(n,p,s);a.push(g);const v=zt({inputs:{x:g},backend:n,attrs:{shape:c}});return a.forEach(_=>n.disposeIntermediateTensorInfo(_)),v}return Mj(n,e,s)}function X2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a}=s;let r=es(a,i.shape);const o=Mi(r,i.shape.length);let l=i;const c=[];o!=null&&(l=Xr({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),r=qi(r.length,l.shape.length)),ir("argMax",[r[0]],l.shape.length);const h=Nj(t,l,r[0],"max");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const q2e={kernelName:HS,backendName:"webgl",kernelFunc:X2e};function K2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a}=s;let r=es(a,i.shape);const o=Mi(r,i.shape.length);let l=i;const c=[];o!=null&&(l=Xr({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),r=qi(r.length,l.shape.length)),ir("argMin",[r[0]],l.shape.length);const h=Nj(t,l,r[0],"min");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const Y2e={kernelName:WS,backendName:"webgl",kernelFunc:K2e};const J2e=dc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Z2e=Ms({opSnippet:J2e}),Q2e={kernelName:by,backendName:"webgl",kernelFunc:Z2e};const eMe=dc+"return log(x + sqrt(x * x + 1.0));",tMe=Ms({opSnippet:eMe}),nMe={kernelName:Sy,backendName:"webgl",kernelFunc:tMe};const sMe=dc+`
  return atan(x);
`,iMe=Ms({opSnippet:sMe}),aMe={kernelName:_y,backendName:"webgl",kernelFunc:iMe};const rMe=$L+`
  return atan(a, b);
`,oMe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Pg+`
  return result;
`,lMe=rr({opSnippet:rMe,packedOpSnippet:oMe}),cMe={kernelName:wy,backendName:"webgl",kernelFunc:lMe};const uMe=dc+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,hMe=Ms({opSnippet:uMe}),dMe={kernelName:Ay,backendName:"webgl",kernelFunc:hMe};class bS{constructor(e,t,s,i=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const r=e.filterWidth,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const _=t==="avg",S=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(_||(w="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${g}, ${v});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?a?S:b:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const T="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const R=Math.floor(r/4)*4,D=r%4,F=`
      if (${_}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${g}, ${v});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${R}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${F}
          }

          int xC = xCCorner + ${R};
          if (${D===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${F}
          } else if (${D===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${F}
          }
        }
        setOutput(${E});
      }
    `}}class VL{constructor(e,t,s,i=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const r=e.filterWidth,o=e.strideDepth,l=e.strideHeight,c=e.strideWidth,h=e.dilationDepth,d=e.dilationHeight,p=e.dilationWidth,g=e.effectiveFilterDepth,v=e.effectiveFilterHeight,_=e.effectiveFilterWidth,S=e.padInfo.front,b=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const T=t==="avg";let E="0.0";if(T||(E="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${c});
        const ivec3 pads = ivec3(${S}, ${b}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${v};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${_};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${v} * ${_} +
                      wR * ${_} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const R="max";let D=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(D="avgValue / max(count, 1.0)");const F=Math.floor(r/4)*4,U=r%4,O=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${R}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${c});
      const ivec3 pads = ivec3(${S}, ${b}, ${w});
      const float initializationValue = ${E};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${E});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${v};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${F}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${O}
            }

            int xC = xCCorner + ${F};
            if (${U===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${U===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${U===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${O}
            }
          }
        }
        setOutput(${D});
      }
    `}}function fMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;wA(i,"avgPool");const{filterSize:a,strides:r,pad:o,dimRoundingMode:l}=s,c=1;ee(sr(r,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const h=uc(i.shape,a,r,c,o,l);if(h.filterWidth===1&&h.filterHeight===1&&as(h.inShape,h.outShape))return el({inputs:{x:i},backend:t});const d=new bS(h,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const pMe={kernelName:jS,backendName:"webgl",kernelFunc:fMe};function mMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:a,strides:r,pad:o,dimRoundingMode:l,dataFormat:c}=s,h=[1,1,1],d=wd(i.shape,a,r,h,o,l,c),p=new VL(d,"avg",!1);return t.runWebGLProgram(p,[i],"float32")}const gMe={kernelName:XS,backendName:"webgl",kernelFunc:mMe};class xMe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,a=e.strideWidth,r=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.top,d=c-1-e.padInfo.left,p=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class yMe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,a=e.strideDepth,r=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,v=d-1-e.padInfo.front,_=p-1-e.padInfo.top,S=g-1-e.padInfo.left,b=1/(t*s*i);this.userCode=`
      const ivec3 pads = ivec3(${v}, ${_}, ${S});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function vMe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a}=e,r=a,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=wd(r.shape,o,l,d,c,h),g=new yMe(p);return t.runWebGLProgram(g,[i],r.dtype)}const bMe={kernelName:$2,backendName:"webgl",kernelFunc:vMe};function SMe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a}=e,r=a;wA([i,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,h=uc(r.shape,o,l,1,c),d=new xMe(h);return t.runWebGLProgram(d,[i],r.dtype)}const _Me={kernelName:z2,backendName:"webgl",kernelFunc:SMe};function AMe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:a}=e,{transposeA:r,transposeB:o}=s;return jE({a:i,b:a,transposeA:r,transposeB:o,backend:t})}const wMe={kernelName:qS,backendName:"webgl",kernelFunc:AMe};class CMe{constructor(e,t,s,i,a,r){this.outputShape=[],this.variableNames=["x","mean","variance"],kn(e,t),kn(e,s);let o="0.0";i!=null&&(kn(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";a!=null&&(kn(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${r}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class TMe{constructor(e,t,s,i,a,r){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],kn(e,t),kn(e,s);let o="vec4(0.0)";i!=null&&(kn(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(kn(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${r}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const EMe=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:i,variance:a,offset:r,scale:o}=n;ee(i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ee(r==null||i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ee(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,i,a];let h=null;r!=null&&(h=r.shape,c.push(r));let d=null;o!=null&&(d=o.shape,c.push(o));const p=Pe().getBool("WEBGL_PACK_NORMALIZATION")?new TMe(s.shape,i.shape,a.shape,h,d,l):new CMe(s.shape,i.shape,a.shape,h,d,l);return e.runWebGLProgram(p,c,c[0].dtype)},MMe={kernelName:o_,backendName:"webgl",kernelFunc:EMe};class NMe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=qs(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=RMe(this.rank);let i;const a=e.map((r,o)=>`sourceLoc.${zD[o]} = start[${o}] + coords.${zD[o]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}}const zD=["x","y","z","w","u","v"];function RMe(n){if(n===1)return"sourceLoc";if(n<=6)return zD.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class IMe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=qs(this.rank),s=Hr("coords",this.rank),i=Hr("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,r=`getChannel(getSource(${i.join()}), ${a})`,o=`
      result.x = ${r};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${r};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${r};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${r};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((h,d)=>`start[${d}]`).join()});`:e.map((h,d)=>`${i[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}function DMe(n,e,t,s){const i=s.texData.get(n.dataId),a=s.makeTensorInfo(t,n.dtype),r=s.texData.get(a.dataId);Object.assign(r,i),r.refCount=1,r.shape=t,r.dtype=n.dtype;let o=Bk(e,gn(n.shape));i.slice&&(o+=i.slice.flatOffset),r.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=s.dataRefCount.get(r.slice.origDataId)||1;return s.dataRefCount.set(r.slice.origDataId,l+1),a}function Mv(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:a,size:r}=s,[o,l]=NN(i,a,r);if(Ik(i,o,l),qe(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const d=t.texData.get(i.dataId),p=wEe(d.values,o,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,p)}const{isPacked:c}=t.texData.get(i.dataId),h=Ok(i.shape,o,l);if(c||!h){const d=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IMe(l):new NMe(l),p=[o];return t.runWebGLProgram(d,[i],i.dtype,p)}return t.uploadToGPU(i.dataId),DMe(i,o,l,t)}const OMe={kernelName:L_,backendName:"webgl",kernelFunc:Mv};const BMe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:a,crops:r}=s;ee(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((w,T)=>w*T),l=hA(i.shape,a,o),c=dA(l.length,a.length),h=fA(i.shape,a,o),d=zk(r,a.length),p=$k(h,r,a.length),g=[],v=zt({inputs:{x:i},backend:t,attrs:{shape:l}}),_=Xr({inputs:{x:v},backend:t,attrs:{perm:c}}),S=zt({inputs:{x:_},backend:t,attrs:{shape:h}}),b=Mv({inputs:{x:S},backend:t,attrs:{begin:d,size:p}});return g.push(v),g.push(_),g.push(S),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),b},kMe={kernelName:KS,backendName:"webgl",kernelFunc:BMe};function LMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:a}=e,{size:r}=s,o=t.readSync(i.dataId),l=t.readSync(a.dataId),c=gj(o,l,a.dtype,a.shape,r);return t.makeTensorInfo([r],a.dtype,c)}const FMe={kernelName:G2,backendName:"webgl",kernelFunc:LMe};const UMe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,PMe=`
  return float(int(a.r) & int(b.r));
`;function zMe(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,a=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),r=Pe().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,i])||r===1){const l=t.texData.get(s.dataId).values,c=t.texData.get(i.dataId).values,[h,d]=qTe(s.shape,i.shape,l,c,s.dtype),p=t.makeTensorInfo(d,s.dtype),g=t.texData.get(p.dataId);return g.values=h,p}let o;return a?o=new Tv(UMe,s.shape,i.shape,!1):o=new _g(PMe,s.shape,i.shape),t.runWebGLProgram(o,[s,i],s.dtype)}const $Me={kernelName:YS,backendName:"webgl",kernelFunc:zMe};function GMe(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,a=t.readSync(s.dataId),r=t.readSync(i.dataId),o=kn(Array.from(a),Array.from(r));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const VMe={kernelName:V2,backendName:"webgl",kernelFunc:GMe};const HMe="return float(a != b);",Rj=rr({opSnippet:HMe,cpuKernelImpl:mEe,dtype:"bool"}),WMe={kernelName:w_,backendName:"webgl",kernelFunc:Rj};function TA(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return el({inputs:{x:i.complexTensorInfos.real},backend:t})}const jMe={kernelName:AM,backendName:"webgl",kernelFunc:TA};const XMe="return float(int(x));";function qMe(n,e){const t=new Yu(n.shape,XMe),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function $D(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:a}=s;if(a==="complex64"){if(i.dtype==="complex64")return el({inputs:{x:i},backend:t});const r=aa(i.shape),o=$D({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=mp({inputs:{real:o,imag:r},backend:t});return r.dispose(),t.disposeIntermediateTensorInfo(o),l}if(i.dtype==="complex64"){const r=TA({inputs:{input:i},backend:t}),o=$D({inputs:{x:r},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(r),o}if(!sB(i.dtype,a)){const r=el({inputs:{x:i},backend:t});return{dataId:r.dataId,shape:r.shape,dtype:a}}if(t.shouldExecuteOnCPU([i])){const r=t.texData.get(i.dataId).values,[o,l,c]=KTe(r,i.shape,i.dtype,a);return t.makeTensorInfo(o,l,c)}if(a==="int32")return qMe(i,t);if(a==="bool"){const r=t.makeTensorInfo([],"bool",ka("bool",1)),l=Rj({inputs:{a:i,b:r},backend:t});return t.disposeIntermediateTensorInfo(r),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}const KMe={kernelName:Cy,backendName:"webgl",kernelFunc:$D};const z$="return ceil(x);",YMe=Ms({opSnippet:z$,packedOpSnippet:z$,cpuKernelImpl:YTe}),JMe={kernelName:Ty,backendName:"webgl",kernelFunc:YMe};class ZMe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class QMe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function eNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:a,clipValueMax:r}=s;let o;Pe().getBool("WEBGL_PACK_CLIP")?o=new QMe(i.shape):o=new ZMe(i.shape);const l=[[a],[r]];return t.runWebGLProgram(o,[i],i.dtype,l)}const tNe={kernelName:Ey,backendName:"webgl",kernelFunc:eNe};class nNe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function $$(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function sNe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.texData.get(s.dataId),a=new nNe(s.shape),r=[$$(s,i.complexTensorInfos.real),$$(s,i.complexTensorInfos.imag)];return t.runWebGLProgram(a,r,r[0].dtype)}const iNe={kernelName:JS,backendName:"webgl",kernelFunc:sNe};class aNe{constructor(e){this.outputShape=[],this.outputShape=th(e,1),this.variableNames=e.map((r,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<t.length;r++){const o=t[r-1];s.push(`else if (yC < ${t[r]}) setOutput(getT${r}(yR, yC-${o}));`)}const i=t.length,a=t[t.length-1];s.push(`else setOutput(getT${i}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class rNe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=th(e,t);const s=this.outputShape,i=s.length,a=qs(i),r=Hr("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((_,S)=>`T${S}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let _=1;_<l.length;_++)l[_]=l[_-1]+e[_][t];const c=o[t],h=o.slice(-2),d=o.join();let p=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${h.join()}));
        }`;for(let _=1;_<l.length;_++){const S=l[_-1];p+=`
        if (${c} < ${l[_]}  && ${c} >= ${l[_-1]}) {
          return getChannel(
            getT${_}(${aT(o,c,S)}),
            vec2(${aT(h,c,S)}));
        }`}const g=l.length,v=l[l.length-1];p+=`
        return getChannel(
          getT${g}(${aT(o,c,v)}),
          vec2(${aT(h,c,v)}));`,this.userCode=`
      float getValue(${o.map(_=>"int "+_)}) {
        ${p}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${r}), 0., 0., 0.);

        ${r[i-1]} = ${r[i-1]} + 1;
        if (${r[i-1]} < ${s[i-1]}) {
          result.g = getValue(${r});
        }

        ${r[i-2]} = ${r[i-2]} + 1;
        if (${r[i-2]} < ${s[i-2]}) {
          result.a = getValue(${r});
        }

        ${r[i-1]} = ${r[i-1]} - 1;
        if (${r[i-2]} < ${s[i-2]} &&
            ${r[i-1]} < ${s[i-1]}) {
          result.b = getValue(${r});
        }
        setOutput(result);
      }
    `}}function aT(n,e,t){const s=n.indexOf(e);return n.map((a,r)=>r===s?`${a} - ${t}`:a).join()}function KN(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return el({inputs:{x:i.complexTensorInfos.imag},backend:t})}const oNe={kernelName:cM,backendName:"webgl",kernelFunc:KN};function I1(n,e,t){const s=n[0].dtype;if(s==="complex64"){const g=n.map(w=>TA({inputs:{input:w},backend:t})),v=n.map(w=>KN({inputs:{input:w},backend:t})),_=I1(g,e,t),S=I1(v,e,t),b=mp({inputs:{real:_,imag:S},backend:t});return g.forEach(w=>t.disposeIntermediateTensorInfo(w)),v.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(S),b}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const g=n.map(E=>{const D=[-1,qe(E.shape.slice(e))];return zt({inputs:{x:E},backend:t,attrs:{shape:D}})}),v=g.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),_=th(g.map(E=>E.shape),1),S=g[0].shape[0]===1,b=JTe(v,_,s,S),w=th(n.map(E=>E.shape),e),T=t.makeTensorInfo(w,s,b);return g.forEach(E=>t.disposeIntermediateTensorInfo(E)),T}const a=n.filter(g=>qe(g.shape)>0),r=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const g=r?new Yu(n[0].shape,Cf):new Df(n[0].shape,Cf);return t.runWebGLProgram(g,n,s)}const o=Pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const g=[];for(let _=0;_<a.length;_+=o){const S=a.slice(_,_+o);g.push(I1(S,e,t))}const v=I1(g,e,t);for(const _ of g)t.disposeIntermediateTensorInfo(_);return v}if(r){const g=new rNe(a.map(v=>v.shape),e);return t.runWebGLProgram(g,a,s)}const{tensors2D:l,outShape:c}=lNe(a,e,t),h=new aNe(l.map(g=>g.shape)),d=t.runWebGLProgram(h,l,s);l.forEach(g=>t.disposeIntermediateTensorInfo(g));const p=zt({inputs:{x:d},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(d),p}function lNe(n,e,t){const s=th(n.map(a=>a.shape),e);return{tensors2D:n.map(a=>zt({inputs:{x:a},attrs:{shape:[-1,qe(a.shape.slice(e))]},backend:t})),outShape:s}}function Ij(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,a=es(i,e[0].shape)[0],r=e.map(c=>c.shape);Fk(r,a);const o=th(e.map(c=>c.shape),a);if(qe(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(c=>qe(c.shape)>0);return l.length===1?el({inputs:{x:l[0]},backend:t}):I1(l,a,t)}const cNe={kernelName:ZS,backendName:"webgl",kernelFunc:Ij};class Dj{constructor(e,t=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const r=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,g=e.filterWidth,v=Math.floor(e.inChannels/4)*4,_=e.inChannels%4,S=e.dataFormat==="channelsLast",b=S?1:2,w=S?2:3,T=S?3:1;let E="",R="";s&&(i?E=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?E=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:E=`
          float activation(float x) {
            ${s}
          }
        `,R="result = activation(result);");const D=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${E}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${v}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${S}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${_===1}) {

              if (${S}) {
                dotProd +=
                    getX(batch, xR, xC, ${v}) *
                    getW(wR, wC, ${v}, d2);
              } else {
                dotProd +=
                    getX(batch, ${v}, xR, xC) *
                    getW(wR, wC, ${v}, d2);
              }

            } else if (${_===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2)
              );

              if (${S}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${_===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2),
                getW(wR, wC, ${v} + 2, d2)
              );

              if (${S}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1),
                  getX(batch, xR, xC, ${v} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC),
                  getX(batch, ${v} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${D}
        ${R}
        setOutput(result);
      }
    `}}class uNe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left,a=e.strideDepth,r=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterDepth,p=e.filterHeight,g=e.filterWidth,v=Math.floor(e.inChannels/4)*4,_=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${r}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${v}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${_===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${v}) *
                  getW(wF, wR, wC, ${v}, d2);
              } else if (${_===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${_===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1),
                  getX(batch, xF, xR, xC, ${v} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2),
                  getW(wF, wR, wC, ${v} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Oj{constructor(e,t=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_r(this.outputShape.length);const r=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<h;S++)p+=`
           vec4 xTexelC${S*2};
           int xTexelC${S*2}Ready;
           vec4 xTexelC${S*2+1};
           int xTexelC${S*2+1}Ready;
           vec4 xC${S};`;p+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let S=0;S<h;S++)p+=`
           xTexelC${S*2} = vec4(0.0);
           xTexelC${S*2}Ready = 0;
           xTexelC${S*2+1} = vec4(0.0);
           xTexelC${S*2+1}Ready = 0;
           xC${S} = vec4(0.0);`;p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let S=0;S<(d+1)/2;S++){const b=S*2;if(p+=`
           xC = xCCorner + ${b*l};
           `,o===1){if(b<h&&(r%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,l===1&&b>0?p+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<h)){const w=r%2===0?L2(l):l;l%2===0&&r%2===1||l%2!==0&&r%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:p+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):w===1?p+=`
                     xC${b+1} = xTexelC${b};
                     `:p+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<h&&(r%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<h&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<h&&(p+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<h&&(p+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<h&&(p+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let g="",v="";s&&(i?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:a?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:g=`vec4 activation(vec4 x) {
           ${s}
         }`,v="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${p}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${_}
         ${v}
         setOutput(result);
       }
     `}}class hNe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=_r(this.outputShape.length);const{dataFormat:s}=t,i=Yr(),a=s==="channelsLast",r=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let h=0;h<=1;h++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${h};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${r}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}function XE(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function Bj({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:r=0,activation:o=null}){const l=n.shape,c=s.texData.get(n.dataId),h=t.inChannels,d=l[0]*l[1]*l[2],p=t.outChannels,g=t.dataFormat==="channelsLast",v=!1,_=!1;let S;const b=[];if(a!=null){const E=XE(a.shape,g);E!=null&&(a=zt({inputs:{x:a},backend:s,attrs:{shape:E}}),b.push(a))}if(i!=null){const E=XE(i.shape,g);E!=null&&(i=zt({inputs:{x:i},backend:s,attrs:{shape:E}}),b.push(i))}if(!((d===1||p===1)&&h>Tj)&&c.isPacked&&g&&c.texture!=null&&l[2]%2!==0&&as(c.shape.slice(-3),l.slice(-3))){const E=l[0]*l[1]*(l[2]+1),R={dataId:n.dataId,shape:[1,E,t.inChannels],dtype:n.dtype},D=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,ee(WE(c.shape,R.shape),()=>`packed reshape ${c.shape} to ${R.shape} isn't free`);const F=zt({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(F);const U=jE({a:R,b:F,backend:s,transposeA:v,transposeB:_,bias:i,activation:o,preluActivationWeights:a,leakyreluAlpha:r}),O=s.texData.get(U.dataId);ee(O.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=D,O.shape=t.outShape,S=el({inputs:{x:U},backend:s}),S.shape=t.outShape,b.push(U)}else{const E=t.outHeight*t.outWidth,R=zt({inputs:{x:n},backend:s,attrs:{shape:g?[t.batchSize,E,t.inChannels]:[t.batchSize,t.inChannels,E]}}),D=zt({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),F=jE({a:g?R:D,b:g?D:R,transposeA:!g,transposeB:_,backend:s,bias:i,activation:o,preluActivationWeights:a,leakyreluAlpha:r});S=zt({inputs:{x:F},backend:s,attrs:{shape:t.outShape}}),b.push(R),b.push(D),b.push(F)}for(const E of b)s.disposeIntermediateTensorInfo(E);return S}function kj({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:r=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:g}=t,v=g==="channelsLast",_=l*c*h,S=p*d,b=[t.batchSize,_,S],w=!0,T=!1,E=[];if(a!=null){const q=XE(a.shape,v);q!=null&&(a=zt({inputs:{x:a},backend:s,attrs:{shape:q}}),E.push(a))}if(i!=null){const q=XE(i.shape,v);q!=null&&(i=zt({inputs:{x:i},backend:s,attrs:{shape:q}}),E.push(i))}const R=zt({inputs:{x:e},backend:s,attrs:{shape:[1,_,qe(e.shape)/_]}});E.push(R);const D=new hNe(b,t),F=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],U=s.runWebGLProgram(D,[n],"float32",F),O=zt({inputs:{x:U},backend:s,attrs:{shape:b}});E.push(U),E.push(O);const B=i!=null,L=a!=null,H=o==="leakyrelu",K=o?vS(o,!0):null,Z=new Cj(v?O.shape:R.shape,v?R.shape:O.shape,v?[t.batchSize,S,t.outChannels]:[t.batchSize,t.outChannels,S],w,T,B,K,L,H),Q=v?[O,R]:[R,O];if(i&&Q.push(i),L&&Q.push(a),H){const q=s.makeTensorInfo([],"float32",Ad(r,"float32"));Q.push(q),E.push(q)}const P=s.runWebGLProgram(Z,Q,"float32"),W=zt({inputs:{x:P},backend:s,attrs:{shape:t.outShape}});E.push(P);for(const q of E)s.disposeIntermediateTensorInfo(q);return W}function dNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dataFormat:l,dilations:c,dimRoundingMode:h}=s,d=Cd(l),p=Fa(i.shape,a.shape,r,c,o,h,!1,d);let g;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))g=Bj({x:i,filter:a,convInfo:p,backend:t});else if(p.strideWidth<=2&&d==="channelsLast"&&Pe().getBool("WEBGL_EXP_CONV")){const _=new Oj(p),S=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];g=t.runWebGLProgram(_,[i,a],"float32",S)}else if(Pe().getBool("WEBGL_CONV_IM2COL"))g=kj({x:i,filter:a,convInfo:p,backend:t});else{const _=new Dj(p);g=t.runWebGLProgram(_,[i,a],"float32")}const v=zt({inputs:{x:g},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(g),v}const fNe={kernelName:QS,backendName:"webgl",kernelFunc:dNe};class pNe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,a=e.padInfo.left,r=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${r?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class mNe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,a=e.strideWidth,r=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=r?1:2,h=r?2:3,d=r?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${r}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class gNe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,a=e.padInfo.front,r=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${r};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class xNe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,a=e.strideDepth,r=e.strideHeight,o=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,h=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function yNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:a}=e,{strides:r,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:h}=s,d=Cd(l),p=Fa(i.shape,h,r,1,o,c,!1,d),g=new pNe(p);return t.runWebGLProgram(g,[i,a],"float32")}const vNe={kernelName:W2,backendName:"webgl",kernelFunc:yNe};class bNe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=_r(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,i=t-1-e.padInfo.top,a=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function SNe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:a}=e,{inputShape:r,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=Cd(c),p=Fa(r,a.shape,o,1,l,h,!1,d);if(Pe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const g=[[p.strideHeight,p.strideWidth]],v=new bNe(p);return t.runWebGLProgram(v,[i,a],"float32",g)}else{const g=new mNe(p);return t.runWebGLProgram(g,[i,a],"float32")}}const _Ne={kernelName:e_,backendName:"webgl",kernelFunc:SNe};function ANe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dilations:l}=s,c=op(i.shape,a.shape,r,l,o),h=new uNe(c);return t.runWebGLProgram(h,[i,a],"float32")}const wNe={kernelName:t_,backendName:"webgl",kernelFunc:ANe};function CNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:a}=e,{strides:r,pad:o,filterShape:l}=s,c=op(i.shape,l,r,1,o),h=new gNe(c);return t.runWebGLProgram(h,[i,a],"float32")}const TNe={kernelName:j2,backendName:"webgl",kernelFunc:CNe};function ENe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:a}=e,{pad:r,strides:o,inputShape:l}=s,c=op(l,a.shape,o,1,r),h=new xNe(c);return t.runWebGLProgram(h,[i,a],"float32")}const MNe={kernelName:X2,backendName:"webgl",kernelFunc:ENe};const NNe=Ev+`
  return cos(x);
`,RNe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Pg}
  return result;
`,INe=Ms({opSnippet:NNe,packedOpSnippet:RNe}),DNe={kernelName:My,backendName:"webgl",kernelFunc:INe};const ONe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,BNe=Ms({opSnippet:ONe}),kNe={kernelName:Ny,backendName:"webgl",kernelFunc:BNe};class LNe{constructor(e,t,s,i,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[r,o,l,c]=e,[h]=t,[d,p]=s;this.outputShape=[h,d,p,c];const g=i==="bilinear"?1:0,[v,_]=[`${o-1}.0`,`${l-1}.0`],[S,b,w]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${v} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${v}`],[T,E,R]=p>1?[`${(l-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${_} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${_}`];this.userCode=`
      const float height_ratio = float(${S});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${r}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${E};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${v} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${R};
        if( in_x < 0.0 || in_x > ${_} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const FNe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:a,boxInd:r}=e,{cropSize:o,method:l,extrapolationValue:c}=s,h=new LNe(i.shape,a.shape,o,l,c);return t.runWebGLProgram(h,[i,a,r],"float32")},UNe={kernelName:K2,backendName:"webgl",kernelFunc:FNe};var SS;(function(n){n.Prod="*",n.Sum="+"})(SS||(SS={}));class G${constructor(e,t,s,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,r=this.op===SS.Prod?"1.0":"0.0",o=s?r:`getX(${V$(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",h="";s?(c=i?`end != ${l-1}`:"end != 0",h=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",h=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${qs(a)} coords = getOutputCoords();
        int end = ${H$(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${h};
          ${H$(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${V$(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function V$(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function H$(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Lj(n,e,t,s,i,a){const r=e.shape.length,o=Mi([s],r);let l=e;o!=null&&(l=Xr({inputs:{x:e},backend:t,attrs:{perm:o}}));const c=qi(1,r)[0];if(c!==r-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const h=l.shape[c];let d=el({inputs:{x:l},backend:t});for(let p=0;p<=Math.ceil(Math.log2(h))-1;p++){const g=new G$(n,l.shape,!1,a),v=[[p]],_=d;d=t.runWebGLProgram(g,[d],d.dtype,v),t.disposeIntermediateTensorInfo(_)}if(i){const p=new G$(n,l.shape,i,a),g=d;d=t.runWebGLProgram(p,[d],d.dtype),t.disposeIntermediateTensorInfo(g)}if(o!=null){const p=lp(o),g=Xr({inputs:{x:d},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(l),g}return d}function PNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,exclusive:r,reverse:o}=s;return Lj(SS.Prod,i,t,a,r,o)}const zNe={kernelName:q2,backendName:"webgl",kernelFunc:PNe};function $Ne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,exclusive:r,reverse:o}=s;return Lj(SS.Sum,i,t,a,r,o)}const GNe={kernelName:n_,backendName:"webgl",kernelFunc:$Ne};function VNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:a}=e,{size:r,binaryOutput:o}=s;if(i.shape.length===1){const l=t.readSync(i.dataId),c=t.readSync(a.dataId),h=gj(l,c,a.dtype,a.shape,r);return t.makeTensorInfo([r],a.dtype,h)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(a),h=XTe(l,c,r,o);return t.makeTensorInfo(h.shape,a.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const HNe={kernelName:Y2,backendName:"webgl",kernelFunc:VNe};class WNe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function jNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:a,dataFormat:r}=s,o=i.shape[0],l=r==="NHWC"?i.shape[1]:i.shape[2],c=r==="NHWC"?i.shape[2]:i.shape[3],h=r==="NHWC"?i.shape[3]:i.shape[1],d=l*a,p=c*a,g=h/(a*a),v=r==="NHWC"?[o,d,p,g]:[o,g,d,p],_=new WNe(v,a,r);return t.runWebGLProgram(_,[i],i.dtype)}const XNe={kernelName:J2,backendName:"webgl",kernelFunc:jNe};class Fj{constructor(e,t=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_r(this.outputShape.length);const r=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let c="",h="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,h="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${r}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${h}
        setOutput(result);
      }
    `}}class Uj{constructor(e,t=!1,s=null,i=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_r(this.outputShape.length);const r=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=d;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)g+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;g+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let b=0;b<d;b++)g+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(p+1)/2;b++){const w=b*2;if(g+=`
          xC = xCCorner + ${w*c};
          `,l===1){if(w<d&&(o%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,c===1&&w>0?g+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<d)){const T=o%2===0?L2(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${T};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,c>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:g+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):T===1?g+=`
                    xC${w+1} = xTexelC${w};
                    `:g+=`
                    xCOffset = xC + ${T};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<d&&(o%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<d&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<d&&(g+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<d&&(g+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<d&&(g+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let v="",_="";s&&(i?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:v=`vec4 activation(vec4 x) {
          ${s}
        }`,_="result = activation(result);");const S=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${r};
        int q = d2 - d1 * ${r};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${S}
        ${_}
        setOutput(result);
      }
    `}}function qNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dilations:l,dimRoundingMode:c}=s;let h=l;h==null&&(h=[1,1]),ee(sr(r,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${h}'`);const d=Fa(i.shape,a.shape,r,h,o,c,!0);let p;Pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new Uj(d):p=new Fj(d);const g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(p,[i,a],"float32",g)}const KNe={kernelName:s_,backendName:"webgl",kernelFunc:qNe};class YNe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,a=e.padInfo.left,r=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${r} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class JNe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,a=e.strideWidth,r=t-1-e.padInfo.top,o=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function ZNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:a}=e,{strides:r,dilations:o,pad:l,dimRoundingMode:c,filterShape:h}=s,d=Fa(i.shape,h,r,o,l,c,!0),p=new YNe(d);return t.runWebGLProgram(p,[i,a],"float32")}const QNe={kernelName:Z2,backendName:"webgl",kernelFunc:ZNe};function eRe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:a}=e,{strides:r,dilations:o,pad:l,dimRoundingMode:c,inputShape:h}=s,d=Fa(h,a.shape,r,o,l,c,!0),p=new JNe(d);return t.runWebGLProgram(p,[i,a],"float32")}const tRe={kernelName:Q2,backendName:"webgl",kernelFunc:eRe};class nRe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function sRe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],a=qe(s.shape),r=zt({inputs:{x:s},backend:t,attrs:{shape:[a]}}),o=new nRe(a),l=t.runWebGLProgram(o,[r],r.dtype),c=zt({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(l),c}const iRe={kernelName:eM,backendName:"webgl",kernelFunc:sRe};class aRe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:i,strideHeight:a,strideWidth:r,filterHeight:o,filterWidth:l,dilationHeight:c,dilationWidth:h}=e,{top:d,left:p}=i;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${r});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function rRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a}=e,{strides:r,pad:o,dilations:l}=s,c=X_(i.shape,a.shape,r,o,"NHWC",l);let h;const d=new aRe(c);h=t.runWebGLProgram(d,[i,a],"float32");const p=zt({inputs:{x:h},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(h),p}const oRe={kernelName:i_,backendName:"webgl",kernelFunc:rRe};function lRe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,a=e,{allDims:r,summedDims:o,idDims:l}=Kk(i,a.length);Jk(r.length,l,a);const{path:c,steps:h}=Zk(o,l),d=h.length;let p=null,g=r.length;const v=[];for(let _=0;_<d;++_){for(const S of h[_]){const{permutationIndices:b,expandDims:w}=Yk(g,l[S]);let T;Qk(b)?T=a[S]:(T=Xr({inputs:{x:a[S]},backend:t,attrs:{perm:b}}),v.push(T));const E=T.shape.slice();for(let R=0;R<w.length;++R)E.splice(w[R],0,1);as(T.shape,E)||(T=zt({inputs:{x:T},backend:t,attrs:{shape:E}}),v.push(T)),p===null?p=T:(p=GL({inputs:{a:T,b:p},backend:t}),v.push(p))}_<d-1&&(c[_]>=0&&(p=qN({inputs:{x:p},backend:t,attrs:{axis:c[_]-(r.length-g),keepDims:!1}}),v.push(p)),g--)}for(const _ of v)_!==p&&t.disposeIntermediateTensorInfo(_);return p}const cRe={kernelName:nM,backendName:"webgl",kernelFunc:lRe};const uRe="return (x >= 0.0) ? x : (exp(x) - 1.0);",hRe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,dRe=Ms({opSnippet:uRe,packedOpSnippet:hRe}),fRe={kernelName:Iy,backendName:"webgl",kernelFunc:dRe};const pRe="return (b >= 0.0) ? a : a * (b + 1.0);",mRe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,gRe=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,a=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Tv(mRe,s.shape,i.shape):new _g(pRe,s.shape,i.shape);return t.runWebGLProgram(a,[s,i],s.dtype)},xRe={kernelName:sM,backendName:"webgl",kernelFunc:gRe};const yRe=`
  return vec4(equal(a, b));
`,vRe="return float(a == b);",bRe=rr({opSnippet:vRe,packedOpSnippet:yRe,dtype:"bool",cpuKernelImpl:ZTe}),SRe={kernelName:a_,backendName:"webgl",kernelFunc:bRe};const _Re=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Gk};
  float a1 = ${Vk};
  float a2 = ${Hk};
  float a3 = ${Wk};
  float a4 = ${jk};
  float a5 = ${Xk};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ARe=Ms({opSnippet:_Re}),wRe={kernelName:Dy,backendName:"webgl",kernelFunc:ARe};const CRe=Ev+`
  return exp(x);
`,TRe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Pj=Ms({opSnippet:CRe,packedOpSnippet:TRe,cpuKernelImpl:QTe,dtype:"float32"}),ERe={kernelName:Oy,backendName:"webgl",kernelFunc:Pj};function GD(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:a}=e,r=a.shape.length,o=a.shape.slice();let l=i;return i<0&&(ee(-(r+1)<=i,()=>`Axis must be in the interval [${-(r+1)}, ${r}]`),l=r+i+1),o.splice(l,0,1),zt({inputs:{x:a},backend:s,attrs:{shape:o}})}const MRe={kernelName:r_,backendName:"webgl",kernelFunc:GD};const W$="return exp(x) - 1.0;",NRe=Ms({opSnippet:W$,packedOpSnippet:W$,cpuKernelImpl:eEe}),RRe={kernelName:By,backendName:"webgl",kernelFunc:NRe};class j${constructor(e,t,s){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,r=s?`${i}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${r};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function zj(n,e,t){const s=t.texData.get(n.dataId),i=qe(n.shape),a=n.shape[n.shape.length-1],r=i/a,o=zt({inputs:{x:n},backend:t,attrs:{shape:[r,a]}}),l=o.shape,c=new j$("real",l,e),h=new j$("imag",l,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],p=t.runWebGLProgram(c,d,"float32"),g=t.runWebGLProgram(h,d,"float32"),v=mp({inputs:{real:p,imag:g},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g);const _=zt({inputs:{x:v},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(v),_}function IRe(n){const{inputs:e,backend:t}=n,{input:s}=e;return zj(s,!1,t)}const DRe={kernelName:iM,backendName:"webgl",kernelFunc:IRe};class ORe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function EA(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:a}=t;if(a=a||Mg(i),a==="string"){const r=Ui(a,qe(s));return r.fill(i),e.makeTensorInfo(s,a,r)}else{const r=new ORe(s,i),o=[[i]];return e.runWebGLProgram(r,[],a,o)}}const BRe={kernelName:aM,backendName:"webgl",kernelFunc:EA};class kRe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const LRe={kernelName:rM,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new kRe(t.shape);return s.runWebGLProgram(i,[t],t.dtype)}};const X$="return floor(x);",FRe=Ms({opSnippet:X$,packedOpSnippet:X$,cpuKernelImpl:tEe}),URe={kernelName:ky,backendName:"webgl",kernelFunc:FRe};const PRe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,zRe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,$Re=rr({opSnippet:PRe,packedOpSnippet:zRe,dtype:"int32"}),GRe={kernelName:Ly,backendName:"webgl",kernelFunc:$Re};class VRe{constructor(e){this.variableNames=["A"];const t=Yr(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class HRe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Yr(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const WRe={kernelName:wE,backendName:"webgl",kernelFunc:jRe};let xx,b3=Pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function jRe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:a}=s,r=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=r?[i.videoWidth,i.videoHeight]:[i.width,i.height],h=[c,l],d=[c,l,a];if(o||r){const _=Pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(xx==null||_!==b3)&&(b3=_,xx=document.createElement("canvas").getContext("2d",{willReadFrequently:b3})),xx.canvas.width=l,xx.canvas.height=c,xx.drawImage(i,0,0,l,c),i=xx.canvas}const p=t.makeTensorInfo(h,"int32");t.texData.get(p.dataId).usage=bl.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),i);const g=Pe().getBool("WEBGL_PACK")?new HRe(d):new VRe(d),v=t.runWebGLProgram(g,[p],"int32");return t.disposeData(p.dataId),v}function XRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a,bias:r,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:g,leakyreluAlpha:v}=s,_=Cd(h),S=Fa(i.shape,a.shape,l,d,c,p,!1,_);let b;const w=[],T=r!=null,E=o!=null,R=g==="leakyrelu",D=()=>{const U=[i,a],O=(B,L)=>{if(L==="NCHW"&&B.shape.length===1&&B.shape[0]!==1){const H=zt({inputs:{x:B},backend:t,attrs:{shape:[B.shape[0],1,1]}});return w.push(H),H}return B};if(T&&U.push(O(r,h)),E&&U.push(O(o,h)),R){const B=t.makeTensorInfo([],"float32",Ad(v,"float32"));U.push(B),w.push(B)}return U};if(S.filterHeight===1&&S.filterWidth===1&&S.dilationHeight===1&&S.dilationWidth===1&&S.strideHeight===1&&S.strideWidth===1&&(S.padInfo.type==="SAME"||S.padInfo.type==="VALID"))b=Bj({x:i,filter:a,convInfo:S,backend:t,bias:r,activation:g,preluActivationWeights:o,leakyreluAlpha:v});else if(S.strideWidth<=2&&_==="channelsLast"&&Pe().getBool("WEBGL_EXP_CONV")){const U=g?vS(g,!0):null,O=new Oj(S,T,U,E,R),B=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],L=D();b=t.runWebGLProgram(O,L,"float32",B)}else if(Pe().getBool("WEBGL_CONV_IM2COL"))b=kj({x:i,filter:a,convInfo:S,backend:t,bias:r,activation:g,preluActivationWeights:o,leakyreluAlpha:v});else{const U=g?vS(g,!1):null,O=new Dj(S,T,U,E,R),B=D();b=t.runWebGLProgram(O,B,"float32")}const F=zt({inputs:{x:b},backend:t,attrs:{shape:S.outShape}});return w.push(b),w.forEach(U=>t.disposeIntermediateTensorInfo(U)),F}const qRe={kernelName:iS,backendName:"webgl",kernelFunc:XRe};function KRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:a,bias:r,preluActivationWeights:o}=e,{strides:l,pad:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:g}=s,v=[];let _=h;_==null&&(_=[1,1]),ee(sr(l,_),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${_}'`);const S=Fa(i.shape,a.shape,l,_,c,d,!0),b=Pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels===1,w=p?vS(p,b):null,T=[i,a],E=r!=null,R=o!=null,D=p==="leakyrelu";if(E&&T.push(r),R&&T.push(o),D){const B=t.makeTensorInfo([],"float32",Ad(g,"float32"));T.push(B),v.push(B)}let F;b?F=new Uj(S,E,w,R,D):F=new Fj(S,E,w,R,D);const U=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],O=t.runWebGLProgram(F,T,"float32",U);return v.forEach(B=>t.disposeIntermediateTensorInfo(B)),O}const YRe={kernelName:aS,backendName:"webgl",kernelFunc:KRe};class JRe{constructor(e,t,s,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const a=qs(s.length);let r=`
    int index;`;for(let o=0;o<this.sliceDim;o++)r+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${r}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function ZRe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,a=i.shape,r=a[a.length-1],o=qe(s.shape),[l,c,h,d]=MN(s,i),p=zt({inputs:{x:i},backend:t,attrs:{shape:[c,r]}}),g=zt({inputs:{x:s},backend:t,attrs:{shape:[qe(s.shape)/h,h]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=t.readSync(i.dataId),w=t.bufferSync(s),T=nEe(b,w,s.dtype,c,r,h,d,s.shape,o);return t.makeTensorInfo(l,s.dtype,T.values)}const v=new JRe(r,d,[c,h],s.shape),_=t.runWebGLProgram(v,[g,p],g.dtype),S=zt({inputs:{x:_},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(_),S}const QRe={kernelName:oM,backendName:"webgl",kernelFunc:ZRe};class eIe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=qs(this.rank),i=tIe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function tIe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${t[i]}`);return s.join()}function $j(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:a}=e,{axis:r,batchDims:o}=s,l=es(r,i.shape)[0];if(Pe().get("DEBUG")){const w=t.readSync(a.dataId),T=i.shape[l];for(let E=0;E<w.length;++E){const R=w[E];ee(R<=T-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${T-1}]`)}}const c=tL(i,a,l,o),h=qe(a.shape),d=[],p=zt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=zt({inputs:{x:a},backend:t,attrs:{shape:[c.batchSize,h/c.batchSize]}});d.push(p),d.push(g);const v=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,a])||i.dtype==="string"){const w=t.bufferSync(g),T=t.bufferSync(p),E=sEe(T,w,v);return d.forEach(R=>t.disposeIntermediateTensorInfo(R)),t.makeTensorInfo(c.outputShape,E.dtype,E.values)}const _=new eIe(p.shape,v),S=t.runWebGLProgram(_,[p,g],p.dtype);d.push(S);const b=zt({inputs:{x:S},backend:t,attrs:{shape:c.outputShape}});return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}const nIe={kernelName:l_,backendName:"webgl",kernelFunc:$j};const sIe="return float(a > b);",iIe=`
  return vec4(greaterThan(a, b));
`,aIe=rr({opSnippet:sIe,packedOpSnippet:iIe,cpuKernelImpl:iEe,dtype:"bool"}),rIe={kernelName:c_,backendName:"webgl",kernelFunc:aIe};const oIe="return float(a >= b);",lIe=`
  return vec4(greaterThanEqual(a, b));
`,cIe=rr({opSnippet:oIe,packedOpSnippet:lIe,dtype:"bool",cpuKernelImpl:aEe}),uIe={kernelName:Fy,backendName:"webgl",kernelFunc:cIe};function hIe(n){const{inputs:e,backend:t}=n,{input:s}=e;return zj(s,!0,t)}const dIe={kernelName:lM,backendName:"webgl",kernelFunc:hIe};const fIe="return float(!isnan(x) && !isinf(x));",pIe=Ms({opSnippet:fIe,dtype:"bool"}),mIe={kernelName:Py,backendName:"webgl",kernelFunc:pIe};const gIe="return float(isinf(x));",xIe=Ms({opSnippet:gIe,dtype:"bool"}),yIe={kernelName:zy,backendName:"webgl",kernelFunc:xIe};const vIe="return float(isnan(x));",bIe=Ms({opSnippet:vIe,dtype:"bool"}),SIe={kernelName:$y,backendName:"webgl",kernelFunc:bIe};const _Ie="return float(a < b);",AIe=`
  return vec4(lessThan(a, b));
`,wIe=rr({opSnippet:_Ie,packedOpSnippet:AIe,cpuKernelImpl:rEe,dtype:"bool"}),CIe={kernelName:h_,backendName:"webgl",kernelFunc:wIe};const TIe="return float(a <= b);",EIe=`
  return vec4(lessThanEqual(a, b));
`,MIe=rr({opSnippet:TIe,packedOpSnippet:EIe,cpuKernelImpl:oEe,dtype:"bool"}),NIe={kernelName:d_,backendName:"webgl",kernelFunc:MIe};function RIe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:a}=t,r=lEe(s,i,a);return e.makeTensorInfo([r.length],"float32",r)}const IIe={kernelName:uM,backendName:"webgl",kernelFunc:RIe};const DIe=Ev+`
  return x < 0.0 ? 0./0. : log(x);
`,OIe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,BIe=Ms({opSnippet:DIe,packedOpSnippet:OIe,cpuKernelImpl:cEe}),kIe={kernelName:Gy,backendName:"webgl",kernelFunc:BIe};const LIe=Ev+`
  return log(1.0 + x);
`,FIe=Ms({opSnippet:LIe}),UIe={kernelName:Vy,backendName:"webgl",kernelFunc:FIe};const PIe="return float(a >= 1.0 && b >= 1.0);",zIe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,$Ie=rr({opSnippet:PIe,packedOpSnippet:zIe,dtype:"bool"}),GIe={kernelName:f_,backendName:"webgl",kernelFunc:$Ie};const VIe="return float(!(x >= 1.0));",HIe=Ms({opSnippet:VIe}),WIe={kernelName:p_,backendName:"webgl",kernelFunc:HIe};const jIe="return float(a >= 1.0 || b >= 1.0);",XIe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,qIe=rr({opSnippet:jIe,packedOpSnippet:XIe,dtype:"bool"}),KIe={kernelName:m_,backendName:"webgl",kernelFunc:qIe};class YIe{constructor(e,t,s,i,a){this.variableNames=["x"],this.outputShape=[];const r=t,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;a===.5?l=`inversesqrt(${c})`:a===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${r}; j <= ${r}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class JIe{constructor(e,t,s,i,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const r=t,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;a===.5?l=`inversesqrt(${c})`:a===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${r};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${r}; j <= ${r}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const ZIe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:a,bias:r,alpha:o,beta:l}=s,c=Pe().getBool("WEBGL_PACK_NORMALIZATION")?new JIe(i.shape,a,r,o,l):new YIe(i.shape,a,r,o,l);return t.runWebGLProgram(c,[i],i.dtype)},QIe={kernelName:g_,backendName:"webgl",kernelFunc:ZIe};class e3e{constructor(e,t,s,i,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=i,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const t3e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i,y:a,dy:r}=e,{depthRadius:o,bias:l,alpha:c,beta:h}=s,d=new e3e(i.shape,o,l,c,h);return t.runWebGLProgram(d,[i,a,r],i.dtype)},n3e={kernelName:hM,backendName:"webgl",kernelFunc:t3e};function s3e(n,e,t,s){const i=qe(e),r=qe(n.shape)/i,o=zt({inputs:{x:n},attrs:{shape:[r,i]},backend:s}),l=zg(o,n.dtype,"max",s),c=zt({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}function Gj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:a,keepDims:r}=s,o=i.shape.length,l=es(a,i.shape);let c=l;const h=Mi(c,o),d=h!=null,p=t.shouldExecuteOnCPU([i]);let g=i;if(d){if(p){const T=t.texData.get(g.dataId).values,E=new Array(o);for(let F=0;F<E.length;F++)E[F]=i.shape[h[F]];const R=zL(T,i.shape,i.dtype,h,E);g=t.makeTensorInfo(E,i.dtype);const D=t.texData.get(g.dataId);D.values=R}else g=XN(i,h,t);c=qi(c.length,o)}ir("max",c,o);const[v,_]=Ua(g.shape,c);let S=v;r&&(S=Xi(v,l));let b;if(p){const T=t.texData.get(g.dataId).values,E=uEe(T,qe(_),S,i.dtype);b=t.makeTensorInfo(S,i.dtype);const R=t.texData.get(b.dataId);R.values=E}else b=s3e(g,_,S,t);return d&&t.disposeIntermediateTensorInfo(g),b}const i3e={kernelName:x_,backendName:"webgl",kernelFunc:Gj};const a3e=$L+`
  return max(a, b);
`,r3e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Pg+`
  return result;
`,o3e=rr({opSnippet:a3e,packedOpSnippet:r3e,cpuKernelImpl:hEe}),l3e={kernelName:Hy,backendName:"webgl",kernelFunc:o3e};function c3e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;wA(i,"maxPool");const{filterSize:a,strides:r,pad:o,dimRoundingMode:l}=s,c=1;ee(sr(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const h=uc(i.shape,a,r,c,o,l);if(h.filterWidth===1&&h.filterHeight===1&&as(h.inShape,h.outShape))return el({inputs:{x:i},backend:t});const d=new bS(h,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const u3e={kernelName:y_,backendName:"webgl",kernelFunc:c3e};function h3e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:a,strides:r,pad:o,dataFormat:l,dimRoundingMode:c}=s,h=[1,1,1],d=wd(i.shape,a,r,h,o,c,l),p=new VL(d,"max",!1);return t.runWebGLProgram(p,[i],i.dtype)}const d3e={kernelName:v_,backendName:"webgl",kernelFunc:h3e};class f3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,a=e.effectiveFilterHeight,r=e.effectiveFilterWidth,o=a-1-e.padInfo.top,l=r-1-e.padInfo.left,c=a*r-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${r} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class p3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,r=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=l-1-e.padInfo.front,p=c-1-e.padInfo.top,g=h-1-e.padInfo.left,v=l*c*h-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${r}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${v} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function m3e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a}=e,r=a,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s,d=[1,1,1],p=wd(r.shape,o,l,d,c,h),g=new VL(p,"max",!0),v=t.runWebGLProgram(g,[r],r.dtype),_=new p3e(p),S=t.runWebGLProgram(_,[i,v],r.dtype);return t.disposeIntermediateTensorInfo(v),S}const g3e={kernelName:fM,backendName:"webgl",kernelFunc:m3e};function x3e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:a,output:r}=e,o=a;wA([a,r],"maxPoolGrad");const{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=uc(o.shape,l,c,1,h,d),g=!0,v=new bS(p,"max",g),_=t.runWebGLProgram(v,[o],o.dtype),S=new f3e(p),b=t.runWebGLProgram(S,[i,_],o.dtype);return t.disposeIntermediateTensorInfo(_),b}const y3e={kernelName:dM,backendName:"webgl",kernelFunc:x3e};function v3e(n,e,t,s){let i=new bS(t,"max",!1);const a=s.runWebGLProgram(i,[n],"float32");i=new bS(t,"max",!0,!0,e);const r=s.runWebGLProgram(i,[n],"float32");return[a,r]}const b3e={kernelName:pM,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:a,pad:r,includeBatchInIndex:o}=e,l=t;ee(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];ee(sr(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const h=uc(s.shape,i,a,c,r),[d,p]=v3e(s,o,h,l);return[d,p]}};function S3e(n,e,t,s){const i=qe(e),r=qe(n.shape)/i,o=zt({inputs:{x:n},attrs:{shape:[r,i]},backend:s}),l=zg(o,"float32","mean",s),c=zt({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),c}const _3e={kernelName:b_,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:i,axis:a}=e,r=t,o=s.shape.length,l=es(a,s.shape);let c=l;const h=Mi(c,o),d=h!=null,p=r.shouldExecuteOnCPU([s]),g=[];let v=s;if(d){if(p){const E=r.texData.get(v.dataId).values,R=new Array(o);for(let U=0;U<R.length;U++)R[U]=s.shape[h[U]];const D=zL(E,s.shape,s.dtype,h,R);v=r.makeTensorInfo(R,s.dtype);const F=r.texData.get(v.dataId);F.values=D}else v=XN(s,h,r);g.push(v),c=qi(c.length,o)}ir("sum",c,o);const[_,S]=Ua(v.shape,c);let b=_;i&&(b=Xi(_,l));const w=S3e(v,S,b,r);for(const T of g)r.disposeIntermediateTensorInfo(T);return w}};function A3e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s,o=i.shape.length,l=es(a,i.shape);let c=l;const h=Mi(c,o);let d=i;h!=null&&(d=Xr({inputs:{x:i},backend:t,attrs:{perm:h}}),c=qi(c.length,i.shape.length)),ir("min",c,o);const[p,g]=Ua(d.shape,c),v=qe(g),_=zt({inputs:{x:d},backend:t,attrs:{shape:[-1,v]}}),S=zg(_,_.dtype,"min",t);let b;if(r){const w=Xi(p,l);b=zt({inputs:{x:S},backend:t,attrs:{shape:w}})}else b=zt({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(S),h!=null&&t.disposeIntermediateTensorInfo(d),b}const w3e={kernelName:S_,backendName:"webgl",kernelFunc:A3e};const C3e=$L+`
  return min(a, b);
`,T3e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Pg+`
  return result;
`,E3e=rr({opSnippet:C3e,packedOpSnippet:T3e,cpuKernelImpl:dEe}),M3e={kernelName:Wy,backendName:"webgl",kernelFunc:E3e};class N3e{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((h,d)=>h[0]+e[d]+h[1]);const i=e.length,a=qs(i),r=t.map(h=>h[0]).join(","),o=t.map((h,d)=>h[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${r};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${r});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class R3e{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((v,_)=>v[0]+e[_]+v[1]);const i=e.length,a=qs(i),r=t.map(v=>v[0]).join(","),o=t.map((v,_)=>v[0]+e[_]).join(","),l=Hr("rc",i),c=Hr("source",i),h=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,p=s==="reflect"?0:1;let g="";if(i===1){const v=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;g=`
        ${a} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const v=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;g=`
        ${a} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${v}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[i-1]} += 1;
          if(${h}) {
            ${v}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${r});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}const I3e=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:i,mode:a}=t,r=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new R3e(s.shape,i,a):new N3e(s.shape,i,a);return e.runWebGLProgram(r,[s],s.dtype)},D3e={kernelName:__,backendName:"webgl",kernelFunc:I3e};const O3e=`if (b == 0.0) return NAN;
  return mod(a, b);`,B3e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Pg+`
  return result;
`,k3e=rr({opSnippet:O3e,packedOpSnippet:B3e}),L3e={kernelName:jy,backendName:"webgl",kernelFunc:k3e};class F3e{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const U3e=`
if (a == b) {
  return 1.0;
};
return a / b;`,P3e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Vj=rr({opSnippet:U3e,packedOpSnippet:P3e,checkOutOfBounds:!0}),z3e={kernelName:Ry,backendName:"webgl",kernelFunc:Vj};const q$="return a - b;",Hj=rr({opSnippet:q$,packedOpSnippet:q$,supportsComplex:!0,cpuKernelImpl:OEe}),$3e={kernelName:lv,backendName:"webgl",kernelFunc:Hj};function Wj(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:a}=s,r=es([a],i.shape),o=Gj({inputs:{x:i},backend:t,attrs:{reductionIndices:r,keepDims:!1}}),l=Xi(o.shape,r),c=zt({inputs:{x:o},backend:t,attrs:{shape:l}}),h=Hj({inputs:{a:i,b:c},backend:t}),d=Pj({inputs:{x:h},backend:t}),p=qN({inputs:{x:d},backend:t,attrs:{axis:r,keepDims:!1}}),g=zt({inputs:{x:p},backend:t,attrs:{shape:l}}),v=Vj({inputs:{a:d,b:g},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),v}const G3e={kernelName:z_,backendName:"webgl",kernelFunc:Wj};function V3e(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:a,seed:r,normalized:o}=s,l=o?i:Wj({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],h=l.shape[1],d=new F3e(c,h,a),p=[[r]],g=t.runWebGLProgram(d,[l],"int32",p);return o||t.disposeIntermediateTensorInfo(l),g}const H3e={kernelName:mM,backendName:"webgl",kernelFunc:V3e};const W3e=dc+`
  return -x;
`,j3e=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function X3e(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const a=t.texData.get(s.dataId),[r,o]=pEe(a.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,r)}let i;return Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Df(s.shape,j3e):i=new Yu(s.shape,W3e),t.runWebGLProgram(i,[s],s.dtype)}const q3e={kernelName:A_,backendName:"webgl",kernelFunc:X3e};const K3e=wN;function Y3e(n){gl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:a}=e,{maxOutputSize:r,iouThreshold:o,scoreThreshold:l}=s,c=t.readSync(i.dataId),h=t.readSync(a.dataId),{selectedIndices:d}=K3e(c,h,r,o,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const J3e={kernelName:gM,backendName:"webgl",kernelFunc:Y3e};const Z3e=CN;function Q3e(n){gl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:a}=e,{maxOutputSize:r,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s,h=t.readSync(i.dataId),d=t.readSync(a.dataId),{selectedIndices:p,validOutputs:g}=Z3e(h,d,r,o,l,c);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([g]))]}const eDe={kernelName:xM,backendName:"webgl",kernelFunc:Q3e};const tDe=TN;function nDe(n){gl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:a}=e,{maxOutputSize:r,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s,h=t.readSync(i.dataId),d=t.readSync(a.dataId),p=r,g=o,v=l,_=c,{selectedIndices:S,selectedScores:b}=tDe(h,d,p,g,v,_);return[t.makeTensorInfo([S.length],"int32",new Int32Array(S)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const sDe={kernelName:yM,backendName:"webgl",kernelFunc:nDe};class iDe{constructor(e,t,s,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const aDe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:a,depth:r,onValue:o,offValue:l}=s,c=qe(i.shape),h=new iDe(c,r,o,l),d=zt({inputs:{x:i},backend:t,attrs:{shape:[c]}}),p=t.runWebGLProgram(h,[d],a);t.disposeIntermediateTensorInfo(d);const g=[...i.shape,r],v=zt({inputs:{x:p},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(p),v},rDe={kernelName:T_,backendName:"webgl",kernelFunc:aDe};function qE(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=TA({inputs:{input:s},backend:t}),a=qE({inputs:{x:i},backend:t}),r=KN({inputs:{input:s},backend:t}),o=qE({inputs:{x:r},backend:t}),l=mp({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),l}else return EA({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const oDe={kernelName:H_,backendName:"webgl",kernelFunc:qE};function jj(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=TA({inputs:{input:s},backend:t}),a=jj({inputs:{x:i},backend:t}),r=KN({inputs:{input:s},backend:t}),o=qE({inputs:{x:r},backend:t}),l=mp({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),l}else return EA({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const lDe={kernelName:C_,backendName:"webgl",kernelFunc:jj};function cDe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return GD({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const a=e[0].shape,r=e[0].dtype;e.forEach(h=>{nr(a,h.shape,"All tensors passed to stack must have matching shapes"),ee(r===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(h=>{const d=GD({inputs:{input:h},backend:t,attrs:{dim:i}});return o.push(d),d}),c=Ij({inputs:l,backend:t,attrs:{axis:i}});return o.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const uDe={kernelName:E_,backendName:"webgl",kernelFunc:cDe};class hDe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const i=e.length,a=qs(i),r=t.map(c=>c[0]).join(","),o=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${r};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${r});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class dDe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((_,S)=>_[0]+e[S]+_[1]);const i=e.length,a=qs(i),r=t.map(_=>_[0]).join(","),o=t.map((_,S)=>_[0]+e[S]).join(","),l=Hr("rc",i),c=Hr("source",i),h=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${h}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${h}) {`],g=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let v="";for(let _=0,S=i===1?2:4;_<S;_++)v+=`
        ${p[_]}
        if (${g}) {
          result[${_}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${_}] = getChannel(getX(${c.join()}), ${d});
        }
      `;v+=i===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${r});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${v}
        setOutput(result);
      }
    `}}const Xj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:a,constantValue:r}=s;if(qe(i.shape)===0){const c=a.map((h,d)=>h[0]+i.shape[d]+h[1]);return EA({backend:t,attrs:{shape:c,value:r,dtype:i.dtype}})}const o=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dDe(i.shape,a,r):new hDe(i.shape,a,r),l=[[r]];return t.runWebGLProgram(o,[i],i.dtype,l)},fDe={kernelName:M_,backendName:"webgl",kernelFunc:Xj};const pDe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,mDe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Pg+`
  return result;
`,gDe=rr({opSnippet:pDe,packedOpSnippet:mDe}),xDe={kernelName:qy,backendName:"webgl",kernelFunc:gDe};function yDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:a,keepDims:r}=s,o=i.shape.length,l=[],c=es(a,i.shape);let h=c;const d=Mi(h,o);let p=i;d!=null&&(p=Xr({inputs:{x:i},backend:t,attrs:{perm:d}}),h=qi(h.length,o),l.push(p)),ir("prod",h,o);let g;if(t.shouldExecuteOnCPU([p])){const v=t.texData.get(p.dataId).values,{outVals:_,outShape:S,outDtype:b}=gEe(p.shape,p.dtype,v,h);g=t.makeTensorInfo(S,b,_)}else{const[v,_]=Ua(p.shape,h),S=qe(_),b=zt({inputs:{x:p},backend:t,attrs:{shape:[-1,S]}}),w=HM(i.dtype),T=zg(b,w,"prod",t);g=zt({inputs:{x:T},backend:t,attrs:{shape:v}}),l.push(b),l.push(T)}if(r){l.push(g);const v=Xi(g.shape,c);g=zt({inputs:{x:g},backend:t,attrs:{shape:v}})}return l.forEach(v=>t.disposeIntermediateTensorInfo(v)),g}const vDe={kernelName:R_,backendName:"webgl",kernelFunc:yDe};function bDe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:a,indices:r}=e,{outputRaggedRank:o}=s,l=i.map(b=>t.readSync(b.dataId)),c=i.map(b=>b.shape),h=t.readSync(a.dataId),d=t.readSync(r.dataId),[p,g,v]=xEe(l,c,h,a.shape,a.dtype,d,r.shape,o),_=p.map(b=>t.makeTensorInfo([b.length],"int32",b)),S=t.makeTensorInfo(v,a.dtype,g);return _.concat([S])}const SDe={kernelName:vM,backendName:"webgl",kernelFunc:bDe};function _De(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:a}=e,r=t.readSync(s.dataId),o=t.readSync(i.dataId),l=t.readSync(a.dataId),[c,h]=yEe(r,s.shape,s.dtype,o,i.shape,l,a.shape),d=t.makeTensorInfo([c.length],"int32",c),p=t.makeTensorInfo([h.length],s.dtype,h);return[d,p]}const ADe={kernelName:bM,backendName:"webgl",kernelFunc:_De};function wDe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:a,defaultValue:r,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=t.readSync(i.dataId),h=t.readSync(a.dataId),d=t.readSync(r.dataId),p=o.map(S=>t.readSync(S.dataId)),g=o.map(S=>S.shape),[v,_]=vEe(c,i.shape,h,a.shape,a.dtype,d,r.shape,p,g,l);return t.makeTensorInfo(v,a.dtype,_)}const CDe={kernelName:SM,backendName:"webgl",kernelFunc:wDe};const qj=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:a,dtype:r}=t,o=bEe(s,i,a,r);return e.makeTensorInfo([o.length],r,o)},TDe={kernelName:_M,backendName:"webgl",kernelFunc:qj};const EDe="return 1.0 / x;",MDe=Ms({opSnippet:EDe}),NDe={kernelName:Ky,backendName:"webgl",kernelFunc:MDe};const RDe=dc+`
  return (x < 0.0) ? 0.0 : x;
`,IDe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DDe=Ms({opSnippet:RDe,packedOpSnippet:IDe}),ODe={kernelName:Yy,backendName:"webgl",kernelFunc:DDe};const BDe=dc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,kDe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,LDe=Ms({opSnippet:BDe,packedOpSnippet:kDe}),FDe={kernelName:Jy,backendName:"webgl",kernelFunc:LDe};class UDe{constructor(e,t,s,i,a){this.variableNames=["A"],this.outputShape=[];const[r,o,l,c]=e;this.outputShape=[r,t,s,c];const h=[i&&t>1?o-1:o,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s];let p;a?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class PDe{constructor(e,t,s,i,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,o,l,c]=e;this.outputShape=[r,t,s,c];const h=[i&&t>1?o-1:o,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s];let p;a?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function zDe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:a,halfPixelCenters:r,size:o}=s,[l,c]=o,h=Pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new PDe(i.shape,l,c,a,r):new UDe(i.shape,l,c,a,r);return t.runWebGLProgram(h,[i],"float32")}const $De={kernelName:O_,backendName:"webgl",kernelFunc:zDe};class GDe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,a]=t,[,r,o]=e,l=[s&&r>1?i-1:i,s&&o>1?a-1:a],c=[s&&r>1?r-1:r,s&&o>1?o-1:o],h=l[0]/c[0],d=l[1]/c[1],p=1/h,g=1/d,v=Math.ceil(p)*2+2,_=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${v});
        const int winWidth = int(${_});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${r}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function VDe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:a}=e,{alignCorners:r}=s,o=new GDe(a.shape,i.shape,r);return t.runWebGLProgram(o,[a],a.dtype)}const HDe={kernelName:CM,backendName:"webgl",kernelFunc:VDe};class WDe{constructor(e,t,s,i,a){this.variableNames=["A"],this.outputShape=[];const[r,o,l,c]=e;this.outputShape=[r,t,s,c];const h=[i&&t>1?o-1:o,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s],p=i?"0.5":"0.0";let g;a?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class jDe{constructor(e,t,s,i,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,o,l,c]=e;this.outputShape=[r,t,s,c];const h=[i&&t>1?o-1:o,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s],p=i?"0.5":"0.0";let g;a?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function XDe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:a,halfPixelCenters:r,size:o}=s,[l,c]=o,h=Pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new jDe(i.shape,l,c,a,r):new WDe(i.shape,l,c,a,r);return t.runWebGLProgram(h,[i],i.dtype)}const qDe={kernelName:D_,backendName:"webgl",kernelFunc:XDe};class KDe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,a]=t,[,r,o]=e,l=[s&&r>1?i-1:i,s&&o>1?a-1:a],c=[s&&r>1?r-1:r,s&&o>1?o-1:o],h=l[0]/c[0],d=l[1]/c[1],p=1/h,g=1/d,v=Math.ceil(p)*2+2,_=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${g});

        const int winHeight = int(${v});
        const int winWidth = int(${_});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${r}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function YDe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:a}=e,{alignCorners:r}=s,o=new KDe(a.shape,i.shape,r);return t.runWebGLProgram(o,[a],a.dtype)}const JDe={kernelName:wM,backendName:"webgl",kernelFunc:YDe};class ZDe{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,a=e.map((o,l)=>i(l)).join(","),r=qs(s);this.userCode=`
      void main() {
        ${r} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}class QDe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const i=Hr("rc",s),a=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,r=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,o=qs(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${a}){
            result.g = ${c(i.slice())};
          }
          if(${r}) {
            result.b = ${h(i.slice())};
            if(${a}) {
              result.a = ${d(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(v){return p(v)}function c(v){return v[s-1]="("+v[s-1]+" + 1)",p(v)}function h(v){return v[s-2]="("+v[s-2]+" + 1)",p(v)}function d(v){return v[s-1]="("+v[s-1]+" + 1)",v[s-2]="("+v[s-2]+" + 1)",p(v)}function p(v){const _=e.map((w,T)=>g(T,v)),S=_.join(","),b=_.slice(-2).join(",");return`getChannel(getX(${S}), vec2(${b}))`}function g(v,_){return t.indexOf(v)!==-1&&e[v]!==1?`${e[v]} - ${_[v]} - 1`:`${_[v]}`}}}function eOe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:a}=s,r=i.shape.length,o=es(a,i.shape);if(r===0)return el({inputs:{x:i},backend:t});const l=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QDe(i.shape,o):new ZDe(i.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const tOe={kernelName:B_,backendName:"webgl",kernelFunc:eOe};class nOe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],i=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const sOe={kernelName:GM,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:a,center:r}=e,o=t,l=new nOe(s.shape,a),[c,h]=Pk(r,s.shape[1],s.shape[2]),d=[[c,h,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[s],s.dtype,d)}};const iOe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,aOe=Ms({opSnippet:iOe}),rOe={kernelName:Zy,backendName:"webgl",kernelFunc:aOe};const oOe="return inversesqrt(x);",lOe=Ms({opSnippet:oOe,cpuKernelImpl:SEe}),cOe={kernelName:Qy,backendName:"webgl",kernelFunc:lOe};class HL{constructor(e,t,s,i,a,r,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=r;const c=qs(a.length),h=qs(r.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let g="";i===1?g="i":i===2&&(g="i, coords[1]");const v=`getUpdates(${g})`;let _="";l&&(_="coords[0], coords[1]");const S=`getDefaultValue(${_})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${v};
              found = true;
            }
          }
          setOutput(mix(${S}, sum, float(found)));
        }
      `}}class uOe{constructor(e,t,s,i,a,r,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;const c=qs(a.length),h=qs(r.length);let d="";s===1?d="i":s===2&&(d="i, j");const p=`getIndices(${d})`;let g="";i===1?g="i":i===2&&(g="i, coords[1]");const v=`getUpdates(${g})`;let _="";l&&(_="coords[0], coords[1]");const S=`getDefaultValue(${_})`,b=t>1?"strides[j]":"strides",w=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${p});
              flattenedIndex += index.xz * ${b};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${w};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${v};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${S}, sum, found));
        }
      `}}function hOe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:a}=e,{shape:r}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=dp(a,i,r),p=[d/c,c];if(d===0)return t.makeTensorInfo(r,i.dtype);const g=zt({inputs:{x:i},backend:t,attrs:{shape:[l,o]}}),v=zt({inputs:{x:a},backend:t,attrs:{shape:[l,c]}}),_=t.makeTensorInfo([],"float32",new Float32Array([0]));let S;Pe().getBool("WEBGL_PACK")?S=new uOe(l,o,g.shape.length,v.shape.length,h,p):S=new HL(l,o,g.shape.length,v.shape.length,h,p);const b=t.runWebGLProgram(S,[v,g,_],v.dtype),w=zt({inputs:{x:b},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(_),w}const dOe={kernelName:TM,backendName:"webgl",kernelFunc:hOe};class fOe{constructor(e,t,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const a="while (left < right) {",r=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=Pe().getNumber("WEBGL_VERSION")===2?a:r,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function pOe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:a}=e,{side:r}=s,o=new fOe(i.shape[0],i.shape[1],a.shape[1],r),l=[[i.shape[1]]];return t.runWebGLProgram(o,[i,a],"int32",l)}const mOe={kernelName:MM,backendName:"webgl",kernelFunc:pOe};class gOe{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let i,a;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)a="resRC",i="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let h=0;h<t.length;h++)c.push(`${o[h]}`),h<e&&l.push(`${o[h]}`);i=l.join(),a=c.join()}const r=qs(s);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}function xOe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:a}=e,r=new gOe(s.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(r,[s,i,a],To(i.dtype,a.dtype))}const yOe={kernelName:k_,backendName:"webgl",kernelFunc:xOe};const vOe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${IN};
  float scale = ${DN};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,bOe=Ms({opSnippet:vOe}),SOe={kernelName:ev,backendName:"webgl",kernelFunc:bOe};const _Oe=Ev+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,AOe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wOe=Ms({opSnippet:_Oe,packedOpSnippet:AOe,cpuKernelImpl:AEe}),COe={kernelName:iv,backendName:"webgl",kernelFunc:wOe};const TOe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,EOe=Ms({opSnippet:TOe}),MOe={kernelName:sv,backendName:"webgl",kernelFunc:EOe};const NOe=Ev+`
  return sin(x);
`,ROe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Pg}
  return result;
`,IOe=Ms({opSnippet:NOe,packedOpSnippet:ROe}),DOe={kernelName:tv,backendName:"webgl",kernelFunc:IOe};const OOe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,BOe=Ms({opSnippet:OOe}),kOe={kernelName:nv,backendName:"webgl",kernelFunc:BOe};const LOe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,FOe=Ms({opSnippet:LOe}),UOe={kernelName:av,backendName:"webgl",kernelFunc:FOe};const POe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:a,paddings:r}=s;ee(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,w)=>b*w),l=[[0,0]];l.push(...r);for(let b=1+a.length;b<i.shape.length;++b)l.push([0,0]);const c=[],h=Xj({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),d=hA(h.shape,a,o,!1),p=dA(d.length,a.length,!1),g=fA(h.shape,a,o,!1),v=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),_=Xr({inputs:{x:v},backend:t,attrs:{perm:p}}),S=zt({inputs:{x:_},backend:t,attrs:{shape:g}});return c.push(h),c.push(v),c.push(_),c.forEach(b=>t.disposeIntermediateTensorInfo(b)),S},zOe={kernelName:U_,backendName:"webgl",kernelFunc:POe};function $Oe(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:a,defaultValue:r}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${r.shape}`);const o=t.readSync(s.dataId),l=t.readSync(i.dataId),c=t.readSync(a.dataId),h=t.readSync(r.dataId)[0],[d,p,g,v,_]=CEe(o,s.shape,s.dtype,l,i.dtype,c,h);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],i.dtype,g),t.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(S=>Number(S)))),t.makeTensorInfo([_.length],s.dtype,new Int32Array(_))]}const GOe={kernelName:NM,backendName:"webgl",kernelFunc:$Oe};function VOe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const r=Array.from(t.readSync(i.dataId)),o=t.readSync(s.dataId),l=Array.from(t.readSync(a.dataId)),[c,h,d]=TEe(o,s.shape,s.dtype,r,l);return[t.makeTensorInfo(h,s.dtype,c),t.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const HOe={kernelName:RM,backendName:"webgl",kernelFunc:VOe};function WOe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const r=t.readSync(s.dataId),o=t.readSync(i.dataId),l=t.readSync(a.dataId),[c,h]=yj(r,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(h,s.dtype,c)}const jOe={kernelName:IM,backendName:"webgl",kernelFunc:WOe};function XOe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const r=t.readSync(s.dataId),o=t.readSync(i.dataId),l=t.readSync(a.dataId),[c,h]=yj(r,s.shape,s.dtype,o,l);return t.makeTensorInfo(h,s.dtype,c)}const qOe={kernelName:DM,backendName:"webgl",kernelFunc:XOe};function KOe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:a,defaultValue:r}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=dp(a,i,o),g=!1;if(a.dtype==="string"){const b=t.bufferSync(i),w=t.bufferSync(a),T=gd(t.readSync(r.dataId)[0]),E=_Ee(b,w,o,p,h,c,l,d,T,g);return t.makeTensorInfo(o,E.dtype,E.values)}const v=new HL(c,l,i.shape.length,a.shape.length,d,[p,1],g),_=t.runWebGLProgram(v,[a,i,r],a.dtype),S=zt({inputs:{x:_},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(_),S}const YOe={kernelName:OM,backendName:"webgl",kernelFunc:KOe};function JOe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:a,axis:r}=s,o=es(r,i.shape)[0],l=eL(i,a,o),c=i.shape.length,h=new Array(c).fill(0),d=i.shape.slice();return l.map(p=>{const g=[...d];g[o]=p;const v=Mv({inputs:{x:i},backend:t,attrs:{begin:h,size:g}});return h[o]+=p,v})}const ZOe={kernelName:P_,backendName:"webgl",kernelFunc:JOe};const K$="return sqrt(x);",QOe=Ms({opSnippet:K$,packedOpSnippet:K$,cpuKernelImpl:EEe}),eBe={kernelName:rv,backendName:"webgl",kernelFunc:QOe};const tBe="return x * x;",nBe=Ms({opSnippet:tBe}),sBe={kernelName:BM,backendName:"webgl",kernelFunc:nBe};const Y$="return (a - b) * (a - b);",iBe=rr({opSnippet:Y$,packedOpSnippet:Y$}),aBe={kernelName:ov,backendName:"webgl",kernelFunc:iBe};function rBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const a=t.readSync(i.dataId),r=bd(a),o=MEe(r,"string",s);return t.makeTensorInfo(i.shape,"string",o)}const oBe={kernelName:$_,backendName:"webgl",kernelFunc:rBe};function lBe({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=dc+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new Yu(s.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}const cBe={kernelName:dv,backendName:"webgl",kernelFunc:lBe};class uBe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,a=qs(s.length),r=qs(s.length);let o="";if(i===1)o="coords * strides + begin";else{let l=0;o=s.map((c,h)=>(l++,s.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${l-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${r} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}function hBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:a,end:r,strides:o,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:g,finalShape:v,isIdentity:_,sliceDim0:S,isSimpleSlice:b,begin:w,end:T,strides:E}=kk(i.shape,a,r,o,l,c,h,d,p);let R;if(_)R=zt({inputs:{x:i},backend:t,attrs:{shape:v}});else if(S||b){ee(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const F=Dk(w,T,E),U=Mv({inputs:{x:i},backend:t,attrs:{begin:w,size:F}});R=zt({inputs:{x:U},backend:t,attrs:{shape:v}}),t.disposeIntermediateTensorInfo(U)}else if(t.shouldExecuteOnCPU([i])){const U=t.readSync(i.dataId),O=Hn(i.shape,i.dtype,U),B=NEe(g,O,E,w);R=t.makeTensorInfo(v,i.dtype,B.values)}else{const U=new uBe(w,E,g);R=t.runWebGLProgram(U,[i],i.dtype)}const D=zt({inputs:{x:R},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(R),D}const dBe={kernelName:kM,backendName:"webgl",kernelFunc:hBe};function fBe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:a,leftPad:r,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:h,dataSplits:d}=e,p=t.readSync(h.dataId),g=t.readSync(d.dataId),[v,_]=REe(p,g,i,a,r,o,l,c);return[t.makeTensorInfo([v.length],"string",v),t.makeTensorInfo(d.shape,"int32",_)]}const pBe={kernelName:LM,backendName:"webgl",kernelFunc:fBe};function mBe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:a,delimiter:r}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(r.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${r.shape}`);const o=t.readSync(a.dataId),l=t.readSync(r.dataId)[0],[c,h,d]=IEe(o,l,i),p=h.length;return[t.makeTensorInfo([p,2],"int32",c),t.makeTensorInfo([p],"string",h),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const gBe={kernelName:FM,backendName:"webgl",kernelFunc:mBe};function xBe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const r=t.readSync(a.dataId),o=DEe(r,i);return t.makeTensorInfo(a.shape,"int32",o)}const yBe={kernelName:UM,backendName:"webgl",kernelFunc:xBe};const vBe="return tan(x);",bBe=Ms({opSnippet:vBe}),SBe={kernelName:cv,backendName:"webgl",kernelFunc:bBe};const _Be=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ABe=Ms({opSnippet:_Be}),wBe={kernelName:uv,backendName:"webgl",kernelFunc:ABe};function CBe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:i,indices:a,updates:r}=e,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=dp(r,a,i.shape),p=[d/c,c];if(d===0)return t.makeTensorInfo(i.shape,a.dtype);const g=zt({inputs:{x:a},backend:t,attrs:{shape:[l,o]}}),v=zt({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),_=zt({inputs:{x:i},backend:t,attrs:{shape:p}}),S=new HL(l,o,g.shape.length,v.shape.length,h,p,!1,!0),b=t.runWebGLProgram(S,[v,g,_],_.dtype),w=zt({inputs:{x:b},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(b),w}const TBe={kernelName:EM,backendName:"webgl",kernelFunc:CBe};class EBe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*t[r];this.outputShape=s,this.rank=s.length;const i=qs(this.rank),a=MBe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function MBe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${t[i]}, ${n[i]})`);return s.join()}function Kj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:a}=s;if(i.dtype==="string"||i.shape.length>5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(p=>gd(p)):l,h=Hn(i.shape,i.dtype,c),d=BEe(h,a);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const r=new EBe(i.shape,a);return t.runWebGLProgram(r,[i],i.dtype)}const NBe={kernelName:hv,backendName:"webgl",kernelFunc:Kj};class RBe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class IBe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function wm(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function J$(n){let e=1;for(;e<n;)e*=2;return e}function DBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:a,sorted:r}=s,o=Pe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Pe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,h=c[c.length-1];if(t.shouldExecuteOnCPU([i])||h<o||a>l){const B=t.readSync(i.dataId),[L,H]=kEe(B,c,i.dtype,a,r);return[t.makeTensorInfo(L.shape,L.dtype,L.values),t.makeTensorInfo(H.shape,H.dtype,H.values)]}if(a===0)return c[c.length-1]=0,[t.makeTensorInfo(c,i.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(h===1)return[i,EA({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const d=t.texData.get(i.dataId),p=d!==null&&d.isPacked,g=p?t.unpackTensor(i):i,_=qe(c)/h,S=zt({inputs:{x:g},attrs:{shape:[_,h]},backend:t});p&&wm(t,g);const b=J$(a),w=J$(h);let T=null;const E=()=>T===null?[S,S]:[S,T],R=(B,L,H)=>{const K=E(),Z=new RBe(H),P=[[h],[T===null?1:0],[Number.NEGATIVE_INFINITY],[B],[L]],W=T;T=t.runWebGLProgram(Z,K,"int32",P),wm(t,W)};for(let B=1;B<b;B*=2){const L=B*2;for(let H=B;H>=1;H/=2)R(L,H,[_,w])}for(let B=w;B>b;B/=2){const L=E(),H=new IBe([_,B/2]),Z=[[h],[T===null?1:0],[b]],Q=T;T=t.runWebGLProgram(H,L,"int32",Z),wm(t,Q);const P=b/2,W=P*2;for(let q=P;q>=1;q/=2)R(W,q,T.shape)}let D=T;T=Mv({inputs:{x:T},backend:t,attrs:{begin:0,size:[_,a]}}),wm(t,D);let F=$j({inputs:{x:S,indices:T},backend:t,attrs:{axis:1,batchDims:1}});wm(t,S);const U=c.slice(0,-1);U.push(a),D=T,T=zt({inputs:{x:T},attrs:{shape:U},backend:t}),wm(t,D);const O=F;return F=zt({inputs:{x:F},attrs:{shape:U},backend:t}),wm(t,O),[F,T]}const OBe={kernelName:PM,backendName:"webgl",kernelFunc:DBe};class BBe{constructor(e,t,s,i,a,r){this.variableNames=["Image","Transforms"],this.outputShape=r;const o=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function kBe(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:a}=e,{interpolation:r,fillMode:o,fillValue:l,outputShape:c}=s,[h,d,p,g]=i.shape,[v,_]=c??[d,p],S=[h,v,_,g],b=new BBe(d,p,r,o,l,S);return t.runWebGLProgram(b,[i,a],"float32")}const LBe={kernelName:zM,backendName:"webgl",kernelFunc:kBe};function FBe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:a}=e;wA(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const r=s.readSync(a.dataId),{outputValues:o,outputShape:l,indices:c}=LEe(r,i,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const UBe={kernelName:$M,backendName:"webgl",kernelFunc:FBe};function PBe(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:a}=s;a<0&&(a+=i.shape.length);const r=i,o=r.shape.length,l=i.shape[a],c=new Array(o-1);let h=0;for(let _=0;_<o;_++)_!==a&&(c[h++]=r.shape[_]);const d=[],p=new Array(o).fill(0),g=r.shape.slice();g[a]=1;const v=new Array(l);for(let _=0;_<v.length;_++){p[a]=_;const S=Mv({inputs:{x:r},backend:t,attrs:{begin:p,size:g}}),b=zt({inputs:{x:S},backend:t,attrs:{shape:c}});v[_]=b,d.push(S)}return d.forEach(_=>t.disposeIntermediateTensorInfo(_)),v}const zBe={kernelName:G_,backendName:"webgl",kernelFunc:PBe};class $Be{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,i=e.batchSize,a=e.inSize,r=e.numSegments,o=r*Math.ceil(a/s);this.outputShape=[i,o];const l="0.0",c="sumValue",h=Math.floor(s/4)*4,d=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let g="";a%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let v="";a%s>0&&(v=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${v}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${r})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${r})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${c});
      }
    `}}function GBe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:a}=e,{numSegments:r}=s,o=i.shape.length,l=[];let c=0;const h=Mi([c],o);let d=i;h!=null&&(d=Xr({inputs:{x:i},backend:t,attrs:{perm:h}}),l.push(d),c=qi(1,o)[0]);const p=T8(d.shape,c,r),g=qe([d.shape[c]]),v=zt({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}});l.push(v);const _=HM(i.dtype),S=(E,R,D,F,U)=>{const O=E.shape[0],B=E.shape[1],L=C8(B,U),H={windowSize:L,inSize:B,batchSize:O,numSegments:U},K=new $Be(H,R),Z=t.compileAndRun(K,[E,D],F);if(l.push(Z),Z.shape[1]===U)return Z;const Q=qj({backend:t,attrs:{start:0,stop:U,step:1,dtype:"float32"}}),P=Kj({inputs:{x:Q},backend:t,attrs:{reps:[B/L]}});return l.push(Q),l.push(P),S(Z,R,P,F,U)},b=S(v,"unsortedSegmentSum",a,_,r),w=zt({inputs:{x:b},backend:t,attrs:{shape:p}});let T=w;if(h!=null){l.push(w);const E=lp(h);T=Xr({inputs:{x:T},backend:t,attrs:{perm:E}})}return l.forEach(E=>t.disposeIntermediateTensorInfo(E)),T}const VBe={kernelName:V_,backendName:"webgl",kernelFunc:GBe};const HBe=[E2e,N2e,D2e,k2e,F2e,z2e,G2e,H2e,q2e,Y2e,Q2e,nMe,aMe,cMe,dMe,pMe,gMe,bMe,_Me,wMe,MMe,kMe,FMe,$Me,VMe,KMe,JMe,tNe,u2e,iNe,cNe,fNe,vNe,_Ne,wNe,TNe,MNe,DNe,kNe,UNe,zNe,GNe,HNe,XNe,KNe,QNe,tRe,iRe,oRe,cRe,fRe,xRe,SRe,wRe,ERe,MRe,RRe,DRe,BRe,LRe,URe,GRe,WRe,qRe,YRe,QRe,nIe,rIe,uIe,c2e,dIe,oNe,mIe,yIe,SIe,d2e,CIe,NIe,IIe,kIe,UIe,GIe,WIe,KIe,QIe,n3e,i3e,l3e,u3e,d3e,g3e,y3e,b3e,_3e,w3e,M3e,D3e,L3e,H3e,m2e,q3e,J3e,eDe,sDe,WMe,rDe,lDe,uDe,fDe,xDe,p2e,vDe,SDe,ADe,CDe,TDe,jMe,z3e,NDe,ODe,FDe,x2e,$De,HDe,qDe,JDe,tOe,sOe,rOe,cOe,dOe,mOe,yOe,SOe,COe,MOe,DOe,kOe,OMe,G3e,UOe,zOe,GOe,HOe,jOe,qOe,YOe,ZOe,eBe,sBe,aBe,oBe,cBe,dBe,pBe,gBe,yBe,$3e,w2e,SBe,wBe,TBe,NBe,OBe,LBe,C2e,UBe,zBe,VBe,oDe];for(const n of HBe)VM(n);function WBe({title:n,highlightColor:e="#00ffc8"}){const t=pe.useRef(null),s=pe.useRef(null),[i,a]=pe.useState(null);pe.useEffect(()=>{Mge.load().then(o=>{a(o),console.log("Model Loaded")})},[]),pe.useEffect(()=>{navigator.mediaDevices.getUserMedia&&navigator.mediaDevices.getUserMedia({video:!0}).then(o=>{t.current&&(t.current.srcObject=o)}).catch(o=>console.error(o))},[]),pe.useEffect(()=>{if(!i)return;let o=0,l=!1;const c=async()=>{if(l)return;const h=t.current,d=s.current;if(!h||!d||h.readyState<2||h.videoWidth===0||h.videoHeight===0){o=requestAnimationFrame(c);return}await r(),o=requestAnimationFrame(c)};return o=requestAnimationFrame(c),()=>{l=!0,cancelAnimationFrame(o)}},[i]);const r=async()=>{if(!i||!s.current||!t.current)return;const o=t.current;if(o.videoWidth===0||o.videoHeight===0)return;const l=await i.detect(o),c=s.current,h=c.getContext("2d");h&&(c.width=o.videoWidth,c.height=o.videoHeight,h.clearRect(0,0,c.width,c.height),l.forEach(d=>{const[p,g,v,_]=d.bbox;h.strokeStyle=e,h.lineWidth=3,h.strokeRect(p,g,v,_),h.fillStyle=e,h.font="18px monospace",h.fillText(`${d.class} (${Math.round(d.score*100)}%)`,p,g-5)}))};return V.jsxs("div",{className:"detect-page",children:[V.jsx("h1",{className:"detect-title",children:n}),V.jsxs("div",{className:"detect-wrapper",children:[V.jsx("video",{ref:t,autoPlay:!0,playsInline:!0,className:"video-feed"}),V.jsx("canvas",{ref:s,className:"overlay-canvas"})]})]})}function jBe(){const[n,e]=pe.useState("kitchen");return V.jsxs("div",{className:"detect-page",children:[" ",V.jsx("h1",{className:"detect-title",children:"AI Object Scanner"})," ",V.jsxs("div",{className:"mode-buttons",children:[V.jsx("button",{className:n==="kitchen"?"mode-btn active":"mode-btn",onClick:()=>e("kitchen"),children:" Kitchen"}),V.jsx("button",{className:n==="clothing"?"mode-btn active":"mode-btn",onClick:()=>e("clothing"),children:" Clothing"})]}),V.jsx(XV,{}),V.jsx(WBe,{title:n==="kitchen"?"DishFinder  Kitchen Mode":"FitFinder  Clothing Mode",highlightColor:n==="kitchen"?"#00ffc8":"#ff00ff"})]})}function XBe(){const n=ly();return V.jsxs("div",{className:"module-page neon-border",children:[V.jsx("button",{className:"back-btn",onClick:()=>n("/control-hub"),children:" Back"}),V.jsx("h1",{className:"module-title rgb-gradient",children:"Power Management System"}),V.jsx("p",{className:"module-desc",children:"Battery monitoring, voltage flow, servo consumption stats, and future power-routing logic will go here."})]})}function qBe(){const n=ly();return V.jsxs("div",{className:"module-page neon-border",children:[V.jsx("button",{className:"back-btn",onClick:()=>n("/control-hub"),children:" Back"}),V.jsx("h1",{className:"module-title rgb-gradient",children:"Network System"}),V.jsx("p",{className:"module-desc",children:"This section will include WiFi diagnostics, robot communication checks, PiArduino link testing, and network tools."})]})}function KBe(){return V.jsxs("div",{className:"voice-module-page",children:[V.jsx(KD,{}),V.jsx("h1",{className:"vm-title",children:"Voice Control Module"}),V.jsx("p",{className:"vm-subtitle",children:"Manage wake-word detection, speech output, and command training."}),V.jsxs("div",{className:"vm-card-container",children:[V.jsxs(So,{to:"/voice/wakeword",className:"vm-card",children:[V.jsx("h2",{children:"Wake-Word Settings"}),V.jsx("p",{children:"Configure recognition engine and microphone settings."})]}),V.jsxs(So,{to:"/voice/tts",className:"vm-card",children:[V.jsx("h2",{children:"Speech Output"}),V.jsx("p",{children:"Control voice type, speed, pitch, and TTS engine."})]}),V.jsxs(So,{to:"/voice/commands",className:"vm-card",children:[V.jsx("h2",{children:"Command Trainer"}),V.jsx("p",{children:"Teach Sonny new commands and behaviors."})]})]})]})}function YBe(){return V.jsxs("div",{className:"subpage",children:[V.jsx(So,{to:"/voice-module",className:"back-btn",children:" Back"}),V.jsx("h1",{children:"Wake-Word Settings"}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"Wake Word"}),V.jsx("input",{type:"text",placeholder:"e.g. 'Hey Sonny'"})]}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"Engine"}),V.jsxs("select",{children:[V.jsx("option",{children:"Mycroft Precise"}),V.jsx("option",{children:"PocketSphinx"}),V.jsx("option",{children:"Vosk (Keyword Mode)"})]})]}),V.jsx("button",{className:"save-btn",children:"Save Settings"})]})}function JBe(){return V.jsxs("div",{className:"subpage",children:[V.jsx(So,{to:"/voice-module",className:"back-btn",children:" Back"}),V.jsx("h1",{children:"Speech Output"}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"Voice Pitch"}),V.jsx("input",{type:"range",min:"0",max:"2",step:"0.1"})]}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"Voice Speed"}),V.jsx("input",{type:"range",min:"0.5",max:"2",step:"0.1"})]}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"Voice Personality"}),V.jsxs("select",{children:[V.jsx("option",{children:"Default"}),V.jsx("option",{children:"Friendly"}),V.jsx("option",{children:"Sarcastic"}),V.jsx("option",{children:"Robot Butler"})]})]}),V.jsx("button",{className:"save-btn",children:"Save"})]})}function ZBe(){return V.jsxs("div",{className:"subpage",children:[V.jsx(So,{to:"/voice-module",className:"back-btn",children:" Back"}),V.jsx("h1",{children:"Command Trainer"}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"New Command"}),V.jsx("input",{type:"text",placeholder:"e.g. 'Sonny wave'"})]}),V.jsxs("div",{className:"panel",children:[V.jsx("label",{children:"Response"}),V.jsx("input",{type:"text",placeholder:"What should Sonny do?"})]}),V.jsx("button",{className:"save-btn",children:"Add Command"})]})}function QBe(){return V.jsxs(V.Fragment,{children:[V.jsx(Hq,{}),V.jsxs(GX,{children:[V.jsx(go,{path:"/",element:V.jsxs(V.Fragment,{children:[V.jsx(Sq,{}),V.jsx(Uq,{}),V.jsx(Pq,{}),V.jsx(zq,{}),V.jsx($q,{}),V.jsx(Gq,{}),V.jsx(Vq,{})]})}),V.jsx(go,{path:"/control-hub",element:V.jsx(Wq,{})}),V.jsx(go,{path:"/virtual-model",element:V.jsx(qV,{})}),V.jsx(go,{path:"/robotstudio",element:V.jsx(cre,{})}),V.jsx(go,{path:"/AIAssistant",element:V.jsx(pre,{})}),V.jsx(go,{path:"/about",element:V.jsx(jq,{})}),V.jsx(go,{path:"/object-scanner",element:V.jsx(jBe,{})}),V.jsx(go,{path:"/movement-module",element:V.jsx(KV,{})}),V.jsx(go,{path:"/voice-module",element:V.jsx(KBe,{})}),V.jsx(go,{path:"/power-module",element:V.jsx(XBe,{})}),V.jsx(go,{path:"/network-module",element:V.jsx(qBe,{})}),V.jsx(go,{path:"/voice/wakeword",element:V.jsx(YBe,{})}),V.jsx(go,{path:"/voice/tts",element:V.jsx(JBe,{})}),V.jsx(go,{path:"/voice/commands",element:V.jsx(ZBe,{})})]})]})}J7.createRoot(document.getElementById("root")).render(V.jsx(hq,{basename:"/Robotics_Portfolio/",children:V.jsx(pe.StrictMode,{children:V.jsx(QBe,{})})}));
